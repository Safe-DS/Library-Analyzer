{
  "schemaVersion": 1,
  "distribution": "",
  "package": "matplotlib",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg",
      "name": "FigureCanvasAgg",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg",
        "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasAgg(FigureCanvasBase):\n    # docstring inherited\n\n    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)\n\n    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)\n\n    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer(cleared=True)\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()\n\n    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (hasattr(self, \"renderer\")\n                          and getattr(self, \"_lastKey\", None) == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer\n\n    def tostring_rgb(self):\n        \"\"\"\n        Get the image as RGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_rgb()\n\n    def tostring_argb(self):\n        \"\"\"\n        Get the image as ARGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_argb()\n\n    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()\n\n    @_check_savefig_extra_args\n    def print_raw(self, filename_or_obj, *args):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n            fh.write(renderer.buffer_rgba())\n\n    print_rgba = print_raw\n\n    @_check_savefig_extra_args\n    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        mpl.image.imsave(\n            filename_or_obj, self.buffer_rgba(), format=\"png\", origin=\"upper\",\n            dpi=self.figure.dpi, metadata=metadata, pil_kwargs=pil_kwargs)\n\n    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))\n\n    # Note that these methods should typically be called via savefig() and\n    # print_figure(), and the latter ensures that `self.figure.dpi` already\n    # matches the dpi kwarg (if any).\n\n    @_check_savefig_extra_args(\n        extra_kwargs=[\"quality\", \"optimize\", \"progressive\"])\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    @cbook._delete_parameter(\"3.3\", \"quality\",\n                             alternative=\"pil_kwargs={'quality': ...}\")\n    @cbook._delete_parameter(\"3.3\", \"optimize\",\n                             alternative=\"pil_kwargs={'optimize': ...}\")\n    @cbook._delete_parameter(\"3.3\", \"progressive\",\n                             alternative=\"pil_kwargs={'progressive': ...}\")\n    def print_jpg(self, filename_or_obj, *args, dryrun=False, pil_kwargs=None,\n                  **kwargs):\n        \"\"\"\n        Write the figure to a JPEG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        Other Parameters\n        ----------------\n        quality : int, default: :rc:`savefig.jpeg_quality`\n            The image quality, on a scale from 1 (worst) to 95 (best).\n            Values above 95 should be avoided; 100 disables portions of\n            the JPEG compression algorithm, and results in large files\n            with hardly any gain in image quality.  This parameter is\n            deprecated.\n\n        optimize : bool, default: False\n            Whether the encoder should make an extra pass over the image\n            in order to select optimal encoder settings.  This parameter is\n            deprecated.\n\n        progressive : bool, default: False\n            Whether the image should be stored as a progressive JPEG file.\n            This parameter is deprecated.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.  These take\n            precedence over *quality*, *optimize* and *progressive*.\n        \"\"\"\n        # Remove transparency by alpha-blending on an assumed white background.\n        r, g, b, a = mcolors.to_rgba(self.figure.get_facecolor())\n        try:\n            self.figure.set_facecolor(a * np.array([r, g, b]) + 1 - a)\n            FigureCanvasAgg.draw(self)\n        finally:\n            self.figure.set_facecolor((r, g, b, a))\n        if dryrun:\n            return\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        for k in [\"quality\", \"optimize\", \"progressive\"]:\n            if k in kwargs:\n                pil_kwargs.setdefault(k, kwargs.pop(k))\n        if \"quality\" not in pil_kwargs:\n            quality = pil_kwargs[\"quality\"] = \\\n                dict.__getitem__(mpl.rcParams, \"savefig.jpeg_quality\")\n            if quality not in [0, 75, 95]:  # default qualities.\n                cbook.warn_deprecated(\n                    \"3.3\", name=\"savefig.jpeg_quality\", obj_type=\"rcParam\",\n                    addendum=\"Set the quality using \"\n                    \"`pil_kwargs={'quality': ...}`; the future default \"\n                    \"quality will be 75, matching the default of Pillow and \"\n                    \"libjpeg.\")\n        pil_kwargs.setdefault(\"dpi\", (self.figure.dpi, self.figure.dpi))\n        # Drop alpha channel now.\n        return (Image.fromarray(np.asarray(self.buffer_rgba())[..., :3])\n                .save(filename_or_obj, format='jpeg', **pil_kwargs))\n\n    print_jpeg = print_jpg\n\n    @_check_savefig_extra_args\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    def print_tif(self, filename_or_obj, *, dryrun=False, pil_kwargs=None):\n        FigureCanvasAgg.draw(self)\n        if dryrun:\n            return\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        pil_kwargs.setdefault(\"dpi\", (self.figure.dpi, self.figure.dpi))\n        return (Image.fromarray(np.asarray(self.buffer_rgba()))\n                .save(filename_or_obj, format='tiff', **pil_kwargs))\n\n    print_tiff = print_tif",
      "instance_attributes": [
        {
          "name": "renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererAgg"
          }
        },
        {
          "name": "_lastKey",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg",
      "name": "RendererAgg",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/_update_methods",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgba_minimized",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/_get_agg_font",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter",
        "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "code": "class RendererAgg(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles\n    \"\"\"\n\n    # we want to cache the fonts at the class level so that when\n    # multiple figures are created we can reuse them.  This helps with\n    # a bug on windows where the creation of too many figures leads to\n    # too many open file handles.  However, storing them at the class\n    # level is not thread safe.  The solution here is to let the\n    # FigureCanvas acquire a lock on the fontd at the start of the\n    # draw, and release it when it is done.  This allows multiple\n    # renderers to share the cached fonts, but only one figure can\n    # draw at time and so the font cache is used by only one\n    # renderer at a time.\n\n    lock = threading.RLock()\n\n    def __init__(self, width, height, dpi):\n        RendererBase.__init__(self)\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)\n\n    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}\n\n    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])\n\n    def _update_methods(self):\n        self.draw_gouraud_triangle = self._renderer.draw_gouraud_triangle\n        self.draw_gouraud_triangles = self._renderer.draw_gouraud_triangles\n        self.draw_image = self._renderer.draw_image\n        self.draw_markers = self._renderer.draw_markers\n        # This is its own method for the duration of the deprecation of\n        # offset_position = \"data\".\n        # self.draw_path_collection = self._renderer.draw_path_collection\n        self.draw_quad_mesh = self._renderer.draw_quad_mesh\n        self.copy_from_bbox = self._renderer.copy_from_bbox\n        self.get_content_extents = self._renderer.get_content_extents\n\n    def tostring_rgba_minimized(self):\n        extents = self.get_content_extents()\n        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n                [extents[0] + extents[2], self.height - extents[1]]]\n        region = self.copy_from_bbox(bbox)\n        return np.array(region), extents\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError as err:\n                    raise OverflowError(\n                        \"Exceeded cell block limit (set 'agg.path.chunksize' \"\n                        \"rcparam)\") from err\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError as err:\n                raise OverflowError(\"Exceeded cell block limit (set \"\n                                    \"'agg.path.chunksize' rcparam)\") from err\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        if offset_position == \"data\":\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Support for offset_position='data' is \"\n                \"deprecated since %(since)s and will be removed %(removal)s.\")\n        return self._renderer.draw_path_collection(\n            gc, master_transform, paths, all_transforms, offsets, offsetTrans,\n            facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls,\n            offset_position)\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw mathtext using :mod:`matplotlib.mathtext`.\"\"\"\n        ox, oy, width, height, descent, font_image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n\n        if font is None:\n            return None\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=flags)\n        font.draw_glyphs_to_bitmap(\n            antialiased=mpl.rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath in [\"TeX\", \"TeX!\"]:\n            if ismath == \"TeX!\":\n                cbook._warn_deprecated(\n                    \"3.3\", message=\"Support for ismath='TeX!' is deprecated \"\n                    \"since %(since)s and will be removed %(removal)s; use \"\n                    \"ismath='TeX' instead.\")\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        font.set_text(s, 0.0, flags=flags)\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d\n\n    @cbook._delete_parameter(\"3.2\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n\n        Z = texmanager.get_grey(s, size, self.dpi)\n        Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xd)\n        y = round(y + yd)\n        self._renderer.draw_text_image(Z, x, y, angle, gc)\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def _get_agg_font(self, prop):\n        \"\"\"\n        Get the font for text instance t, caching for efficiency\n        \"\"\"\n        fname = findfont(prop)\n        font = get_font(fname)\n\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, self.dpi)\n\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72\n\n    def buffer_rgba(self):\n        return memoryview(self._renderer)\n\n    def tostring_argb(self):\n        return np.asarray(self._renderer).take([3, 0, 1, 2], axis=2).tobytes()\n\n    def tostring_rgb(self):\n        return np.asarray(self._renderer).take([0, 1, 2], axis=2).tobytes()\n\n    def clear(self):\n        self._renderer.clear()\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True\n\n    def option_scale_image(self):\n        # docstring inherited\n        return False\n\n    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a pair of floats) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            # The incoming data is float, but the _renderer type-checking wants\n            # to see integers.\n            self._renderer.restore_region(region, int(x1), int(y1),\n                                          int(x2), int(y2), int(ox), int(oy))\n\n        else:\n            self._renderer.restore_region(region)\n\n    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()\n\n    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n\n        width, height = int(self.width), int(self.height)\n\n        buffer, (l, b, w, h) = self.tostring_rgba_minimized()\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if w > 0 and h > 0:\n            img = np.frombuffer(buffer, np.uint8)\n            img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                          self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            img = img[::-1]\n            self._renderer.draw_image(gc, l + ox, height - b - h + oy, img)",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "_renderer",
          "types": null
        },
        {
          "name": "_filter_renderers",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "mathtext_parser",
          "types": null
        },
        {
          "name": "bbox",
          "types": null
        },
        {
          "name": "draw_gouraud_triangle",
          "types": null
        },
        {
          "name": "draw_gouraud_triangles",
          "types": null
        },
        {
          "name": "draw_image",
          "types": null
        },
        {
          "name": "draw_markers",
          "types": null
        },
        {
          "name": "draw_quad_mesh",
          "types": null
        },
        {
          "name": "copy_from_bbox",
          "types": null
        },
        {
          "name": "get_content_extents",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo",
      "name": "FigureCanvasCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_get_printed_image_surface",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_pdf",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_ps",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svg",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svgz",
        "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/_save"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasCairo(FigureCanvasBase):\n\n    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)\n\n    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"restore_region only works when rendering to an ImageSurface\")\n        surface.flush()\n        sw = surface.get_width()\n        sh = surface.get_height()\n        sly, slx = region._slices\n        (np.frombuffer(surface.get_data(), np.uint32)\n         .reshape((sh, sw))[sly, slx]) = region._data\n        surface.mark_dirty_rectangle(\n            slx.start, sly.start, slx.stop - slx.start, sly.stop - sly.start)\n\n    @_check_savefig_extra_args\n    def print_png(self, fobj):\n        self._get_printed_image_surface().write_to_png(fobj)\n\n    @_check_savefig_extra_args\n    def print_rgba(self, fobj):\n        width, height = self.get_width_height()\n        buf = self._get_printed_image_surface().get_data()\n        fobj.write(cbook._premultiplied_argb32_to_unmultiplied_rgba8888(\n            np.asarray(buf).reshape((width, height, 4))))\n\n    print_raw = print_rgba\n\n    def _get_printed_image_surface(self):\n        width, height = self.get_width_height()\n        renderer = RendererCairo(self.figure.dpi)\n        renderer.set_width_height(width, height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        renderer.set_ctx_from_surface(surface)\n        self.figure.draw(renderer)\n        return surface\n\n    def print_pdf(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'pdf', *args, **kwargs)\n\n    def print_ps(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'ps', *args, **kwargs)\n\n    def print_svg(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'svg', *args, **kwargs)\n\n    def print_svgz(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'svgz', *args, **kwargs)\n\n    @_check_savefig_extra_args\n    def _save(self, fo, fmt, *, orientation='portrait'):\n        # save PDF/PS/SVG\n\n        dpi = 72\n        self.figure.dpi = dpi\n        w_in, h_in = self.figure.get_size_inches()\n        width_in_points, height_in_points = w_in * dpi, h_in * dpi\n\n        if orientation == 'landscape':\n            width_in_points, height_in_points = (\n                height_in_points, width_in_points)\n\n        if fmt == 'ps':\n            if not hasattr(cairo, 'PSSurface'):\n                raise RuntimeError('cairo has not been compiled with PS '\n                                   'support enabled')\n            surface = cairo.PSSurface(fo, width_in_points, height_in_points)\n        elif fmt == 'pdf':\n            if not hasattr(cairo, 'PDFSurface'):\n                raise RuntimeError('cairo has not been compiled with PDF '\n                                   'support enabled')\n            surface = cairo.PDFSurface(fo, width_in_points, height_in_points)\n        elif fmt in ('svg', 'svgz'):\n            if not hasattr(cairo, 'SVGSurface'):\n                raise RuntimeError('cairo has not been compiled with SVG '\n                                   'support enabled')\n            if fmt == 'svgz':\n                if isinstance(fo, str):\n                    fo = gzip.GzipFile(fo, 'wb')\n                else:\n                    fo = gzip.GzipFile(None, 'wb', fileobj=fo)\n            surface = cairo.SVGSurface(fo, width_in_points, height_in_points)\n        else:\n            raise ValueError(\"Unknown format: {!r}\".format(fmt))\n\n        # surface.set_dpi() can be used\n        renderer = RendererCairo(self.figure.dpi)\n        renderer.set_width_height(width_in_points, height_in_points)\n        renderer.set_ctx_from_surface(surface)\n        ctx = renderer.gc.ctx\n\n        if orientation == 'landscape':\n            ctx.rotate(np.pi / 2)\n            ctx.translate(0, -height_in_points)\n            # Perhaps add an '%%Orientation: Landscape' comment?\n\n        self.figure.draw(renderer)\n\n        ctx.show_page()\n        surface.finish()\n        if fmt == 'svgz':\n            fo.close()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo",
      "name": "GraphicsContextCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle",
        "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextCairo(GraphicsContextBase):\n    _joind = {\n        'bevel':  cairo.LINE_JOIN_BEVEL,\n        'miter':  cairo.LINE_JOIN_MITER,\n        'round':  cairo.LINE_JOIN_ROUND,\n    }\n\n    _capd = {\n        'butt':        cairo.LINE_CAP_BUTT,\n        'projecting':  cairo.LINE_CAP_SQUARE,\n        'round':       cairo.LINE_CAP_ROUND,\n    }\n\n    def __init__(self, renderer):\n        GraphicsContextBase.__init__(self)\n        self.renderer = renderer\n\n    def restore(self):\n        self.ctx.restore()\n\n    def set_alpha(self, alpha):\n        GraphicsContextBase.set_alpha(self, alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], rgb[3])\n\n    # def set_antialiased(self, b):\n        # cairo has many antialiasing modes, we need to pick one for True and\n        # one for False.\n\n    def set_capstyle(self, cs):\n        self.ctx.set_line_cap(cbook._check_getitem(self._capd, capstyle=cs))\n        self._capstyle = cs\n\n    def set_clip_rectangle(self, rectangle):\n        if not rectangle:\n            return\n        x, y, w, h = np.round(rectangle.bounds)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle(x, self.renderer.height - h - y, w, h)\n        ctx.clip()\n\n    def set_clip_path(self, path):\n        if not path:\n            return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = (affine\n                  + Affine2D().scale(1, -1).translate(0, self.renderer.height))\n        _append_path(ctx, tpath, affine)\n        ctx.clip()\n\n    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes is None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))),\n                offset)\n\n    def set_foreground(self, fg, isRGBA=None):\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)\n\n    def get_rgb(self):\n        return self.ctx.get_source().get_rgba()[:3]\n\n    def set_joinstyle(self, js):\n        self.ctx.set_line_join(cbook._check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js\n\n    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))",
      "instance_attributes": [
        {
          "name": "ctx",
          "types": null
        },
        {
          "name": "_alpha",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_forced_alpha",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "renderer",
          "types": null
        },
        {
          "name": "_capstyle",
          "types": null
        },
        {
          "name": "_dashes",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_joinstyle",
          "types": null
        },
        {
          "name": "_linewidth",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo",
      "name": "RendererCairo",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/fontweights@getter",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/fontangles@getter",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/_fill_and_stroke",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/_draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererCairo(RendererBase):\n    @cbook.deprecated(\"3.3\")\n    @property\n    def fontweights(self):\n        return {\n            100:          cairo.FONT_WEIGHT_NORMAL,\n            200:          cairo.FONT_WEIGHT_NORMAL,\n            300:          cairo.FONT_WEIGHT_NORMAL,\n            400:          cairo.FONT_WEIGHT_NORMAL,\n            500:          cairo.FONT_WEIGHT_NORMAL,\n            600:          cairo.FONT_WEIGHT_BOLD,\n            700:          cairo.FONT_WEIGHT_BOLD,\n            800:          cairo.FONT_WEIGHT_BOLD,\n            900:          cairo.FONT_WEIGHT_BOLD,\n            'ultralight': cairo.FONT_WEIGHT_NORMAL,\n            'light':      cairo.FONT_WEIGHT_NORMAL,\n            'normal':     cairo.FONT_WEIGHT_NORMAL,\n            'medium':     cairo.FONT_WEIGHT_NORMAL,\n            'regular':    cairo.FONT_WEIGHT_NORMAL,\n            'semibold':   cairo.FONT_WEIGHT_BOLD,\n            'bold':       cairo.FONT_WEIGHT_BOLD,\n            'heavy':      cairo.FONT_WEIGHT_BOLD,\n            'ultrabold':  cairo.FONT_WEIGHT_BOLD,\n            'black':      cairo.FONT_WEIGHT_BOLD,\n        }\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def fontangles(self):\n        return {\n            'italic':  cairo.FONT_SLANT_ITALIC,\n            'normal':  cairo.FONT_SLANT_NORMAL,\n            'oblique': cairo.FONT_SLANT_OBLIQUE,\n        }\n\n    def __init__(self, dpi):\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo(renderer=self)\n        self.text_ctx = cairo.Context(\n           cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1))\n        self.mathtext_parser = MathTextParser('Cairo')\n        RendererBase.__init__(self)\n\n    def set_ctx_from_surface(self, surface):\n        self.gc.ctx = cairo.Context(surface)\n        # Although it may appear natural to automatically call\n        # `self.set_width_height(surface.get_width(), surface.get_height())`\n        # here (instead of having the caller do so separately), this would fail\n        # for PDF/PS/SVG surfaces, which have no way to report their extents.\n\n    def set_width_height(self, width, height):\n        self.width = width\n        self.height = height\n\n    def _fill_and_stroke(self, ctx, fill_c, alpha, alpha_overrides):\n        if fill_c is not None:\n            ctx.save()\n            if len(fill_c) == 3 or alpha_overrides:\n                ctx.set_source_rgba(fill_c[0], fill_c[1], fill_c[2], alpha)\n            else:\n                ctx.set_source_rgba(fill_c[0], fill_c[1], fill_c[2], fill_c[3])\n            ctx.fill_preserve()\n            ctx.restore()\n        ctx.stroke()\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        ctx = gc.ctx\n        # Clip the path to the actual rendering extents if it isn't filled.\n        clip = (ctx.clip_extents()\n                if rgbFace is None and gc.get_hatch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        self._fill_and_stroke(\n            ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            filled = True\n\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n\n        ctx.new_path()\n        for i, (vertices, codes) in enumerate(\n                path.iter_segments(transform, simplify=False)):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ctx.save()\n\n                # Translate and apply path\n                ctx.translate(x, y)\n                ctx.append_path(marker_path)\n\n                ctx.restore()\n\n                # Slower code path if there is a fill; we need to draw\n                # the fill and stroke for each marker at the same time.\n                # Also flush out the drawing every once in a while to\n                # prevent the paths from getting way too long.\n                if filled or i % 1000 == 0:\n                    self._fill_and_stroke(\n                        ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n        # Fast path, if there is no fill, draw everything in one step\n        if not filled:\n            self._fill_and_stroke(\n                ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n    def draw_image(self, gc, x, y, im):\n        im = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(im[::-1])\n        surface = cairo.ImageSurface.create_for_data(\n            im.ravel().data, cairo.FORMAT_ARGB32,\n            im.shape[1], im.shape[0], im.shape[1] * 4)\n        ctx = gc.ctx\n        y = self.height - y - im.shape[0]\n\n        ctx.save()\n        ctx.set_source_surface(surface, float(x), float(y))\n        ctx.paint()\n        ctx.restore()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # Note: (x, y) are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to(x, y)\n\n            ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n            ctx.save()\n            ctx.set_font_size(prop.get_size_in_points() * self.dpi / 72)\n            if angle:\n                ctx.rotate(np.deg2rad(-angle))\n            ctx.show_text(s)\n            ctx.restore()\n\n    def _draw_mathtext(self, gc, x, y, s, prop, angle):\n        ctx = gc.ctx\n        width, height, descent, glyphs, rects = self.mathtext_parser.parse(\n            s, self.dpi, prop)\n\n        ctx.save()\n        ctx.translate(x, y)\n        if angle:\n            ctx.rotate(np.deg2rad(-angle))\n\n        for font, fontsize, s, ox, oy in glyphs:\n            ctx.new_path()\n            ctx.move_to(ox, oy)\n\n            ctx.select_font_face(\n                *_cairo_font_args_from_font_prop(ttfFontProperty(font)))\n            ctx.set_font_size(fontsize * self.dpi / 72)\n            ctx.show_text(s)\n\n        for ox, oy, w, h in rects:\n            ctx.new_path()\n            ctx.rectangle(ox, oy, w, h)\n            ctx.set_source_rgb(0, 0, 0)\n            ctx.fill_preserve()\n\n        ctx.restore()\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.save()\n        ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n        # Cairo (says it) uses 1/96 inch user space units, ref: cairo_gstate.c\n        # but if /96.0 is used the font is too small\n        ctx.set_font_size(prop.get_size_in_points() * self.dpi / 72)\n\n        y_bearing, w, h = ctx.text_extents(s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing\n\n    def new_gc(self):\n        # docstring inherited\n        self.gc.ctx.save()\n        self.gc._alpha = 1\n        self.gc._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        return self.gc\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points / 72 * self.dpi",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextCairo"
          }
        },
        {
          "name": "text_ctx",
          "types": null
        },
        {
          "name": "mathtext_parser",
          "types": null
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3",
      "name": "ConfigureSubplotsGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3",
      "decorators": [],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase",
        "Gtk.Window"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@getter",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@setter",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/init_window",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/_get_canvas",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsGTK3(backend_tools.ConfigureSubplotsBase, Gtk.Window):\n    @cbook.deprecated(\"3.2\")\n    @property\n    def window(self):\n        if not hasattr(self, \"_window\"):\n            self._window = None\n        return self._window\n\n    @window.setter\n    @cbook.deprecated(\"3.2\")\n    def window(self, window):\n        self._window = window\n\n    @cbook.deprecated(\"3.2\")\n    def init_window(self):\n        if self.window:\n            return\n        self.window = Gtk.Window(title=\"Subplot Configuration Tool\")\n\n        try:\n            self.window.window.set_icon_from_file(window_icon)\n        except Exception:\n            # we presumably already logged a message on the\n            # failure of the main plot, don't keep reporting\n            pass\n\n        self.vbox = Gtk.Box()\n        self.vbox.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.window.add(self.vbox)\n        self.vbox.show()\n        self.window.connect('destroy', self.destroy)\n\n        toolfig = Figure(figsize=(6, 3))\n        canvas = self.figure.canvas.__class__(toolfig)\n\n        toolfig.subplots_adjust(top=0.9)\n        SubplotTool(self.figure, toolfig)\n\n        w = int(toolfig.bbox.width)\n        h = int(toolfig.bbox.height)\n\n        self.window.set_default_size(w, h)\n\n        canvas.show()\n        self.vbox.pack_start(canvas, True, True, 0)\n        self.window.show()\n\n    @cbook.deprecated(\"3.2\")\n    def destroy(self, *args):\n        self.window.destroy()\n        self.window = None\n\n    def _get_canvas(self, fig):\n        return self.canvas.__class__(fig)\n\n    def trigger(self, *args):\n        NavigationToolbar2GTK3.configure_subplots(\n            self._make_classic_style_pseudo_toolbar(), None)",
      "instance_attributes": [
        {
          "name": "_window",
          "types": null
        },
        {
          "name": "window",
          "types": null
        },
        {
          "name": "vbox",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3",
      "name": "FigureCanvasGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3",
      "decorators": [],
      "superclasses": [
        "Gtk.DrawingArea",
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_renderer_init",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/_post_draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3(Gtk.DrawingArea, FigureCanvasBase):\n    required_interactive_framework = \"gtk3\"\n    _timer_cls = TimerGTK3\n\n    keyvald = {65507: 'control',\n               65505: 'shift',\n               65513: 'alt',\n               65508: 'control',\n               65506: 'shift',\n               65514: 'alt',\n               65361: 'left',\n               65362: 'up',\n               65363: 'right',\n               65364: 'down',\n               65307: 'escape',\n               65470: 'f1',\n               65471: 'f2',\n               65472: 'f3',\n               65473: 'f4',\n               65474: 'f5',\n               65475: 'f6',\n               65476: 'f7',\n               65477: 'f8',\n               65478: 'f9',\n               65479: 'f10',\n               65480: 'f11',\n               65481: 'f12',\n               65300: 'scroll_lock',\n               65299: 'break',\n               65288: 'backspace',\n               65293: 'enter',\n               65379: 'insert',\n               65535: 'delete',\n               65360: 'home',\n               65367: 'end',\n               65365: 'pageup',\n               65366: 'pagedown',\n               65438: '0',\n               65436: '1',\n               65433: '2',\n               65435: '3',\n               65430: '4',\n               65437: '5',\n               65432: '6',\n               65429: '7',\n               65431: '8',\n               65434: '9',\n               65451: '+',\n               65453: '-',\n               65450: '*',\n               65455: '/',\n               65439: 'dec',\n               65421: 'enter',\n               }\n\n    # Setting this as a static constant prevents\n    # this resulting expression from leaking\n    event_mask = (Gdk.EventMask.BUTTON_PRESS_MASK\n                  | Gdk.EventMask.BUTTON_RELEASE_MASK\n                  | Gdk.EventMask.EXPOSURE_MASK\n                  | Gdk.EventMask.KEY_PRESS_MASK\n                  | Gdk.EventMask.KEY_RELEASE_MASK\n                  | Gdk.EventMask.ENTER_NOTIFY_MASK\n                  | Gdk.EventMask.LEAVE_NOTIFY_MASK\n                  | Gdk.EventMask.POINTER_MOTION_MASK\n                  | Gdk.EventMask.POINTER_MOTION_HINT_MASK\n                  | Gdk.EventMask.SCROLL_MASK)\n\n    def __init__(self, figure):\n        FigureCanvasBase.__init__(self, figure)\n        GObject.GObject.__init__(self)\n\n        self._idle_draw_id = 0\n        self._lastCursor = None\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_double_buffered(True)\n        self.set_can_focus(True)\n\n        renderer_init = cbook._deprecate_method_override(\n            __class__._renderer_init, self, allow_empty=True, since=\"3.3\",\n            addendum=\"Please initialize the renderer, if needed, in the \"\n            \"subclass' __init__; a fully empty _renderer_init implementation \"\n            \"may be kept for compatibility with earlier versions of \"\n            \"Matplotlib.\")\n        if renderer_init:\n            renderer_init()\n\n    @cbook.deprecated(\"3.3\", alternative=\"__init__\")\n    def _renderer_init(self):\n        pass\n\n    def destroy(self):\n        #Gtk.DrawingArea.destroy(self)\n        self.close_event()\n\n    def scroll_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n        FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=event)\n        return False  # finish event propagation?\n\n    def button_press_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        FigureCanvasBase.button_press_event(\n            self, x, y, event.button, guiEvent=event)\n        return False  # finish event propagation?\n\n    def button_release_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        FigureCanvasBase.button_release_event(\n            self, x, y, event.button, guiEvent=event)\n        return False  # finish event propagation?\n\n    def key_press_event(self, widget, event):\n        key = self._get_key(event)\n        FigureCanvasBase.key_press_event(self, key, guiEvent=event)\n        return True  # stop event propagation\n\n    def key_release_event(self, widget, event):\n        key = self._get_key(event)\n        FigureCanvasBase.key_release_event(self, key, guiEvent=event)\n        return True  # stop event propagation\n\n    def motion_notify_event(self, widget, event):\n        if event.is_hint:\n            t, x, y, state = event.window.get_pointer()\n        else:\n            x, y = event.x, event.y\n\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - y\n        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event)\n        return False  # finish event propagation?\n\n    def leave_notify_event(self, widget, event):\n        FigureCanvasBase.leave_notify_event(self, event)\n\n    def enter_notify_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        FigureCanvasBase.enter_notify_event(self, guiEvent=event, xy=(x, y))\n\n    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width / dpival\n        hinch = allocation.height / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        FigureCanvasBase.resize_event(self)\n        self.draw_idle()\n\n    def _get_key(self, event):\n        if event.keyval in self.keyvald:\n            key = self.keyvald[event.keyval]\n        elif event.keyval < 256:\n            key = chr(event.keyval)\n        else:\n            key = None\n\n        modifiers = [\n                     (Gdk.ModifierType.MOD4_MASK, 'super'),\n                     (Gdk.ModifierType.MOD1_MASK, 'alt'),\n                     (Gdk.ModifierType.CONTROL_MASK, 'ctrl'),\n                    ]\n        for key_mask, prefix in modifiers:\n            if event.state & key_mask:\n                key = '{0}+{1}'.format(prefix, key)\n\n        return key\n\n    def configure_event(self, widget, event):\n        if widget.get_property(\"window\") is None:\n            return\n        w, h = event.width, event.height\n        if w < 3 or h < 3:\n            return  # empty fig\n        # resize the figure (in inches)\n        dpi = self.figure.dpi\n        self.figure.set_size_inches(w / dpi, h / dpi, forward=False)\n        return False  # finish event propagation?\n\n    def _draw_rubberband(self, rect):\n        self._rubberband_rect = rect\n        # TODO: Only update the rubberband area.\n        self.queue_draw()\n\n    def _post_draw(self, widget, ctx):\n        if self._rubberband_rect is None:\n            return\n\n        x0, y0, w, h = self._rubberband_rect\n        x1 = x0 + w\n        y1 = y0 + h\n\n        # Draw the lines from x0, y0 towards x1, y1 so that the\n        # dashes don't \"jump\" when moving the zoom box.\n        ctx.move_to(x0, y0)\n        ctx.line_to(x0, y1)\n        ctx.move_to(x0, y0)\n        ctx.line_to(x1, y0)\n        ctx.move_to(x0, y1)\n        ctx.line_to(x1, y1)\n        ctx.move_to(x1, y0)\n        ctx.line_to(x1, y1)\n\n        ctx.set_antialias(1)\n        ctx.set_line_width(1)\n        ctx.set_dash((3, 3), 0)\n        ctx.set_source_rgb(0, 0, 0)\n        ctx.stroke_preserve()\n\n        ctx.set_dash((3, 3), 3)\n        ctx.set_source_rgb(1, 1, 1)\n        ctx.stroke()\n\n    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK3Agg or GTK3Cairo\n        pass\n\n    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()\n\n    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)\n\n    def flush_events(self):\n        # docstring inherited\n        Gdk.threads_enter()\n        while Gtk.events_pending():\n            Gtk.main_iteration()\n        Gdk.flush()\n        Gdk.threads_leave()",
      "instance_attributes": [
        {
          "name": "_idle_draw_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_lastCursor",
          "types": null
        },
        {
          "name": "_rubberband_rect",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3",
      "name": "FigureManagerGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/destroy",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/show",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/full_screen_toggle",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/_get_toolbar",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Attributes\n----------\ncanvas : `FigureCanvas`\n    The FigureCanvas instance\nnum : int or str\n    The Figure number\ntoolbar : Gtk.Toolbar\n    The Gtk.Toolbar\nvbox : Gtk.VBox\n    The Gtk.VBox containing the canvas and toolbar\nwindow : Gtk.Window\n    The Gtk.Window",
      "code": "class FigureManagerGTK3(FigureManagerBase):\n    \"\"\"\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        The FigureCanvas instance\n    num : int or str\n        The Figure number\n    toolbar : Gtk.Toolbar\n        The Gtk.Toolbar\n    vbox : Gtk.VBox\n        The Gtk.VBox containing the canvas and toolbar\n    window : Gtk.Window\n        The Gtk.Window\n\n    \"\"\"\n    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n\n        self.window = Gtk.Window()\n        self.window.set_wmclass(\"matplotlib\", \"Matplotlib\")\n        self.set_window_title(\"Figure %d\" % num)\n        try:\n            self.window.set_icon_from_file(window_icon)\n        except Exception:\n            # Some versions of gtk throw a glib.GError but not all, so I am not\n            # sure how to catch it.  I am unhappy doing a blanket catch here,\n            # but am not sure what a better way is - JDH\n            _log.info('Could not load matplotlib icon: %s', sys.exc_info()[1])\n\n        self.vbox = Gtk.Box()\n        self.vbox.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.window.add(self.vbox)\n        self.vbox.show()\n\n        self.canvas.show()\n\n        self.vbox.pack_start(self.canvas, True, True, 0)\n        # calculate size for window\n        w = int(self.canvas.figure.bbox.width)\n        h = int(self.canvas.figure.bbox.height)\n\n        self.toolbar = self._get_toolbar()\n\n        def add_widget(child):\n            child.show()\n            self.vbox.pack_end(child, False, False, 0)\n            size_request = child.size_request()\n            return size_request.height\n\n        if self.toolmanager:\n            backend_tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                backend_tools.add_tools_to_container(self.toolbar)\n\n        if self.toolbar is not None:\n            self.toolbar.show()\n            h += add_widget(self.toolbar)\n\n        self.window.set_default_size(w, h)\n\n        self._destroying = False\n        self.window.connect(\"destroy\", lambda *args: Gcf.destroy(self))\n        self.window.connect(\"delete_event\", lambda *args: Gcf.destroy(self))\n        if mpl.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        self.canvas.grab_focus()\n\n    def destroy(self, *args):\n        if self._destroying:\n            # Otherwise, this can be called twice when the user presses 'q',\n            # which calls Gcf.destroy(self), then this destroy(), then triggers\n            # Gcf.destroy(self) once again via\n            # `connect(\"destroy\", lambda *args: Gcf.destroy(self))`.\n            return\n        self._destroying = True\n        self.vbox.destroy()\n        self.window.destroy()\n        self.canvas.destroy()\n        if self.toolbar:\n            self.toolbar.destroy()\n\n        if (Gcf.get_num_fig_managers() == 0 and not mpl.is_interactive() and\n                Gtk.main_level() >= 1):\n            Gtk.main_quit()\n\n    def show(self):\n        # show the figure window\n        self.window.show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.window.present()\n\n    def full_screen_toggle(self):\n        self._full_screen_flag = not self._full_screen_flag\n        if self._full_screen_flag:\n            self.window.fullscreen()\n        else:\n            self.window.unfullscreen()\n    _full_screen_flag = False\n\n    def _get_toolbar(self):\n        # must be inited after the window, drawingArea and figure\n        # attrs are set\n        if mpl.rcParams['toolbar'] == 'toolbar2':\n            toolbar = NavigationToolbar2GTK3(self.canvas, self.window)\n        elif mpl.rcParams['toolbar'] == 'toolmanager':\n            toolbar = ToolbarGTK3(self.toolmanager)\n        else:\n            toolbar = None\n        return toolbar\n\n    def get_window_title(self):\n        return self.window.get_title()\n\n    def set_window_title(self, title):\n        self.window.set_title(title)\n\n    def resize(self, width, height):\n        \"\"\"Set the canvas size in pixels.\"\"\"\n        if self.toolbar:\n            toolbar_size = self.toolbar.size_request()\n            height += toolbar_size.height\n        canvas_size = self.canvas.get_allocation()\n        if canvas_size.width == canvas_size.height == 1:\n            # A canvas size of (1, 1) cannot exist in most cases, because\n            # window decorations would prevent such a small window. This call\n            # must be before the window has been mapped and widgets have been\n            # sized, so just change the window's starting size.\n            self.window.set_default_size(width, height)\n        else:\n            self.window.resize(width, height)",
      "instance_attributes": [
        {
          "name": "window",
          "types": null
        },
        {
          "name": "vbox",
          "types": null
        },
        {
          "name": "toolbar",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "ToolbarGTK3"
              },
              {
                "kind": "NamedType",
                "name": "NavigationToolbar2GTK3"
              }
            ]
          }
        },
        {
          "name": "_destroying",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_full_screen_flag",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3",
      "name": "HelpGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3",
      "decorators": [],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_normalize_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_is_valid_shortcut",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_show_shortcuts_window",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/_show_shortcuts_dialog",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpGTK3(backend_tools.ToolHelpBase):\n    def _normalize_shortcut(self, key):\n        \"\"\"\n        Convert Matplotlib key presses to GTK+ accelerator identifiers.\n\n        Related to `FigureCanvasGTK3._get_key`.\n        \"\"\"\n        special = {\n            'backspace': 'BackSpace',\n            'pagedown': 'Page_Down',\n            'pageup': 'Page_Up',\n            'scroll_lock': 'Scroll_Lock',\n        }\n\n        parts = key.split('+')\n        mods = ['<' + mod + '>' for mod in parts[:-1]]\n        key = parts[-1]\n\n        if key in special:\n            key = special[key]\n        elif len(key) > 1:\n            key = key.capitalize()\n        elif key.isupper():\n            mods += ['<shift>']\n\n        return ''.join(mods) + key\n\n    def _is_valid_shortcut(self, key):\n        \"\"\"\n        Check for a valid shortcut to be displayed.\n\n        - GTK will never send 'cmd+' (see `FigureCanvasGTK3._get_key`).\n        - The shortcut window only shows keyboard shortcuts, not mouse buttons.\n        \"\"\"\n        return 'cmd+' not in key and not key.startswith('MouseButton.')\n\n    def _show_shortcuts_window(self):\n        section = Gtk.ShortcutsSection()\n\n        for name, tool in sorted(self.toolmanager.tools.items()):\n            if not tool.description:\n                continue\n\n            # Putting everything in a separate group allows GTK to\n            # automatically split them into separate columns/pages, which is\n            # useful because we have lots of shortcuts, some with many keys\n            # that are very wide.\n            group = Gtk.ShortcutsGroup()\n            section.add(group)\n            # A hack to remove the title since we have no group naming.\n            group.forall(lambda widget, data: widget.set_visible(False), None)\n\n            shortcut = Gtk.ShortcutsShortcut(\n                accelerator=' '.join(\n                    self._normalize_shortcut(key)\n                    for key in self.toolmanager.get_tool_keymap(name)\n                    if self._is_valid_shortcut(key)),\n                title=tool.name,\n                subtitle=tool.description)\n            group.add(shortcut)\n\n        window = Gtk.ShortcutsWindow(\n            title='Help',\n            modal=True,\n            transient_for=self._figure.canvas.get_toplevel())\n        section.show()  # Must be done explicitly before add!\n        window.add(section)\n\n        window.show_all()\n\n    def _show_shortcuts_dialog(self):\n        dialog = Gtk.MessageDialog(\n            self._figure.canvas.get_toplevel(),\n            0, Gtk.MessageType.INFO, Gtk.ButtonsType.OK, self._get_help_text(),\n            title=\"Help\")\n        dialog.run()\n        dialog.destroy()\n\n    def trigger(self, *args):\n        if Gtk.check_version(3, 20, 0) is None:\n            self._show_shortcuts_window()\n        else:\n            self._show_shortcuts_dialog()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3",
      "name": "NavigationToolbar2GTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "Gtk.Toolbar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/ctx@getter",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_message",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/_update_buttons_checked",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/pan",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/zoom",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2GTK3(NavigationToolbar2, Gtk.Toolbar):\n    def __init__(self, canvas, window):\n        self.win = window\n        GObject.GObject.__init__(self)\n\n        self.set_style(Gtk.ToolbarStyle.ICONS)\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.insert(Gtk.SeparatorToolItem(), -1)\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            self._gtk_ids[text] = tbutton = (\n                Gtk.ToggleToolButton() if callback in ['zoom', 'pan'] else\n                Gtk.ToolButton())\n            tbutton.set_label(text)\n            tbutton.set_icon_widget(image)\n            self.insert(tbutton, -1)\n            # Save the handler id, so that we can block it as needed.\n            tbutton._signal_handler = tbutton.connect(\n                'clicked', getattr(self, callback))\n            tbutton.set_tooltip_text(tooltip_text)\n\n        toolitem = Gtk.SeparatorToolItem()\n        self.insert(toolitem, -1)\n        toolitem.set_draw(False)\n        toolitem.set_expand(True)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        toolitem.add(label)\n\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        self.message = Gtk.Label()\n        toolitem.add(self.message)\n\n        self.show_all()\n\n        NavigationToolbar2.__init__(self, canvas)\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def ctx(self):\n        return self.canvas.get_property(\"window\").cairo_create()\n\n    def set_message(self, s):\n        escaped = GLib.markup_escape_text(s)\n        self.message.set_markup(f'<small>{escaped}</small>')\n\n    def set_cursor(self, cursor):\n        window = self.canvas.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(cursord[cursor])\n            Gtk.main_iteration()\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas._draw_rubberband(rect)\n\n    def remove_rubberband(self):\n        self.canvas._draw_rubberband(None)\n\n    def _update_buttons_checked(self):\n        for name, active in [(\"Pan\", \"PAN\"), (\"Zoom\", \"ZOOM\")]:\n            button = self._gtk_ids.get(name)\n            if button:\n                with button.handler_block(button._signal_handler):\n                    button.set_active(self.mode.name == active)\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def save_figure(self, *args):\n        dialog = Gtk.FileChooserDialog(\n            title=\"Save the figure\",\n            parent=self.canvas.get_toplevel(),\n            action=Gtk.FileChooserAction.SAVE,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                     Gtk.STOCK_SAVE,   Gtk.ResponseType.OK),\n        )\n        for name, fmts \\\n                in self.canvas.get_supported_filetypes_grouped().items():\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(\"*.\" + fmt)\n            dialog.add_filter(ff)\n            if self.canvas.get_default_filetype() in fmts:\n                dialog.set_filter(ff)\n\n        @functools.partial(dialog.connect, \"notify::filter\")\n        def on_notify_filter(*args):\n            name = dialog.get_filter().get_name()\n            fmt = self.canvas.get_supported_filetypes_grouped()[name][0]\n            dialog.set_current_name(\n                str(Path(dialog.get_current_name()).with_suffix(\".\" + fmt)))\n\n        dialog.set_current_folder(mpl.rcParams[\"savefig.directory\"])\n        dialog.set_current_name(self.canvas.get_default_filename())\n        dialog.set_do_overwrite_confirmation(True)\n\n        response = dialog.run()\n        fname = dialog.get_filename()\n        ff = dialog.get_filter()  # Doesn't autoadjust to filename :/\n        fmt = self.canvas.get_supported_filetypes_grouped()[ff.get_name()][0]\n        dialog.destroy()\n        if response != Gtk.ResponseType.OK:\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n        try:\n            self.canvas.figure.savefig(fname, format=fmt)\n        except Exception as e:\n            error_msg_gtk(str(e), parent=self)\n\n    def configure_subplots(self, button):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = type(self.canvas)(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n\n        w = int(toolfig.bbox.width)\n        h = int(toolfig.bbox.height)\n\n        window = Gtk.Window()\n        try:\n            window.set_icon_from_file(window_icon)\n        except Exception:\n            # we presumably already logged a message on the\n            # failure of the main plot, don't keep reporting\n            pass\n        window.set_title(\"Subplot Configuration Tool\")\n        window.set_default_size(w, h)\n        vbox = Gtk.Box()\n        vbox.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        window.add(vbox)\n        vbox.show()\n\n        canvas.show()\n        vbox.pack_start(canvas, True, True, 0)\n        window.show()\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self._gtk_ids:\n            self._gtk_ids['Back'].set_sensitive(can_backward)\n        if 'Forward' in self._gtk_ids:\n            self._gtk_ids['Forward'].set_sensitive(can_forward)",
      "instance_attributes": [
        {
          "name": "win",
          "types": null
        },
        {
          "name": "_gtk_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "message",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3",
      "name": "RubberbandGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3",
      "decorators": [],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RubberbandGTK3(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2GTK3.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2GTK3.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3",
      "name": "SaveFigureGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3",
      "decorators": [],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureGTK3(backend_tools.SaveFigureBase):\n    def trigger(self, *args, **kwargs):\n\n        class PseudoToolbar:\n            canvas = self.figure.canvas\n\n        return NavigationToolbar2GTK3.save_figure(PseudoToolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3",
      "name": "SetCursorGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3",
      "decorators": [],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorGTK3(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2GTK3.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3",
      "name": "StatusbarGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "superclasses": [
        "StatusbarBase",
        "Gtk.Statusbar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StatusbarGTK3(StatusbarBase, Gtk.Statusbar):\n    def __init__(self, *args, **kwargs):\n        StatusbarBase.__init__(self, *args, **kwargs)\n        Gtk.Statusbar.__init__(self)\n        self._context = self.get_context_id('message')\n\n    def set_message(self, s):\n        self.pop(self._context)\n        self.push(self._context, s)",
      "instance_attributes": [
        {
          "name": "_context",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3",
      "name": "TimerGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.TimerGTK3",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/_timer_set_interval",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/_on_timer"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using GTK3 timer events.",
      "docstring": "Subclass of `.TimerBase` using GTK3 timer events.",
      "code": "class TimerGTK3(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using GTK3 timer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._timer = None\n        TimerBase.__init__(self, *args, **kwargs)\n\n    def _timer_start(self):\n        # Need to stop it, otherwise we potentially leak a timer id that will\n        # never be stopped.\n        self._timer_stop()\n        self._timer = GLib.timeout_add(self._interval, self._on_timer)\n\n    def _timer_stop(self):\n        if self._timer is not None:\n            GLib.source_remove(self._timer)\n            self._timer = None\n\n    def _timer_set_interval(self):\n        # Only stop and restart it if the timer has already been started\n        if self._timer is not None:\n            self._timer_stop()\n            self._timer_start()\n\n    def _on_timer(self):\n        TimerBase._on_timer(self)\n\n        # Gtk timeout_add() requires that the callback returns True if it\n        # is to be called again.\n        if self.callbacks and not self._single:\n            return True\n        else:\n            self._timer = None\n            return False",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3",
      "name": "ToolCopyToClipboardGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3",
      "decorators": [],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardGTK3(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        window = self.canvas.get_window()\n        x, y, width, height = window.get_geometry()\n        pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)\n        clipboard.set_image(pb)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3",
      "name": "ToolbarGTK3",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "Gtk.Box"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_add_button",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_call_tool",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/_add_separator",
        "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarGTK3(ToolContainerBase, Gtk.Box):\n    _icon_extension = '-symbolic.svg'\n\n    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            tbutton = Gtk.ToggleToolButton()\n        else:\n            tbutton = Gtk.ToolButton()\n        tbutton.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            tbutton.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(tbutton, group, position)\n        signal = tbutton.connect('clicked', self._call_tool, name)\n        tbutton.set_tooltip_text(description)\n        tbutton.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tbutton, signal))\n\n    def _add_button(self, button, group, position):\n        if group not in self._groups:\n            if self._groups:\n                self._add_separator()\n            toolbar = Gtk.Toolbar()\n            toolbar.set_style(Gtk.ToolbarStyle.ICONS)\n            self.pack_start(toolbar, False, False, 0)\n            toolbar.show_all()\n            self._groups[group] = toolbar\n        self._groups[group].insert(button, position)\n\n    def _call_tool(self, btn, name):\n        self.trigger_tool(name)\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)\n\n    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event('%s Not in toolbar' % name, self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]\n\n    def _add_separator(self):\n        sep = Gtk.Separator()\n        sep.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.pack_start(sep, False, True, 0)\n        sep.show_all()\n\n    def set_message(self, s):\n        self._message.set_label(s)",
      "instance_attributes": [
        {
          "name": "_message",
          "types": null
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg",
      "name": "FigureCanvasGTK3Agg",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg",
      "decorators": [],
      "superclasses": [
        "backend_gtk3.FigureCanvasGTK3",
        "backend_agg.FigureCanvasAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/draw",
        "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/print_png"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3Agg(backend_gtk3.FigureCanvasGTK3,\n                          backend_agg.FigureCanvasAgg):\n    def __init__(self, figure):\n        backend_gtk3.FigureCanvasGTK3.__init__(self, figure)\n        self._bbox_queue = []\n\n    def on_draw_event(self, widget, ctx):\n        \"\"\"GtkDrawable draw event, like expose_event in GTK 2.X.\"\"\"\n        allocation = self.get_allocation()\n        w, h = allocation.width, allocation.height\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        ctx = backend_cairo._to_context(ctx)\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            ctx.set_source_surface(image, x, y)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False\n\n    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        allocation = self.get_allocation()\n        x = int(bbox.x0)\n        y = allocation.height - int(bbox.y1)\n        width = int(bbox.x1) - int(bbox.x0)\n        height = int(bbox.y1) - int(bbox.y0)\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)\n\n    def draw(self):\n        backend_agg.FigureCanvasAgg.draw(self)\n        super().draw()\n\n    def print_png(self, filename, *args, **kwargs):\n        # Do this so we can save the resolution of figure in the PNG file\n        agg = self.switch_backends(backend_agg.FigureCanvasAgg)\n        return agg.print_png(filename, *args, **kwargs)",
      "instance_attributes": [
        {
          "name": "_bbox_queue",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureManagerGTK3Agg",
      "name": "FigureManagerGTK3Agg",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureManagerGTK3Agg",
      "decorators": [],
      "superclasses": [
        "backend_gtk3.FigureManagerGTK3"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerGTK3Agg(backend_gtk3.FigureManagerGTK3):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo",
      "name": "FigureCanvasGTK3Cairo",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo",
      "decorators": [],
      "superclasses": [
        "backend_gtk3.FigureCanvasGTK3",
        "backend_cairo.FigureCanvasCairo"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasGTK3Cairo(backend_gtk3.FigureCanvasGTK3,\n                            backend_cairo.FigureCanvasCairo):\n\n    def __init__(self, figure):\n        super().__init__(figure)\n        self._renderer = RendererGTK3Cairo(self.figure.dpi)\n\n    def on_draw_event(self, widget, ctx):\n        \"\"\"GtkDrawable draw event.\"\"\"\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.set_width_height(\n                allocation.width, allocation.height)\n            self.figure.draw(self._renderer)",
      "instance_attributes": [
        {
          "name": "_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererGTK3Cairo"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/RendererGTK3Cairo",
      "name": "RendererGTK3Cairo",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.RendererGTK3Cairo",
      "decorators": [],
      "superclasses": [
        "backend_cairo.RendererCairo"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/RendererGTK3Cairo/set_context"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererGTK3Cairo(backend_cairo.RendererCairo):\n    def set_context(self, ctx):\n        self.gc.ctx = backend_cairo._to_context(ctx)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac",
      "name": "FigureCanvasMac",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac",
      "decorators": [],
      "superclasses": [
        "_macosx.FigureCanvas",
        "FigureCanvasAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/_set_device_scale",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/_draw",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/invalidate",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc...\n\nEvents such as button presses, mouse movements, and key presses\nare handled in the C code and the base class methods\nbutton_press_event, button_release_event, motion_notify_event,\nkey_press_event, and key_release_event are called from there.",
      "docstring": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc...\n\nEvents such as button presses, mouse movements, and key presses\nare handled in the C code and the base class methods\nbutton_press_event, button_release_event, motion_notify_event,\nkey_press_event, and key_release_event are called from there.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    A high-level Figure instance",
      "code": "class FigureCanvasMac(_macosx.FigureCanvas, FigureCanvasAgg):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc...\n\n    Events such as button presses, mouse movements, and key presses\n    are handled in the C code and the base class methods\n    button_press_event, button_release_event, motion_notify_event,\n    key_press_event, and key_release_event are called from there.\n\n    Attributes\n    ----------\n    figure : `matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    required_interactive_framework = \"macosx\"\n    _timer_cls = TimerMac\n\n    def __init__(self, figure):\n        FigureCanvasBase.__init__(self, figure)\n        width, height = self.get_width_height()\n        _macosx.FigureCanvas.__init__(self, width, height)\n        self._dpi_ratio = 1.0\n\n    def _set_device_scale(self, value):\n        if self._dpi_ratio != value:\n            # Need the new value in place before setting figure.dpi, which\n            # will trigger a resize\n            self._dpi_ratio, old_value = value, self._dpi_ratio\n            self.figure.dpi = self.figure.dpi / old_value * self._dpi_ratio\n\n    def _draw(self):\n        renderer = self.get_renderer(cleared=self.figure.stale)\n        if self.figure.stale:\n            self.figure.draw(renderer)\n        return renderer\n\n    def draw(self):\n        # docstring inherited\n        self.draw_idle()\n        self.flush_events()\n\n    # draw_idle is provided by _macosx.FigureCanvas\n\n    @cbook.deprecated(\"3.2\", alternative=\"draw_idle()\")\n    def invalidate(self):\n        return self.draw_idle()\n\n    def blit(self, bbox=None):\n        self.draw_idle()\n\n    def resize(self, width, height):\n        dpi = self.figure.dpi\n        width /= dpi\n        height /= dpi\n        self.figure.set_size_inches(width * self._dpi_ratio,\n                                    height * self._dpi_ratio,\n                                    forward=False)\n        FigureCanvasBase.resize_event(self)\n        self.draw_idle()",
      "instance_attributes": [
        {
          "name": "_dpi_ratio",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac",
      "name": "FigureManagerMac",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac",
      "decorators": [],
      "superclasses": [
        "_macosx.FigureManager",
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Wrap everything up into a window for the pylab interface",
      "docstring": "Wrap everything up into a window for the pylab interface",
      "code": "class FigureManagerMac(_macosx.FigureManager, FigureManagerBase):\n    \"\"\"\n    Wrap everything up into a window for the pylab interface\n    \"\"\"\n    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n        title = \"Figure %d\" % num\n        _macosx.FigureManager.__init__(self, canvas, title)\n        if mpl.rcParams['toolbar'] == 'toolbar2':\n            self.toolbar = NavigationToolbar2Mac(canvas)\n        else:\n            self.toolbar = None\n        if self.toolbar is not None:\n            self.toolbar.update()\n\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()\n\n    def close(self):\n        Gcf.destroy(self)",
      "instance_attributes": [
        {
          "name": "toolbar",
          "types": {
            "kind": "NamedType",
            "name": "NavigationToolbar2Mac"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac",
      "name": "NavigationToolbar2Mac",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac",
      "decorators": [],
      "superclasses": [
        "_macosx.NavigationToolbar2",
        "NavigationToolbar2"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/release_zoom",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2Mac(_macosx.NavigationToolbar2, NavigationToolbar2):\n\n    def __init__(self, canvas):\n        self.canvas = canvas  # Needed by the _macosx __init__.\n        data_path = cbook._get_data_path('images')\n        _, tooltips, image_names, _ = zip(*NavigationToolbar2.toolitems)\n        _macosx.NavigationToolbar2.__init__(\n            self,\n            tuple(str(data_path / image_name) + \".pdf\"\n                  for image_name in image_names if image_name is not None),\n            tuple(tooltip for tooltip in tooltips if tooltip is not None))\n        NavigationToolbar2.__init__(self, canvas)\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))\n\n    def release_zoom(self, event):\n        super().release_zoom(event)\n        self.canvas.remove_rubberband()\n\n    def set_cursor(self, cursor):\n        _macosx.set_cursor(cursor)\n\n    def save_figure(self, *args):\n        filename = _macosx.choose_save_file('Save the figure',\n                                            self.canvas.get_default_filename())\n        if filename is None:  # Cancel\n            return\n        self.canvas.figure.savefig(filename)\n\n    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas\n\n    def set_message(self, message):\n        _macosx.NavigationToolbar2.set_message(self, message.encode('utf-8'))",
      "instance_attributes": [
        {
          "name": "canvas",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/TimerMac",
      "name": "TimerMac",
      "qname": "lib.matplotlib.backends.backend_macosx.TimerMac",
      "decorators": [],
      "superclasses": [
        "_macosx.Timer",
        "TimerBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using CFRunLoop timer events.",
      "docstring": "Subclass of `.TimerBase` using CFRunLoop timer events.",
      "code": "class TimerMac(_macosx.Timer, TimerBase):\n    \"\"\"Subclass of `.TimerBase` using CFRunLoop timer events.\"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer",
      "name": "MixedModeRenderer",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing",
        "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "docstring": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "code": "class MixedModeRenderer:\n    \"\"\"\n    A helper class to implement a renderer that switches between\n    vector and raster drawing.  An example may be a PDF writer, where\n    most things are drawn with PDF vector commands, but some very\n    complex objects, such as quad meshes, are rasterised and then\n    output as images.\n    \"\"\"\n    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n\n        width : scalar\n            The width of the canvas in logical units\n\n        height : scalar\n            The height of the canvas in logical units\n\n        dpi : float\n            The dpi of the canvas\n\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n        self._rasterizing = 0\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.get_dpi()\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer\n\n    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)\n\n    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.set_dpi(self.dpi)\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n        if self._rasterizing == 0:\n            self._raster_renderer = self._raster_renderer_class(\n                self._width*self.dpi, self._height*self.dpi, self.dpi)\n            self._renderer = self._raster_renderer\n        self._rasterizing += 1\n\n    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last `start_rasterizing` call will be copied to the\n        vector backend by calling draw_image.\n\n        If `start_rasterizing` has been called multiple times,\n        `stop_rasterizing` must be called the same number of times before\n        \"raster\" mode is exited.\n        \"\"\"\n        self._rasterizing -= 1\n        if self._rasterizing == 0:\n            self._renderer = self._vector_renderer\n\n            height = self._height * self.dpi\n            buffer, bounds = self._raster_renderer.tostring_rgba_minimized()\n            l, b, w, h = bounds\n            if w > 0 and h > 0:\n                image = np.frombuffer(buffer, dtype=np.uint8)\n                image = image.reshape((h, w, 4))\n                image = image[::-1]\n                gc = self._renderer.new_gc()\n                # TODO: If the mixedmode resolution differs from the figure's\n                #       dpi, the image must be scaled (dpi->_figdpi). Not all\n                #       backends support this.\n                self._renderer.draw_image(\n                    gc,\n                    l * self._figdpi / self.dpi,\n                    (height-b-h) * self._figdpi / self.dpi,\n                    image)\n            self._raster_renderer = None\n            self._rasterizing = False\n\n            # restore the figure dpi.\n            self.figure.set_dpi(self._figdpi)\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r",
      "instance_attributes": [
        {
          "name": "_raster_renderer_class",
          "types": null
        },
        {
          "name": "_width",
          "types": null
        },
        {
          "name": "_height",
          "types": null
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "_vector_renderer",
          "types": null
        },
        {
          "name": "_raster_renderer",
          "types": null
        },
        {
          "name": "_rasterizing",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "name": "figure",
          "types": null
        },
        {
          "name": "_figdpi",
          "types": null
        },
        {
          "name": "_bbox_inches_restore",
          "types": null
        },
        {
          "name": "_renderer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket",
      "name": "CommSocket",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "docstring": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "code": "class CommSocket:\n    \"\"\"\n    Manages the Comm connection between IPython and the browser (client).\n\n    Comms are 2 way, with the CommSocket being able to publish a message\n    via the send_json method, and handle a message with on_message. On the\n    JS side figure.send_message and figure.ws.onmessage do the sending and\n    receiving respectively.\n\n    \"\"\"\n    def __init__(self, manager):\n        self.supports_binary = None\n        self.manager = manager\n        self.uuid = str(uuid.uuid4())\n        # Publish an output area with a unique ID. The javascript can then\n        # hook into this area.\n        display(HTML(\"<div id=%r></div>\" % self.uuid))\n        try:\n            self.comm = Comm('matplotlib', data={'id': self.uuid})\n        except AttributeError as err:\n            raise RuntimeError('Unable to create an IPython notebook Comm '\n                               'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)\n\n    def is_open(self):\n        return not (self._ext_close or self.comm._closed)\n\n    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass\n\n    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})\n\n    def send_binary(self, blob):\n        # The comm is ascii, so we always send the image in base64\n        # encoded data URL form.\n        data = b64encode(blob).decode('ascii')\n        data_uri = \"data:image/png;base64,{0}\".format(data)\n        self.comm.send({'data': data_uri})\n\n    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)",
      "instance_attributes": [
        {
          "name": "supports_binary",
          "types": null
        },
        {
          "name": "manager",
          "types": null
        },
        {
          "name": "uuid",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "comm",
          "types": {
            "kind": "NamedType",
            "name": "Comm"
          }
        },
        {
          "name": "_ext_close",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureCanvasNbAgg",
      "name": "FigureCanvasNbAgg",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureCanvasNbAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasWebAggCore"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasNbAgg(FigureCanvasWebAggCore):\n    _timer_cls = TimerTornado",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg",
      "name": "FigureManagerNbAgg",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg",
      "decorators": [],
      "superclasses": [
        "FigureManagerWebAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/_create_comm",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed",
        "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerNbAgg(FigureManagerWebAgg):\n    ToolbarCls = NavigationIPy\n\n    def __init__(self, canvas, num):\n        self._shown = False\n        FigureManagerWebAgg.__init__(self, canvas, num)\n\n    def display_js(self):\n        # XXX How to do this just once? It has to deal with multiple\n        # browser instances using the same kernel (require.js - but the\n        # file isn't static?).\n        display(Javascript(FigureManagerNbAgg.get_javascript()))\n\n    def show(self):\n        if not self._shown:\n            self.display_js()\n            self._create_comm()\n        else:\n            self.canvas.draw_idle()\n        self._shown = True\n\n    def reshow(self):\n        \"\"\"\n        A special method to re-show the figure in the notebook.\n\n        \"\"\"\n        self._shown = False\n        self.show()\n\n    @property\n    def connected(self):\n        return bool(self.web_sockets)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n        super().get_javascript(stream=output)\n        output.write((pathlib.Path(__file__).parent\n                      / \"web_backend/js/nbagg_mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n        if stream is None:\n            return output.getvalue()\n\n    def _create_comm(self):\n        comm = CommSocket(self)\n        self.add_web_socket(comm)\n        return comm\n\n    def destroy(self):\n        self._send_event('close')\n        # need to copy comms as callbacks will modify this list\n        for comm in list(self.web_sockets):\n            comm.on_close()\n        self.clearup_closed()\n\n    def clearup_closed(self):\n        \"\"\"Clear up any closed Comms.\"\"\"\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.is_open()}\n\n        if len(self.web_sockets) == 0:\n            self.canvas.close_event()\n\n    def remove_comm(self, comm_id):\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.comm.comm_id != comm_id}",
      "instance_attributes": [
        {
          "name": "_shown",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "web_sockets",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/NavigationIPy",
      "name": "NavigationIPy",
      "qname": "lib.matplotlib.backends.backend_nbagg.NavigationIPy",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2WebAgg"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationIPy(NavigationToolbar2WebAgg):\n\n    # Use the standard toolbar items + download button\n    toolitems = [(text, tooltip_text,\n                  _FONT_AWESOME_CLASSES[image_file], name_of_method)\n                 for text, tooltip_text, image_file, name_of_method\n                 in (NavigationToolbar2.toolitems +\n                     (('Download', 'Download plot', 'download', 'download'),))\n                 if image_file in _FONT_AWESOME_CLASSES]",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf",
      "name": "FigureCanvasPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc...",
      "docstring": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc...\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    A high-level Figure instance",
      "code": "class FigureCanvasPdf(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc...\n\n    Attributes\n    ----------\n    figure : `matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    fixed_dpi = 72\n    filetypes = {'pdf': 'Portable Document Format'}\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    @_check_savefig_extra_args\n    def print_pdf(self, filename, *,\n                  dpi=72,  # dpi to use for images\n                  bbox_inches_restore=None, metadata=None):\n\n        self.figure.set_dpi(72)            # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf",
      "name": "GraphicsContextPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties",
        "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextPdf(GraphicsContextBase):\n\n    def __init__(self, file):\n        GraphicsContextBase.__init__(self)\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None\n\n    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)\n\n    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))\n\n    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))\n\n    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())\n\n    capstyles = {'butt': 0, 'round': 1, 'projecting': 2}\n    joinstyles = {'miter': 0, 'round': 1, 'bevel': 2}\n\n    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]\n\n    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]\n\n    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]\n\n    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]\n\n    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]\n\n    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]\n\n    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]\n\n    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]\n\n    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]\n\n    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]\n\n    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds\n\n    commands = (\n        # must come first since may pop\n        (('_cliprect', '_clippath'), clip_cmd),\n        (('_alpha', '_forced_alpha', '_effective_alphas'), alpha_cmd),\n        (('_capstyle',), capstyle_cmd),\n        (('_fillcolor',), fillcolor_cmd),\n        (('_joinstyle',), joinstyle_cmd),\n        (('_linewidth',), linewidth_cmd),\n        (('_dashes',), dash_cmd),\n        (('_rgb',), rgb_cmd),\n        # must come after fillcolor and rgb\n        (('_hatch', '_hatch_color'), hatch_cmd),\n        )\n\n    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds\n\n    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        GraphicsContextBase.copy_properties(self, other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas\n\n    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds",
      "instance_attributes": [
        {
          "name": "_fillcolor",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "_effective_alphas",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "file",
          "types": null
        },
        {
          "name": "parent",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextPdf"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name",
      "name": "Name",
      "qname": "lib.matplotlib.backends.backend_pdf.Name",
      "decorators": [
        "total_ordering"
      ],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF name object.",
      "docstring": "PDF name object.",
      "code": "class Name:\n    \"\"\"PDF name object.\"\"\"\n    __slots__ = ('name',)\n    _regex = re.compile(r'[^!-~]')\n\n    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = self._regex.sub(Name.hexify, name).encode('ascii')\n\n    def __repr__(self):\n        return \"<Name %s>\" % self.name\n\n    def __str__(self):\n        return '/' + str(self.name)\n\n    def __eq__(self, other):\n        return isinstance(other, Name) and self.name == other.name\n\n    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name\n\n    def __hash__(self):\n        return hash(self.name)\n\n    @staticmethod\n    def hexify(match):\n        return '#%02x' % ord(match.group())\n\n    def pdfRepr(self):\n        return b'/' + self.name",
      "instance_attributes": [
        {
          "name": "name",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator",
      "name": "Operator",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF operator object.",
      "docstring": "PDF operator object.",
      "code": "class Operator:\n    \"\"\"PDF operator object.\"\"\"\n    __slots__ = ('op',)\n\n    def __init__(self, op):\n        self.op = op\n\n    def __repr__(self):\n        return '<Operator %s>' % self.op\n\n    def pdfRepr(self):\n        return self.op",
      "instance_attributes": [
        {
          "name": "op",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile",
      "name": "PdfFile",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/used_characters@getter",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_afm_font",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_embedTeXFont",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_get_xobject_symbol_name",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_soft_mask_state",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_write_soft_mask_groups",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_unpack",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_writePng",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/_writeImg",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF file object.",
      "docstring": "PDF file object.",
      "code": "class PdfFile:\n    \"\"\"PDF file object.\"\"\"\n\n    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        # reproducible writeHatches needs an ordered dict:\n        self.hatchPatterns = collections.OrderedDict()\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = collections.OrderedDict()   # reproducible writeImages\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = collections.OrderedDict()   # reproducible writeMarkers\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        self.pageAnnotations = []  # A list of annotations for the current page\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def used_characters(self):\n        return self.file._character_tracker.used_characters\n\n    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Group': {'Type': Name('Group'),\n                             'S': Name('Transparency'),\n                             'CS': Name('DeviceRGB')},\n                   'Annots': self.pageAnnotations,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default mpl\n        # graphics context: currently only the join style needs to be set\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []\n\n    def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n        # Create a new annotation of type text\n        theNote = {'Type': Name('Annot'),\n                   'Subtype': Name('Text'),\n                   'Contents': text,\n                   'Rect': positionRect,\n                   }\n        annotObject = self.reserveObject('annotation')\n        self.writeObject(annotObject, theNote)\n        self.pageAnnotations.append(annotObject)\n\n    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()\n\n    def close(self):\n        \"\"\"Flush all buffers and free all resources.\"\"\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()\n\n    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)\n\n    def output(self, *data):\n        self.write(fill([pdfRepr(x) for x in data]))\n        self.write(b'\\n')\n\n    def beginStream(self, id, len, extra=None, png=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra, png)\n\n    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None\n\n    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filename = fontprop\n        elif mpl.rcParams['pdf.use14corefonts']:\n            filename = findfont(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir)\n        else:\n            filename = findfont(fontprop)\n\n        Fx = self.fontNames.get(filename)\n        if Fx is None:\n            Fx = next(self._internal_font_seq)\n            self.fontNames[filename] = Fx\n            _log.debug('Assigning font %s = %r', Fx, filename)\n\n        return Fx\n\n    def dviFontName(self, dvifont):\n        \"\"\"\n        Given a dvi font object, return a name suitable for Op.selectfont.\n        This registers the font information in ``self.dviFontInfo`` if not yet\n        registered.\n        \"\"\"\n\n        dvi_info = self.dviFontInfo.get(dvifont.texname)\n        if dvi_info is not None:\n            return dvi_info.pdfname\n\n        tex_font_map = dviread.PsfontsMap(dviread.find_tex_file('pdftex.map'))\n        psfont = tex_font_map[dvifont.texname]\n        if psfont.filename is None:\n            raise ValueError(\n                \"No usable font file found for {} (TeX: {}); \"\n                \"the font may lack a Type-1 version\"\n                .format(psfont.psname, dvifont.texname))\n\n        pdfname = next(self._internal_font_seq)\n        _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n        self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n            dvifont=dvifont,\n            pdfname=pdfname,\n            fontfile=psfont.filename,\n            basefont=psfont.psname,\n            encodingfile=psfont.encoding,\n            effects=psfont.effects)\n        return pdfname\n\n    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                chars = self._character_tracker.used.get(filename)\n                if chars:\n                    fonts[Fx] = self.embedTTF(filename, chars)\n        self.writeObject(self.fontObject, fonts)\n\n    def _write_afm_font(self, filename):\n        with open(filename, 'rb') as fh:\n            font = AFM(fh)\n        fontname = font.get_fontname()\n        fontdict = {'Type': Name('Font'),\n                    'Subtype': Name('Type1'),\n                    'BaseFont': Name(fontname),\n                    'Encoding': Name('WinAnsiEncoding')}\n        fontdictObject = self.reserveObject('font dictionary')\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def _embedTeXFont(self, fontinfo):\n        _log.debug('Embedding TeX font %s - fontinfo=%s',\n                   fontinfo.dvifont.texname, fontinfo.__dict__)\n\n        # Widths\n        widthsObject = self.reserveObject('font widths')\n        self.writeObject(widthsObject, fontinfo.dvifont.widths)\n\n        # Font dictionary\n        fontdictObject = self.reserveObject('font dictionary')\n        fontdict = {\n            'Type':      Name('Font'),\n            'Subtype':   Name('Type1'),\n            'FirstChar': 0,\n            'LastChar':  len(fontinfo.dvifont.widths) - 1,\n            'Widths':    widthsObject,\n            }\n\n        # Encoding (if needed)\n        if fontinfo.encodingfile is not None:\n            fontdict['Encoding'] = {\n                'Type': Name('Encoding'),\n                'Differences': [\n                    0, *map(Name, dviread._parse_enc(fontinfo.encodingfile))],\n            }\n\n        # If no file is specified, stop short\n        if fontinfo.fontfile is None:\n            _log.warning(\n                \"Because of TeX configuration (pdftex.map, see updmap option \"\n                \"pdftexDownloadBase14) the font %s is not embedded. This is \"\n                \"deprecated as of PDF 1.5 and it may cause the consumer \"\n                \"application to show something that was not intended.\",\n                fontinfo.basefont)\n            fontdict['BaseFont'] = Name(fontinfo.basefont)\n            self.writeObject(fontdictObject, fontdict)\n            return fontdictObject\n\n        # We have a font file to embed - read it in and apply any effects\n        t1font = type1font.Type1Font(fontinfo.fontfile)\n        if fontinfo.effects:\n            t1font = t1font.transform(fontinfo.effects)\n        fontdict['BaseFont'] = Name(t1font.prop['FontName'])\n\n        # Font descriptors may be shared between differently encoded\n        # Type-1 fonts, so only create a new descriptor if there is no\n        # existing descriptor for this font.\n        effects = (fontinfo.effects.get('slant', 0.0),\n                   fontinfo.effects.get('extend', 1.0))\n        fontdesc = self.type1Descriptors.get((fontinfo.fontfile, effects))\n        if fontdesc is None:\n            fontdesc = self.createType1Descriptor(t1font, fontinfo.fontfile)\n            self.type1Descriptors[(fontinfo.fontfile, effects)] = fontdesc\n        fontdict['FontDescriptor'] = fontdesc\n\n        self.writeObject(fontdictObject, fontdict)\n        return fontdictObject\n\n    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = get_font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            # 'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.beginStream(fontfileObject.id, None,\n                         {'Length1': len(t1font.parts[0]),\n                          'Length2': len(t1font.parts[1]),\n                          'Length3': 0})\n        self.currentstream.write(t1font.parts[0])\n        self.currentstream.write(t1font.parts[1])\n        self.endStream()\n\n        return fontdescObject\n\n    def _get_xobject_symbol_name(self, filename, symbol_name):\n        Fx = self.fontName(filename)\n        return \"-\".join([\n            Fx.name.decode(),\n            os.path.splitext(os.path.basename(filename))[0],\n            symbol_name])\n\n    _identityToUnicodeCMap = b\"\"\"/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (Adobe)\n   /Ordering (UCS)\n   /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000> <ffff>\nendcodespacerange\n%d beginbfrange\n%s\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\"\"\"\n\n    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            try:\n                rawcharprocs = _ttconv.get_pdf_charprocs(\n                    os.fsencode(filename), glyph_ids)\n            except RuntimeError:\n                _log.warning(\"The PDF backend does not currently support the \"\n                             \"selected font.\")\n                raise\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            length1Object = self.reserveObject('decoded length of a font')\n            self.beginStream(\n                fontfileObject.id,\n                self.reserveObject('length of font stream'),\n                {'Length1': length1Object})\n            with open(filename, 'rb') as fontfile:\n                length1 = 0\n                while True:\n                    data = fontfile.read(4096)\n                    if not data:\n                        break\n                    length1 += len(data)\n                    self.currentstream.write(data)\n            self.endStream()\n            self.writeObject(length1Object, length1)\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.beginStream(cidToGidMapObject.id,\n                             None,\n                             {'Length': len(cid_to_gid_map)})\n            self.currentstream.write(cid_to_gid_map)\n            self.endStream()\n\n            # ToUnicode CMap\n            self.beginStream(toUnicodeMapObject.id,\n                             None,\n                             {'Length': unicode_cmap})\n            self.currentstream.write(unicode_cmap)\n            self.endStream()\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = font.postscript_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        # The font subsetting to a Type 3 font does not work for\n        # OpenType (.otf) that embed a Postscript CFF font, so avoid that --\n        # save as a (non-subsetted) Type 42 font instead.\n        if is_opentype_cff_font(filename):\n            fonttype = 42\n            _log.warning(\"%r can not be subsetted into a Type 3 font. The \"\n                         \"entire font will be embedded in the output.\",\n                         os.path.basename(filename))\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)\n\n    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name\n\n    def _soft_mask_state(self, smask):\n        \"\"\"\n        Return an ExtGState that sets the soft mask to the given shading.\n\n        Parameters\n        ----------\n        smask : Reference\n            Reference to a shading in DeviceGray color space, whose luminosity\n            is to be used as the alpha channel.\n\n        Returns\n        -------\n        Name\n        \"\"\"\n\n        state = self._soft_mask_states.get(smask, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._soft_mask_seq)\n        groupOb = self.reserveObject('transparency group for soft mask')\n        self._soft_mask_states[smask] = (\n            name,\n            {\n                'Type': Name('ExtGState'),\n                'AIS': False,\n                'SMask': {\n                    'Type': Name('Mask'),\n                    'S': Name('Luminosity'),\n                    'BC': [1],\n                    'G': groupOb\n                }\n            }\n        )\n        self._soft_mask_groups.append((\n            groupOb,\n            {\n                'Type': Name('XObject'),\n                'Subtype': Name('Form'),\n                'FormType': 1,\n                'Group': {\n                    'S': Name('Transparency'),\n                    'CS': Name('DeviceGray')\n                },\n                'Matrix': [1, 0, 0, 1, 0, 0],\n                'Resources': {'Shading': {'S': smask}},\n                'BBox': [0, 0, 1, 1]\n            },\n            [Name('S'), Op.shading]\n        ))\n        return name\n\n    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )\n\n    def _write_soft_mask_groups(self):\n        for ob, attributes, content in self._soft_mask_groups:\n            self.beginStream(ob.id, None, attributes)\n            self.output(*content)\n            self.endStream()\n\n    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            edge, face, hatch = hatch_style\n            if edge is not None:\n                edge = tuple(edge)\n            if face is not None:\n                face = tuple(face)\n            hatch_style = (edge, face, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self.hatchPatterns[hatch_style] = name\n        return name\n\n    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, path = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(path),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)\n\n    def addGouraudTriangles(self, points, colors):\n        \"\"\"\n        Add a Gouraud triangle shading.\n\n        Parameters\n        ----------\n        points : np.ndarray\n            Triangle vertices, shape (n, 3, 2)\n            where n = number of triangles, 3 = vertices, 2 = x, y.\n        colors : np.ndarray\n            Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n            as with points, but last dimension is either (gray,)\n            or (r, g, b, alpha).\n\n        Returns\n        -------\n        Name, Reference\n        \"\"\"\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        ob = self.reserveObject(f'Gouraud triangle {name}')\n        self.gouraudTriangles.append((name, ob, points, colors))\n        return name, ob\n\n    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tobytes())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)\n\n    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name\n\n    def _unpack(self, im):\n        \"\"\"\n        Unpack image array *im* into ``(data, alpha)``, which have shape\n        ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or\n        alpha), except that alpha is None if the image is fully opaque.\n        \"\"\"\n        im = im[::-1]\n        if im.ndim == 2:\n            return im, None\n        else:\n            rgb = im[:, :, :3]\n            rgb = np.array(rgb, order='C')\n            # PDF needs a separate alpha image\n            if im.shape[2] == 4:\n                alpha = im[:, :, 3][..., None]\n                if np.all(alpha == 255):\n                    alpha = None\n                else:\n                    alpha = np.array(alpha, order='C')\n            else:\n                alpha = None\n            return rgb, alpha\n\n    def _writePng(self, data):\n        \"\"\"\n        Write the image *data* into the pdf file using png\n        predictors with Flate compression.\n        \"\"\"\n        buffer = BytesIO()\n        if data.shape[-1] == 1:\n            data = data.squeeze(axis=-1)\n        Image.fromarray(data).save(buffer, format=\"png\")\n        buffer.seek(8)\n        while True:\n            length, type = struct.unpack(b'!L4s', buffer.read(8))\n            if type == b'IDAT':\n                data = buffer.read(length)\n                if len(data) != length:\n                    raise RuntimeError(\"truncated data\")\n                self.currentstream.write(data)\n            elif type == b'IEND':\n                break\n            else:\n                buffer.seek(length, 1)\n            buffer.seek(4, 1)   # skip CRC\n\n    def _writeImg(self, data, id, smask=None):\n        \"\"\"\n        Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or\n        ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask\n        (alpha channel) *smask*, which should be either None or a ``(height,\n        width, 1)`` array.\n        \"\"\"\n        height, width, colors = data.shape\n        obj = {'Type': Name('XObject'),\n               'Subtype': Name('Image'),\n               'Width': width,\n               'Height': height,\n               'ColorSpace': Name({1: 'DeviceGray', 3: 'DeviceRGB'}[colors]),\n               'BitsPerComponent': 8}\n        if smask:\n            obj['SMask'] = smask\n        if mpl.rcParams['pdf.compression']:\n            png = {'Predictor': 10, 'Colors': colors, 'Columns': width}\n        else:\n            png = None\n        self.beginStream(\n            id,\n            self.reserveObject('length of image stream'),\n            obj,\n            png=png\n            )\n        if png:\n            self._writePng(data)\n        else:\n            self.currentstream.write(data.tobytes())\n        self.endStream()\n\n    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)\n\n    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name\n\n    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            # bbox wraps the exact limits of the control points, so half a line\n            # will appear outside it. If the join style is miter and the line\n            # is not parallel to the edge, then the line will extend even\n            # further. From the PDF specification, Section 8.4.3.5, the miter\n            # limit is miterLength / lineWidth and from Table 52, the default\n            # is 10. With half the miter length outside, that works out to the\n            # following padding:\n            bbox = bbox.padded(lw * 5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()\n\n    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name\n\n    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()\n\n    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.op, Op.lineto.op, b'', Op.curveto.op, Op.closepath.op],\n            True))]\n\n    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)\n\n    def reserveObject(self, name=''):\n        \"\"\"\n        Reserve an ID for an indirect object.\n\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)\n\n    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base\n\n    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)\n\n    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)\n\n    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)\n\n    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)",
      "instance_attributes": [
        {
          "name": "_object_seq",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "xrefTable",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "passed_in_file_object",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "original_file_like",
          "types": null
        },
        {
          "name": "tell_base",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "fh",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        },
        {
          "name": "currentstream",
          "types": {
            "kind": "NamedType",
            "name": "Stream"
          }
        },
        {
          "name": "rootObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "pagesObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "pageList",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "fontObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "_extGStateObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "hatchObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "gouraudObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "XObjectObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "resourceObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        },
        {
          "name": "infoDict",
          "types": null
        },
        {
          "name": "fontNames",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_internal_font_seq",
          "types": null
        },
        {
          "name": "dviFontInfo",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "type1Descriptors",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_character_tracker",
          "types": null
        },
        {
          "name": "alphaStates",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_alpha_state_seq",
          "types": null
        },
        {
          "name": "_soft_mask_states",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_soft_mask_seq",
          "types": null
        },
        {
          "name": "_soft_mask_groups",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "hatchPatterns",
          "types": {
            "kind": "NamedType",
            "name": "OrderedDict"
          }
        },
        {
          "name": "_hatch_pattern_seq",
          "types": null
        },
        {
          "name": "gouraudTriangles",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_images",
          "types": {
            "kind": "NamedType",
            "name": "OrderedDict"
          }
        },
        {
          "name": "_image_seq",
          "types": null
        },
        {
          "name": "markers",
          "types": {
            "kind": "NamedType",
            "name": "OrderedDict"
          }
        },
        {
          "name": "multi_byte_charprocs",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "paths",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "pageAnnotations",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "startxref",
          "types": null
        },
        {
          "name": "infoObject",
          "types": {
            "kind": "NamedType",
            "name": "Reference"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages",
      "name": "PdfPages",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount",
        "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file.",
      "docstring": "A multi-page PDF file.\n\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> # Initialize:\n>>> with PdfPages('foo.pdf') as pdf:\n...     # As many times as you like, create a figure fig and save it:\n...     fig = plt.figure()\n...     pdf.savefig(fig)\n...     # When no figure is specified the current figure is saved\n...     pdf.savefig()\n\nNotes\n-----\nIn reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\nconfusion when using `~.pyplot.savefig` and forgetting the format argument.",
      "code": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file.\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n\n    Notes\n    -----\n    In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid\n    confusion when using `~.pyplot.savefig` and forgetting the format argument.\n    \"\"\"\n    __slots__ = ('_file', 'keep_empty')\n\n    def __init__(self, filename, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. The file is opened at once and any older file with the\n            same name is overwritten.\n        keep_empty : bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._file = PdfFile(filename, metadata=metadata)\n        self.keep_empty = keep_empty\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None\n\n    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a `.Figure` instance is provided, this\n            figure is saved. If an int is specified, the figure instance to\n            save is looked up by number.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas\n\n    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return len(self._file.pageList)\n\n    def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n        \"\"\"\n        Add a new text note to the page to be saved next. The optional\n        positionRect specifies the position of the new note on the\n        page. It is outside the page per default to make sure it is\n        invisible on printouts.\n        \"\"\"\n        self._file.newTextnote(text, positionRect)",
      "instance_attributes": [
        {
          "name": "_file",
          "types": {
            "kind": "NamedType",
            "name": "PdfFile"
          }
        },
        {
          "name": "keep_empty",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference",
      "name": "Reference",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "docstring": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "code": "class Reference:\n    \"\"\"\n    PDF reference object.\n\n    Use PdfFile.reserveObject() to create References.\n    \"\"\"\n\n    def __init__(self, id):\n        self.id = id\n\n    def __repr__(self):\n        return \"<Reference %d>\" % self.id\n\n    def pdfRepr(self):\n        return b\"%d 0 R\" % self.id\n\n    def write(self, contents, file):\n        write = file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf",
      "name": "RendererPdf",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf",
      "decorators": [],
      "superclasses": [
        "_backend_pdf_ps.RendererPDFPSBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/track_characters",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/merge_used_characters",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/_setup_textpos",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/pdfcorefonts\")\n    _use_afm_rc_name = \"pdf.use14corefonts\"\n\n    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.mathtext_parser = MathTextParser(\"Pdf\")\n        self.image_dpi = image_dpi\n\n    def finalize(self):\n        self.file.output(*self.gc.finalize())\n\n    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas\n\n    @cbook.deprecated(\"3.3\")\n    def track_characters(self, *args, **kwargs):\n        \"\"\"Keep track of which characters are required from each font.\"\"\"\n        self.file._character_tracker.track(*args, **kwargs)\n\n    @cbook.deprecated(\"3.3\")\n    def merge_used_characters(self, *args, **kwargs):\n        self.file._character_tracker.merge(*args, **kwargs)\n\n    def get_image_magnification(self):\n        return self.image_dpi/72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        if len(points) == 0:\n            return\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] in (1, 4)\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name, _ = self.file.addGouraudTriangles(tpoints, colors)\n        output = self.file.output\n\n        if colors.shape[2] == 1:\n            # grayscale\n            gc.set_alpha(1.0)\n            self.check_gc(gc)\n            output(name, Op.shading)\n            return\n\n        alpha = colors[0, 0, 3]\n        if np.allclose(alpha, colors[:, :, 3]):\n            # single alpha value\n            gc.set_alpha(alpha)\n            self.check_gc(gc)\n            output(name, Op.shading)\n        else:\n            # varying alpha: use a soft mask\n            alpha = colors[:, :, 3][:, :, None]\n            _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n            gstate = self.file._soft_mask_state(smask_ob)\n            output(Op.gsave, gstate, Op.setgstate,\n                   name, Op.shading,\n                   Op.grestore)\n\n    def _setup_textpos(self, x, y, angle, oldx=0, oldy=0, oldangle=0):\n        if angle == oldangle == 0:\n            self.file.output(x - oldx, y - oldy, Op.textpos)\n        else:\n            angle = math.radians(angle)\n            self.file.output(math.cos(angle), math.sin(angle),\n                             -math.sin(angle), math.cos(angle),\n                             x, y, Op.textmatrix)\n            self.file.output(0, 0, Op.textpos)\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects, used_characters = \\\n            self.mathtext_parser.parse(s, 72, prop)\n        self.file._character_tracker.merge(used_characters)\n\n        # When using Type 3 fonts, we can't use character codes higher\n        # than 255, so we use the \"Do\" command to render those\n        # instead.\n        global_fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        for ox, oy, fontname, fontsize, num, symbol_name in glyphs:\n            if is_opentype_cff_font(fontname):\n                fonttype = 42\n            else:\n                fonttype = global_fonttype\n\n            if fonttype == 42 or num <= 255:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        # If using Type 3 fonts, render all of the multi-byte characters\n        # as XObjects using the 'Do' command.\n        if global_fonttype == 3:\n            for ox, oy, fontname, fontsize, num, symbol_name in glyphs:\n                if is_opentype_cff_font(fontname):\n                    fonttype = 42\n                else:\n                    fonttype = global_fonttype\n\n                if fonttype == 3 and num > 255:\n                    self.file.fontName(fontname)\n                    self.file.output(Op.gsave,\n                                     0.001 * fontsize, 0,\n                                     0, 0.001 * fontsize,\n                                     ox, oy, Op.concat_matrix)\n                    name = self.file._get_xobject_symbol_name(\n                        fontname, symbol_name)\n                    self.file.output(Name(name), Op.use_xobject)\n                    self.file.output(Op.grestore)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)\n\n    @cbook._delete_parameter(\"3.3\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)\n\n    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n            # We can't subset all OpenType fonts, so switch to Type 42\n            # in that case.\n            if is_opentype_cff_font(font.fname):\n                fonttype = 42\n\n        # If fonttype != 3 or there are no multibyte characters, emit the whole\n        # string at once.\n        if fonttype != 3 or all(ord(char) <= 255 for char in s):\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype), Op.show,\n                             Op.end_text)\n\n        # There is no way to access multibyte characters of Type 3 fonts, as\n        # they cannot have a CIDMap.  Therefore, in this case we break the\n        # string into chunks, where each chunk contains either a string of\n        # consecutive 1-byte characters or a single multibyte character.  Each\n        # chunk is emitted with a separate command: 1-byte characters use the\n        # regular text show command (Tj), whereas multibyte characters use\n        # the XObject command (Do).  (If using Type 42 fonts, all of this\n        # complication is avoided, but of course, those fonts can not be\n        # subsetted.)\n        else:\n            singlebyte_chunks = []  # List of (start_x, list-of-1-byte-chars).\n            multibyte_glyphs = []  # List of (start_x, glyph_index).\n            prev_was_singlebyte = False\n            for char, (glyph_idx, glyph_x) in zip(\n                    s,\n                    _text_layout.layout(s, font, kern_mode=KERNING_UNFITTED)):\n                if ord(char) <= 255:\n                    if prev_was_singlebyte:\n                        singlebyte_chunks[-1][1].append(char)\n                    else:\n                        singlebyte_chunks.append((glyph_x, [char]))\n                    prev_was_singlebyte = True\n                else:\n                    multibyte_glyphs.append((glyph_x, glyph_idx))\n                    prev_was_singlebyte = False\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            prev_start_x = 0\n            for start_x, chars in singlebyte_chunks:\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(self.encode_string(''.join(chars), fonttype),\n                                 Op.show)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for start_x, glyph_idx in multibyte_glyphs:\n                glyph_name = font.get_glyph_name(glyph_idx)\n                self.file.output(Op.gsave)\n                self.file.output(0.001 * fontsize, 0,\n                                 0, 0.001 * fontsize,\n                                 start_x, 0, Op.concat_matrix)\n                name = self.file._get_xobject_symbol_name(\n                    font.fname, glyph_name)\n                self.file.output(Name(name), Op.use_xobject)\n                self.file.output(Op.grestore)\n            self.file.output(Op.grestore)\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)",
      "instance_attributes": [
        {
          "name": "file",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextPdf"
          }
        },
        {
          "name": "mathtext_parser",
          "types": null
        },
        {
          "name": "image_dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream",
      "name": "Stream",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/_writeHeader",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/_flush"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "docstring": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "code": "class Stream:\n    \"\"\"\n    PDF stream object.\n\n    This has no pdfRepr method. Instead, call begin(), then output the\n    contents of the stream by calling write(), and finally call end().\n    \"\"\"\n    __slots__ = ('id', 'len', 'pdfFile', 'file', 'compressobj', 'extra', 'pos')\n\n    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if mpl.rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(\n                mpl.rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()\n\n    def _writeHeader(self):\n        write = self.file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        dict = self.extra\n        dict['Length'] = self.len\n        if mpl.rcParams['pdf.compression']:\n            dict['Filter'] = Name('FlateDecode')\n\n        write(pdfRepr(dict))\n        write(b\"\\nstream\\n\")\n\n    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)\n\n    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)\n\n    def _flush(self):\n        \"\"\"Flush the compression object.\"\"\"\n\n        if self.compressobj is not None:\n            compressed = self.compressobj.flush()\n            self.file.write(compressed)\n            self.compressobj = None",
      "instance_attributes": [
        {
          "name": "id",
          "types": null
        },
        {
          "name": "len",
          "types": null
        },
        {
          "name": "pdfFile",
          "types": null
        },
        {
          "name": "file",
          "types": {
            "kind": "NamedType",
            "name": "BytesIO"
          }
        },
        {
          "name": "compressobj",
          "types": null
        },
        {
          "name": "extra",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "pos",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim",
      "name": "Verbatim",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Store verbatim PDF command content for later inclusion in the stream.",
      "docstring": "Store verbatim PDF command content for later inclusion in the stream.",
      "code": "class Verbatim:\n    \"\"\"Store verbatim PDF command content for later inclusion in the stream.\"\"\"\n    def __init__(self, x):\n        self._x = x\n\n    def pdfRepr(self):\n        return self._x",
      "instance_attributes": [
        {
          "name": "_x",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf",
      "name": "FigureCanvasPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/_print_pgf_to_fh",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/_print_pdf_to_fh",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/_print_png_to_fh",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png",
        "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPgf(FigureCanvasBase):\n    filetypes = {\"pgf\": \"LaTeX PGF picture\",\n                 \"pdf\": \"LaTeX compiled PGF picture\",\n                 \"png\": \"Portable Network Graphics\", }\n\n    def get_default_filetype(self):\n        return 'pdf'\n\n    @_check_savefig_extra_args\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    def _print_pgf_to_fh(self, fh, *,\n                         dryrun=False, bbox_inches_restore=None):\n\n        if dryrun:\n            renderer = RendererPgf(self.figure, None, dummy=True)\n            self.figure.draw(renderer)\n            return\n\n        header_text = \"\"\"%% Creator: Matplotlib, PGF backend\n%%\n%% To include the figure in your LaTeX document, write\n%%   \\\\input{<filename>.pgf}\n%%\n%% Make sure the required packages are loaded in your preamble\n%%   \\\\usepackage{pgf}\n%%\n%% and, on pdftex\n%%   \\\\usepackage[utf8]{inputenc}\\\\DeclareUnicodeCharacter{2212}{-}\n%%\n%% or, on luatex and xetex\n%%   \\\\usepackage{unicode-math}\n%%\n%% Figures using additional raster images can only be included by \\\\input if\n%% they are in the same directory as the main LaTeX file. For loading figures\n%% from other directories you can use the `import` package\n%%   \\\\usepackage{import}\n%%\n%% and then include the figures with\n%%   \\\\import{<path to file>}{<filename>.pgf}\n%%\n\"\"\"\n\n        # append the preamble used by the backend as a comment for debugging\n        header_info_preamble = [\"%% Matplotlib used the following preamble\"]\n        for line in get_preamble().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        for line in get_fontspec().splitlines():\n            header_info_preamble.append(\"%%   \" + line)\n        header_info_preamble.append(\"%%\")\n        header_info_preamble = \"\\n\".join(header_info_preamble)\n\n        # get figure size in inch\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n        dpi = self.figure.get_dpi()\n\n        # create pgfpicture environment and write the pgf code\n        fh.write(header_text)\n        fh.write(header_info_preamble)\n        fh.write(\"\\n\")\n        writeln(fh, r\"\\begingroup\")\n        writeln(fh, r\"\\makeatletter\")\n        writeln(fh, r\"\\begin{pgfpicture}\")\n        writeln(fh,\n                r\"\\pgfpathrectangle{\\pgfpointorigin}{\\pgfqpoint{%fin}{%fin}}\"\n                % (w, h))\n        writeln(fh, r\"\\pgfusepath{use as bounding box, clip}\")\n        renderer = MixedModeRenderer(self.figure, w, h, dpi,\n                                     RendererPgf(self.figure, fh),\n                                     bbox_inches_restore=bbox_inches_restore)\n        self.figure.draw(renderer)\n\n        # end the pgfpicture environment\n        writeln(fh, r\"\\end{pgfpicture}\")\n        writeln(fh, r\"\\makeatother\")\n        writeln(fh, r\"\\endgroup\")\n\n    def print_pgf(self, fname_or_fh, *args, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, *args, **kwargs)\n\n    def _print_pdf_to_fh(self, fh, *args, metadata=None, **kwargs):\n        w, h = self.figure.get_figwidth(), self.figure.get_figheight()\n\n        info_dict = _create_pdf_info_dict('pgf', metadata or {})\n        hyperref_options = ','.join(\n            _metadata_to_str(k, v) for k, v in info_dict.items())\n\n        try:\n            # create temporary directory for compiling the figure\n            tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_\")\n            fname_pgf = os.path.join(tmpdir, \"figure.pgf\")\n            fname_tex = os.path.join(tmpdir, \"figure.tex\")\n            fname_pdf = os.path.join(tmpdir, \"figure.pdf\")\n\n            # print figure to pgf and compile it with latex\n            self.print_pgf(fname_pgf, *args, **kwargs)\n\n            latex_preamble = get_preamble()\n            latex_fontspec = get_fontspec()\n            latexcode = \"\"\"\n\\\\PassOptionsToPackage{pdfinfo={%s}}{hyperref}\n\\\\RequirePackage{hyperref}\n\\\\documentclass[12pt]{minimal}\n\\\\usepackage[paperwidth=%fin, paperheight=%fin, margin=0in]{geometry}\n%s\n%s\n\\\\usepackage{pgf}\n\n\\\\begin{document}\n\\\\centering\n\\\\input{figure.pgf}\n\\\\end{document}\"\"\" % (hyperref_options, w, h, latex_preamble, latex_fontspec)\n            pathlib.Path(fname_tex).write_text(latexcode, encoding=\"utf-8\")\n\n            texcommand = mpl.rcParams[\"pgf.texsystem\"]\n            cbook._check_and_log_subprocess(\n                [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n                 \"figure.tex\"], _log, cwd=tmpdir)\n\n            # copy file contents to target\n            with open(fname_pdf, \"rb\") as fh_src:\n                shutil.copyfileobj(fh_src, fh)\n        finally:\n            try:\n                shutil.rmtree(tmpdir)\n            except:\n                TmpDirCleaner.add(tmpdir)\n\n    def print_pdf(self, fname_or_fh, *args, **kwargs):\n        \"\"\"Use LaTeX to compile a Pgf generated figure to PDF.\"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n        with cbook.open_file_cm(fname_or_fh, \"wb\") as file:\n            self._print_pdf_to_fh(file, *args, **kwargs)\n\n    def _print_png_to_fh(self, fh, *args, **kwargs):\n        converter = make_pdf_to_png_converter()\n\n        try:\n            # create temporary directory for pdf creation and png conversion\n            tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_\")\n            fname_pdf = os.path.join(tmpdir, \"figure.pdf\")\n            fname_png = os.path.join(tmpdir, \"figure.png\")\n            # create pdf and try to convert it to png\n            self.print_pdf(fname_pdf, *args, **kwargs)\n            converter(fname_pdf, fname_png, dpi=self.figure.dpi)\n            # copy file contents to target\n            with open(fname_png, \"rb\") as fh_src:\n                shutil.copyfileobj(fh_src, fh)\n        finally:\n            try:\n                shutil.rmtree(tmpdir)\n            except:\n                TmpDirCleaner.add(tmpdir)\n\n    def print_png(self, fname_or_fh, *args, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n        with cbook.open_file_cm(fname_or_fh, \"wb\") as file:\n            self._print_png_to_fh(file, *args, **kwargs)\n\n    def get_renderer(self):\n        return RendererPgf(self.figure, None)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/GraphicsContextPgf",
      "name": "GraphicsContextPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.GraphicsContextPgf",
      "decorators": [
        "cbook.deprecated('3.3', alternative='GraphicsContextBase')"
      ],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextPgf(GraphicsContextBase):\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError",
      "name": "LatexError",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class LatexError(Exception):\n    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output",
      "instance_attributes": [
        {
          "name": "latex_output",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager",
      "name": "LatexManager",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_build_latex_header",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_cached_or_new",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_get_cached_or_new_impl",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_stdin_writeln",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_expect",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_expect_prompt",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/_setup_latex_process",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/latex_stdin_utf8",
        "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "docstring": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "code": "class LatexManager:\n    \"\"\"\n    The LatexManager opens an instance of the LaTeX application for\n    determining the metrics of text elements. The LaTeX environment can be\n    modified by setting fonts and/or a custom preamble in `.rcParams`.\n    \"\"\"\n\n    @staticmethod\n    def _build_latex_header():\n        latex_preamble = get_preamble()\n        latex_fontspec = get_fontspec()\n        # Create LaTeX header with some content, else LaTeX will load some math\n        # fonts later when we don't expect the additional output on stdout.\n        # TODO: is this sufficient?\n        latex_header = [\n            r\"\\documentclass{minimal}\",\n            # Include TeX program name as a comment for cache invalidation.\n            # TeX does not allow this to be the first line.\n            rf\"% !TeX program = {mpl.rcParams['pgf.texsystem']}\",\n            # Test whether \\includegraphics supports interpolate option.\n            r\"\\usepackage{graphicx}\",\n            latex_preamble,\n            latex_fontspec,\n            r\"\\begin{document}\",\n            r\"text $math \\mu$\",  # force latex to load fonts now\n            r\"\\typeout{pgf_backend_query_start}\",\n        ]\n        return \"\\n\".join(latex_header)\n\n    @classmethod\n    def _get_cached_or_new(cls):\n        \"\"\"\n        Return the previous LatexManager if the header and tex system did not\n        change, or a new instance otherwise.\n        \"\"\"\n        return cls._get_cached_or_new_impl(cls._build_latex_header())\n\n    @classmethod\n    @functools.lru_cache(1)\n    def _get_cached_or_new_impl(cls, header):  # Helper for _get_cached_or_new.\n        return cls()\n\n    def _stdin_writeln(self, s):\n        if self.latex is None:\n            self._setup_latex_process()\n        self.latex.stdin.write(s)\n        self.latex.stdin.write(\"\\n\")\n        self.latex.stdin.flush()\n\n    def _expect(self, s):\n        s = list(s)\n        chars = []\n        while True:\n            c = self.latex.stdout.read(1)\n            chars.append(c)\n            if chars[-len(s):] == s:\n                break\n            if not c:\n                self.latex.kill()\n                self.latex = None\n                raise LatexError(\"LaTeX process halted\", \"\".join(chars))\n        return \"\".join(chars)\n\n    def _expect_prompt(self):\n        return self._expect(\"\\n*\")\n\n    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        self.texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        self.latex_header = LatexManager._build_latex_header()\n        latex_end = \"\\n\\\\makeatletter\\n\\\\@@end\\n\"\n        try:\n            latex = subprocess.Popen(\n                [self.texcommand, \"-halt-on-error\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                encoding=\"utf-8\", cwd=self.tmpdir)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{self.texcommand} not found.  Install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX \"\n                f\"implementation.\") from err\n        except OSError as err:\n            raise RuntimeError(\"Error starting process %r\" %\n                               self.texcommand) from err\n        test_input = self.latex_header + latex_end\n        stdout, stderr = latex.communicate(test_input)\n        if latex.returncode != 0:\n            raise LatexError(\"LaTeX returned an error, probably missing font \"\n                             \"or error in preamble:\\n%s\" % stdout)\n\n        self.latex = None  # Will be set up on first use.\n        self.str_cache = {}  # cache for strings already processed\n\n    def _setup_latex_process(self):\n        # Open LaTeX process for real work; register it for deletion.  On\n        # Windows, we must ensure that the subprocess has quit before being\n        # able to delete the tmpdir in which it runs; in order to do so, we\n        # must first `kill()` it, and then `communicate()` with it.\n        self.latex = subprocess.Popen(\n            [self.texcommand, \"-halt-on-error\"],\n            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n            encoding=\"utf-8\", cwd=self.tmpdir)\n\n        def finalize_latex(latex):\n            latex.kill()\n            latex.communicate()\n\n        self._finalize_latex = weakref.finalize(\n            self, finalize_latex, self.latex)\n        # write header with 'pgf_backend_query_start' token\n        self._stdin_writeln(self._build_latex_header())\n        # read all lines until our 'pgf_backend_query_start' token appears\n        self._expect(\"*pgf_backend_query_start\")\n        self._expect_prompt()\n\n    @cbook.deprecated(\"3.3\")\n    def latex_stdin_utf8(self):\n        return self.latex.stdin\n\n    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height and descent for a text typeset by the\n        current LaTeX environment.\n        \"\"\"\n\n        # apply font properties and define textbox\n        prop_cmds = _font_properties_str(prop)\n        textbox = \"\\\\sbox0{%s %s}\" % (prop_cmds, text)\n\n        # check cache\n        if textbox in self.str_cache:\n            return self.str_cache[textbox]\n\n        # send textbox to LaTeX and wait for prompt\n        self._stdin_writeln(textbox)\n        try:\n            self._expect_prompt()\n        except LatexError as e:\n            raise ValueError(\"Error processing '{}'\\nLaTeX Output:\\n{}\"\n                             .format(text, e.latex_output)) from e\n\n        # typeout width, height and text offset of the last textbox\n        self._stdin_writeln(r\"\\typeout{\\the\\wd0,\\the\\ht0,\\the\\dp0}\")\n        # read answer from latex and advance to the next prompt\n        try:\n            answer = self._expect_prompt()\n        except LatexError as e:\n            raise ValueError(\"Error processing '{}'\\nLaTeX Output:\\n{}\"\n                             .format(text, e.latex_output)) from e\n\n        # parse metrics from the answer string\n        try:\n            width, height, offset = answer.splitlines()[0].split(\",\")\n        except Exception as err:\n            raise ValueError(\"Error processing '{}'\\nLaTeX Output:\\n{}\"\n                             .format(text, answer)) from err\n        w, h, o = float(width[:-2]), float(height[:-2]), float(offset[:-2])\n\n        # the height returned from LaTeX goes from base to top.\n        # the height matplotlib expects goes from bottom to top.\n        self.str_cache[textbox] = (w, h + o, o)\n        return w, h + o, o",
      "instance_attributes": [
        {
          "name": "latex",
          "types": {
            "kind": "NamedType",
            "name": "Popen"
          }
        },
        {
          "name": "_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "TemporaryDirectory"
          }
        },
        {
          "name": "tmpdir",
          "types": null
        },
        {
          "name": "_finalize_tmpdir",
          "types": {
            "kind": "NamedType",
            "name": "finalize"
          }
        },
        {
          "name": "texcommand",
          "types": null
        },
        {
          "name": "latex_header",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "str_cache",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_finalize_latex",
          "types": {
            "kind": "NamedType",
            "name": "finalize"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages",
      "name": "PdfPages",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/metadata@getter",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/_write_header",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/_run_latex",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig",
        "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file using the pgf backend",
      "docstring": "A multi-page PDF file using the pgf backend\n\nExamples\n--------\n>>> import matplotlib.pyplot as plt\n>>> # Initialize:\n>>> with PdfPages('foo.pdf') as pdf:\n...     # As many times as you like, create a figure fig and save it:\n...     fig = plt.figure()\n...     pdf.savefig(fig)\n...     # When no figure is specified the current figure is saved\n...     pdf.savefig()",
      "code": "class PdfPages:\n    \"\"\"\n    A multi-page PDF file using the pgf backend\n\n    Examples\n    --------\n    >>> import matplotlib.pyplot as plt\n    >>> # Initialize:\n    >>> with PdfPages('foo.pdf') as pdf:\n    ...     # As many times as you like, create a figure fig and save it:\n    ...     fig = plt.figure()\n    ...     pdf.savefig(fig)\n    ...     # When no figure is specified the current figure is saved\n    ...     pdf.savefig()\n    \"\"\"\n    __slots__ = (\n        '_outputfile',\n        'keep_empty',\n        '_tmpdir',\n        '_basename',\n        '_fname_tex',\n        '_fname_pdf',\n        '_n_figures',\n        '_file',\n        '_info_dict',\n        '_metadata',\n    )\n\n    def __init__(self, filename, *, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n        keep_empty : bool, default: True\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._outputfile = filename\n        self._n_figures = 0\n        self.keep_empty = keep_empty\n        self._metadata = (metadata or {}).copy()\n        if metadata:\n            for key in metadata:\n                canonical = {\n                    'creationdate': 'CreationDate',\n                    'moddate': 'ModDate',\n                }.get(key.lower(), key.lower().title())\n                if canonical != key:\n                    cbook.warn_deprecated(\n                        '3.3', message='Support for setting PDF metadata keys '\n                        'case-insensitively is deprecated since %(since)s and '\n                        'will be removed %(removal)s; '\n                        f'set {canonical} instead of {key}.')\n                    self._metadata[canonical] = self._metadata.pop(key)\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n\n        # create temporary directory for compiling the figure\n        self._tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_pdfpages_\")\n        self._basename = 'pdf_pages'\n        self._fname_tex = os.path.join(self._tmpdir, self._basename + \".tex\")\n        self._fname_pdf = os.path.join(self._tmpdir, self._basename + \".pdf\")\n        self._file = open(self._fname_tex, 'wb')\n\n    @cbook.deprecated('3.3')\n    @property\n    def metadata(self):\n        return self._metadata\n\n    def _write_header(self, width_inches, height_inches):\n        hyperref_options = ','.join(\n            _metadata_to_str(k, v) for k, v in self._info_dict.items())\n\n        latex_preamble = get_preamble()\n        latex_fontspec = get_fontspec()\n        latex_header = r\"\"\"\\PassOptionsToPackage{{\n  pdfinfo={{\n    {metadata}\n  }}\n}}{{hyperref}}\n\\RequirePackage{{hyperref}}\n\\documentclass[12pt]{{minimal}}\n\\usepackage[\n    paperwidth={width}in,\n    paperheight={height}in,\n    margin=0in\n]{{geometry}}\n{preamble}\n{fontspec}\n\\usepackage{{pgf}}\n\\setlength{{\\parindent}}{{0pt}}\n\n\\begin{{document}}%%\n\"\"\".format(\n            width=width_inches,\n            height=height_inches,\n            preamble=latex_preamble,\n            fontspec=latex_fontspec,\n            metadata=hyperref_options,\n        )\n        self._file.write(latex_header.encode('utf-8'))\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def close(self):\n        \"\"\"\n        Finalize this object, running LaTeX in a temporary directory\n        and moving the final pdf file to *filename*.\n        \"\"\"\n        self._file.write(rb'\\end{document}\\n')\n        self._file.close()\n\n        if self._n_figures > 0:\n            try:\n                self._run_latex()\n            finally:\n                try:\n                    shutil.rmtree(self._tmpdir)\n                except:\n                    TmpDirCleaner.add(self._tmpdir)\n        elif self.keep_empty:\n            open(self._outputfile, 'wb').close()\n\n    def _run_latex(self):\n        texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        cbook._check_and_log_subprocess(\n            [texcommand, \"-interaction=nonstopmode\", \"-halt-on-error\",\n             os.path.basename(self._fname_tex)],\n            _log, cwd=self._tmpdir)\n        # copy file contents to target\n        shutil.copyfile(self._fname_pdf, self._outputfile)\n\n    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a `.Figure` instance is provided, this\n            figure is saved. If an int is specified, the figure instance to\n            save is looked up by number.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPgf(figure)\n\n            width, height = figure.get_size_inches()\n            if self._n_figures == 0:\n                self._write_header(width, height)\n            else:\n                # \\pdfpagewidth and \\pdfpageheight exist on pdftex, xetex, and\n                # luatex<0.85; they were renamed to \\pagewidth and \\pageheight\n                # on luatex>=0.85.\n                self._file.write(\n                    br'\\newpage'\n                    br'\\ifdefined\\pdfpagewidth\\pdfpagewidth'\n                    br'\\else\\pagewidth\\fi=%ain'\n                    br'\\ifdefined\\pdfpageheight\\pdfpageheight'\n                    br'\\else\\pageheight\\fi=%ain'\n                    b'%%\\n' % (width, height)\n                )\n\n            figure.savefig(self._file, format=\"pgf\", **kwargs)\n            self._n_figures += 1\n        finally:\n            figure.canvas = orig_canvas\n\n    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return self._n_figures",
      "instance_attributes": [
        {
          "name": "_outputfile",
          "types": null
        },
        {
          "name": "_n_figures",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "keep_empty",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_metadata",
          "types": null
        },
        {
          "name": "_info_dict",
          "types": null
        },
        {
          "name": "_tmpdir",
          "types": null
        },
        {
          "name": "_basename",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_fname_tex",
          "types": null
        },
        {
          "name": "_fname_pdf",
          "types": null
        },
        {
          "name": "_file",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf",
      "name": "RendererPgf",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_clip",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_path_styles",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_print_pgf_path",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/_pgf_path_draw",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererPgf(RendererBase):\n\n    @cbook._delete_parameter(\"3.3\", \"dummy\")\n    def __init__(self, figure, fh, dummy=False):\n        \"\"\"\n        Create a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes\n        ----------\n        figure : `matplotlib.figure.Figure`\n            Matplotlib figure to initialize height, width and dpi from.\n        fh : file-like\n            File handle for the output of the drawing commands.\n        \"\"\"\n\n        RendererBase.__init__(self)\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0\n\n        self._latexManager = LatexManager._get_cached_or_new()  # deprecated\n\n        if dummy:\n            # dummy==True deactivate all methods\n            for m in RendererPgf.__dict__:\n                if m.startswith(\"draw_\"):\n                    self.__dict__[m] = lambda *args, **kwargs: None\n\n    latexManager = cbook._deprecate_privatize_attribute(\"3.2\")\n\n    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        writeln(self.fh,\n                r\"\\pgfsys@defobject{currentmarker}\"\n                r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        writeln(self.fh, r\"}\")\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False):\n            x, y = point[0] * f, point[1] * f\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            writeln(self.fh, r\"\\end{pgfscope}\")\n\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform, rgbFace)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform, rgbFace)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            writeln(self.fh,\n                    r\"\\pgfsys@defobject{currentpattern}\"\n                    r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            writeln(self.fh,\n                    r\"\\pgfpathrectangle\"\n                    r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            writeln(self.fh, r\"\\end{pgfscope}\")\n            writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            writeln(self.fh,\n                    r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def _print_pgf_clip(self, gc):\n        f = 1. / self.dpi\n        # check for clip box\n        bbox = gc.get_clip_rectangle()\n        if bbox:\n            p1, p2 = bbox.get_points()\n            w, h = p2 - p1\n            coords = p1[0] * f, p1[1] * f, w * f, h * f\n            writeln(self.fh,\n                    r\"\\pgfpathrectangle\"\n                    r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                    % coords)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n        # check for clip path\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            self._print_pgf_path(gc, clippath, clippath_trans)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n    def _print_pgf_path_styles(self, gc, rgbFace):\n        # cap style\n        capstyles = {\"butt\": r\"\\pgfsetbuttcap\",\n                     \"round\": r\"\\pgfsetroundcap\",\n                     \"projecting\": r\"\\pgfsetrectcap\"}\n        writeln(self.fh, capstyles[gc.get_capstyle()])\n\n        # join style\n        joinstyles = {\"miter\": r\"\\pgfsetmiterjoin\",\n                      \"round\": r\"\\pgfsetroundjoin\",\n                      \"bevel\": r\"\\pgfsetbeveljoin\"}\n        writeln(self.fh, joinstyles[gc.get_joinstyle()])\n\n        # filling\n        has_fill = rgbFace is not None\n\n        if gc.get_forced_alpha():\n            fillopacity = strokeopacity = gc.get_alpha()\n        else:\n            strokeopacity = gc.get_rgb()[3]\n            fillopacity = rgbFace[3] if has_fill and len(rgbFace) > 3 else 1.0\n\n        if has_fill:\n            writeln(self.fh,\n                    r\"\\definecolor{currentfill}{rgb}{%f,%f,%f}\"\n                    % tuple(rgbFace[:3]))\n            writeln(self.fh, r\"\\pgfsetfillcolor{currentfill}\")\n        if has_fill and fillopacity != 1.0:\n            writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % fillopacity)\n\n        # linewidth and color\n        lw = gc.get_linewidth() * mpl_pt_to_in * latex_in_to_pt\n        stroke_rgba = gc.get_rgb()\n        writeln(self.fh, r\"\\pgfsetlinewidth{%fpt}\" % lw)\n        writeln(self.fh,\n                r\"\\definecolor{currentstroke}{rgb}{%f,%f,%f}\"\n                % stroke_rgba[:3])\n        writeln(self.fh, r\"\\pgfsetstrokecolor{currentstroke}\")\n        if strokeopacity != 1.0:\n            writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % strokeopacity)\n\n        # line style\n        dash_offset, dash_list = gc.get_dashes()\n        if dash_list is None:\n            writeln(self.fh, r\"\\pgfsetdash{}{0pt}\")\n        else:\n            writeln(self.fh,\n                    r\"\\pgfsetdash{%s}{%fpt}\"\n                    % (\"\".join(r\"{%fpt}\" % dash for dash in dash_list),\n                       dash_offset))\n\n    def _print_pgf_path(self, gc, path, transform, rgbFace=None):\n        f = 1. / self.dpi\n        # check for clip box / ignore clip for filled paths\n        bbox = gc.get_clip_rectangle() if gc else None\n        if bbox and (rgbFace is None):\n            p1, p2 = bbox.get_points()\n            clip = (p1[0], p1[1], p2[0], p2[1])\n        else:\n            clip = None\n        # build path\n        for points, code in path.iter_segments(transform, clip=clip):\n            if code == Path.MOVETO:\n                x, y = tuple(points)\n                writeln(self.fh,\n                        r\"\\pgfpathmoveto{\\pgfqpoint{%fin}{%fin}}\" %\n                        (f * x, f * y))\n            elif code == Path.CLOSEPOLY:\n                writeln(self.fh, r\"\\pgfpathclose\")\n            elif code == Path.LINETO:\n                x, y = tuple(points)\n                writeln(self.fh,\n                        r\"\\pgfpathlineto{\\pgfqpoint{%fin}{%fin}}\" %\n                        (f * x, f * y))\n            elif code == Path.CURVE3:\n                cx, cy, px, py = tuple(points)\n                coords = cx * f, cy * f, px * f, py * f\n                writeln(self.fh,\n                        r\"\\pgfpathquadraticcurveto\"\n                        r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}\"\n                        % coords)\n            elif code == Path.CURVE4:\n                c1x, c1y, c2x, c2y, px, py = tuple(points)\n                coords = c1x * f, c1y * f, c2x * f, c2y * f, px * f, py * f\n                writeln(self.fh,\n                        r\"\\pgfpathcurveto\"\n                        r\"{\\pgfqpoint{%fin}{%fin}}\"\n                        r\"{\\pgfqpoint{%fin}{%fin}}\"\n                        r\"{\\pgfqpoint{%fin}{%fin}}\"\n                        % coords)\n\n    def _pgf_path_draw(self, stroke=True, fill=False):\n        actions = []\n        if stroke:\n            actions.append(\"stroke\")\n        if fill:\n            actions.append(\"fill\")\n        writeln(self.fh, r\"\\pgfusepath{%s}\" % \",\".join(actions))\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if not os.path.exists(getattr(self.fh, \"name\", \"\")):\n            cbook._warn_external(\n                \"streamed pgf-code does not support raster graphics, consider \"\n                \"using the pgf-to-pdf option.\")\n\n        # save the images to png files\n        path = pathlib.Path(self.fh.name)\n        fname_img = \"%s-img%d.png\" % (path.stem, self.image_counter)\n        Image.fromarray(im[::-1]).save(path.parent / fname_img)\n        self.image_counter += 1\n\n        # reference the image in the pgf picture\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        f = 1. / self.dpi  # from display coords to inch\n        if transform is None:\n            writeln(self.fh,\n                    r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x * f, y * f))\n            w, h = w * f, h * f\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n            writeln(self.fh,\n                    r\"\\pgfsys@transformcm{%f}{%f}{%f}{%f}{%fin}{%fin}\" %\n                    (tr1 * f, tr2 * f, tr3 * f, tr4 * f,\n                     (tr5 + x) * f, (tr6 + y) * f))\n            w = h = 1  # scale is already included in the transform\n        interp = str(transform is None).lower()  # interpolation in PDF reader\n        writeln(self.fh,\n                r\"\\pgftext[left,bottom]\"\n                r\"{%s[interpolate=%s,width=%fin,height=%fin]{%s}}\" %\n                (_get_image_inclusion_command(),\n                 interp, w, h, fname_img))\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX!\", mtext=None):\n        # docstring inherited\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = common_texification(s)\n        prop_cmds = _font_properties_str(prop)\n        s = r\"%s %s\" % (prop_cmds, s)\n\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        # check if the math is supposed to be displaystyled\n        s = common_texification(s)\n\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = (LatexManager._get_cached_or_new()\n                   .get_width_height_descent(s, prop))\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f\n\n    def flipy(self):\n        # docstring inherited\n        return False\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return (self.figure.get_figwidth() * self.dpi,\n                self.figure.get_figheight() * self.dpi)\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * mpl_pt_to_in * self.dpi",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "fh",
          "types": null
        },
        {
          "name": "figure",
          "types": null
        },
        {
          "name": "image_counter",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_latexManager",
          "types": {
            "kind": "NamedType",
            "name": "LatexManager"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/TmpDirCleaner",
      "name": "TmpDirCleaner",
      "qname": "lib.matplotlib.backends.backend_pgf.TmpDirCleaner",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_pgf/TmpDirCleaner/add",
        "matplotlib/lib.matplotlib.backends.backend_pgf/TmpDirCleaner/cleanup_remaining_tmpdirs"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TmpDirCleaner:\n    remaining_tmpdirs = set()\n\n    @staticmethod\n    def add(tmpdir):\n        TmpDirCleaner.remaining_tmpdirs.add(tmpdir)\n\n    @staticmethod\n    @atexit.register\n    def cleanup_remaining_tmpdirs():\n        for tmpdir in TmpDirCleaner.remaining_tmpdirs:\n            error_message = \"error deleting tmp directory {}\".format(tmpdir)\n            shutil.rmtree(\n                tmpdir,\n                onerror=lambda *args: _log.error(error_message))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS",
      "name": "FigureCanvasPS",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_ps",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_eps",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_ps",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_figure",
        "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/_print_figure_tex"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasPS(FigureCanvasBase):\n    fixed_dpi = 72\n    filetypes = {'ps': 'Postscript',\n                 'eps': 'Encapsulated Postscript'}\n\n    def get_default_filetype(self):\n        return 'ps'\n\n    def print_ps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'ps', *args, **kwargs)\n\n    def print_eps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'eps', *args, **kwargs)\n\n    def _print_ps(\n            self, outfile, format, *args,\n            dpi=72, metadata=None, papertype=None, orientation='portrait',\n            **kwargs):\n\n        self.figure.set_dpi(72)  # Override the dpi kwarg\n\n        dsc_comments = {}\n        if isinstance(outfile, (str, os.PathLike)):\n            dsc_comments[\"Title\"] = \\\n                os.fspath(outfile).encode(\"ascii\", \"replace\").decode(\"ascii\")\n        dsc_comments[\"Creator\"] = (metadata or {}).get(\n            \"Creator\",\n            f\"matplotlib version {mpl.__version__}, http://matplotlib.org/\")\n        # See https://reproducible-builds.org/specs/source-date-epoch/\n        source_date_epoch = os.getenv(\"SOURCE_DATE_EPOCH\")\n        dsc_comments[\"CreationDate\"] = (\n            datetime.datetime.utcfromtimestamp(\n                int(source_date_epoch)).strftime(\"%a %b %d %H:%M:%S %Y\")\n            if source_date_epoch\n            else time.ctime())\n        dsc_comments = \"\\n\".join(\n            f\"%%{k}: {v}\" for k, v in dsc_comments.items())\n\n        if papertype is None:\n            papertype = mpl.rcParams['ps.papersize']\n        papertype = papertype.lower()\n        cbook._check_in_list(['auto', *papersize], papertype=papertype)\n\n        orientation = cbook._check_getitem(\n            _Orientation, orientation=orientation.lower())\n\n        printer = (self._print_figure_tex\n                   if mpl.rcParams['text.usetex'] else\n                   self._print_figure)\n        printer(outfile, format, dpi=dpi, dsc_comments=dsc_comments,\n                orientation=orientation, papertype=papertype, **kwargs)\n\n    @_check_savefig_extra_args\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    def _print_figure(\n            self, outfile, format, *,\n            dpi, dsc_comments, orientation, papertype,\n            dryrun=False, bbox_inches_restore=None):\n        \"\"\"\n        Render the figure to a filesystem path or a file-like object.\n\n        Parameters are as for `.print_figure`, except that *dsc_comments* is a\n        all string containing Document Structuring Convention comments,\n        generated from the *metadata* parameter to `.print_figure`.\n        \"\"\"\n        is_eps = format == 'eps'\n        if isinstance(outfile, (str, os.PathLike)):\n            outfile = os.fspath(outfile)\n            passed_in_file_object = False\n        elif is_writable_file_like(outfile):\n            passed_in_file_object = True\n        else:\n            raise ValueError(\"outfile must be a path or a file-like object\")\n\n        # find the appropriate papertype\n        width, height = self.figure.get_size_inches()\n        if papertype == 'auto':\n            papertype = _get_papertype(\n                *orientation.swap_if_landscape((width, height)))\n        paper_width, paper_height = orientation.swap_if_landscape(\n            papersize[papertype])\n\n        if mpl.rcParams['ps.usedistiller']:\n            # distillers improperly clip eps files if pagesize is too small\n            if width > paper_width or height > paper_height:\n                papertype = _get_papertype(\n                    *orientation.swap_if_landscape(width, height))\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    papersize[papertype])\n\n        # center the figure on the paper\n        xo = 72 * 0.5 * (paper_width - width)\n        yo = 72 * 0.5 * (paper_height - height)\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        rotation = 0\n        if orientation is _Orientation.landscape:\n            llx, lly, urx, ury = lly, llx, ury, urx\n            xo, yo = 72 * paper_height - yo, xo\n            rotation = 90\n        bbox = (llx, lly, urx, ury)\n\n        if dryrun:\n            class NullWriter:\n                def write(self, *args, **kwargs):\n                    pass\n\n            self._pswriter = NullWriter()\n        else:\n            self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi, ps_renderer,\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        if dryrun:  # return immediately if dryrun (tightbbox=True)\n            return\n\n        def print_figure_impl(fh):\n            # write the PostScript headers\n            if is_eps:\n                print(\"%!PS-Adobe-3.0 EPSF-3.0\", file=fh)\n            else:\n                print(f\"%!PS-Adobe-3.0\\n\"\n                      f\"%%DocumentPaperSizes: {papertype}\\n\"\n                      f\"%%Pages: 1\\n\",\n                      end=\"\", file=fh)\n            print(f\"{dsc_comments}\\n\"\n                  f\"%%Orientation: {orientation.name}\\n\"\n                  f\"%%BoundingBox: {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\\n\"\n                  f\"%%EndComments\\n\",\n                  end=\"\", file=fh)\n\n            Ndict = len(psDefs)\n            print(\"%%BeginProlog\", file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                Ndict += len(ps_renderer._character_tracker.used)\n            print(\"/mpldict %d dict def\" % Ndict, file=fh)\n            print(\"mpldict begin\", file=fh)\n            print(\"\\n\".join(psDefs), file=fh)\n            if not mpl.rcParams['ps.useafm']:\n                for font_path, chars \\\n                        in ps_renderer._character_tracker.used.items():\n                    if not chars:\n                        continue\n                    font = get_font(font_path)\n                    glyph_ids = [font.get_char_index(c) for c in chars]\n                    fonttype = mpl.rcParams['ps.fonttype']\n                    # Can't use more than 255 chars from a single Type 3 font.\n                    if len(glyph_ids) > 255:\n                        fonttype = 42\n                    # The ttf to ps (subsetting) support doesn't work for\n                    # OpenType fonts that are Postscript inside (like the STIX\n                    # fonts).  This will simply turn that off to avoid errors.\n                    if is_opentype_cff_font(font_path):\n                        raise RuntimeError(\n                            \"OpenType CFF fonts can not be saved using \"\n                            \"the internal Postscript backend at this \"\n                            \"time; consider using the Cairo backend\")\n                    fh.flush()\n                    try:\n                        convert_ttf_to_ps(os.fsencode(font_path),\n                                          fh, fonttype, glyph_ids)\n                    except RuntimeError:\n                        _log.warning(\"The PostScript backend does not \"\n                                     \"currently support the selected font.\")\n                        raise\n            print(\"end\", file=fh)\n            print(\"%%EndProlog\", file=fh)\n\n            if not is_eps:\n                print(\"%%Page: 1 1\", file=fh)\n            print(\"mpldict begin\", file=fh)\n\n            print(\"%s translate\" % _nums_to_str(xo, yo), file=fh)\n            if rotation:\n                print(\"%d rotate\" % rotation, file=fh)\n            print(\"%s clipbox\" % _nums_to_str(width*72, height*72, 0, 0),\n                  file=fh)\n\n            # write the figure\n            print(self._pswriter.getvalue(), file=fh)\n\n            # write the trailer\n            print(\"end\", file=fh)\n            print(\"showpage\", file=fh)\n            if not is_eps:\n                print(\"%%EOF\", file=fh)\n            fh.flush()\n\n        if mpl.rcParams['ps.usedistiller']:\n            # We are going to use an external program to process the output.\n            # Write to a temporary file.\n            with TemporaryDirectory() as tmpdir:\n                tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n                with open(tmpfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n                if mpl.rcParams['ps.usedistiller'] == 'ghostscript':\n                    _try_distill(gs_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                    _try_distill(xpdf_distill,\n                                 tmpfile, is_eps, ptype=papertype, bbox=bbox)\n                _move_path_to_path_or_stream(tmpfile, outfile)\n\n        else:\n            # Write directly to outfile.\n            if passed_in_file_object:\n                requires_unicode = file_requires_unicode(outfile)\n\n                if not requires_unicode:\n                    fh = TextIOWrapper(outfile, encoding=\"latin-1\")\n                    # Prevent the TextIOWrapper from closing the underlying\n                    # file.\n                    fh.close = lambda: None\n                else:\n                    fh = outfile\n\n                print_figure_impl(fh)\n            else:\n                with open(outfile, 'w', encoding='latin-1') as fh:\n                    print_figure_impl(fh)\n\n    @_check_savefig_extra_args\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    def _print_figure_tex(\n            self, outfile, format, *,\n            dpi, dsc_comments, orientation, papertype,\n            dryrun=False, bbox_inches_restore=None):\n        \"\"\"\n        If :rc:`text.usetex` is True, a temporary pair of tex/eps files\n        are created to allow tex to manage the text layout via the PSFrags\n        package. These files are processed to yield the final ps or eps file.\n\n        The rest of the behavior is as for `._print_figure`.\n        \"\"\"\n        is_eps = format == 'eps'\n\n        width, height = self.figure.get_size_inches()\n        xo = 0\n        yo = 0\n\n        llx = xo\n        lly = yo\n        urx = llx + self.figure.bbox.width\n        ury = lly + self.figure.bbox.height\n        bbox = (llx, lly, urx, ury)\n\n        if dryrun:\n            class NullWriter:\n                def write(self, *args, **kwargs):\n                    pass\n\n            self._pswriter = NullWriter()\n        else:\n            self._pswriter = StringIO()\n\n        # mixed mode rendering\n        ps_renderer = RendererPS(width, height, self._pswriter, imagedpi=dpi)\n        renderer = MixedModeRenderer(self.figure,\n                                     width, height, dpi, ps_renderer,\n                                     bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n\n        if dryrun:  # return immediately if dryrun (tightbbox=True)\n            return\n\n        # write to a temp file, we'll move it to outfile when done\n        with TemporaryDirectory() as tmpdir:\n            tmpfile = os.path.join(tmpdir, \"tmp.ps\")\n            pathlib.Path(tmpfile).write_text(\n                f\"\"\"\\\n%!PS-Adobe-3.0 EPSF-3.0\n{dsc_comments}\n%%BoundingBox: {bbox[0]} {bbox[1]} {bbox[2]} {bbox[3]}\n%%EndComments\n%%BeginProlog\n/mpldict {len(psDefs)} dict def\nmpldict begin\n{\"\".join(psDefs)}\nend\n%%EndProlog\nmpldict begin\n{_nums_to_str(xo, yo)} translate\n{_nums_to_str(width*72, height*72)} 0 0 clipbox\n{self._pswriter.getvalue()}\nend\nshowpage\n\"\"\",\n                encoding=\"latin-1\")\n\n            if orientation is _Orientation.landscape:  # now, ready to rotate\n                width, height = height, width\n                bbox = (lly, llx, ury, urx)\n\n            # set the paper size to the figure size if is_eps. The\n            # resulting ps file has the given size with correct bounding\n            # box so that there is no need to call 'pstoeps'\n            if is_eps:\n                paper_width, paper_height = orientation.swap_if_landscape(\n                    self.figure.get_size_inches())\n            else:\n                if papertype == 'auto':\n                    papertype = _get_papertype(width, height)\n                paper_width, paper_height = papersize[papertype]\n\n            texmanager = ps_renderer.get_texmanager()\n            font_preamble = texmanager.get_font_preamble()\n            custom_preamble = texmanager.get_custom_preamble()\n\n            psfrag_rotated = convert_psfrags(tmpfile, ps_renderer.psfrag,\n                                             font_preamble,\n                                             custom_preamble, paper_width,\n                                             paper_height,\n                                             orientation.name)\n\n            if (mpl.rcParams['ps.usedistiller'] == 'ghostscript'\n                    or mpl.rcParams['text.usetex']):\n                _try_distill(gs_distill,\n                             tmpfile, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n            elif mpl.rcParams['ps.usedistiller'] == 'xpdf':\n                _try_distill(xpdf_distill,\n                             tmpfile, is_eps, ptype=papertype, bbox=bbox,\n                             rotated=psfrag_rotated)\n\n            _move_path_to_path_or_stream(tmpfile, outfile)",
      "instance_attributes": [
        {
          "name": "_pswriter",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "NullWriter"
              },
              {
                "kind": "NamedType",
                "name": "StringIO"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS",
      "name": "GraphicsContextPS",
      "qname": "lib.matplotlib.backends.backend_ps.GraphicsContextPS",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS/get_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS/get_joinstyle"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class GraphicsContextPS(GraphicsContextBase):\n    def get_capstyle(self):\n        return {'butt': 0, 'round': 1, 'projecting': 2}[\n            GraphicsContextBase.get_capstyle(self)]\n\n    def get_joinstyle(self):\n        return {'miter': 0, 'round': 1, 'bevel': 2}[\n            GraphicsContextBase.get_joinstyle(self)]",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper",
      "name": "PsBackendHelper",
      "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class PsBackendHelper:\n    def __init__(self):\n        self._cached = {}",
      "instance_attributes": [
        {
          "name": "_cached",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS",
      "name": "RendererPS",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS",
      "decorators": [],
      "superclasses": [
        "_backend_pdf_ps.RendererPDFPSBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/used_characters@getter",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/track_characters",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/merge_used_characters",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_convert_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_get_clip_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/_draw_ps"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "code": "class RendererPS(_backend_pdf_ps.RendererPDFPSBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles.\n    \"\"\"\n\n    _afm_font_dir = cbook._get_data_path(\"fonts/afm\")\n    _use_afm_rc_name = \"ps.useafm\"\n\n    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self.mathtext_parser = MathTextParser(\"PS\")\n\n    @cbook.deprecated(\"3.3\")\n    @property\n    def used_characters(self):\n        return self._character_tracker.used_characters\n\n    @cbook.deprecated(\"3.3\")\n    def track_characters(self, *args, **kwargs):\n        \"\"\"Keep track of which characters are required from each font.\"\"\"\n        self._character_tracker.track(*args, **kwargs)\n\n    @cbook.deprecated(\"3.3\")\n    def merge_used_characters(self, *args, **kwargs):\n        self._character_tracker.merge(*args, **kwargs)\n\n    def set_color(self, r, g, b, store=True):\n        if (r, g, b) != self.color:\n            if r == g and r == b:\n                self._pswriter.write(\"%1.3f setgray\\n\" % r)\n            else:\n                self._pswriter.write(\n                    \"%1.3f %1.3f %1.3f setrgbcolor\\n\" % (r, g, b))\n            if store:\n                self.color = (r, g, b)\n\n    def set_linewidth(self, linewidth, store=True):\n        linewidth = float(linewidth)\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\" % linewidth)\n            if store:\n                self.linewidth = linewidth\n\n    def set_linejoin(self, linejoin, store=True):\n        if linejoin != self.linejoin:\n            self._pswriter.write(\"%d setlinejoin\\n\" % linejoin)\n            if store:\n                self.linejoin = linejoin\n\n    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(\"%d setlinecap\\n\" % linecap)\n            if store:\n                self.linecap = linecap\n\n    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        if seq is not None and len(seq):\n            s = \"[%s] %d setdash\\n\" % (_nums_to_str(*seq), offset)\n            self._pswriter.write(s)\n        else:\n            self._pswriter.write(\"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)\n\n    def set_font(self, fontname, fontsize, store=True):\n        if mpl.rcParams['ps.useafm']:\n            return\n        if (fontname, fontsize) != (self.fontname, self.fontsize):\n            out = (\"/%s findfont\\n\"\n                   \"%1.3f scalefont\\n\"\n                   \"setfont\\n\" % (fontname, fontsize))\n            self._pswriter.write(out)\n            if store:\n                self.fontname = fontname\n                self.fontsize = fontsize\n\n    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        linewidth = mpl.rcParams['hatch.linewidth']\n        pageheight = self.height * 72\n        self._pswriter.write(f\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 {sidelen:d} {sidelen:d}]\n     /XStep {sidelen:d}\n     /YStep {sidelen:d}\n\n     /PaintProc {{\n        pop\n        {linewidth:f} setlinewidth\n{self._convert_path(\n    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}\n        gsave\n        fill\n        grestore\n        stroke\n     }} bind\n   >>\n   matrix\n   0.0 {pageheight:f} translate\n   makepattern\n   /{name} exch def\n\"\"\")\n        self._hatches[hatch] = name\n        return name\n\n    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        # data.tobytes().hex() has no spaces, so can be linewrapped by simply\n        # splitting data every nchars. It's equivalent to textwrap.fill only\n        # much faster.\n        nchars = 128\n        data = data.tobytes().hex()\n        hexlines = \"\\n\".join(\n            [\n                data[n * nchars:(n + 1) * nchars]\n                for n in range(math.ceil(len(data) / nchars))\n            ]\n        )\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        bbox = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n\n        clip = []\n        if bbox is not None:\n            clip.append('%s clipbox' % _nums_to_str(*bbox.size, *bbox.p0))\n        if clippath is not None:\n            id = self._get_clip_path(clippath, clippath_trans)\n            clip.append('%s' % id)\n        clip = '\\n'.join(clip)\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{clip}\n{x:f} {y:f} translate\n[{matrix}] concat\n{xscale:f} {yscale:f} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexlines}\ngrestore\n\"\"\")\n\n    def _convert_path(self, path, transform, clip=False, simplify=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72.0, self.height * 72.0)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, None,\n            6, [b'm', b'l', b'', b'c', b'cl'], True).decode('ascii')\n\n    def _get_clip_path(self, clippath, clippath_transform):\n        key = (clippath, id(clippath_transform))\n        pid = self._clip_paths.get(key)\n        if pid is None:\n            pid = 'c%x' % len(self._clip_paths)\n            clippath_bytes = self._convert_path(\n                clippath, clippath_transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{pid} {{\n{clippath_bytes}\nclip\nnewpath\n}} bind def\n\"\"\")\n            self._clip_paths[key] = pid\n        return pid\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)\n\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if debugPS:\n            self._pswriter.write('% draw_markers \\n')\n\n        ps_color = (\n            None\n            if _is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            jint = gc.get_joinstyle()\n            ps_cmd.append('%d setlinejoin' % jint)\n            cint = gc.get_capstyle()\n            ps_cmd.append('%d setlinecap' % cint)\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #     (len_path + 2) * uses_per_path\n        # cost of definition+use is\n        #     (len_path + 3) + 3 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 3 * uses_per_path + 3 < (len_path + 2) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = 'p%x_%x' % (self._path_collection_id, i)\n            path_bytes = self._convert_path(path, transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{name} {{\nnewpath\ntranslate\n{path_bytes}\n}} bind def\n\"\"\")\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1\n\n    @cbook._delete_parameter(\"3.3\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        if not hasattr(self, \"psfrag\"):\n            _log.warning(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        corr = 0  # w/2*(fontsize-10)/10\n        if dict.__getitem__(mpl.rcParams, 'text.latex.preview'):\n            # use baseline alignment!\n            pos = _nums_to_str(x-corr, y)\n            self.psfrag.append(\n                r'\\psfrag{%s}[Bl][Bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                    thetext, angle, fontsize, fontsize*1.25, tex))\n        else:\n            # Stick to the bottom alignment.\n            pos = _nums_to_str(x-corr, y-bl)\n            self.psfrag.append(\n                r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                    thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if debugPS:\n            self._pswriter.write(\"% text\\n\")\n\n        if _is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        elif ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        elif mpl.rcParams['ps.useafm']:\n            self.set_color(*gc.get_rgb())\n\n            font = self._get_font_afm(prop)\n            fontname = font.get_fontname()\n            fontsize = prop.get_size_in_points()\n            scale = 0.001 * fontsize\n\n            thisx = 0\n            thisy = font.get_str_bbox_and_descent(s)[4] * scale\n            last_name = None\n            lines = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                if last_name is not None:\n                    kern = font.get_kern_dist_from_name(last_name, name)\n                else:\n                    kern = 0\n                last_name = name\n                thisx += kern * scale\n\n                lines.append('%f %f m /%s glyphshow' % (thisx, thisy, name))\n\n                thisx += width * scale\n\n            thetext = \"\\n\".join(lines)\n            self._pswriter.write(f\"\"\"\\\ngsave\n/{fontname} findfont\n{fontsize} scalefont\nsetfont\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")\n\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0, flags=LOAD_NO_HINTING)\n            self._character_tracker.track(font, s)\n\n            self.set_color(*gc.get_rgb())\n            ps_name = (font.postscript_name\n                       .encode('ascii', 'replace').decode('ascii'))\n            self.set_font(ps_name, prop.get_size_in_points())\n\n            thetext = '\\n'.join(\n                '%f 0 m /%s glyphshow' % (x, font.get_glyph_name(glyph_idx))\n                for glyph_idx, x in _text_layout.layout(s, font))\n            self._pswriter.write(f\"\"\"\\\ngsave\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPS()\n\n    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw the math text using matplotlib.mathtext.\"\"\"\n        if debugPS:\n            self._pswriter.write(\"% mathtext\\n\")\n\n        width, height, descent, pswriter, used_characters = \\\n            self.mathtext_parser.parse(s, 72, prop)\n        self._character_tracker.merge(used_characters)\n        self.set_color(*gc.get_rgb())\n        thetext = pswriter.getvalue()\n        self._pswriter.write(f\"\"\"\\\ngsave\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)\n\n    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil((2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        streamarr = np.empty(\n            shape[0] * shape[1],\n            dtype=[('flags', 'u1'), ('points', '2>u4'), ('colors', '3u1')])\n        streamarr['flags'] = 0\n        streamarr['points'] = (flat_points - points_min) * factor\n        streamarr['colors'] = flat_colors[:, :3] * 255.0\n        stream = quote_ps_string(streamarr.tobytes())\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ {xmin:f} {xmax:f} {ymin:f} {ymax:f} 0 1 0 1 0 1 ]\n   /DataSource ({stream})\n>>\nshfill\ngrestore\n\"\"\")\n\n    def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None):\n        \"\"\"\n        Emit the PostScript snippet 'ps' with all the attributes from 'gc'\n        applied.  'ps' must consist of PostScript commands to construct a path.\n\n        The fill and/or stroke kwargs can be set to False if the\n        'ps' string already includes filling and/or stroking, in\n        which case _draw_ps is just supplying properties and\n        clipping.\n        \"\"\"\n        # local variable eliminates all repeated attribute lookups\n        write = self._pswriter.write\n        if debugPS and command:\n            write(\"% \"+command+\"\\n\")\n        mightstroke = (gc.get_linewidth() > 0\n                       and not _is_transparent(gc.get_rgb()))\n        if not mightstroke:\n            stroke = False\n        if _is_transparent(rgbFace):\n            fill = False\n        hatch = gc.get_hatch()\n\n        if mightstroke:\n            self.set_linewidth(gc.get_linewidth())\n            jint = gc.get_joinstyle()\n            self.set_linejoin(jint)\n            cint = gc.get_capstyle()\n            self.set_linecap(cint)\n            self.set_linedash(*gc.get_dashes())\n            self.set_color(*gc.get_rgb()[:3])\n        write('gsave\\n')\n\n        cliprect = gc.get_clip_rectangle()\n        if cliprect:\n            write('%1.4g %1.4g %1.4g %1.4g clipbox\\n'\n                  % (*cliprect.size, *cliprect.p0))\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath:\n            id = self._get_clip_path(clippath, clippath_trans)\n            write('%s\\n' % id)\n\n        # Jochen, is the strip necessary? - this could be a honking big string\n        write(ps.strip())\n        write(\"\\n\")\n\n        if fill:\n            if stroke or hatch:\n                write(\"gsave\\n\")\n            self.set_color(*rgbFace[:3], store=False)\n            write(\"fill\\n\")\n            if stroke or hatch:\n                write(\"grestore\\n\")\n\n        if hatch:\n            hatch_name = self.create_hatch(hatch)\n            write(\"gsave\\n\")\n            write(\"%f %f %f \" % gc.get_hatch_color()[:3])\n            write(\"%s setpattern fill grestore\\n\" % hatch_name)\n\n        if stroke:\n            write(\"stroke\\n\")\n\n        write(\"grestore\\n\")",
      "instance_attributes": [
        {
          "name": "_pswriter",
          "types": null
        },
        {
          "name": "textcnt",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "psfrag",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "imagedpi",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "color",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "linewidth",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "linejoin",
          "types": null
        },
        {
          "name": "linecap",
          "types": null
        },
        {
          "name": "linedash",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        },
        {
          "name": "fontname",
          "types": null
        },
        {
          "name": "fontsize",
          "types": null
        },
        {
          "name": "_hatches",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "image_magnification",
          "types": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "name": "_clip_paths",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_path_collection_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_character_tracker",
          "types": null
        },
        {
          "name": "mathtext_parser",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ConfigureSubplotsQt",
      "name": "ConfigureSubplotsQt",
      "qname": "lib.matplotlib.backends.backend_qt5.ConfigureSubplotsQt",
      "decorators": [],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/ConfigureSubplotsQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsQt(backend_tools.ConfigureSubplotsBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT",
      "name": "FigureCanvasQT",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT",
      "decorators": [],
      "superclasses": [
        "QtWidgets.QWidget",
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/_update_figure_dpi",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/_dpi_ratio@getter",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/_update_dpi",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/get_width_height",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/enterEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/leaveEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseEventCoords",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mousePressEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseDoubleClickEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseMoveEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseReleaseEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/wheelEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/wheelEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyPressEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyReleaseEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/resizeEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/sizeHint",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/minumumSizeHint",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/_get_key",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/flush_events",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/start_event_loop",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/stop_event_loop",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/draw",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/blit",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/_draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/drawRectangle"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQT(QtWidgets.QWidget, FigureCanvasBase):\n    required_interactive_framework = \"qt5\"\n    _timer_cls = TimerQT\n\n    # map Qt button codes to MouseEvent's ones:\n    buttond = {QtCore.Qt.LeftButton: MouseButton.LEFT,\n               QtCore.Qt.MidButton: MouseButton.MIDDLE,\n               QtCore.Qt.RightButton: MouseButton.RIGHT,\n               QtCore.Qt.XButton1: MouseButton.BACK,\n               QtCore.Qt.XButton2: MouseButton.FORWARD,\n               }\n\n    @_allow_super_init\n    def __init__(self, figure):\n        _create_qApp()\n        super().__init__(figure=figure)\n\n        # We don't want to scale up the figure DPI more than once.\n        # Note, we don't handle a signal for changing DPI yet.\n        figure._original_dpi = figure.dpi\n        self._update_figure_dpi()\n        # In cases with mixed resolution displays, we need to be careful if the\n        # dpi_ratio changes - in this case we need to resize the canvas\n        # accordingly. We could watch for screenChanged events from Qt, but\n        # the issue is that we can't guarantee this will be emitted *before*\n        # the first paintEvent for the canvas, so instead we keep track of the\n        # dpi_ratio value here and in paintEvent we resize the canvas if\n        # needed.\n        self._dpi_ratio_prev = None\n\n        self._draw_pending = False\n        self._is_drawing = False\n        self._draw_rect_callback = lambda painter: None\n\n        self.setAttribute(QtCore.Qt.WA_OpaquePaintEvent)\n        self.setMouseTracking(True)\n        self.resize(*self.get_width_height())\n\n        palette = QtGui.QPalette(QtCore.Qt.white)\n        self.setPalette(palette)\n\n    def _update_figure_dpi(self):\n        dpi = self._dpi_ratio * self.figure._original_dpi\n        self.figure._set_dpi(dpi, forward=False)\n\n    @property\n    def _dpi_ratio(self):\n        return _devicePixelRatioF(self)\n\n    def _update_dpi(self):\n        # As described in __init__ above, we need to be careful in cases with\n        # mixed resolution displays if dpi_ratio is changing between painting\n        # events.\n        # Return whether we triggered a resizeEvent (and thus a paintEvent)\n        # from within this function.\n        if self._dpi_ratio != self._dpi_ratio_prev:\n            # We need to update the figure DPI.\n            self._update_figure_dpi()\n            self._dpi_ratio_prev = self._dpi_ratio\n            # The easiest way to resize the canvas is to emit a resizeEvent\n            # since we implement all the logic for resizing the canvas for\n            # that event.\n            event = QtGui.QResizeEvent(self.size(), self.size())\n            self.resizeEvent(event)\n            # resizeEvent triggers a paintEvent itself, so we exit this one\n            # (after making sure that the event is immediately handled).\n            return True\n        return False\n\n    def get_width_height(self):\n        w, h = FigureCanvasBase.get_width_height(self)\n        return int(w / self._dpi_ratio), int(h / self._dpi_ratio)\n\n    def enterEvent(self, event):\n        try:\n            x, y = self.mouseEventCoords(event.pos())\n        except AttributeError:\n            # the event from PyQt4 does not include the position\n            x = y = None\n        FigureCanvasBase.enter_notify_event(self, guiEvent=event, xy=(x, y))\n\n    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        FigureCanvasBase.leave_notify_event(self, guiEvent=event)\n\n    def mouseEventCoords(self, pos):\n        \"\"\"\n        Calculate mouse coordinates in physical pixels.\n\n        Qt5 use logical pixels, but the figure is scaled to physical\n        pixels for rendering.  Transform to physical pixels so that\n        all of the down-stream transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        dpi_ratio = self._dpi_ratio\n        x = pos.x()\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height / dpi_ratio - pos.y()\n        return x * dpi_ratio, y * dpi_ratio\n\n    def mousePressEvent(self, event):\n        x, y = self.mouseEventCoords(event.pos())\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_press_event(self, x, y, button,\n                                                guiEvent=event)\n\n    def mouseDoubleClickEvent(self, event):\n        x, y = self.mouseEventCoords(event.pos())\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_press_event(self, x, y,\n                                                button, dblclick=True,\n                                                guiEvent=event)\n\n    def mouseMoveEvent(self, event):\n        x, y = self.mouseEventCoords(event)\n        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event)\n\n    def mouseReleaseEvent(self, event):\n        x, y = self.mouseEventCoords(event)\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_release_event(self, x, y, button,\n                                                  guiEvent=event)\n\n    if QtCore.qVersion() >= \"5.\":\n        def wheelEvent(self, event):\n            x, y = self.mouseEventCoords(event)\n            # from QWheelEvent::delta doc\n            if event.pixelDelta().x() == 0 and event.pixelDelta().y() == 0:\n                steps = event.angleDelta().y() / 120\n            else:\n                steps = event.pixelDelta().y()\n            if steps:\n                FigureCanvasBase.scroll_event(\n                    self, x, y, steps, guiEvent=event)\n    else:\n        def wheelEvent(self, event):\n            x = event.x()\n            # flipy so y=0 is bottom of canvas\n            y = self.figure.bbox.height - event.y()\n            # from QWheelEvent::delta doc\n            steps = event.delta() / 120\n            if event.orientation() == QtCore.Qt.Vertical:\n                FigureCanvasBase.scroll_event(\n                    self, x, y, steps, guiEvent=event)\n\n    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            FigureCanvasBase.key_press_event(self, key, guiEvent=event)\n\n    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            FigureCanvasBase.key_release_event(self, key, guiEvent=event)\n\n    def resizeEvent(self, event):\n        # _dpi_ratio_prev will be set the first time the canvas is painted, and\n        # the rendered buffer is useless before anyways.\n        if self._dpi_ratio_prev is None:\n            return\n        w = event.size().width() * self._dpi_ratio\n        h = event.size().height() * self._dpi_ratio\n        dpival = self.figure.dpi\n        winch = w / dpival\n        hinch = h / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        # pass back into Qt to let it finish\n        QtWidgets.QWidget.resizeEvent(self, event)\n        # emit our resize events\n        FigureCanvasBase.resize_event(self)\n\n    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)\n\n    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)\n\n    def _get_key(self, event):\n        event_key = event.key()\n        event_mods = int(event.modifiers())  # actually a bitmask\n\n        # get names of the pressed modifier keys\n        # 'control' is named 'control' when a standalone key, but 'ctrl' when a\n        # modifier\n        # bit twiddling to pick out modifier keys from event_mods bitmask,\n        # if event_key is a MODIFIER, it should not be duplicated in mods\n        mods = [SPECIAL_KEYS[key].replace('control', 'ctrl')\n                for mod, key in _MODIFIER_KEYS\n                if event_key != key and event_mods & mod]\n        try:\n            # for certain keys (enter, left, backspace, etc) use a word for the\n            # key, rather than unicode\n            key = SPECIAL_KEYS[event_key]\n        except KeyError:\n            # unicode defines code points up to 0x10ffff (sys.maxunicode)\n            # QT will use Key_Codes larger than that for keyboard keys that are\n            # are not unicode characters (like multimedia keys)\n            # skip these\n            # if you really want them, you should add them to SPECIAL_KEYS\n            if event_key > sys.maxunicode:\n                return None\n\n            key = chr(event_key)\n            # qt delivers capitalized letters.  fix capitalization\n            # note that capslock is ignored\n            if 'shift' in mods:\n                mods.remove('shift')\n            else:\n                key = key.lower()\n\n        return '+'.join(mods + [key])\n\n    def flush_events(self):\n        # docstring inherited\n        qApp.processEvents()\n\n    def start_event_loop(self, timeout=0):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\") and self._event_loop.isRunning():\n            raise RuntimeError(\"Event loop already running\")\n        self._event_loop = event_loop = QtCore.QEventLoop()\n        if timeout > 0:\n            timer = QtCore.QTimer.singleShot(int(timeout * 1000),\n                                             event_loop.quit)\n        event_loop.exec_()\n\n    def stop_event_loop(self, event=None):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\"):\n            self._event_loop.quit()\n\n    def draw(self):\n        \"\"\"Render the figure, and queue a request for a Qt draw.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()\n\n    def draw_idle(self):\n        \"\"\"Queue redraw of the Agg buffer and request Qt paintEvent.\"\"\"\n        # The Agg draw needs to be handled by the same thread Matplotlib\n        # modifies the scene graph from. Post Agg draw request to the\n        # current event loop in order to ensure thread affinity and to\n        # accumulate multiple draw requests from event handling.\n        # TODO: queued signal connection might be safer than singleShot\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            QtCore.QTimer.singleShot(0, self._draw_idle)\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None and self.figure:\n            bbox = self.figure.bbox  # Blit the entire canvas if bbox is None.\n        # repaint uses logical pixels, not physical pixels like the renderer.\n        l, b, w, h = [int(pt / self._dpi_ratio) for pt in bbox.bounds]\n        t = b + h\n        self.repaint(l, self.rect().height() - t, w, h)\n\n    def _draw_idle(self):\n        with self._idle_draw_cntx():\n            if not self._draw_pending:\n                return\n            self._draw_pending = False\n            if self.height() < 0 or self.width() < 0:\n                return\n            try:\n                self.draw()\n            except Exception:\n                # Uncaught exceptions are fatal for PyQt5, so catch them.\n                traceback.print_exc()\n\n    def drawRectangle(self, rect):\n        # Draw the zoom rectangle to the QPainter.  _draw_rect_callback needs\n        # to be called at the end of paintEvent.\n        if rect is not None:\n            x0, y0, w, h = [int(pt / self._dpi_ratio) for pt in rect]\n            x1 = x0 + w\n            y1 = y0 + h\n            def _draw_rect_callback(painter):\n                pen = QtGui.QPen(QtCore.Qt.black, 1 / self._dpi_ratio)\n                pen.setDashPattern([3, 3])\n                for color, offset in [\n                        (QtCore.Qt.black, 0), (QtCore.Qt.white, 3)]:\n                    pen.setDashOffset(offset)\n                    pen.setColor(color)\n                    painter.setPen(pen)\n                    # Draw the lines from x0, y0 towards x1, y1 so that the\n                    # dashes don't \"jump\" when moving the zoom box.\n                    painter.drawLine(x0, y0, x0, y1)\n                    painter.drawLine(x0, y0, x1, y0)\n                    painter.drawLine(x0, y1, x1, y1)\n                    painter.drawLine(x1, y0, x1, y1)\n        else:\n            def _draw_rect_callback(painter):\n                return\n        self._draw_rect_callback = _draw_rect_callback\n        self.update()",
      "instance_attributes": [
        {
          "name": "_dpi_ratio_prev",
          "types": null
        },
        {
          "name": "_draw_pending",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_is_drawing",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_draw_rect_callback",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "_event_loop",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT",
      "name": "FigureManagerQT",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/full_screen_toggle",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/_widgetclosed",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/_get_toolbar",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/resize",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/show",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/destroy",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/set_window_title"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Attributes\n----------\ncanvas : `FigureCanvas`\n    The FigureCanvas instance\nnum : int or str\n    The Figure number\ntoolbar : qt.QToolBar\n    The qt.QToolBar\nwindow : qt.QMainWindow\n    The qt.QMainWindow",
      "code": "class FigureManagerQT(FigureManagerBase):\n    \"\"\"\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        The FigureCanvas instance\n    num : int or str\n        The Figure number\n    toolbar : qt.QToolBar\n        The qt.QToolBar\n    window : qt.QMainWindow\n        The qt.QMainWindow\n    \"\"\"\n\n    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n        self.window = MainWindow()\n        self.window.closing.connect(canvas.close_event)\n        self.window.closing.connect(self._widgetclosed)\n\n        self.window.setWindowTitle(\"Figure %d\" % num)\n        image = str(cbook._get_data_path('images/matplotlib.svg'))\n        self.window.setWindowIcon(QtGui.QIcon(image))\n\n        # Give the keyboard focus to the figure instead of the manager:\n        # StrongFocus accepts both tab and click to focus and will enable the\n        # canvas to process event without clicking.\n        # https://doc.qt.io/qt-5/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.canvas.setFocus()\n\n        self.window._destroying = False\n\n        self.toolbar = self._get_toolbar(self.canvas, self.window)\n\n        if self.toolmanager:\n            backend_tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                backend_tools.add_tools_to_container(self.toolbar)\n\n        if self.toolbar:\n            self.window.addToolBar(self.toolbar)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        cs_height = cs.height()\n        height = cs_height + tbs_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if matplotlib.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        self.window.raise_()\n\n    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()\n\n    def _widgetclosed(self):\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        try:\n            Gcf.destroy(self)\n        except AttributeError:\n            pass\n            # It seems that when the python session is killed,\n            # Gcf can get destroyed before the Gcf.destroy\n            # line is run, leading to a useless AttributeError.\n\n    def _get_toolbar(self, canvas, parent):\n        # must be inited after the window, drawingArea and figure\n        # attrs are set\n        if matplotlib.rcParams['toolbar'] == 'toolbar2':\n            toolbar = NavigationToolbar2QT(canvas, parent, True)\n        elif matplotlib.rcParams['toolbar'] == 'toolmanager':\n            toolbar = ToolbarQt(self.toolmanager, self.window)\n        else:\n            toolbar = None\n        return toolbar\n\n    def resize(self, width, height):\n        # these are Qt methods so they return sizes in 'virtual' pixels\n        # so we do not need to worry about dpi scaling here.\n        extra_width = self.window.width() - self.canvas.width()\n        extra_height = self.window.height() - self.canvas.height()\n        self.canvas.resize(width, height)\n        self.window.resize(width + extra_width, height + extra_height)\n\n    def show(self):\n        self.window.show()\n        if matplotlib.rcParams['figure.raise_window']:\n            self.window.activateWindow()\n            self.window.raise_()\n\n    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        if self.toolbar:\n            self.toolbar.destroy()\n        self.window.close()\n\n    def get_window_title(self):\n        return self.window.windowTitle()\n\n    def set_window_title(self, title):\n        self.window.setWindowTitle(title)",
      "instance_attributes": [
        {
          "name": "window",
          "types": {
            "kind": "NamedType",
            "name": "MainWindow"
          }
        },
        {
          "name": "toolbar",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "ToolbarQt"
              },
              {
                "kind": "NamedType",
                "name": "NavigationToolbar2QT"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/HelpQt",
      "name": "HelpQt",
      "qname": "lib.matplotlib.backends.backend_qt5.HelpQt",
      "decorators": [],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/HelpQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpQt(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/MainWindow",
      "name": "MainWindow",
      "qname": "lib.matplotlib.backends.backend_qt5.MainWindow",
      "decorators": [],
      "superclasses": [
        "QtWidgets.QMainWindow"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/MainWindow/closeEvent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class MainWindow(QtWidgets.QMainWindow):\n    closing = QtCore.Signal()\n\n    def closeEvent(self, event):\n        self.closing.emit()\n        QtWidgets.QMainWindow.closeEvent(self, event)",
      "instance_attributes": [
        {
          "name": "_destroying",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT",
      "name": "NavigationToolbar2QT",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "QtWidgets.QToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@getter",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@setter",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/basedir@getter",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/_icon",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/edit_parameters",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/_update_buttons_checked",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/pan",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/zoom",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_message",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/remove_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2QT(NavigationToolbar2, QtWidgets.QToolBar):\n    message = QtCore.Signal(str)\n\n    toolitems = [*NavigationToolbar2.toolitems]\n    toolitems.insert(\n        # Add 'customize' action after 'subplots'\n        [name for name, *_ in toolitems].index(\"Subplots\") + 1,\n        (\"Customize\", \"Edit axis, curve and image parameters\",\n         \"qt4_editor_options\", \"edit_parameters\"))\n\n    def __init__(self, canvas, parent, coordinates=True):\n        \"\"\"coordinates: should we show the coordinates on the right?\"\"\"\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(\n            QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)\n\n        self.coordinates = coordinates\n        self._actions = {}  # mapping of toolitem method names to QActions.\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                   text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        # Add the (x, y) location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(\n                QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n            self.locLabel.setSizePolicy(\n                QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                      QtWidgets.QSizePolicy.Ignored))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        NavigationToolbar2.__init__(self, canvas)\n\n    @cbook.deprecated(\"3.3\", alternative=\"self.canvas.parent()\")\n    @property\n    def parent(self):\n        return self.canvas.parent()\n\n    @cbook.deprecated(\"3.3\", alternative=\"self.canvas.setParent()\")\n    @parent.setter\n    def parent(self, value):\n        pass\n\n    @cbook.deprecated(\n        \"3.3\", alternative=\"os.path.join(mpl.get_data_path(), 'images')\")\n    @property\n    def basedir(self):\n        return str(cbook._get_data_path('images'))\n\n    def _icon(self, name):\n        \"\"\"\n        Construct a `.QIcon` from an image file *name*, including the extension\n        and relative to Matplotlib's \"images\" data directory.\n        \"\"\"\n        if QtCore.qVersion() >= '5.':\n            name = name.replace('.png', '_large.png')\n        pm = QtGui.QPixmap(str(cbook._get_data_path('images', name)))\n        _setDevicePixelRatioF(pm, _devicePixelRatioF(self))\n        if self.palette().color(self.backgroundRole()).value() < 128:\n            icon_color = self.palette().color(self.foregroundRole())\n            mask = pm.createMaskFromColor(QtGui.QColor('black'),\n                                          QtCore.Qt.MaskOutColor)\n            pm.fill(icon_color)\n            pm.setMask(mask)\n        return QtGui.QIcon(pm)\n\n    def edit_parameters(self):\n        axes = self.canvas.figure.get_axes()\n        if not axes:\n            QtWidgets.QMessageBox.warning(\n                self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\n            return\n        elif len(axes) == 1:\n            ax, = axes\n        else:\n            titles = [\n                ax.get_label() or\n                ax.get_title() or\n                \" - \".join(filter(None, [ax.get_xlabel(), ax.get_ylabel()])) or\n                f\"<anonymous {type(ax).__name__}>\"\n                for ax in axes]\n            duplicate_titles = [\n                title for title in titles if titles.count(title) > 1]\n            for i, ax in enumerate(axes):\n                if titles[i] in duplicate_titles:\n                    titles[i] += f\" (id: {id(ax):#x})\"  # Deduplicate titles.\n            item, ok = QtWidgets.QInputDialog.getItem(\n                self.canvas.parent(),\n                'Customize', 'Select axes:', titles, 0, False)\n            if not ok:\n                return\n            ax = axes[titles.index(item)]\n        figureoptions.figure_edit(ax, self)\n\n    def _update_buttons_checked(self):\n        # sync button checkstates to match active mode\n        if 'pan' in self._actions:\n            self._actions['pan'].setChecked(self.mode.name == 'PAN')\n        if 'zoom' in self._actions:\n            self._actions['zoom'].setChecked(self.mode.name == 'ZOOM')\n\n    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()\n\n    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()\n\n    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)\n\n    def set_cursor(self, cursor):\n        self.canvas.setCursor(cursord[cursor])\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas.drawRectangle(rect)\n\n    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)\n\n    def configure_subplots(self):\n        image = str(cbook._get_data_path('images/matplotlib.png'))\n        dia = SubplotToolQt(self.canvas.figure, self.canvas.parent())\n        dia.setWindowIcon(QtGui.QIcon(image))\n        dia.exec_()\n\n    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = sorted(filetypes.items())\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = os.path.expanduser(\n            matplotlib.rcParams['savefig.directory'])\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = qt_compat._getSaveFileName(\n            self.canvas.parent(), \"Choose a filename to save to\", start,\n            filters, selectedFilter)\n        if fname:\n            # Save dir for next time, unless empty str (i.e., use cwd).\n            if startpath != \"\":\n                matplotlib.rcParams['savefig.directory'] = (\n                    os.path.dirname(fname))\n            try:\n                self.canvas.figure.savefig(fname)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", str(e),\n                    QtWidgets.QMessageBox.Ok, QtWidgets.QMessageBox.NoButton)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'back' in self._actions:\n            self._actions['back'].setEnabled(can_backward)\n        if 'forward' in self._actions:\n            self._actions['forward'].setEnabled(can_forward)",
      "instance_attributes": [
        {
          "name": "coordinates",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_actions",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "locLabel",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt",
      "name": "RubberbandQt",
      "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt",
      "decorators": [],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RubberbandQt(backend_tools.RubberbandBase):\n    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)\n\n    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SaveFigureQt",
      "name": "SaveFigureQt",
      "qname": "lib.matplotlib.backends.backend_qt5.SaveFigureQt",
      "decorators": [],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/SaveFigureQt/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureQt(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SetCursorQt",
      "name": "SetCursorQt",
      "qname": "lib.matplotlib.backends.backend_qt5.SetCursorQt",
      "decorators": [],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/SetCursorQt/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorQt(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2QT.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt",
      "name": "StatusbarQt",
      "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "superclasses": [
        "StatusbarBase",
        "QtWidgets.QLabel"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StatusbarQt(StatusbarBase, QtWidgets.QLabel):\n    def __init__(self, window, *args, **kwargs):\n        StatusbarBase.__init__(self, *args, **kwargs)\n        QtWidgets.QLabel.__init__(self)\n        window.statusBar().addWidget(self)\n\n    def set_message(self, s):\n        self.setText(s)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt",
      "name": "SubplotToolQt",
      "qname": "lib.matplotlib.backends.backend_qt5.SubplotToolQt",
      "decorators": [],
      "superclasses": [
        "UiSubplotTool"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/_export_values",
        "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/_on_value_changed",
        "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/_tight_layout",
        "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/_reset"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SubplotToolQt(UiSubplotTool):\n    def __init__(self, targetfig, parent):\n        UiSubplotTool.__init__(self, None)\n\n        self._figure = targetfig\n\n        for lower, higher in [(\"bottom\", \"top\"), (\"left\", \"right\")]:\n            self._widgets[lower].valueChanged.connect(\n                lambda val: self._widgets[higher].setMinimum(val + .001))\n            self._widgets[higher].valueChanged.connect(\n                lambda val: self._widgets[lower].setMaximum(val - .001))\n\n        self._attrs = [\"top\", \"bottom\", \"left\", \"right\", \"hspace\", \"wspace\"]\n        self._defaults = {attr: vars(self._figure.subplotpars)[attr]\n                          for attr in self._attrs}\n\n        # Set values after setting the range callbacks, but before setting up\n        # the redraw callbacks.\n        self._reset()\n\n        for attr in self._attrs:\n            self._widgets[attr].valueChanged.connect(self._on_value_changed)\n        for action, method in [(\"Export values\", self._export_values),\n                               (\"Tight layout\", self._tight_layout),\n                               (\"Reset\", self._reset),\n                               (\"Close\", self.close)]:\n            self._widgets[action].clicked.connect(method)\n\n    def _export_values(self):\n        # Explicitly round to 3 decimals (which is also the spinbox precision)\n        # to avoid numbers of the form 0.100...001.\n        dialog = QtWidgets.QDialog()\n        layout = QtWidgets.QVBoxLayout()\n        dialog.setLayout(layout)\n        text = QtWidgets.QPlainTextEdit()\n        text.setReadOnly(True)\n        layout.addWidget(text)\n        text.setPlainText(\n            \",\\n\".join(\"{}={:.3}\".format(attr, self._widgets[attr].value())\n                       for attr in self._attrs))\n        # Adjust the height of the text widget to fit the whole text, plus\n        # some padding.\n        size = text.maximumSize()\n        size.setHeight(\n            QtGui.QFontMetrics(text.document().defaultFont())\n            .size(0, text.toPlainText()).height() + 20)\n        text.setMaximumSize(size)\n        dialog.exec_()\n\n    def _on_value_changed(self):\n        self._figure.subplots_adjust(**{attr: self._widgets[attr].value()\n                                        for attr in self._attrs})\n        self._figure.canvas.draw_idle()\n\n    def _tight_layout(self):\n        self._figure.tight_layout()\n        for attr in self._attrs:\n            widget = self._widgets[attr]\n            widget.blockSignals(True)\n            widget.setValue(vars(self._figure.subplotpars)[attr])\n            widget.blockSignals(False)\n        self._figure.canvas.draw_idle()\n\n    def _reset(self):\n        for attr, value in self._defaults.items():\n            self._widgets[attr].setValue(value)",
      "instance_attributes": [
        {
          "name": "_figure",
          "types": null
        },
        {
          "name": "_attrs",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "_defaults",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT",
      "name": "TimerQT",
      "qname": "lib.matplotlib.backends.backend_qt5.TimerQT",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__del__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/_timer_set_single_shot",
        "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/_timer_set_interval",
        "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/_timer_stop"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using QTimer events.",
      "docstring": "Subclass of `.TimerBase` using QTimer events.",
      "code": "class TimerQT(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using QTimer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        TimerBase.__init__(self, *args, **kwargs)\n\n    def __del__(self):\n        # The check for deletedness is needed to avoid an error at animation\n        # shutdown with PySide2.\n        if not _isdeleted(self._timer):\n            self._timer_stop()\n\n    def _timer_set_single_shot(self):\n        self._timer.setSingleShot(self._single)\n\n    def _timer_set_interval(self):\n        self._timer.setInterval(self._interval)\n\n    def _timer_start(self):\n        self._timer.start()\n\n    def _timer_stop(self):\n        self._timer.stop()",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolCopyToClipboardQT",
      "name": "ToolCopyToClipboardQT",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolCopyToClipboardQT",
      "decorators": [],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolCopyToClipboardQT/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardQT(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        qApp.clipboard().setPixmap(pixmap)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt",
      "name": "ToolbarQt",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "QtWidgets.QToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/_add_to_group",
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarQt(ToolContainerBase, QtWidgets.QToolBar):\n    def __init__(self, toolmanager, parent):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(\n            QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(\n            QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        message_label.setSizePolicy(\n            QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                  QtWidgets.QSizePolicy.Ignored))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}\n\n    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))\n\n    def _add_to_group(self, group, name, button, position):\n        gr = self._groups.get(group, [])\n        if not gr:\n            sep = self.insertSeparator(self._message_action)\n            gr.append(sep)\n        before = gr[position]\n        widget = self.insertWidget(before, button)\n        gr.insert(position, widget)\n        self._groups[group] = gr\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)\n\n    def remove_toolitem(self, name):\n        for button, handler in self._toolitems[name]:\n            button.setParent(None)\n        del self._toolitems[name]\n\n    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)",
      "instance_attributes": [
        {
          "name": "_message_action",
          "types": null
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg",
      "name": "FigureCanvasQTAgg",
      "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "FigureCanvasQT"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/paintEvent",
        "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/print_figure"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQTAgg(FigureCanvasAgg, FigureCanvasQT):\n\n    def __init__(self, figure):\n        # Must pass 'figure' as kwarg to Qt base class.\n        super().__init__(figure=figure)\n\n    def paintEvent(self, event):\n        \"\"\"\n        Copy the image from the Agg canvas to the qt.drawable.\n\n        In Qt, all drawing should be done inside of here when a widget is\n        shown onscreen.\n        \"\"\"\n        if self._update_dpi():\n            # The dpi update triggered its own paintEvent.\n            return\n        self._draw_idle()  # Only does something if a draw is pending.\n\n        # If the canvas does not have a renderer, then give up and wait for\n        # FigureCanvasAgg.draw(self) to be called.\n        if not hasattr(self, 'renderer'):\n            return\n\n        painter = QtGui.QPainter(self)\n        try:\n            # See documentation of QRect: bottom() and right() are off\n            # by 1, so use left() + width() and top() + height().\n            rect = event.rect()\n            # scale rect dimensions using the screen dpi ratio to get\n            # correct values for the Figure coordinates (rather than\n            # QT5's coords)\n            width = rect.width() * self._dpi_ratio\n            height = rect.height() * self._dpi_ratio\n            left, top = self.mouseEventCoords(rect.topLeft())\n            # shift the \"top\" by the height of the image to get the\n            # correct corner for our coordinate system\n            bottom = top - height\n            # same with the right side of the image\n            right = left + width\n            # create a buffer using the image bounding box\n            bbox = Bbox([[left, bottom], [right, top]])\n            reg = self.copy_from_bbox(bbox)\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                memoryview(reg))\n\n            # clear the widget canvas\n            painter.eraseRect(rect)\n\n            qimage = QtGui.QImage(buf, buf.shape[1], buf.shape[0],\n                                  QtGui.QImage.Format_ARGB32_Premultiplied)\n            _setDevicePixelRatioF(qimage, self._dpi_ratio)\n            # set origin using original QT coordinates\n            origin = QtCore.QPoint(rect.left(), rect.top())\n            painter.drawImage(origin, qimage)\n            # Adjust the buf reference count to work around a memory\n            # leak bug in QImage under PySide on Python 3.\n            if QT_API in ('PySide', 'PySide2'):\n                ctypes.c_long.from_address(id(buf)).value = 1\n\n            self._draw_rect_callback(painter)\n        finally:\n            painter.end()\n\n    def print_figure(self, *args, **kwargs):\n        super().print_figure(*args, **kwargs)\n        self.draw()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo",
      "name": "FigureCanvasQTCairo",
      "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasQT",
        "FigureCanvasCairo"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/draw",
        "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/paintEvent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasQTCairo(FigureCanvasQT, FigureCanvasCairo):\n    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._renderer = RendererCairo(self.figure.dpi)\n        self._renderer.set_width_height(-1, -1)  # Invalid values.\n\n    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self.figure.draw(self._renderer)\n        super().draw()\n\n    def paintEvent(self, event):\n        self._update_dpi()\n        dpi_ratio = self._dpi_ratio\n        width = int(dpi_ratio * self.width())\n        height = int(dpi_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_ctx_from_surface(surface)\n            self._renderer.set_width_height(width, height)\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        qimage = QtGui.QImage(buf, width, height,\n                              QtGui.QImage.Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide on Python 3.\n        if QT_API == 'PySide':\n            ctypes.c_long.from_address(id(buf)).value = 1\n        _setDevicePixelRatioF(qimage, dpi_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()",
      "instance_attributes": [
        {
          "name": "_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererCairo"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG",
      "name": "FigureCanvasSVG",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/_print_svg",
        "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasSVG(FigureCanvasBase):\n    filetypes = {'svg': 'Scalable Vector Graphics',\n                 'svgz': 'Scalable Vector Graphics'}\n\n    fixed_dpi = 72\n\n    def print_svg(self, filename, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n        metadata : Dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n\n            filename = getattr(fh, 'name', '')\n            if not isinstance(filename, str):\n                filename = ''\n\n            if cbook.file_requires_unicode(fh):\n                detach = False\n            else:\n                fh = TextIOWrapper(fh, 'utf-8')\n                detach = True\n\n            self._print_svg(filename, fh, **kwargs)\n\n            # Detach underlying stream from wrapper so that it remains open in\n            # the caller.\n            if detach:\n                fh.detach()\n\n    def print_svgz(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter)\n\n    @_check_savefig_extra_args\n    def _print_svg(self, filename, fh, *, dpi=72, bbox_inches_restore=None,\n                   metadata=None):\n        self.figure.set_dpi(72.0)\n        width, height = self.figure.get_size_inches()\n        w, h = width * 72, height * 72\n\n        renderer = MixedModeRenderer(\n            self.figure, width, height, dpi,\n            RendererSVG(w, h, fh, filename, dpi, metadata=metadata),\n            bbox_inches_restore=bbox_inches_restore)\n\n        self.figure.draw(renderer)\n        renderer.finalize()\n\n    def get_default_filetype(self):\n        return 'svg'",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG",
      "name": "RendererSVG",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_metadata",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_default_style",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_make_id",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_make_flip_transform",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_font",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_hatch",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_hatches",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_style_dict",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_style",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_get_clip",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_write_clips",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_convert_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_update_glyph_map_defs",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_adjust_char_id",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_draw_text_as_path",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/_draw_text_as_text",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class RendererSVG(RendererBase):\n    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        self._groupd = {}\n        self.basename = basename\n        self._image_counter = itertools.count()\n        self._clipd = OrderedDict()\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = OrderedDict()\n        self._has_gouraud = False\n        self._n_gradients = 0\n        self._fonts = OrderedDict()\n        self.mathtext_parser = MathTextParser('SVG')\n\n        RendererBase.__init__(self)\n        self._glyph_map = dict()\n        str_height = short_float_fmt(height)\n        str_width = short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()\n\n    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()\n\n    def _write_metadata(self, metadata):\n        # Add metadata following the Dublin Core Metadata Initiative, and the\n        # Creative Commons Rights Expression Language. This is mainly for\n        # compatibility with Inkscape.\n        if metadata is None:\n            metadata = {}\n        metadata = {\n            'Format': 'image/svg+xml',\n            'Type': 'http://purl.org/dc/dcmitype/StillImage',\n            'Creator':\n                f'Matplotlib v{mpl.__version__}, https://matplotlib.org/',\n            **metadata\n        }\n        writer = self.writer\n\n        if 'Title' in metadata:\n            writer.element('title', text=metadata['Title'])\n\n        # Special handling.\n        date = metadata.get('Date', None)\n        if date is not None:\n            if isinstance(date, str):\n                dates = [date]\n            elif isinstance(date, (datetime.datetime, datetime.date)):\n                dates = [date.isoformat()]\n            elif np.iterable(date):\n                dates = []\n                for d in date:\n                    if isinstance(d, str):\n                        dates.append(d)\n                    elif isinstance(d, (datetime.datetime, datetime.date)):\n                        dates.append(d.isoformat())\n                    else:\n                        raise ValueError(\n                            'Invalid type for Date metadata. '\n                            'Expected iterable of str, date, or datetime, '\n                            'not {!r}.'.format(type(d)))\n            else:\n                raise ValueError('Invalid type for Date metadata. '\n                                 'Expected str, date, datetime, or iterable '\n                                 'of the same, not {!r}.'.format(type(date)))\n            metadata['Date'] = '/'.join(dates)\n        elif 'Date' not in metadata:\n            # Do not add `Date` if the user explicitly set `Date` to `None`\n            # Get source date from SOURCE_DATE_EPOCH, if set.\n            # See https://reproducible-builds.org/specs/source-date-epoch/\n            date = os.getenv(\"SOURCE_DATE_EPOCH\")\n            if date:\n                date = datetime.datetime.utcfromtimestamp(int(date))\n                metadata['Date'] = date.replace(tzinfo=UTC).isoformat()\n            else:\n                metadata['Date'] = datetime.datetime.today().isoformat()\n\n        mid = None\n        def ensure_metadata(mid):\n            if mid is not None:\n                return mid\n            mid = writer.start('metadata')\n            writer.start('rdf:RDF', attrib={\n                'xmlns:dc': \"http://purl.org/dc/elements/1.1/\",\n                'xmlns:cc': \"http://creativecommons.org/ns#\",\n                'xmlns:rdf': \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n            })\n            writer.start('cc:Work')\n            return mid\n\n        uri = metadata.pop('Type', None)\n        if uri is not None:\n            mid = ensure_metadata(mid)\n            writer.element('dc:type', attrib={'rdf:resource': uri})\n\n        # Single value only.\n        for key in ['title', 'coverage', 'date', 'description', 'format',\n                    'identifier', 'language', 'relation', 'source']:\n            info = metadata.pop(key.title(), None)\n            if info is not None:\n                mid = ensure_metadata(mid)\n                writer.element(f'dc:{key}', text=info)\n\n        # Multiple Agent values.\n        for key in ['creator', 'contributor', 'publisher', 'rights']:\n            agents = metadata.pop(key.title(), None)\n            if agents is None:\n                continue\n\n            if isinstance(agents, str):\n                agents = [agents]\n\n            mid = ensure_metadata(mid)\n            writer.start(f'dc:{key}')\n            for agent in agents:\n                writer.start('cc:Agent')\n                writer.element('dc:title', text=agent)\n                writer.end('cc:Agent')\n            writer.end(f'dc:{key}')\n\n        # Multiple values.\n        keywords = metadata.pop('Keywords', None)\n        if keywords is not None:\n            if isinstance(keywords, str):\n                keywords = [keywords]\n\n            mid = ensure_metadata(mid)\n            writer.start('dc:subject')\n            writer.start('rdf:Bag')\n            for keyword in keywords:\n                writer.element('rdf:li', text=keyword)\n            writer.end('rdf:Bag')\n            writer.end('dc:subject')\n\n        if mid is not None:\n            writer.close(mid)\n\n        if metadata:\n            raise ValueError('Unknown metadata key(s) passed to SVG writer: ' +\n                             ','.join(metadata))\n\n    def _write_default_style(self):\n        writer = self.writer\n        default_style = generate_css({\n            'stroke-linejoin': 'round',\n            'stroke-linecap': 'butt'})\n        writer.start('defs')\n        writer.element('style', type='text/css', text='*{%s}' % default_style)\n        writer.end('defs')\n\n    def _make_id(self, type, content):\n        salt = mpl.rcParams['svg.hashsalt']\n        if salt is None:\n            salt = str(uuid.uuid4())\n        m = hashlib.md5()\n        m.update(salt.encode('utf8'))\n        m.update(str(content).encode('utf8'))\n        return '%s%s' % (type, m.hexdigest()[:10])\n\n    def _make_flip_transform(self, transform):\n        return (transform +\n                Affine2D()\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n    def _get_font(self, prop):\n        fname = findfont(prop)\n        font = get_font(fname)\n        font.clear()\n        size = prop.get_size_in_points()\n        font.set_size(size, 72.0)\n        return font\n\n    def _get_hatch(self, gc, rgbFace):\n        \"\"\"\n        Create a new hatch pattern\n        \"\"\"\n        if rgbFace is not None:\n            rgbFace = tuple(rgbFace)\n        edge = gc.get_hatch_color()\n        if edge is not None:\n            edge = tuple(edge)\n        dictkey = (gc.get_hatch(), rgbFace, edge)\n        oid = self._hatchd.get(dictkey)\n        if oid is None:\n            oid = self._make_id('h', dictkey)\n            self._hatchd[dictkey] = ((gc.get_hatch_path(), rgbFace, edge), oid)\n        else:\n            _, oid = oid\n        return oid\n\n    def _write_hatches(self):\n        if not len(self._hatchd):\n            return\n        HATCH_SIZE = 72\n        writer = self.writer\n        writer.start('defs')\n        for (path, face, stroke), oid in self._hatchd.values():\n            writer.start(\n                'pattern',\n                id=oid,\n                patternUnits=\"userSpaceOnUse\",\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE),\n                height=str(HATCH_SIZE))\n            path_data = self._convert_path(\n                path,\n                Affine2D()\n                .scale(HATCH_SIZE).scale(1.0, -1.0).translate(0, HATCH_SIZE),\n                simplify=False)\n            if face is None:\n                fill = 'none'\n            else:\n                fill = rgb2hex(face)\n            writer.element(\n                'rect',\n                x=\"0\", y=\"0\", width=str(HATCH_SIZE+1),\n                height=str(HATCH_SIZE+1),\n                fill=fill)\n            hatch_style = {\n                    'fill': rgb2hex(stroke),\n                    'stroke': rgb2hex(stroke),\n                    'stroke-width': str(mpl.rcParams['hatch.linewidth']),\n                    'stroke-linecap': 'butt',\n                    'stroke-linejoin': 'miter'\n                    }\n            if stroke[3] < 1:\n                hatch_style['stroke-opacity'] = str(stroke[3])\n            writer.element(\n                'path',\n                d=path_data,\n                style=generate_css(hatch_style)\n                )\n            writer.end('pattern')\n        writer.end('defs')\n\n    def _get_style_dict(self, gc, rgbFace):\n        \"\"\"Generate a style string from the GraphicsContext and rgbFace.\"\"\"\n        attrib = {}\n\n        forced_alpha = gc.get_forced_alpha()\n\n        if gc.get_hatch() is not None:\n            attrib['fill'] = \"url(#%s)\" % self._get_hatch(gc, rgbFace)\n            if (rgbFace is not None and len(rgbFace) == 4 and rgbFace[3] != 1.0\n                    and not forced_alpha):\n                attrib['fill-opacity'] = short_float_fmt(rgbFace[3])\n        else:\n            if rgbFace is None:\n                attrib['fill'] = 'none'\n            else:\n                if tuple(rgbFace[:3]) != (0, 0, 0):\n                    attrib['fill'] = rgb2hex(rgbFace)\n                if (len(rgbFace) == 4 and rgbFace[3] != 1.0\n                        and not forced_alpha):\n                    attrib['fill-opacity'] = short_float_fmt(rgbFace[3])\n\n        if forced_alpha and gc.get_alpha() != 1.0:\n            attrib['opacity'] = short_float_fmt(gc.get_alpha())\n\n        offset, seq = gc.get_dashes()\n        if seq is not None:\n            attrib['stroke-dasharray'] = ','.join(\n                short_float_fmt(val) for val in seq)\n            attrib['stroke-dashoffset'] = short_float_fmt(float(offset))\n\n        linewidth = gc.get_linewidth()\n        if linewidth:\n            rgb = gc.get_rgb()\n            attrib['stroke'] = rgb2hex(rgb)\n            if not forced_alpha and rgb[3] != 1.0:\n                attrib['stroke-opacity'] = short_float_fmt(rgb[3])\n            if linewidth != 1.0:\n                attrib['stroke-width'] = short_float_fmt(linewidth)\n            if gc.get_joinstyle() != 'round':\n                attrib['stroke-linejoin'] = gc.get_joinstyle()\n            if gc.get_capstyle() != 'butt':\n                attrib['stroke-linecap'] = _capstyle_d[gc.get_capstyle()]\n\n        return attrib\n\n    def _get_style(self, gc, rgbFace):\n        return generate_css(self._get_style_dict(gc, rgbFace))\n\n    def _get_clip(self, gc):\n        cliprect = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n        if clippath is not None:\n            clippath_trans = self._make_flip_transform(clippath_trans)\n            dictkey = (id(clippath), str(clippath_trans))\n        elif cliprect is not None:\n            x, y, w, h = cliprect.bounds\n            y = self.height-(y+h)\n            dictkey = (x, y, w, h)\n        else:\n            return None\n\n        clip = self._clipd.get(dictkey)\n        if clip is None:\n            oid = self._make_id('p', dictkey)\n            if clippath is not None:\n                self._clipd[dictkey] = ((clippath, clippath_trans), oid)\n            else:\n                self._clipd[dictkey] = (dictkey, oid)\n        else:\n            clip, oid = clip\n        return oid\n\n    def _write_clips(self):\n        if not len(self._clipd):\n            return\n        writer = self.writer\n        writer.start('defs')\n        for clip, oid in self._clipd.values():\n            writer.start('clipPath', id=oid)\n            if len(clip) == 2:\n                clippath, clippath_trans = clip\n                path_data = self._convert_path(\n                    clippath, clippath_trans, simplify=False)\n                writer.element('path', d=path_data)\n            else:\n                x, y, w, h = clip\n                writer.element(\n                    'rect',\n                    x=short_float_fmt(x),\n                    y=short_float_fmt(y),\n                    width=short_float_fmt(w),\n                    height=short_float_fmt(h))\n            writer.end('clipPath')\n        writer.end('defs')\n\n    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))\n\n    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')\n\n    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']\n\n    def _convert_path(self, path, transform=None, clip=None, simplify=None,\n                      sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width, self.height)\n        else:\n            clip = None\n        return _path.convert_to_string(\n            path, transform, clip, simplify, sketch, 6,\n            [b'M', b'L', b'Q', b'C', b'z'], False).decode('ascii')\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        attrib = {}\n        attrib['style'] = self._get_style(gc, rgbFace)\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, attrib=attrib)\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n        writer.start('g', attrib=attrib)\n\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = short_float_fmt(x)\n                attrib['y'] = short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')\n\n    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            clipid = self._get_clip(gc0)\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            if clipid is not None:\n                writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': short_float_fmt(xo),\n                'y': short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clipid is not None:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1\n\n    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # docstring inherited\n\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0' +\n                       ' \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            # Skip fully-transparent triangles\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                gradientUnits=\"userSpaceOnUse\",\n                x1=short_float_fmt(x1), y1=short_float_fmt(y1),\n                x2=short_float_fmt(xb), y2=short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        # triangle formation using \"path\"\n        dpath = \"M \" + short_float_fmt(x1)+',' + short_float_fmt(y1)\n        dpath += \" L \" + short_float_fmt(x2) + ',' + short_float_fmt(y2)\n        dpath += \" \" + short_float_fmt(x3) + ',' + short_float_fmt(y3) + \" Z\"\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_0)' % self._n_gradients,\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_1)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_2)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1\n\n    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n\n        self.writer.start('g', attrib=attrib)\n\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n\n        self.writer.end('g')\n\n    def option_scale_image(self):\n        # docstring inherited\n        return True\n\n    def get_image_magnification(self):\n        return self.image_dpi / 72.0\n\n    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Can't apply clip-path directly to the image because the\n            # image has a transformation, which would also be applied\n            # to the clip-path\n            self.writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        oid = gc.get_gid()\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=short_float_fmt(x),\n                y=short_float_fmt(-(self.height - y - h)),\n                width=short_float_fmt(w), height=short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=short_float_fmt(w), height=short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clipid is not None:\n            self.writer.end('g')\n\n    def _update_glyph_map_defs(self, glyph_map_new):\n        \"\"\"\n        Emit definitions for not-yet-defined glyphs, and record them as having\n        been defined.\n        \"\"\"\n        writer = self.writer\n        if glyph_map_new:\n            writer.start('defs')\n            for char_id, (vertices, codes) in glyph_map_new.items():\n                char_id = self._adjust_char_id(char_id)\n                path_data = self._convert_path(\n                    Path(vertices, codes), simplify=False)\n                writer.element('path', id=char_id, d=path_data)\n            writer.end('defs')\n            self._glyph_map.update(glyph_map_new)\n\n    def _adjust_char_id(self, char_id):\n        return char_id.replace(\"%20\", \"_\")\n\n    def _draw_text_as_path(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        \"\"\"\n        Draw the text by converting them to paths using the textpath module.\n\n        Parameters\n        ----------\n        s : str\n          text to be converted\n        prop : `matplotlib.font_manager.FontProperties`\n          font property\n        ismath : bool\n          If True, use mathtext parser. If \"TeX\", use *usetex* mode.\n        \"\"\"\n        writer = self.writer\n\n        writer.comment(s)\n\n        glyph_map = self._glyph_map\n\n        text2path = self._text2path\n        color = rgb2hex(gc.get_rgb())\n        fontsize = prop.get_size_in_points()\n\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = short_float_fmt(alpha)\n        font_scale = fontsize / text2path.FONT_SCALE\n        attrib = {\n            'style': generate_css(style),\n            'transform': generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,)),\n                ('scale', (font_scale, -font_scale))]),\n        }\n        writer.start('g', attrib=attrib)\n\n        if not ismath:\n            font = text2path._get_font(prop)\n            _glyphs = text2path.get_glyphs_with_font(\n                font, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for glyph_id, xposition, yposition, scale in glyph_info:\n                attrib = {'xlink:href': '#%s' % glyph_id}\n                if xposition != 0.0:\n                    attrib['x'] = short_float_fmt(xposition)\n                if yposition != 0.0:\n                    attrib['y'] = short_float_fmt(yposition)\n                writer.element('use', attrib=attrib)\n\n        else:\n            if ismath == \"TeX\":\n                _glyphs = text2path.get_glyphs_tex(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            else:\n                _glyphs = text2path.get_glyphs_mathtext(\n                    prop, s, glyph_map=glyph_map, return_new_glyphs_only=True)\n            glyph_info, glyph_map_new, rects = _glyphs\n            self._update_glyph_map_defs(glyph_map_new)\n\n            for char_id, xposition, yposition, scale in glyph_info:\n                char_id = self._adjust_char_id(char_id)\n                writer.element(\n                    'use',\n                    transform=generate_transform([\n                        ('translate', (xposition, yposition)),\n                        ('scale', (scale,)),\n                        ]),\n                    attrib={'xlink:href': '#%s' % char_id})\n\n            for verts, codes in rects:\n                path = Path(verts, codes)\n                path_data = self._convert_path(path, simplify=False)\n                writer.element('path', d=path_data)\n\n        writer.end('g')\n\n    def _draw_text_as_text(self, gc, x, y, s, prop, angle, ismath, mtext=None):\n        writer = self.writer\n\n        color = rgb2hex(gc.get_rgb())\n        style = {}\n        if color != '#000000':\n            style['fill'] = color\n\n        alpha = gc.get_alpha() if gc.get_forced_alpha() else gc.get_rgb()[3]\n        if alpha != 1:\n            style['opacity'] = short_float_fmt(alpha)\n\n        if not ismath:\n            font = self._get_font(prop)\n            font.set_text(s, 0.0, flags=LOAD_NO_HINTING)\n\n            attrib = {}\n            style['font-family'] = str(font.family_name)\n            style['font-weight'] = str(prop.get_weight()).lower()\n            style['font-stretch'] = str(prop.get_stretch()).lower()\n            style['font-style'] = prop.get_style().lower()\n            # Must add \"px\" to workaround a Firefox bug\n            style['font-size'] = short_float_fmt(prop.get_size()) + 'px'\n            attrib['style'] = generate_css(style)\n\n            if mtext and (angle == 0 or mtext.get_rotation_mode() == \"anchor\"):\n                # If text anchoring can be supported, get the original\n                # coordinates and add alignment information.\n\n                # Get anchor coordinates.\n                transform = mtext.get_transform()\n                ax, ay = transform.transform(mtext.get_unitless_position())\n                ay = self.height - ay\n\n                # Don't do vertical anchor alignment. Most applications do not\n                # support 'alignment-baseline' yet. Apply the vertical layout\n                # to the anchor point manually for now.\n                angle_rad = np.deg2rad(angle)\n                dir_vert = np.array([np.sin(angle_rad), np.cos(angle_rad)])\n                v_offset = np.dot(dir_vert, [(x - ax), (y - ay)])\n                ax = ax + v_offset * dir_vert[0]\n                ay = ay + v_offset * dir_vert[1]\n\n                ha_mpl_to_svg = {'left': 'start', 'right': 'end',\n                                 'center': 'middle'}\n                style['text-anchor'] = ha_mpl_to_svg[mtext.get_ha()]\n\n                attrib['x'] = short_float_fmt(ax)\n                attrib['y'] = short_float_fmt(ay)\n                attrib['style'] = generate_css(style)\n                attrib['transform'] = \"rotate(%s, %s, %s)\" % (\n                    short_float_fmt(-angle),\n                    short_float_fmt(ax),\n                    short_float_fmt(ay))\n                writer.element('text', s, attrib=attrib)\n            else:\n                attrib['transform'] = generate_transform([\n                    ('translate', (x, y)),\n                    ('rotate', (-angle,))])\n\n                writer.element('text', s, attrib=attrib)\n\n        else:\n            writer.comment(s)\n\n            width, height, descent, svg_elements, used_characters = \\\n                self.mathtext_parser.parse(s, 72, prop)\n            svg_glyphs = svg_elements.svg_glyphs\n            svg_rects = svg_elements.svg_rects\n\n            attrib = {}\n            attrib['style'] = generate_css(style)\n            attrib['transform'] = generate_transform([\n                ('translate', (x, y)),\n                ('rotate', (-angle,))])\n\n            # Apply attributes to 'g', not 'text', because we likely have some\n            # rectangles as well with the same style and transformation.\n            writer.start('g', attrib=attrib)\n\n            writer.start('text')\n\n            # Sort the characters by font, and output one tspan for each.\n            spans = OrderedDict()\n            for font, fontsize, thetext, new_x, new_y, metrics in svg_glyphs:\n                style = generate_css({\n                    'font-size': short_float_fmt(fontsize) + 'px',\n                    'font-family': font.family_name,\n                    'font-style': font.style_name.lower(),\n                    'font-weight': font.style_name.lower()})\n                if thetext == 32:\n                    thetext = 0xa0  # non-breaking space\n                spans.setdefault(style, []).append((new_x, -new_y, thetext))\n\n            for style, chars in spans.items():\n                chars.sort()\n\n                if len({y for x, y, t in chars}) == 1:  # Are all y's the same?\n                    ys = str(chars[0][1])\n                else:\n                    ys = ' '.join(str(c[1]) for c in chars)\n\n                attrib = {\n                    'style': style,\n                    'x': ' '.join(short_float_fmt(c[0]) for c in chars),\n                    'y': ys\n                    }\n\n                writer.element(\n                    'tspan',\n                    ''.join(chr(c[2]) for c in chars),\n                    attrib=attrib)\n\n            writer.end('text')\n\n            if len(svg_rects):\n                for x, y, width, height in svg_rects:\n                    writer.element(\n                        'rect',\n                        x=short_float_fmt(x),\n                        y=short_float_fmt(-y + height),\n                        width=short_float_fmt(width),\n                        height=short_float_fmt(height)\n                        )\n\n            writer.end('g')\n\n    @cbook._delete_parameter(\"3.3\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Cannot apply clip-path directly to the text, because\n            # is has a transformation\n            self.writer.start(\n                'g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clipid is not None:\n            self.writer.end('g')\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)",
      "instance_attributes": [
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "writer",
          "types": {
            "kind": "NamedType",
            "name": "XMLWriter"
          }
        },
        {
          "name": "image_dpi",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_groupd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "basename",
          "types": null
        },
        {
          "name": "_image_counter",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "_clipd",
          "types": {
            "kind": "NamedType",
            "name": "OrderedDict"
          }
        },
        {
          "name": "_markers",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_path_collection_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_hatchd",
          "types": {
            "kind": "NamedType",
            "name": "OrderedDict"
          }
        },
        {
          "name": "_has_gouraud",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_n_gradients",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_fonts",
          "types": {
            "kind": "NamedType",
            "name": "OrderedDict"
          }
        },
        {
          "name": "mathtext_parser",
          "types": null
        },
        {
          "name": "_glyph_map",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_start_id",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter",
      "name": "XMLWriter",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__flush",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element",
        "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nfile : writable text file-like object",
      "code": "class XMLWriter:\n    \"\"\"\n    Parameters\n    ----------\n    file : writable text file-like object\n    \"\"\"\n\n    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0  # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64\n\n    def __flush(self, indent=True):\n        # flush internal buffers\n        if self.__open:\n            if indent:\n                self.__write(\">\\n\")\n            else:\n                self.__write(\">\")\n            self.__open = 0\n        if self.__data:\n            data = ''.join(self.__data)\n            self.__write(escape_cdata(data))\n            self.__data = []\n\n    def start(self, tag, attrib={}, **extra):\n        \"\"\"\n        Open a new element.  Attributes can be given as keyword\n        arguments, or as a string/string dictionary. The method returns\n        an opaque identifier that can be passed to the :meth:`close`\n        method, to close all open elements up to and including this one.\n\n        Parameters\n        ----------\n        tag\n            Element tag.\n        attrib\n            Attribute dictionary.  Alternatively, attributes can be given as\n            keyword arguments.\n\n        Returns\n        -------\n        An element identifier.\n        \"\"\"\n        self.__flush()\n        tag = escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        for k, v in sorted({**attrib, **extra}.items()):\n            if v:\n                k = escape_cdata(k)\n                v = escape_attrib(v)\n                self.__write(' %s=\"%s\"' % (k, v))\n        self.__open = 1\n        return len(self.__tags) - 1\n\n    def comment(self, comment):\n        \"\"\"\n        Add a comment to the output stream.\n\n        Parameters\n        ----------\n        comment : str\n            Comment text.\n        \"\"\"\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % escape_comment(comment))\n\n    def data(self, text):\n        \"\"\"\n        Add character data to the output stream.\n\n        Parameters\n        ----------\n        text : str\n            Character data.\n        \"\"\"\n        self.__data.append(text)\n\n    def end(self, tag=None, indent=True):\n        \"\"\"\n        Close the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n       \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)\n\n    def close(self, id):\n        \"\"\"\n        Close open elements, up to (and including) the element identified\n        by the given identifier.\n\n        Parameters\n        ----------\n        id\n            Element identifier, as returned by the :meth:`start` method.\n        \"\"\"\n        while len(self.__tags) > id:\n            self.end()\n\n    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Add an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)\n\n    def flush(self):\n        \"\"\"Flush the output stream.\"\"\"\n        pass  # replaced by the constructor",
      "instance_attributes": [
        {
          "name": "__write",
          "types": null
        },
        {
          "name": "flush",
          "types": null
        },
        {
          "name": "__open",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "__tags",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "__data",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        },
        {
          "name": "__indentation",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate",
      "name": "FigureCanvasTemplate",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate",
      "decorators": [],
      "superclasses": [
        "FigureCanvasBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw",
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo",
        "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc.\n\nNote: GUI templates will want to connect events for button presses,\nmouse movements and key presses to functions that call the base\nclass methods button_press_event, button_release_event,\nmotion_notify_event, key_press_event, and key_release_event.  See the\nimplementations of the interactive backends for examples.",
      "docstring": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc.\n\nNote: GUI templates will want to connect events for button presses,\nmouse movements and key presses to functions that call the base\nclass methods button_press_event, button_release_event,\nmotion_notify_event, key_press_event, and key_release_event.  See the\nimplementations of the interactive backends for examples.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    A high-level Figure instance",
      "code": "class FigureCanvasTemplate(FigureCanvasBase):\n    \"\"\"\n    The canvas the figure renders into.  Calls the draw and print fig\n    methods, creates the renderers, etc.\n\n    Note: GUI templates will want to connect events for button presses,\n    mouse movements and key presses to functions that call the base\n    class methods button_press_event, button_release_event,\n    motion_notify_event, key_press_event, and key_release_event.  See the\n    implementations of the interactive backends for examples.\n\n    Attributes\n    ----------\n    figure : `matplotlib.figure.Figure`\n        A high-level Figure instance\n    \"\"\"\n\n    def draw(self):\n        \"\"\"Draw the figure using the renderer.\"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)\n\n    # You should provide a print_xxx function for every file format\n    # you can write.\n\n    # If the file type is not in the base set of filetypes,\n    # you should add it to the class-scope filetypes dictionary as follows:\n    filetypes = {**FigureCanvasBase.filetypes, 'foo': 'My magic Foo format'}\n\n    def print_foo(self, filename, *args, **kwargs):\n        \"\"\"\n        Write out format foo.  The dpi, facecolor and edgecolor are restored\n        to their original values after this call, so you don't need to\n        save and restore them.\n        \"\"\"\n        self.draw()\n\n    def get_default_filetype(self):\n        return 'foo'",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureManagerTemplate",
      "name": "FigureManagerTemplate",
      "qname": "lib.matplotlib.backends.backend_template.FigureManagerTemplate",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.",
      "docstring": "Helper class for pyplot mode, wraps everything up into a neat bundle.\n\nFor non-interactive backends, the base class is sufficient.",
      "code": "class FigureManagerTemplate(FigureManagerBase):\n    \"\"\"\n    Helper class for pyplot mode, wraps everything up into a neat bundle.\n\n    For non-interactive backends, the base class is sufficient.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/GraphicsContextTemplate",
      "name": "GraphicsContextTemplate",
      "qname": "lib.matplotlib.backends.backend_template.GraphicsContextTemplate",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc...  See the cairo\nand postscript backends for examples of mapping the graphics context\nattributes (cap styles, join styles, line widths, colors) to a particular\nbackend.  In cairo this is done by wrapping a cairo.Context object and\nforwarding the appropriate calls to it using a dictionary mapping styles\nto gdk constants.  In Postscript, all the work is done by the renderer,\nmapping line styles to postscript calls.\n\nIf it's more appropriate to do the mapping at the renderer level (as in\nthe postscript backend), you don't need to override any of the GC methods.\nIf it's more appropriate to wrap an instance (as in the cairo backend) and\ndo the mapping here, you'll need to override several of the setter\nmethods.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\nappropriate for your backend.",
      "docstring": "The graphics context provides the color, line styles, etc...  See the cairo\nand postscript backends for examples of mapping the graphics context\nattributes (cap styles, join styles, line widths, colors) to a particular\nbackend.  In cairo this is done by wrapping a cairo.Context object and\nforwarding the appropriate calls to it using a dictionary mapping styles\nto gdk constants.  In Postscript, all the work is done by the renderer,\nmapping line styles to postscript calls.\n\nIf it's more appropriate to do the mapping at the renderer level (as in\nthe postscript backend), you don't need to override any of the GC methods.\nIf it's more appropriate to wrap an instance (as in the cairo backend) and\ndo the mapping here, you'll need to override several of the setter\nmethods.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\nappropriate for your backend.",
      "code": "class GraphicsContextTemplate(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc...  See the cairo\n    and postscript backends for examples of mapping the graphics context\n    attributes (cap styles, join styles, line widths, colors) to a particular\n    backend.  In cairo this is done by wrapping a cairo.Context object and\n    forwarding the appropriate calls to it using a dictionary mapping styles\n    to gdk constants.  In Postscript, all the work is done by the renderer,\n    mapping line styles to postscript calls.\n\n    If it's more appropriate to do the mapping at the renderer level (as in\n    the postscript backend), you don't need to override any of the GC methods.\n    If it's more appropriate to wrap an instance (as in the cairo backend) and\n    do the mapping here, you'll need to override several of the setter\n    methods.\n\n    The base GraphicsContext stores colors as a RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors\n    appropriate for your backend.\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate",
      "name": "RendererTemplate",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `backend_bases.RendererBase` for\ndocumentation of the methods.",
      "docstring": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `backend_bases.RendererBase` for\ndocumentation of the methods.",
      "code": "class RendererTemplate(RendererBase):\n    \"\"\"\n    The renderer handles drawing/rendering operations.\n\n    This is a minimal do-nothing class that can be used to get started when\n    writing a new backend.  Refer to `backend_bases.RendererBase` for\n    documentation of the methods.\n    \"\"\"\n\n    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass\n\n    # draw_markers is optional, and we get more correct relative\n    # timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n#                      rgbFace=None):\n#         pass\n\n    # draw_path_collection is optional, and we get more correct\n    # relative timings by leaving it out. backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_path_collection(self, gc, master_transform, paths,\n#                              all_transforms, offsets, offsetTrans,\n#                              facecolors, edgecolors, linewidths, linestyles,\n#                              antialiaseds):\n#         pass\n\n    # draw_quad_mesh is optional, and we get more correct\n    # relative timings by leaving it out.  backend implementers concerned with\n    # performance will probably want to implement it\n#     def draw_quad_mesh(self, gc, master_transform, meshWidth, meshHeight,\n#                        coordinates, offsets, offsetTrans, facecolors,\n#                        antialiased, edgecolors):\n#         pass\n\n    def draw_image(self, gc, x, y, im):\n        pass\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return 100, 100\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        return 1, 1, 1\n\n    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextTemplate()\n\n    def points_to_pixels(self, points):\n        # if backend doesn't have dpi, e.g., postscript or svg\n        return points",
      "instance_attributes": [
        {
          "name": "dpi",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg",
      "name": "FigureCanvasTkAgg",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "FigureCanvasTk"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasTkAgg(FigureCanvasAgg, FigureCanvasTk):\n    def draw(self):\n        super(FigureCanvasTkAgg, self).draw()\n        _backend_tk.blit(self._tkphoto, self.renderer._renderer, (0, 1, 2, 3))\n        self._master.update_idletasks()\n\n    def blit(self, bbox=None):\n        _backend_tk.blit(\n            self._tkphoto, self.renderer._renderer, (0, 1, 2, 3), bbox=bbox)\n        self._master.update_idletasks()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo",
      "name": "FigureCanvasTkCairo",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo",
      "decorators": [],
      "superclasses": [
        "FigureCanvasCairo",
        "FigureCanvasTk"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasTkCairo(FigureCanvasCairo, FigureCanvasTk):\n    def __init__(self, *args, **kwargs):\n        super(FigureCanvasTkCairo, self).__init__(*args, **kwargs)\n        self._renderer = RendererCairo(self.figure.dpi)\n\n    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_ctx_from_surface(surface)\n        self._renderer.set_width_height(width, height)\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))\n        self._master.update_idletasks()",
      "instance_attributes": [
        {
          "name": "_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererCairo"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureCanvasWebAgg",
      "name": "FigureCanvasWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg.FigureCanvasWebAgg",
      "decorators": [],
      "superclasses": [
        "core.FigureCanvasWebAggCore"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/FigureCanvasWebAgg/show"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWebAgg(core.FigureCanvasWebAggCore):\n    _timer_cls = TimerTornado\n\n    def show(self):\n        # show the figure window\n        global show  # placates pyflakes: created by @_Backend.export below\n        show()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread",
      "name": "ServerThread",
      "qname": "lib.matplotlib.backends.backend_webagg.ServerThread",
      "decorators": [],
      "superclasses": [
        "threading.Thread"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ServerThread(threading.Thread):\n    def run(self):\n        tornado.ioloop.IOLoop.instance().start()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication",
      "name": "WebAggApplication",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication",
      "decorators": [],
      "superclasses": [
        "tornado.web.Application"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize",
        "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class WebAggApplication(tornado.web.Application):\n    initialized = False\n    started = False\n\n    class FavIcon(tornado.web.RequestHandler):\n        def get(self):\n            self.set_header('Content-Type', 'image/png')\n            self.write(Path(mpl.get_data_path(),\n                            'images/matplotlib.png').read_bytes())\n\n    class SingleFigurePage(tornado.web.RequestHandler):\n        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)\n\n        def get(self, fignum):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"single_figure.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                fig_id=fignum,\n                toolitems=core.NavigationToolbar2WebAgg.toolitems,\n                canvas=manager.canvas)\n\n    class AllFiguresPage(tornado.web.RequestHandler):\n        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)\n\n        def get(self):\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"all_figures.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                figures=sorted(Gcf.figs.items()),\n                toolitems=core.NavigationToolbar2WebAgg.toolitems)\n\n    class MplJs(tornado.web.RequestHandler):\n        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n\n            js_content = core.FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)\n\n    class Download(tornado.web.RequestHandler):\n        def get(self, fignum, fmt):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())\n\n    class WebSocket(tornado.websocket.WebSocketHandler):\n        supports_binary = True\n\n        def open(self, fignum):\n            self.fignum = int(fignum)\n            self.manager = Gcf.get_fig_manager(self.fignum)\n            self.manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)\n\n        def on_close(self):\n            self.manager.remove_web_socket(self)\n\n        def on_message(self, message):\n            message = json.loads(message)\n            # The 'supports_binary' message is on a client-by-client\n            # basis.  The others affect the (shared) canvas as a\n            # whole.\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = Gcf.get_fig_manager(self.fignum)\n                # It is possible for a figure to be closed,\n                # but a stale figure UI is still sending messages\n                # from the browser.\n                if manager is not None:\n                    manager.handle_json(message)\n\n        def send_json(self, content):\n            self.write_message(json.dumps(content))\n\n        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = \"data:image/png;base64,{0}\".format(\n                    blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)\n\n    def __init__(self, url_prefix=''):\n        if url_prefix:\n            assert url_prefix[0] == '/' and url_prefix[-1] != '/', \\\n                'url_prefix must start with a \"/\" and not end with one.'\n\n        super().__init__(\n            [\n                # Static files for the CSS and JS\n                (url_prefix + r'/_static/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': core.FigureManagerWebAgg.get_static_file_path()}),\n\n                # Static images for the toolbar\n                (url_prefix + r'/_images/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': Path(mpl.get_data_path(), 'images')}),\n\n                # A Matplotlib favicon\n                (url_prefix + r'/favicon.ico', self.FavIcon),\n\n                # The page that contains all of the pieces\n                (url_prefix + r'/([0-9]+)', self.SingleFigurePage,\n                 {'url_prefix': url_prefix}),\n\n                # The page that contains all of the figures\n                (url_prefix + r'/?', self.AllFiguresPage,\n                 {'url_prefix': url_prefix}),\n\n                (url_prefix + r'/js/mpl.js', self.MplJs),\n\n                # Sends images and events to the browser, and receives\n                # events from the browser\n                (url_prefix + r'/([0-9]+)/ws', self.WebSocket),\n\n                # Handles the downloading (i.e., saving) of static images\n                (url_prefix + r'/([0-9]+)/download.([a-z0-9.]+)',\n                 self.Download),\n            ],\n            template_path=core.FigureManagerWebAgg.get_static_file_path())\n\n    @classmethod\n    def initialize(cls, url_prefix='', port=None, address=None):\n        if cls.initialized:\n            return\n\n        # Create the class instance\n        app = cls(url_prefix=url_prefix)\n\n        cls.url_prefix = url_prefix\n\n        # This port selection algorithm is borrowed, more or less\n        # verbatim, from IPython.\n        def random_ports(port, n):\n            \"\"\"\n            Generate a list of n random ports near the given port.\n\n            The first 5 ports will be sequential, and the remaining n-5 will be\n            randomly selected in the range [port-2*n, port+2*n].\n            \"\"\"\n            for i in range(min(5, n)):\n                yield port + i\n            for i in range(n - 5):\n                yield port + random.randint(-2 * n, 2 * n)\n\n        if address is None:\n            cls.address = mpl.rcParams['webagg.address']\n        else:\n            cls.address = address\n        cls.port = mpl.rcParams['webagg.port']\n        for port in random_ports(cls.port,\n                                 mpl.rcParams['webagg.port_retries']):\n            try:\n                app.listen(port, cls.address)\n            except socket.error as e:\n                if e.errno != errno.EADDRINUSE:\n                    raise\n            else:\n                cls.port = port\n                break\n        else:\n            raise SystemExit(\n                \"The webagg server could not be started because an available \"\n                \"port could not be found\")\n\n        cls.initialized = True\n\n    @classmethod\n    def start(cls):\n        if cls.started:\n            return\n\n        \"\"\"\n        IOLoop.running() was removed as of Tornado 2.4; see for example\n        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY\n        Thus there is no correct way to check if the loop has already been\n        launched. We may end up with two concurrently running loops in that\n        unlucky case with all the expected consequences.\n        \"\"\"\n        ioloop = tornado.ioloop.IOLoop.instance()\n\n        def shutdown():\n            ioloop.stop()\n            print(\"Server is stopped\")\n            sys.stdout.flush()\n            cls.started = False\n\n        @contextmanager\n        def catch_sigint():\n            old_handler = signal.signal(\n                signal.SIGINT,\n                lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n            try:\n                yield\n            finally:\n                signal.signal(signal.SIGINT, old_handler)\n\n        # Set the flag to True *before* blocking on ioloop.start()\n        cls.started = True\n\n        print(\"Press Ctrl+C to stop WebAgg server\")\n        sys.stdout.flush()\n        with catch_sigint():\n            ioloop.start()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore",
      "name": "FigureCanvasWebAggCore",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore",
      "decorators": [],
      "superclasses": [
        "backend_agg.FigureCanvasAgg"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_renderer",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_mouse",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/_handle_key",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWebAggCore(backend_agg.FigureCanvasAgg):\n    supports_blit = False\n\n    def __init__(self, *args, **kwargs):\n        backend_agg.FigureCanvasAgg.__init__(self, *args, **kwargs)\n\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n\n        # Store the DPI ratio of the browser.  This is the scaling that\n        # occurs automatically for all images on a HiDPI display.\n        self._dpi_ratio = 1\n\n    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()\n\n    def draw(self):\n        self._png_is_old = True\n        try:\n            super().draw()\n        finally:\n            self.manager.refresh_all()  # Swap the frames.\n\n    def draw_idle(self):\n        self.send_event(\"draw\")\n\n    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n        \"\"\"\n        cbook._check_in_list(['full', 'diff'], mode=mode)\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)\n\n    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = (np.frombuffer(renderer.buffer_rgba(), dtype=np.uint32)\n                    .reshape((renderer.height, renderer.width)))\n\n            # If any pixels have transparency, we need to force a full\n            # draw as we cannot overlay new on top of old.\n            pixels = buff.view(dtype=np.uint8).reshape(buff.shape + (4,))\n\n            if self._force_full or np.any(pixels[:, :, 3] != 255):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                last_buffer = (np.frombuffer(self._last_renderer.buffer_rgba(),\n                                             dtype=np.uint32)\n                               .reshape((renderer.height, renderer.width)))\n                diff = buff != last_buffer\n                output = np.where(diff, buff, 0)\n\n            buf = BytesIO()\n            data = output.view(dtype=np.uint8).reshape((*output.shape, 4))\n            Image.fromarray(data).save(buf, format=\"png\")\n            # Swap the renderer frames\n            self._renderer, self._last_renderer = (\n                self._last_renderer, renderer)\n            self._force_full = False\n            self._png_is_old = False\n            return buf.getvalue()\n\n    def get_renderer(self, cleared=None):\n        # Mirrors super.get_renderer, but caches the old one so that we can do\n        # things such as produce a diff image in get_diff_image.\n        w, h = self.figure.bbox.size.astype(int)\n        key = w, h, self.figure.dpi\n        try:\n            self._lastKey, self._renderer\n        except AttributeError:\n            need_new_renderer = True\n        else:\n            need_new_renderer = (self._lastKey != key)\n\n        if need_new_renderer:\n            self._renderer = backend_agg.RendererAgg(\n                w, h, self.figure.dpi)\n            self._last_renderer = backend_agg.RendererAgg(\n                w, h, self.figure.dpi)\n            self._lastKey = key\n\n        elif cleared:\n            self._renderer.clear()\n\n        return self._renderer\n\n    def handle_event(self, event):\n        e_type = event['type']\n        handler = getattr(self, 'handle_{0}'.format(e_type),\n                          self.handle_unknown_event)\n        return handler(event)\n\n    def handle_unknown_event(self, event):\n        _log.warning('Unhandled message type {0}. {1}'.format(\n                     event['type'], event))\n\n    def handle_ack(self, event):\n        # Network latency tends to decrease if traffic is flowing\n        # in both directions.  Therefore, the browser sends back\n        # an \"ack\" message after each image frame is received.\n        # This could also be used as a simple sanity check in the\n        # future, but for now the performance increase is enough\n        # to justify it, even if the server does nothing with it.\n        pass\n\n    def handle_draw(self, event):\n        self.draw()\n\n    def _handle_mouse(self, event):\n        x = event['x']\n        y = event['y']\n        y = self.get_renderer().height - y\n\n        # Javascript button numbers and matplotlib button numbers are\n        # off by 1\n        button = event['button'] + 1\n\n        # The right mouse button pops up a context menu, which\n        # doesn't work very well, so use the middle mouse button\n        # instead.  It doesn't seem that it's possible to disable\n        # the context menu in recent versions of Chrome.  If this\n        # is resolved, please also adjust the docstring in MouseEvent.\n        if button == 2:\n            button = 3\n\n        e_type = event['type']\n        guiEvent = event.get('guiEvent', None)\n        if e_type == 'button_press':\n            self.button_press_event(x, y, button, guiEvent=guiEvent)\n        elif e_type == 'button_release':\n            self.button_release_event(x, y, button, guiEvent=guiEvent)\n        elif e_type == 'motion_notify':\n            self.motion_notify_event(x, y, guiEvent=guiEvent)\n        elif e_type == 'figure_enter':\n            self.enter_notify_event(xy=(x, y), guiEvent=guiEvent)\n        elif e_type == 'figure_leave':\n            self.leave_notify_event()\n        elif e_type == 'scroll':\n            self.scroll_event(x, y, event['step'], guiEvent=guiEvent)\n    handle_button_press = handle_button_release = handle_motion_notify = \\\n        handle_figure_enter = handle_figure_leave = handle_scroll = \\\n        _handle_mouse\n\n    def _handle_key(self, event):\n        key = _handle_key(event['key'])\n        e_type = event['type']\n        guiEvent = event.get('guiEvent', None)\n        if e_type == 'key_press':\n            self.key_press_event(key, guiEvent=guiEvent)\n        elif e_type == 'key_release':\n            self.key_release_event(key, guiEvent=guiEvent)\n    handle_key_press = handle_key_release = _handle_key\n\n    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()\n\n    def handle_refresh(self, event):\n        figure_label = self.figure.get_label()\n        if not figure_label:\n            figure_label = \"Figure {0}\".format(self.manager.num)\n        self.send_event('figure_label', label=figure_label)\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()\n\n    def handle_resize(self, event):\n        x, y = event.get('width', 800), event.get('height', 800)\n        x, y = int(x) * self._dpi_ratio, int(y) * self._dpi_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        self.resize_event()\n\n    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)\n\n    def handle_set_dpi_ratio(self, event):\n        dpi_ratio = event.get('dpi_ratio', 1)\n        if dpi_ratio != self._dpi_ratio:\n            # We don't want to scale up the figure dpi more than once.\n            if not hasattr(self.figure, '_original_dpi'):\n                self.figure._original_dpi = self.figure.dpi\n            self.figure.dpi = dpi_ratio * self.figure._original_dpi\n            self._dpi_ratio = dpi_ratio\n            self._force_full = True\n            self.draw_idle()\n\n    def send_event(self, event_type, **kwargs):\n        if self.manager:\n            self.manager._send_event(event_type, **kwargs)",
      "instance_attributes": [
        {
          "name": "_png_is_old",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_force_full",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_current_image_mode",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_dpi_ratio",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_renderer",
          "types": null
        },
        {
          "name": "_last_renderer",
          "types": null
        },
        {
          "name": "_lastKey",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg",
      "name": "FigureManagerWebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg",
      "decorators": [],
      "superclasses": [
        "backend_bases.FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/_get_toolbar",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/_send_event"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureManagerWebAgg(backend_bases.FigureManagerBase):\n    ToolbarCls = NavigationToolbar2WebAgg\n\n    def __init__(self, canvas, num):\n        backend_bases.FigureManagerBase.__init__(self, canvas, num)\n\n        self.web_sockets = set()\n\n        self.toolbar = self._get_toolbar(canvas)\n\n    def show(self):\n        pass\n\n    def _get_toolbar(self, canvas):\n        toolbar = self.ToolbarCls(canvas)\n        return toolbar\n\n    def resize(self, w, h, forward=True):\n        self._send_event(\n            'resize',\n            size=(w / self.canvas._dpi_ratio, h / self.canvas._dpi_ratio),\n            forward=forward)\n\n    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)\n\n    # The following methods are specific to FigureManagerWebAgg\n\n    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n        self.web_sockets.add(web_socket)\n        self.resize(*self.canvas.figure.bbox.size)\n        self._send_event('refresh')\n\n    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)\n\n    def handle_json(self, content):\n        self.canvas.handle_event(content)\n\n    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            if diff is not None:\n                for s in self.web_sockets:\n                    s.send_binary(diff)\n\n    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = StringIO()\n        else:\n            output = stream\n\n        output.write((Path(__file__).parent / \"web_backend/js/mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            if ext[0] != 'pgf':  # pgf does not support BytesIO\n                extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()\n\n    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')\n\n    def _send_event(self, event_type, **kwargs):\n        payload = {'type': event_type, **kwargs}\n        for s in self.web_sockets:\n            s.send_json(payload)",
      "instance_attributes": [
        {
          "name": "web_sockets",
          "types": {
            "kind": "NamedType",
            "name": "set"
          }
        },
        {
          "name": "toolbar",
          "types": {
            "kind": "NamedType",
            "name": "NavigationToolbar2WebAgg"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg",
      "name": "NavigationToolbar2WebAgg",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg",
      "decorators": [],
      "superclasses": [
        "backend_bases.NavigationToolbar2"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/release_zoom",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2WebAgg(backend_bases.NavigationToolbar2):\n\n    # Use the standard toolbar items + download button\n    toolitems = [\n        (text, tooltip_text, image_file, name_of_method)\n        for text, tooltip_text, image_file, name_of_method\n        in (*backend_bases.NavigationToolbar2.toolitems,\n            ('Download', 'Download plot', 'filesave', 'download'))\n        if name_of_method in _ALLOWED_TOOL_ITEMS\n    ]\n\n    def __init__(self, canvas):\n        self.message = ''\n        self.cursor = 0\n        super().__init__(canvas)\n\n    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message\n\n    def set_cursor(self, cursor):\n        if cursor != self.cursor:\n            self.canvas.send_event(\"cursor\", cursor=cursor)\n        self.cursor = cursor\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\n            \"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)\n\n    def release_zoom(self, event):\n        backend_bases.NavigationToolbar2.release_zoom(self, event)\n        self.canvas.send_event(\n            \"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)\n\n    def save_figure(self, *args):\n        \"\"\"Save the current figure\"\"\"\n        self.canvas.send_event('save')\n\n    def pan(self):\n        super().pan()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)\n\n    def zoom(self):\n        super().zoom()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        self.canvas.send_event('history_buttons',\n                               Back=can_backward, Forward=can_forward)",
      "instance_attributes": [
        {
          "name": "message",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "cursor",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado",
      "name": "TimerTornado",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado",
      "decorators": [],
      "superclasses": [
        "backend_bases.TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class TimerTornado(backend_bases.TimerBase):\n    def __init__(self, *args, **kwargs):\n        self._timer = None\n        super().__init__(*args, **kwargs)\n\n    def _timer_start(self):\n        self._timer_stop()\n        if self._single:\n            ioloop = tornado.ioloop.IOLoop.instance()\n            self._timer = ioloop.add_timeout(\n                datetime.timedelta(milliseconds=self.interval),\n                self._on_timer)\n        else:\n            self._timer = tornado.ioloop.PeriodicCallback(\n                self._on_timer,\n                max(self.interval, 1e-6))\n            self._timer.start()\n\n    def _timer_stop(self):\n        if self._timer is None:\n            return\n        elif self._single:\n            ioloop = tornado.ioloop.IOLoop.instance()\n            ioloop.remove_timeout(self._timer)\n        else:\n            self._timer.stop()\n        self._timer = None\n\n    def _timer_set_interval(self):\n        # Only stop and restart it if the timer has already been started\n        if self._timer is not None:\n            self._timer_stop()\n            self._timer_start()",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": {
            "kind": "NamedType",
            "name": "PeriodicCallback"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx",
      "name": "ConfigureSubplotsWx",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx",
      "decorators": [],
      "superclasses": [
        "backend_tools.ConfigureSubplotsBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger",
        "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ConfigureSubplotsWx(backend_tools.ConfigureSubplotsBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.configure_subplots(\n            self._make_classic_style_pseudo_toolbar())\n\n    @cbook.deprecated(\"3.2\")\n    def configure_subplots(self):\n        frame = wx.Frame(None, -1, \"Configure subplots\")\n        _set_frame_icon(frame)\n\n        toolfig = Figure((6, 3))\n        canvas = self.get_canvas(frame, toolfig)\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        frame.SetSizer(sizer)\n        frame.Fit()\n        SubplotTool(self.canvas.figure, toolfig)\n        frame.Show()\n\n    @cbook.deprecated(\"3.2\")\n    def get_canvas(self, frame, fig):\n        return type(self.canvas)(frame, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx",
      "name": "FigureCanvasWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx",
      "decorators": [],
      "superclasses": [
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_bmp",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_jpeg",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_pcx",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_png",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_tiff",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_xpm",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/_print_image"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureCanvasWx(_FigureCanvasWxBase):\n    # Rendering to a Wx canvas using the deprecated Wx renderer.\n\n    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using RendererWx instance renderer, or using a\n        previously defined renderer if none is specified.\n        \"\"\"\n        _log.debug(\"%s - draw()\", type(self))\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)\n\n    def print_bmp(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_BMP, *args, **kwargs)\n\n    def print_jpeg(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_JPEG,\n                                 *args, **kwargs)\n    print_jpg = print_jpeg\n\n    def print_pcx(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_PCX, *args, **kwargs)\n\n    def print_png(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_PNG, *args, **kwargs)\n\n    def print_tiff(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_TIF, *args, **kwargs)\n    print_tif = print_tiff\n\n    def print_xpm(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_XPM, *args, **kwargs)\n\n    @_check_savefig_extra_args\n    def _print_image(self, filename, filetype, *, quality=None):\n        origBitmap = self.bitmap\n\n        self.bitmap = wx.Bitmap(math.ceil(self.figure.bbox.width),\n                                math.ceil(self.figure.bbox.height))\n        renderer = RendererWx(self.bitmap, self.figure.dpi)\n\n        gc = renderer.new_gc()\n        self.figure.draw(renderer)\n\n        # image is the object that we call SaveFile on.\n        image = self.bitmap\n        # set the JPEG quality appropriately.  Unfortunately, it is only\n        # possible to set the quality on a wx.Image object.  So if we\n        # are saving a JPEG, convert the wx.Bitmap to a wx.Image,\n        # and set the quality.\n        if filetype == wx.BITMAP_TYPE_JPEG:\n            if quality is None:\n                quality = dict.__getitem__(mpl.rcParams,\n                                           'savefig.jpeg_quality')\n            image = self.bitmap.ConvertToImage()\n            image.SetOption(wx.IMAGE_OPTION_QUALITY, str(quality))\n\n        # Now that we have rendered into the bitmap, save it to the appropriate\n        # file type and clean up.\n        if (cbook.is_writable_file_like(filename) and\n                not isinstance(image, wx.Image)):\n            image = image.ConvertToImage()\n        if not image.SaveFile(filename, filetype):\n            raise RuntimeError(f'Could not save figure to {filename}')\n\n        # Restore everything to normal\n        self.bitmap = origBitmap\n\n        # Note: draw is required here since bits of state about the\n        # last renderer are strewn about the artist draw methods.  Do\n        # not remove the draw without first verifying that these have\n        # been cleaned up.  The artist contains() methods will fail\n        # otherwise.\n        if self._isDrawn:\n            self.draw()\n        # The \"if self\" check avoids a \"wrapped C/C++ object has been deleted\"\n        # RuntimeError if doing things after window is closed.\n        if self:\n            self.Refresh()",
      "instance_attributes": [
        {
          "name": "renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererWx"
          }
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "bitmap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx",
      "name": "FigureFrameWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx",
      "decorators": [],
      "superclasses": [
        "wx.Frame"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/statusbar@getter",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/toolmanager@getter",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/_get_toolbar",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/_onClose",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/GetToolBar",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/Destroy"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWx(wx.Frame):\n    def __init__(self, num, fig):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        wx.Frame.__init__(self, parent=None, id=-1, pos=pos,\n                          title=\"Figure %d\" % num)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        self.num = num\n        _set_frame_icon(self)\n\n        self.canvas = self.get_canvas(fig)\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(wx.Size(w, h))\n        self.canvas.SetFocus()\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version\n\n        self.figmgr = FigureManagerWx(self.canvas, num, self)\n\n        self.toolbar = self._get_toolbar()\n\n        if self.figmgr.toolmanager:\n            backend_tools.add_tools_to_manager(self.figmgr.toolmanager)\n            if self.toolbar:\n                backend_tools.add_tools_to_container(self.toolbar)\n\n        if self.toolbar is not None:\n            self.toolbar.Realize()\n            # On Windows platform, default window size is incorrect, so set\n            # toolbar width to figure width.\n            tw, th = self.toolbar.GetSize()\n            fw, fh = self.canvas.GetSize()\n            # By adding toolbar in sizer, we are able to put it at the bottom\n            # of the frame - so appearance is closer to GTK version.\n            self.toolbar.SetSize(wx.Size(fw, th))\n            self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.canvas.SetMinSize((2, 2))\n\n        self.Bind(wx.EVT_CLOSE, self._onClose)\n\n    @cbook.deprecated(\"3.2\", alternative=\"self.GetStatusBar()\")\n    @property\n    def statusbar(self):\n        return self.GetStatusBar()\n\n    @property\n    def toolmanager(self):\n        return self.figmgr.toolmanager\n\n    def _get_toolbar(self):\n        if mpl.rcParams['toolbar'] == 'toolbar2':\n            toolbar = NavigationToolbar2Wx(self.canvas)\n        elif mpl.rcParams['toolbar'] == 'toolmanager':\n            toolbar = ToolbarWx(self.toolmanager, self)\n        else:\n            toolbar = None\n        return toolbar\n\n    def get_canvas(self, fig):\n        return FigureCanvasWx(self, -1, fig)\n\n    def get_figure_manager(self):\n        _log.debug(\"%s - get_figure_manager()\", type(self))\n        return self.figmgr\n\n    def _onClose(self, event):\n        _log.debug(\"%s - onClose()\", type(self))\n        self.canvas.close_event()\n        self.canvas.stop_event_loop()\n        Gcf.destroy(self)\n        if self:\n            self.Destroy()\n\n    def GetToolBar(self):\n        \"\"\"Override wxFrame::GetToolBar as we don't have managed toolbar\"\"\"\n        return self.toolbar\n\n    def Destroy(self, *args, **kwargs):\n        try:\n            self.canvas.mpl_disconnect(self.toolbar._id_drag)\n            # Rationale for line above: see issue 2941338.\n        except AttributeError:\n            pass  # classic toolbar lacks the attribute\n        # The \"if self\" check avoids a \"wrapped C/C++ object has been deleted\"\n        # RuntimeError at exit with e.g.\n        # MPLBACKEND=wxagg python -c 'from pylab import *; plot()'.\n        if self and not self.IsBeingDeleted():\n            wx.Frame.Destroy(self, *args, **kwargs)\n            if self.toolbar is not None:\n                self.toolbar.Destroy()\n            wxapp = wx.GetApp()\n            if wxapp:\n                wxapp.Yield()\n        return True",
      "instance_attributes": [
        {
          "name": "num",
          "types": null
        },
        {
          "name": "canvas",
          "types": {
            "kind": "NamedType",
            "name": "FigureCanvasWx"
          }
        },
        {
          "name": "sizer",
          "types": null
        },
        {
          "name": "figmgr",
          "types": {
            "kind": "NamedType",
            "name": "FigureManagerWx"
          }
        },
        {
          "name": "toolbar",
          "types": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "NavigationToolbar2Wx"
              },
              {
                "kind": "NamedType",
                "name": "ToolbarWx"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx",
      "name": "FigureManagerWx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx",
      "decorators": [],
      "superclasses": [
        "FigureManagerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@getter",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@setter",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title",
        "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.",
      "docstring": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.\n\nAttributes\n----------\ncanvas : `FigureCanvas`\n    a FigureCanvasWx(wx.Panel) instance\nwindow : wxFrame\n    a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html",
      "code": "class FigureManagerWx(FigureManagerBase):\n    \"\"\"\n    Container/controller for the FigureCanvas and GUI frame.\n\n    It is instantiated by Gcf whenever a new figure is created.  Gcf is\n    responsible for managing multiple instances of FigureManagerWx.\n\n    Attributes\n    ----------\n    canvas : `FigureCanvas`\n        a FigureCanvasWx(wx.Panel) instance\n    window : wxFrame\n        a wxFrame instance - wxpython.org/Phoenix/docs/html/Frame.html\n    \"\"\"\n\n    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        FigureManagerBase.__init__(self, canvas, num)\n        self.frame = frame\n        self.window = frame\n\n    @property\n    def toolbar(self):\n        return self.frame.GetToolBar()\n\n    @toolbar.setter\n    def toolbar(self, value):\n        # Never allow this, except that base class inits this to None before\n        # the frame is set up.\n        if value is not None or hasattr(self, \"frame\"):\n            raise AttributeError(\"can't set attribute\")\n\n    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()\n\n    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            frame.Close()\n        wxapp = wx.GetApp()\n        if wxapp:\n            wxapp.Yield()\n\n    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()\n\n    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)\n\n    def resize(self, width, height):\n        # docstring inherited\n        self.canvas.SetInitialSize(\n            wx.Size(math.ceil(width), math.ceil(height)))\n        self.window.GetSizer().Fit(self.window)",
      "instance_attributes": [
        {
          "name": "frame",
          "types": null
        },
        {
          "name": "window",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx",
      "name": "GraphicsContextWx",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx",
      "decorators": [],
      "superclasses": [
        "GraphicsContextBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle",
        "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc...\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "docstring": "The graphics context provides the color, line styles, etc...\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "code": "class GraphicsContextWx(GraphicsContextBase):\n    \"\"\"\n    The graphics context provides the color, line styles, etc...\n\n    This class stores a reference to a wxMemoryDC, and a\n    wxGraphicsContext that draws to it.  Creating a wxGraphicsContext\n    seems to be fairly heavy, so these objects are cached based on the\n    bitmap object that is passed in.\n\n    The base GraphicsContext stores colors as a RGB tuple on the unit\n    interval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\n    since wxPython colour management is rather simple, I have not chosen\n    to implement a separate colour manager class.\n    \"\"\"\n    _capd = {'butt': wx.CAP_BUTT,\n             'projecting': wx.CAP_PROJECTING,\n             'round': wx.CAP_ROUND}\n\n    _joind = {'bevel': wx.JOIN_BEVEL,\n              'miter': wx.JOIN_MITER,\n              'round': wx.JOIN_ROUND}\n\n    _cache = weakref.WeakKeyDictionary()\n\n    def __init__(self, bitmap, renderer):\n        GraphicsContextBase.__init__(self)\n        # assert self.Ok(), \"wxMemoryDC not OK to use\"\n        _log.debug(\"%s - __init__(): %s\", type(self), bitmap)\n\n        dc, gfx_ctx = self._cache.get(bitmap, (None, None))\n        if dc is None:\n            dc = wx.MemoryDC()\n            dc.SelectObject(bitmap)\n            gfx_ctx = wx.GraphicsContext.Create(dc)\n            gfx_ctx._lastcliprect = None\n            self._cache[bitmap] = dc, gfx_ctx\n\n        self.bitmap = bitmap\n        self.dc = dc\n        self.gfx_ctx = gfx_ctx\n        self._pen = wx.Pen('BLACK', 1, wx.SOLID)\n        gfx_ctx.SetPen(self._pen)\n        self.renderer = renderer\n\n    def select(self):\n        \"\"\"Select the current bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True\n\n    def unselect(self):\n        \"\"\"Select a Null bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False\n\n    def set_foreground(self, fg, isRGBA=None):\n        # docstring inherited\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        _log.debug(\"%s - set_foreground()\", type(self))\n        self.select()\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_linewidth(self, w):\n        # docstring inherited\n        w = float(w)\n        _log.debug(\"%s - set_linewidth()\", type(self))\n        self.select()\n        if 0 < w < 1:\n            w = 1\n        GraphicsContextBase.set_linewidth(self, w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw == 0:\n            lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_capstyle(self, cs):\n        # docstring inherited\n        _log.debug(\"%s - set_capstyle()\", type(self))\n        self.select()\n        GraphicsContextBase.set_capstyle(self, cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def set_joinstyle(self, js):\n        # docstring inherited\n        _log.debug(\"%s - set_joinstyle()\", type(self))\n        self.select()\n        GraphicsContextBase.set_joinstyle(self, js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()\n\n    def get_wxcolour(self, color):\n        \"\"\"Convert a RGB(A) color to a wx.Colour.\"\"\"\n        _log.debug(\"%s - get_wx_color()\", type(self))\n        if len(color) == 3:\n            r, g, b = color\n            r *= 255\n            g *= 255\n            b *= 255\n            return wx.Colour(red=int(r), green=int(g), blue=int(b))\n        else:\n            r, g, b, a = color\n            r *= 255\n            g *= 255\n            b *= 255\n            a *= 255\n            return wx.Colour(\n                red=int(r),\n                green=int(g),\n                blue=int(b),\n                alpha=int(a))",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "dc",
          "types": null
        },
        {
          "name": "gfx_ctx",
          "types": null
        },
        {
          "name": "_pen",
          "types": null
        },
        {
          "name": "renderer",
          "types": null
        },
        {
          "name": "IsSelected",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx",
      "name": "HelpWx",
      "qname": "lib.matplotlib.backends.backend_wx.HelpWx",
      "decorators": [],
      "superclasses": [
        "backend_tools.ToolHelpBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HelpWx(backend_tools.ToolHelpBase):\n    def trigger(self, *args):\n        _HelpDialog.show(self.figure.canvas.GetTopLevelParent(),\n                         self._get_help_entries())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx",
      "name": "NavigationToolbar2Wx",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx",
      "decorators": [],
      "superclasses": [
        "NavigationToolbar2",
        "wx.ToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/_icon",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/get_canvas",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/configure_subplots",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_cursor",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/press_zoom",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/release_zoom",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_status_bar",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/statbar@getter",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message",
        "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class NavigationToolbar2Wx(NavigationToolbar2, wx.ToolBar):\n    def __init__(self, canvas, coordinates=True):\n        wx.ToolBar.__init__(self, canvas.GetParent(), -1)\n\n        if 'wxMac' in wx.PlatformInfo:\n            self.SetToolBitmapSize((24, 24))\n        self.wx_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.AddSeparator()\n                continue\n            self.wx_ids[text] = (\n                self.AddTool(\n                    -1,\n                    bitmap=self._icon(f\"{image_file}.png\"),\n                    bmpDisabled=wx.NullBitmap,\n                    label=text, shortHelp=tooltip_text,\n                    kind=(wx.ITEM_CHECK if text in [\"Pan\", \"Zoom\"]\n                          else wx.ITEM_NORMAL))\n                .Id)\n            self.Bind(wx.EVT_TOOL, getattr(self, callback),\n                      id=self.wx_ids[text])\n\n        self._coordinates = coordinates\n        if self._coordinates:\n            self.AddStretchableSpace()\n            self._label_text = wx.StaticText(self)\n            self.AddControl(self._label_text)\n\n        self.Realize()\n\n        NavigationToolbar2.__init__(self, canvas)\n        self._idle = True\n        self._prevZoomRect = None\n        # for now, use alternate zoom-rectangle drawing on all\n        # Macs. N.B. In future versions of wx it may be possible to\n        # detect Retina displays with window.GetContentScaleFactor()\n        # and/or dc.GetContentScaleFactor()\n        self._retinaFix = 'wxMac' in wx.PlatformInfo\n\n    prevZoomRect = cbook._deprecate_privatize_attribute(\"3.3\")\n    retinaFix = cbook._deprecate_privatize_attribute(\"3.3\")\n    savedRetinaImage = cbook._deprecate_privatize_attribute(\"3.3\")\n    wxoverlay = cbook._deprecate_privatize_attribute(\"3.3\")\n    zoomAxes = cbook._deprecate_privatize_attribute(\"3.3\")\n    zoomStartX = cbook._deprecate_privatize_attribute(\"3.3\")\n    zoomStartY = cbook._deprecate_privatize_attribute(\"3.3\")\n\n    @staticmethod\n    def _icon(name):\n        \"\"\"\n        Construct a `wx.Bitmap` suitable for use as icon from an image file\n        *name*, including the extension and relative to Matplotlib's \"images\"\n        data directory.\n        \"\"\"\n        image = np.array(PIL.Image.open(cbook._get_data_path(\"images\", name)))\n        try:\n            dark = wx.SystemSettings.GetAppearance().IsDark()\n        except AttributeError:  # wxpython < 4.1\n            # copied from wx's IsUsingDarkBackground / GetLuminance.\n            bg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW)\n            fg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n            # See wx.Colour.GetLuminance.\n            bg_lum = (.299 * bg.red + .587 * bg.green + .114 * bg.blue) / 255\n            fg_lum = (.299 * fg.red + .587 * fg.green + .114 * fg.blue) / 255\n            dark = fg_lum - bg_lum > .2\n        if dark:\n            fg = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n            black_mask = (image[..., :3] == 0).all(axis=-1)\n            image[black_mask, :3] = (fg.Red(), fg.Green(), fg.Blue())\n        return wx.Bitmap.FromBufferRGBA(\n            image.shape[1], image.shape[0], image.tobytes())\n\n    def get_canvas(self, frame, fig):\n        return type(self.canvas)(frame, -1, fig)\n\n    def zoom(self, *args):\n        self.ToggleTool(self.wx_ids['Pan'], False)\n        NavigationToolbar2.zoom(self, *args)\n\n    def pan(self, *args):\n        self.ToggleTool(self.wx_ids['Zoom'], False)\n        NavigationToolbar2.pan(self, *args)\n\n    def configure_subplots(self, *args):\n        global FigureManager  # placates pyflakes: created by @_Backend.export\n        frame = wx.Frame(None, -1, \"Configure subplots\")\n        _set_frame_icon(frame)\n\n        toolfig = Figure((6, 3))\n        canvas = type(self.canvas)(frame, -1, toolfig)\n\n        # Create a figure manager to manage things\n        FigureManager(canvas, 1, frame)\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        frame.SetSizer(sizer)\n        frame.Fit()\n        SubplotTool(self.canvas.figure, toolfig)\n        frame.Show()\n\n    def save_figure(self, *args):\n        # Fetch the required filename and file type.\n        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards()\n        default_file = self.canvas.get_default_filename()\n        dlg = wx.FileDialog(\n            self.canvas.GetParent(), \"Save to file\",\n            mpl.rcParams[\"savefig.directory\"], default_file, filetypes,\n            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        dlg.SetFilterIndex(filter_index)\n        if dlg.ShowModal() == wx.ID_OK:\n            path = pathlib.Path(dlg.GetPath())\n            _log.debug('%s - Save file path: %s', type(self), path)\n            fmt = exts[dlg.GetFilterIndex()]\n            ext = path.suffix[1:]\n            if ext in self.canvas.get_supported_filetypes() and fmt != ext:\n                # looks like they forgot to set the image type drop\n                # down, going with the extension.\n                _log.warning('extension %s did not match the selected '\n                             'image type %s; going with %s',\n                             ext, fmt, ext)\n                fmt = ext\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams[\"savefig.directory\"]:\n                mpl.rcParams[\"savefig.directory\"] = str(path.parent)\n            try:\n                self.canvas.figure.savefig(str(path), format=fmt)\n            except Exception as e:\n                error_msg_wx(str(e))\n\n    def set_cursor(self, cursor):\n        cursor = wx.Cursor(cursord[cursor])\n        self.canvas.SetCursor(cursor)\n        self.canvas.Update()\n\n    def press_zoom(self, event):\n        super().press_zoom(event)\n        if self.mode.name == 'ZOOM':\n            if not self._retinaFix:\n                self._wxoverlay = wx.Overlay()\n            else:\n                if event.inaxes is not None:\n                    self._savedRetinaImage = self.canvas.copy_from_bbox(\n                        event.inaxes.bbox)\n                    self._zoomStartX = event.xdata\n                    self._zoomStartY = event.ydata\n                    self._zoomAxes = event.inaxes\n\n    def release_zoom(self, event):\n        super().release_zoom(event)\n        if self.mode.name == 'ZOOM':\n            # When the mouse is released we reset the overlay and it\n            # restores the former content to the window.\n            if not self._retinaFix:\n                self._wxoverlay.Reset()\n                del self._wxoverlay\n            else:\n                del self._savedRetinaImage\n                if self._prevZoomRect:\n                    self._prevZoomRect.pop(0).remove()\n                    self._prevZoomRect = None\n                if self._zoomAxes:\n                    self._zoomAxes = None\n\n    def draw_rubberband(self, event, x0, y0, x1, y1):\n        if self._retinaFix:  # On Macs, use the following code\n            # wx.DCOverlay does not work properly on Retina displays.\n            rubberBandColor = '#C0C0FF'\n            if self._prevZoomRect:\n                self._prevZoomRect.pop(0).remove()\n            self.canvas.restore_region(self._savedRetinaImage)\n            X0, X1 = self._zoomStartX, event.xdata\n            Y0, Y1 = self._zoomStartY, event.ydata\n            lineX = (X0, X0, X1, X1, X0)\n            lineY = (Y0, Y1, Y1, Y0, Y0)\n            self._prevZoomRect = self._zoomAxes.plot(\n                lineX, lineY, '-', color=rubberBandColor)\n            self._zoomAxes.draw_artist(self._prevZoomRect[0])\n            self.canvas.blit(self._zoomAxes.bbox)\n            return\n\n        # Use an Overlay to draw a rubberband-like bounding box.\n\n        dc = wx.ClientDC(self.canvas)\n        odc = wx.DCOverlay(self._wxoverlay, dc)\n        odc.Clear()\n\n        # Mac's DC is already the same as a GCDC, and it causes\n        # problems with the overlay if we try to use an actual\n        # wx.GCDC so don't try it.\n        if 'wxMac' not in wx.PlatformInfo:\n            dc = wx.GCDC(dc)\n\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n\n        if y1 < y0:\n            y0, y1 = y1, y0\n        if x1 < x0:\n            x0, x1 = x1, x0\n\n        w = x1 - x0\n        h = y1 - y0\n        rect = wx.Rect(x0, y0, w, h)\n\n        rubberBandColor = '#C0C0FF'  # or load from config?\n\n        # Set a pen for the border\n        color = wx.Colour(rubberBandColor)\n        dc.SetPen(wx.Pen(color, 1))\n\n        # use the same color, plus alpha for the brush\n        r, g, b, a = color.Get(True)\n        color.Set(r, g, b, 0x60)\n        dc.SetBrush(wx.Brush(color))\n        dc.DrawRectangle(rect)\n\n    @cbook.deprecated(\"3.2\")\n    def set_status_bar(self, statbar):\n        self.GetTopLevelParent().SetStatusBar(statbar)\n\n    @cbook.deprecated(\"3.2\",\n                      alternative=\"self.GetTopLevelParent().GetStatusBar()\")\n    @property\n    def statbar(self):\n        return self.GetTopLevelParent().GetStatusBar()\n\n    def set_message(self, s):\n        if self._coordinates:\n            self._label_text.SetLabel(s)\n\n    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)",
      "instance_attributes": [
        {
          "name": "wx_ids",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_coordinates",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_label_text",
          "types": null
        },
        {
          "name": "_idle",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_prevZoomRect",
          "types": null
        },
        {
          "name": "_retinaFix",
          "types": null
        },
        {
          "name": "_wxoverlay",
          "types": null
        },
        {
          "name": "_savedRetinaImage",
          "types": null
        },
        {
          "name": "_zoomStartX",
          "types": null
        },
        {
          "name": "_zoomStartY",
          "types": null
        },
        {
          "name": "_zoomAxes",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx",
      "name": "RendererWx",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx",
      "decorators": [],
      "superclasses": [
        "RendererBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_gc",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font",
        "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "docstring": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "code": "class RendererWx(RendererBase):\n    \"\"\"\n    The renderer handles all the drawing primitives using a graphics\n    context instance that controls the colors/styles. It acts as the\n    'renderer' instance used by many classes in the hierarchy.\n    \"\"\"\n    # In wxPython, drawing is performed on a wxDC instance, which will\n    # generally be mapped to the client area of the window displaying\n    # the plot. Under wxPython, the wxDC instance has a wx.Pen which\n    # describes the colour and weight of any lines drawn, and a wxBrush\n    # which describes the fill colour of any closed polygon.\n\n    # Font styles, families and weight.\n    fontweights = {\n        100: wx.FONTWEIGHT_LIGHT,\n        200: wx.FONTWEIGHT_LIGHT,\n        300: wx.FONTWEIGHT_LIGHT,\n        400: wx.FONTWEIGHT_NORMAL,\n        500: wx.FONTWEIGHT_NORMAL,\n        600: wx.FONTWEIGHT_NORMAL,\n        700: wx.FONTWEIGHT_BOLD,\n        800: wx.FONTWEIGHT_BOLD,\n        900: wx.FONTWEIGHT_BOLD,\n        'ultralight': wx.FONTWEIGHT_LIGHT,\n        'light': wx.FONTWEIGHT_LIGHT,\n        'normal': wx.FONTWEIGHT_NORMAL,\n        'medium': wx.FONTWEIGHT_NORMAL,\n        'semibold': wx.FONTWEIGHT_NORMAL,\n        'bold': wx.FONTWEIGHT_BOLD,\n        'heavy': wx.FONTWEIGHT_BOLD,\n        'ultrabold': wx.FONTWEIGHT_BOLD,\n        'black': wx.FONTWEIGHT_BOLD,\n    }\n    fontangles = {\n        'italic': wx.FONTSTYLE_ITALIC,\n        'normal': wx.FONTSTYLE_NORMAL,\n        'oblique': wx.FONTSTYLE_SLANT,\n    }\n\n    # wxPython allows for portable font styles, choosing them appropriately for\n    # the target platform. Map some standard font names to the portable styles.\n    # QUESTION: Is it be wise to agree standard fontnames across all backends?\n    fontnames = {\n        'Sans': wx.FONTFAMILY_SWISS,\n        'Roman': wx.FONTFAMILY_ROMAN,\n        'Script': wx.FONTFAMILY_SCRIPT,\n        'Decorative': wx.FONTFAMILY_DECORATIVE,\n        'Modern': wx.FONTFAMILY_MODERN,\n        'Courier': wx.FONTFAMILY_MODERN,\n        'courier': wx.FONTFAMILY_MODERN,\n    }\n\n    def __init__(self, bitmap, dpi):\n        \"\"\"Initialise a wxWindows renderer instance.\"\"\"\n        cbook.warn_deprecated(\n            \"2.0\", name=\"wx\", obj_type=\"backend\", removal=\"the future\",\n            alternative=\"wxagg\", addendum=\"See the Matplotlib usage FAQ for \"\n            \"more info on backends.\")\n        RendererBase.__init__(self)\n        _log.debug(\"%s - __init__()\", type(self))\n        self.width = bitmap.GetWidth()\n        self.height = bitmap.GetHeight()\n        self.bitmap = bitmap\n        self.fontd = {}\n        self.dpi = dpi\n        self.gc = None\n\n    def flipy(self):\n        # docstring inherited\n        return True\n\n    def offset_text_height(self):\n        return True\n\n    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent\n\n    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height\n\n    def handle_clip_rectangle(self, gc):\n        new_bounds = gc.get_clip_rectangle()\n        if new_bounds is not None:\n            new_bounds = new_bounds.bounds\n        gfx_ctx = gc.gfx_ctx\n        if gfx_ctx._lastcliprect != new_bounds:\n            gfx_ctx._lastcliprect = new_bounds\n            if new_bounds is None:\n                gfx_ctx.ResetClip()\n            else:\n                gfx_ctx.Clip(new_bounds[0],\n                             self.height - new_bounds[1] - new_bounds[3],\n                             new_bounds[2], new_bounds[3])\n\n    @staticmethod\n    def convert_path(gfx_ctx, path, transform):\n        wxpath = gfx_ctx.CreatePath()\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                wxpath.MoveToPoint(*points)\n            elif code == Path.LINETO:\n                wxpath.AddLineToPoint(*points)\n            elif code == Path.CURVE3:\n                wxpath.AddQuadCurveToPoint(*points)\n            elif code == Path.CURVE4:\n                wxpath.AddCurveToPoint(*points)\n            elif code == Path.CLOSEPOLY:\n                wxpath.CloseSubpath()\n        return wxpath\n\n    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0.0, self.height)\n        wxpath = self.convert_path(gfx_ctx, path, transform)\n        if rgbFace is not None:\n            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))\n            gfx_ctx.DrawPath(wxpath)\n        else:\n            gfx_ctx.StrokePath(wxpath)\n        gc.unselect()\n\n    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n        if bbox is not None:\n            l, b, w, h = bbox.bounds\n        else:\n            l = 0\n            b = 0\n            w = self.width\n            h = self.height\n        rows, cols = im.shape[:2]\n        bitmap = wx.Bitmap.FromBufferRGBA(cols, rows, im.tobytes())\n        gc.select()\n        gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),\n                              int(w), int(-h))\n        gc.unselect()\n\n    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n        _log.debug(\"%s - draw_text()\", type(self))\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n\n        font = self.get_wx_font(s, prop)\n        color = gc.get_wxcolour(gc.get_rgb())\n        gfx_ctx.SetFont(font, color)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        x = int(x)\n        y = int(y - h)\n\n        if angle == 0.0:\n            gfx_ctx.DrawText(s, x, y)\n        else:\n            rads = math.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()\n\n    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc\n\n    @cbook.deprecated(\"3.3\", alternative=\".gc\")\n    def get_gc(self):\n        \"\"\"\n        Fetch the locally cached gc.\n        \"\"\"\n        # This is a dirty hack to allow anything with access to a renderer to\n        # access the current graphics context\n        assert self.gc is not None, \"gc must be defined\"\n        return self.gc\n\n    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=self.points_to_pixels(prop.get_size_in_points()),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font\n\n    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)",
      "instance_attributes": [
        {
          "name": "width",
          "types": null
        },
        {
          "name": "height",
          "types": null
        },
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "fontd",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "dpi",
          "types": null
        },
        {
          "name": "gc",
          "types": {
            "kind": "NamedType",
            "name": "GraphicsContextWx"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx",
      "name": "RubberbandWx",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx",
      "decorators": [],
      "superclasses": [
        "backend_tools.RubberbandBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband",
        "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    class RubberbandWx(backend_tools.RubberbandBase):\n        def __init__(self, *args, **kwargs):\n            backend_tools.RubberbandBase.__init__(self, *args, **kwargs)\n            self._rect = None\n\n        def draw_rubberband(self, x0, y0, x1, y1):\n            dc = wx.ClientDC(self.canvas)\n            # this would be required if the Canvas is a ScrolledWindow,\n            # which is not the case for now\n            # self.PrepareDC(dc)\n\n            # delete old rubberband\n            if self._rect:\n                self.remove_rubberband(dc)\n\n            # draw new rubberband\n            dc.SetPen(wx.Pen(wx.BLACK, 1, wx.SOLID))\n            dc.SetBrush(wx.TRANSPARENT_BRUSH)\n            self._rect = (x0, self.canvas._height-y0, x1-x0, -y1+y0)\n            dc.DrawRectangle(self._rect)\n\n        def remove_rubberband(self, dc=None):\n            if not self._rect:\n                return\n            if self.canvas.bitmap:\n                if dc is None:\n                    dc = wx.ClientDC(self.canvas)\n                dc.DrawBitmap(self.canvas.bitmap, 0, 0)\n                #  for testing the method on Windows, use this code instead:\n                # img = self.canvas.bitmap.ConvertToImage()\n                # bmp = img.ConvertToBitmap()\n                # dc.DrawBitmap(bmp, 0, 0)\n            self._rect = None",
      "instance_attributes": [
        {
          "name": "_rect",
          "types": {
            "kind": "NamedType",
            "name": "tuple"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx",
      "name": "SaveFigureWx",
      "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx",
      "decorators": [],
      "superclasses": [
        "backend_tools.SaveFigureBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SaveFigureWx(backend_tools.SaveFigureBase):\n    def trigger(self, *args):\n        NavigationToolbar2Wx.save_figure(\n            self._make_classic_style_pseudo_toolbar())",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx",
      "name": "SetCursorWx",
      "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx",
      "decorators": [],
      "superclasses": [
        "backend_tools.SetCursorBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class SetCursorWx(backend_tools.SetCursorBase):\n    def set_cursor(self, cursor):\n        NavigationToolbar2Wx.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx",
      "name": "StatusBarWx",
      "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "superclasses": [
        "wx.StatusBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/set_function"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A status bar is added to _FigureFrame to allow measurements and the\npreviously selected scroll function to be displayed as a user convenience.",
      "docstring": "A status bar is added to _FigureFrame to allow measurements and the\npreviously selected scroll function to be displayed as a user convenience.",
      "code": "class StatusBarWx(wx.StatusBar):\n    \"\"\"\n    A status bar is added to _FigureFrame to allow measurements and the\n    previously selected scroll function to be displayed as a user convenience.\n    \"\"\"\n\n    def __init__(self, parent, *args, **kwargs):\n        wx.StatusBar.__init__(self, parent, -1)\n        self.SetFieldsCount(2)\n\n    def set_function(self, string):\n        self.SetStatusText(\"%s\" % string, 1)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx",
      "name": "StatusbarWx",
      "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "superclasses": [
        "StatusbarBase",
        "wx.StatusBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "For use with ToolManager.",
      "docstring": "For use with ToolManager.",
      "code": "class StatusbarWx(StatusbarBase, wx.StatusBar):\n    \"\"\"For use with ToolManager.\"\"\"\n    def __init__(self, parent, *args, **kwargs):\n        StatusbarBase.__init__(self, *args, **kwargs)\n        wx.StatusBar.__init__(self, parent, -1)\n        self.SetFieldsCount(1)\n        self.SetStatusText(\"\")\n\n    def set_message(self, s):\n        self.SetStatusText(s)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx",
      "name": "TimerWx",
      "qname": "lib.matplotlib.backends.backend_wx.TimerWx",
      "decorators": [],
      "superclasses": [
        "TimerBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_start",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_stop",
        "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/_timer_set_interval"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using wx.Timer events.",
      "docstring": "Subclass of `.TimerBase` using wx.Timer events.",
      "code": "class TimerWx(TimerBase):\n    \"\"\"Subclass of `.TimerBase` using wx.Timer events.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        TimerBase.__init__(self, *args, **kwargs)\n\n    def _timer_start(self):\n        self._timer.Start(self._interval, self._single)\n\n    def _timer_stop(self):\n        self._timer.Stop()\n\n    def _timer_set_interval(self):\n        if self._timer.IsRunning():\n            self._timer_start()  # Restart with new interval.",
      "instance_attributes": [
        {
          "name": "_timer",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx",
      "name": "ToolCopyToClipboardWx",
      "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx",
      "decorators": [],
      "superclasses": [
        "backend_tools.ToolCopyToClipboardBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolCopyToClipboardWx(backend_tools.ToolCopyToClipboardBase):\n    def trigger(self, *args, **kwargs):\n        if not self.canvas._isDrawn:\n            self.canvas.draw()\n        if not self.canvas.bitmap.IsOk() or not wx.TheClipboard.Open():\n            return\n        try:\n            wx.TheClipboard.SetData(wx.BitmapDataObject(self.canvas.bitmap))\n        finally:\n            wx.TheClipboard.Close()",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx",
      "name": "ToolbarWx",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx",
      "decorators": [],
      "superclasses": [
        "ToolContainerBase",
        "wx.ToolBar"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/_get_tool_pos",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem",
        "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ToolbarWx(ToolContainerBase, wx.ToolBar):\n    def __init__(self, toolmanager, parent, style=wx.TB_HORIZONTAL):\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them.\n\n    def _get_tool_pos(self, tool):\n        \"\"\"\n        Find the position (index) of a wx.ToolBarToolBase in a ToolBar.\n\n        ``ToolBar.GetToolPos`` is not useful because wx assigns the same Id to\n        all Separators and StretchableSpaces.\n        \"\"\"\n        pos, = [pos for pos in range(self.ToolsCount)\n                if self.GetToolByPos(pos) == tool]\n        return pos\n\n    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))\n\n    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()\n\n    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems[name]:\n            self.DeleteTool(tool.Id)\n        del self._toolitems[name]\n\n    def set_message(self, s):\n        self._label_text.SetLabel(s)",
      "instance_attributes": [
        {
          "name": "_space",
          "types": null
        },
        {
          "name": "_label_text",
          "types": null
        },
        {
          "name": "_toolitems",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_groups",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg",
      "name": "FigureCanvasWxAgg",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg",
      "decorators": [],
      "superclasses": [
        "FigureCanvasAgg",
        "_FigureCanvasWxBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw",
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually)\nlives inside a frame instantiated by a FigureManagerWx. The parent\nwindow probably implements a wxSizer to control the displayed\ncontrol size - but we give a hint as to our preferred minimum\nsize.",
      "docstring": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually)\nlives inside a frame instantiated by a FigureManagerWx. The parent\nwindow probably implements a wxSizer to control the displayed\ncontrol size - but we give a hint as to our preferred minimum\nsize.",
      "code": "class FigureCanvasWxAgg(FigureCanvasAgg, _FigureCanvasWxBase):\n    \"\"\"\n    The FigureCanvas contains the figure and does event handling.\n\n    In the wxPython backend, it is derived from wxPanel, and (usually)\n    lives inside a frame instantiated by a FigureManagerWx. The parent\n    window probably implements a wxSizer to control the displayed\n    control size - but we give a hint as to our preferred minimum\n    size.\n    \"\"\"\n\n    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using agg.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n\n        self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC, origin='WXAgg')\n\n    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None:\n            self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n            self.gui_repaint()\n            return\n\n        srcBmp = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n        srcDC = wx.MemoryDC()\n        srcDC.SelectObject(srcBmp)\n\n        destDC = wx.MemoryDC()\n        destDC.SelectObject(self.bitmap)\n\n        x = int(bbox.x0)\n        y = int(self.bitmap.GetHeight() - bbox.y1)\n        destDC.Blit(x, y, int(bbox.width), int(bbox.height), srcDC, x, y)\n\n        destDC.SelectObject(wx.NullBitmap)\n        srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()",
      "instance_attributes": [
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg",
      "name": "FigureFrameWxAgg",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg",
      "decorators": [],
      "superclasses": [
        "FigureFrameWx"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWxAgg(FigureFrameWx):\n    def get_canvas(self, fig):\n        return FigureCanvasWxAgg(self, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo",
      "name": "FigureCanvasWxCairo",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo",
      "decorators": [],
      "superclasses": [
        "_FigureCanvasWxBase",
        "FigureCanvasCairo"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/__init__",
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "docstring": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "code": "class FigureCanvasWxCairo(_FigureCanvasWxBase, FigureCanvasCairo):\n    \"\"\"\n    The FigureCanvas contains the figure and does event handling.\n\n    In the wxPython backend, it is derived from wxPanel, and (usually) lives\n    inside a frame instantiated by a FigureManagerWx. The parent window\n    probably implements a wxSizer to control the displayed control size - but\n    we give a hint as to our preferred minimum size.\n    \"\"\"\n\n    def __init__(self, parent, id, figure):\n        # _FigureCanvasWxBase should be fixed to have the same signature as\n        # every other FigureCanvas and use cooperative inheritance, but in the\n        # meantime the following will make do.\n        _FigureCanvasWxBase.__init__(self, parent, id, figure)\n        FigureCanvasCairo.__init__(self, figure)\n        self._renderer = RendererCairo(self.figure.dpi)\n\n    def draw(self, drawDC=None):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_ctx_from_surface(surface)\n        self._renderer.set_width_height(width, height)\n        self.figure.draw(self._renderer)\n        self.bitmap = wxcairo.BitmapFromImageSurface(surface)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC, origin='WXCairo')",
      "instance_attributes": [
        {
          "name": "_renderer",
          "types": {
            "kind": "NamedType",
            "name": "RendererCairo"
          }
        },
        {
          "name": "bitmap",
          "types": null
        },
        {
          "name": "_isDrawn",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo",
      "name": "FigureFrameWxCairo",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo",
      "decorators": [],
      "superclasses": [
        "FigureFrameWx"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FigureFrameWxCairo(FigureFrameWx):\n    def get_canvas(self, fig):\n        return FigureCanvasWxCairo(self, -1, fig)",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook.deprecation/MatplotlibDeprecationWarning",
      "name": "MatplotlibDeprecationWarning",
      "qname": "lib.matplotlib.cbook.deprecation.MatplotlibDeprecationWarning",
      "decorators": [],
      "superclasses": [
        "UserWarning"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A class for issuing deprecation warnings for Matplotlib users.\n\nIn light of the fact that Python builtin DeprecationWarnings are ignored\nby default as of Python 2.7 (see link below), this class was put in to\nallow for the signaling of deprecation, but via UserWarnings which are not\nignored by default.\n\nhttps://docs.python.org/dev/whatsnew/2.7.html#the-future-for-python-2-x",
      "docstring": "A class for issuing deprecation warnings for Matplotlib users.\n\nIn light of the fact that Python builtin DeprecationWarnings are ignored\nby default as of Python 2.7 (see link below), this class was put in to\nallow for the signaling of deprecation, but via UserWarnings which are not\nignored by default.\n\nhttps://docs.python.org/dev/whatsnew/2.7.html#the-future-for-python-2-x",
      "code": "class MatplotlibDeprecationWarning(UserWarning):\n    \"\"\"\n    A class for issuing deprecation warnings for Matplotlib users.\n\n    In light of the fact that Python builtin DeprecationWarnings are ignored\n    by default as of Python 2.7 (see link below), this class was put in to\n    allow for the signaling of deprecation, but via UserWarnings which are not\n    ignored by default.\n\n    https://docs.python.org/dev/whatsnew/2.7.html#the-future-for-python-2-x\n    \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry",
      "name": "CallbackRegistry",
      "qname": "lib.matplotlib.cbook.CallbackRegistry",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/_remove_proxy",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect",
        "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Handle registering and disconnecting for a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456) # nothing will be called\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)      # nothing will be called\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.",
      "docstring": "Handle registering and disconnecting for a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456) # nothing will be called\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)      # nothing will be called\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.\n\nParameters\n----------\nexception_handler : callable, optional\n   If provided must have signature ::\n\n      def handler(exc: Exception) -> None:\n\n   If not None this function will be called with any `Exception`\n   subclass raised by the callbacks in `CallbackRegistry.process`.\n   The handler may either consume the exception or re-raise.\n\n   The callable must be pickle-able.\n\n   The default handler is ::\n\n      def h(exc):\n          traceback.print_exc()",
      "code": "class CallbackRegistry:\n    \"\"\"\n    Handle registering and disconnecting for a set of signals and callbacks:\n\n        >>> def oneat(x):\n        ...    print('eat', x)\n        >>> def ondrink(x):\n        ...    print('drink', x)\n\n        >>> from matplotlib.cbook import CallbackRegistry\n        >>> callbacks = CallbackRegistry()\n\n        >>> id_eat = callbacks.connect('eat', oneat)\n        >>> id_drink = callbacks.connect('drink', ondrink)\n\n        >>> callbacks.process('drink', 123)\n        drink 123\n        >>> callbacks.process('eat', 456)\n        eat 456\n        >>> callbacks.process('be merry', 456) # nothing will be called\n        >>> callbacks.disconnect(id_eat)\n        >>> callbacks.process('eat', 456)      # nothing will be called\n\n    In practice, one should always disconnect all callbacks when they are\n    no longer needed to avoid dangling references (and thus memory leaks).\n    However, real code in Matplotlib rarely does so, and due to its design,\n    it is rather difficult to place this kind of code.  To get around this,\n    and prevent this class of memory leaks, we instead store weak references\n    to bound methods only, so when the destination object needs to die, the\n    CallbackRegistry won't keep it alive.\n\n    Parameters\n    ----------\n    exception_handler : callable, optional\n       If provided must have signature ::\n\n          def handler(exc: Exception) -> None:\n\n       If not None this function will be called with any `Exception`\n       subclass raised by the callbacks in `CallbackRegistry.process`.\n       The handler may either consume the exception or re-raise.\n\n       The callable must be pickle-able.\n\n       The default handler is ::\n\n          def h(exc):\n              traceback.print_exc()\n    \"\"\"\n\n    # We maintain two mappings:\n    #   callbacks: signal -> {cid -> weakref-to-callback}\n    #   _func_cid_map: signal -> {weakref-to-callback -> cid}\n\n    def __init__(self, exception_handler=_exception_printer):\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}\n\n    def __getstate__(self):\n        # In general, callbacks may not be pickled, so we just drop them.\n        return {**vars(self), \"callbacks\": {}, \"_func_cid_map\": {}}\n\n    def connect(self, s, func):\n        \"\"\"Register *func* to be called when signal *s* is generated.\"\"\"\n        self._func_cid_map.setdefault(s, {})\n        try:\n            proxy = weakref.WeakMethod(func, self._remove_proxy)\n        except TypeError:\n            proxy = _StrongRef(func)\n        if proxy in self._func_cid_map[s]:\n            return self._func_cid_map[s][proxy]\n\n        cid = next(self._cid_gen)\n        self._func_cid_map[s][proxy] = cid\n        self.callbacks.setdefault(s, {})\n        self.callbacks[s][cid] = proxy\n        return cid\n\n    # Keep a reference to sys.is_finalizing, as sys may have been cleared out\n    # at that point.\n    def _remove_proxy(self, proxy, *, _is_finalizing=sys.is_finalizing):\n        if _is_finalizing():\n            # Weakrefs can't be properly torn down at that point anymore.\n            return\n        for signal, proxies in list(self._func_cid_map.items()):\n            try:\n                del self.callbacks[signal][proxies[proxy]]\n            except KeyError:\n                pass\n            if len(self.callbacks[signal]) == 0:\n                del self.callbacks[signal]\n                del self._func_cid_map[signal]\n\n    def disconnect(self, cid):\n        \"\"\"Disconnect the callback registered with callback id *cid*.\"\"\"\n        for eventname, callbackd in list(self.callbacks.items()):\n            try:\n                del callbackd[cid]\n            except KeyError:\n                continue\n            else:\n                for signal, functions in list(self._func_cid_map.items()):\n                    for function, value in list(functions.items()):\n                        if value == cid:\n                            del functions[function]\n                return\n\n    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise",
      "instance_attributes": [
        {
          "name": "exception_handler",
          "types": {
            "kind": "NamedType",
            "name": "Callable"
          }
        },
        {
          "name": "callbacks",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "name": "_cid_gen",
          "types": {
            "kind": "NamedType",
            "name": "count"
          }
        },
        {
          "name": "_func_cid_map",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper",
      "name": "Grouper",
      "qname": "lib.matplotlib.cbook.Grouper",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/Grouper/__init__",
        "matplotlib/lib.matplotlib.cbook/Grouper/__contains__",
        "matplotlib/lib.matplotlib.cbook/Grouper/clean",
        "matplotlib/lib.matplotlib.cbook/Grouper/join",
        "matplotlib/lib.matplotlib.cbook/Grouper/joined",
        "matplotlib/lib.matplotlib.cbook/Grouper/remove",
        "matplotlib/lib.matplotlib.cbook/Grouper/__iter__",
        "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.",
      "docstring": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.\n\nExamples\n--------\n>>> from matplotlib.cbook import Grouper\n>>> class Foo:\n...     def __init__(self, s):\n...         self.s = s\n...     def __repr__(self):\n...         return self.s\n...\n>>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n>>> grp = Grouper()\n>>> grp.join(a, b)\n>>> grp.join(b, c)\n>>> grp.join(d, e)\n>>> sorted(map(tuple, grp))\n[(a, b, c), (d, e)]\n>>> grp.joined(a, b)\nTrue\n>>> grp.joined(a, c)\nTrue\n>>> grp.joined(a, d)\nFalse",
      "code": "class Grouper:\n    \"\"\"\n    A disjoint-set data structure.\n\n    Objects can be joined using :meth:`join`, tested for connectedness\n    using :meth:`joined`, and all disjoint sets can be retrieved by\n    using the object as an iterator.\n\n    The objects being joined must be hashable and weak-referenceable.\n\n    Examples\n    --------\n    >>> from matplotlib.cbook import Grouper\n    >>> class Foo:\n    ...     def __init__(self, s):\n    ...         self.s = s\n    ...     def __repr__(self):\n    ...         return self.s\n    ...\n    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n    >>> grp = Grouper()\n    >>> grp.join(a, b)\n    >>> grp.join(b, c)\n    >>> grp.join(d, e)\n    >>> sorted(map(tuple, grp))\n    [(a, b, c), (d, e)]\n    >>> grp.joined(a, b)\n    True\n    >>> grp.joined(a, c)\n    True\n    >>> grp.joined(a, d)\n    False\n    \"\"\"\n\n    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n\n    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping\n\n    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)\n\n    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()\n\n    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))\n\n    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))\n\n    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]\n\n    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]",
      "instance_attributes": [
        {
          "name": "_mapping",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/IgnoredKeywordWarning",
      "name": "IgnoredKeywordWarning",
      "qname": "lib.matplotlib.cbook.IgnoredKeywordWarning",
      "decorators": [
        "deprecated('3.3')"
      ],
      "superclasses": [
        "UserWarning"
      ],
      "methods": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A class for issuing warnings about keyword arguments that will be ignored\nby Matplotlib.",
      "docstring": "A class for issuing warnings about keyword arguments that will be ignored\nby Matplotlib.",
      "code": "class IgnoredKeywordWarning(UserWarning):\n    \"\"\"\n    A class for issuing warnings about keyword arguments that will be ignored\n    by Matplotlib.\n    \"\"\"\n    pass",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack",
      "name": "Stack",
      "qname": "lib.matplotlib.cbook.Stack",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/Stack/__init__",
        "matplotlib/lib.matplotlib.cbook/Stack/__call__",
        "matplotlib/lib.matplotlib.cbook/Stack/__len__",
        "matplotlib/lib.matplotlib.cbook/Stack/__getitem__",
        "matplotlib/lib.matplotlib.cbook/Stack/forward",
        "matplotlib/lib.matplotlib.cbook/Stack/back",
        "matplotlib/lib.matplotlib.cbook/Stack/push",
        "matplotlib/lib.matplotlib.cbook/Stack/home",
        "matplotlib/lib.matplotlib.cbook/Stack/empty",
        "matplotlib/lib.matplotlib.cbook/Stack/clear",
        "matplotlib/lib.matplotlib.cbook/Stack/bubble",
        "matplotlib/lib.matplotlib.cbook/Stack/remove"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "docstring": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "code": "class Stack:\n    \"\"\"\n    Stack of elements with a movable cursor.\n\n    Mimics home/back/forward in a web browser.\n    \"\"\"\n\n    def __init__(self, default=None):\n        self.clear()\n        self._default = default\n\n    def __call__(self):\n        \"\"\"Return the current element, or None.\"\"\"\n        if not self._elements:\n            return self._default\n        else:\n            return self._elements[self._pos]\n\n    def __len__(self):\n        return len(self._elements)\n\n    def __getitem__(self, ind):\n        return self._elements[ind]\n\n    def forward(self):\n        \"\"\"Move the position forward and return the current element.\"\"\"\n        self._pos = min(self._pos + 1, len(self._elements) - 1)\n        return self()\n\n    def back(self):\n        \"\"\"Move the position back and return the current element.\"\"\"\n        if self._pos > 0:\n            self._pos -= 1\n        return self()\n\n    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()\n\n    def home(self):\n        \"\"\"\n        Push the first element onto the top of the stack.\n\n        The first element is returned.\n        \"\"\"\n        if not self._elements:\n            return\n        self.push(self._elements[0])\n        return self()\n\n    def empty(self):\n        \"\"\"Return whether the stack is empty.\"\"\"\n        return len(self._elements) == 0\n\n    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []\n\n    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o\n\n    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)",
      "instance_attributes": [
        {
          "name": "_default",
          "types": null
        },
        {
          "name": "_pos",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_elements",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict",
      "name": "maxdict",
      "qname": "lib.matplotlib.cbook.maxdict",
      "decorators": [],
      "superclasses": [
        "dict"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/maxdict/__init__",
        "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A dictionary with a maximum size.",
      "docstring": "A dictionary with a maximum size.\n\nNotes\n-----\nThis doesn't override all the relevant methods to constrain the size,\njust ``__setitem__``, so use with caution.",
      "code": "class maxdict(dict):\n    \"\"\"\n    A dictionary with a maximum size.\n\n    Notes\n    -----\n    This doesn't override all the relevant methods to constrain the size,\n    just ``__setitem__``, so use with caution.\n    \"\"\"\n    def __init__(self, maxsize):\n        dict.__init__(self)\n        self.maxsize = maxsize\n        self._killkeys = []\n\n    def __setitem__(self, k, v):\n        if k not in self:\n            if len(self) >= self.maxsize:\n                del self[self._killkeys[0]]\n                del self._killkeys[0]\n            self._killkeys.append(k)\n        dict.__setitem__(self, k, v)",
      "instance_attributes": [
        {
          "name": "maxsize",
          "types": null
        },
        {
          "name": "_killkeys",
          "types": {
            "kind": "NamedType",
            "name": "list"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list",
      "name": "silent_list",
      "qname": "lib.matplotlib.cbook.silent_list",
      "decorators": [],
      "superclasses": [
        "list"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.cbook/silent_list/__init__",
        "matplotlib/lib.matplotlib.cbook/silent_list/__repr__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>",
      "docstring": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>",
      "code": "class silent_list(list):\n    \"\"\"\n    A list with a short ``repr()``.\n\n    This is meant to be used for a homogeneous list of artists, so that they\n    don't cause long, meaningless output.\n\n    Instead of ::\n\n        [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n         <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n         <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\n    one will get ::\n\n        <a list of 3 Line2D objects>\n    \"\"\"\n    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)\n\n    def __repr__(self):\n        return '<a list of %d %s objects>' % (len(self), self.type)",
      "instance_attributes": [
        {
          "name": "type",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes",
      "name": "AitoffAxes",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/_get_core_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class AitoffAxes(GeoAxes):\n    name = 'aitoff'\n\n    class AitoffTransform(_GeoTransform):\n        \"\"\"The base Aitoff transform.\"\"\"\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n\n            alpha = np.arccos(cos_latitude * np.cos(half_long))\n            # Avoid divide-by-zero errors using same method as NumPy.\n            alpha[alpha == 0.0] = 1e-20\n            # We want unnormalized sinc.  numpy.sinc gives us normalized\n            sinc_alpha = np.sin(alpha) / alpha\n\n            x = (cos_latitude * np.sin(half_long)) / sinc_alpha\n            y = np.sin(latitude) / sinc_alpha\n            return np.column_stack([x, y])\n\n        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.InvertedAitoffTransform(self._resolution)\n\n    class InvertedAitoffTransform(_GeoTransform):\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            # MGDTODO: Math is hard ;(\n            return xy\n\n        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.AitoffTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.cla()\n\n    def _get_core_transform(self, resolution):\n        return self.AitoffTransform(resolution)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes",
      "name": "GeoAxes",
      "qname": "lib.matplotlib.projections.geo.GeoAxes",
      "decorators": [],
      "superclasses": [
        "Axes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_init_axis",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/cla",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_set_lim_and_transforms",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_get_affine_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_gen_axes_patch",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/_gen_axes_spines",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_data_ratio",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_zoom",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_pan",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/end_pan",
        "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "An abstract base class for geographic projections.",
      "docstring": "An abstract base class for geographic projections.",
      "code": "class GeoAxes(Axes):\n    \"\"\"An abstract base class for geographic projections.\"\"\"\n\n    class ThetaFormatter(Formatter):\n        \"\"\"\n        Used to format the theta tick labels.  Converts the native\n        unit of radians into degrees and adds a degree symbol.\n        \"\"\"\n        def __init__(self, round_to=1.0):\n            self._round_to = round_to\n\n        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f\"{degrees:0.0f}\\N{DEGREE SIGN}\"\n\n    RESOLUTION = 75\n\n    def _init_axis(self):\n        self.xaxis = maxis.XAxis(self)\n        self.yaxis = maxis.YAxis(self)\n        # Do not register xaxis or yaxis with spines -- as done in\n        # Axes._init_axis() -- until GeoAxes.xaxis.cla() works.\n        # self.spines['geo'].register_axis(self.yaxis)\n        self._update_transScale()\n\n    def cla(self):\n        Axes.cla(self)\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position('none')\n        self.yaxis.set_ticks_position('none')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(rcParams['axes.grid'])\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)\n\n    def _set_lim_and_transforms(self):\n        # A (possibly non-linear) projection on the (already scaled) data\n        self.transProjection = self._get_core_transform(self.RESOLUTION)\n\n        self.transAffine = self._get_affine_transform()\n\n        self.transAxes = BboxTransformTo(self.bbox)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = \\\n            self.transProjection + \\\n            self.transAffine + \\\n            self.transAxes\n\n        # This is the transform for longitude ticks.\n        self._xaxis_pretransform = \\\n            Affine2D() \\\n            .scale(1, self._longitude_cap * 2) \\\n            .translate(0, -self._longitude_cap)\n        self._xaxis_transform = \\\n            self._xaxis_pretransform + \\\n            self.transData\n        self._xaxis_text1_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, 4)\n        self._xaxis_text2_transform = \\\n            Affine2D().scale(1, 0) + \\\n            self.transData + \\\n            Affine2D().translate(0, -4)\n\n        # This is the transform for latitude ticks.\n        yaxis_stretch = Affine2D().scale(np.pi * 2, 1).translate(-np.pi, 0)\n        yaxis_space = Affine2D().scale(1, 1.1)\n        self._yaxis_transform = \\\n            yaxis_stretch + \\\n            self.transData\n        yaxis_text_base = \\\n            yaxis_stretch + \\\n            self.transProjection + \\\n            (yaxis_space +\n             self.transAffine +\n             self.transAxes)\n        self._yaxis_text1_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(-8, 0)\n        self._yaxis_text2_transform = \\\n            yaxis_text_base + \\\n            Affine2D().translate(8, 0)\n\n    def _get_affine_transform(self):\n        transform = self._get_core_transform(1)\n        xscale, _ = transform.transform((np.pi, 0))\n        _, yscale = transform.transform((0, np.pi/2))\n        return Affine2D() \\\n            .scale(0.5 / xscale, 0.5 / yscale) \\\n            .translate(0.5, 0.5)\n\n    def get_xaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, 'bottom', 'center'\n\n    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text2_transform, 'top', 'center'\n\n    def get_yaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._yaxis_transform\n\n    def get_yaxis_text1_transform(self, pad):\n        return self._yaxis_text1_transform, 'center', 'right'\n\n    def get_yaxis_text2_transform(self, pad):\n        return self._yaxis_text2_transform, 'center', 'left'\n\n    def _gen_axes_patch(self):\n        return Circle((0.5, 0.5), 0.5)\n\n    def _gen_axes_spines(self):\n        return {'geo': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}\n\n    def set_yscale(self, *args, **kwargs):\n        if args[0] != 'linear':\n            raise NotImplementedError\n\n    set_xscale = set_yscale\n\n    def set_xlim(self, *args, **kwargs):\n        raise TypeError(\"Changing axes limits of a geographic projection is \"\n                        \"not supported.  Please consider using Cartopy.\")\n\n    set_ylim = set_xlim\n\n    def format_coord(self, lon, lat):\n        \"\"\"Return a format string formatting the coordinate.\"\"\"\n        lon, lat = np.rad2deg([lon, lat])\n        if lat >= 0.0:\n            ns = 'N'\n        else:\n            ns = 'S'\n        if lon >= 0.0:\n            ew = 'E'\n        else:\n            ew = 'W'\n        return ('%f\\N{DEGREE SIGN}%s, %f\\N{DEGREE SIGN}%s'\n                % (abs(lat), ns, abs(lon), ew))\n\n    def set_longitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n        \"\"\"\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_latitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each latitude grid.\n        \"\"\"\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))\n\n    def set_longitude_grid_ends(self, degrees):\n        \"\"\"\n        Set the latitude(s) at which to stop drawing the longitude grids.\n        \"\"\"\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\n            .clear() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)\n\n    def get_data_ratio(self):\n        \"\"\"Return the aspect ratio of the data itself.\"\"\"\n        return 1.0\n\n    ### Interactive panning\n\n    def can_zoom(self):\n        \"\"\"\n        Return *True* if this axes supports the zoom box button functionality.\n\n        This axes object does not support interactive zoom box.\n        \"\"\"\n        return False\n\n    def can_pan(self):\n        \"\"\"\n        Return *True* if this axes supports the pan/zoom button functionality.\n\n        This axes object does not support interactive pan/zoom.\n        \"\"\"\n        return False\n\n    def start_pan(self, x, y, button):\n        pass\n\n    def end_pan(self):\n        pass\n\n    def drag_pan(self, button, key, x, y):\n        pass",
      "instance_attributes": [
        {
          "name": "xaxis",
          "types": null
        },
        {
          "name": "yaxis",
          "types": null
        },
        {
          "name": "transProjection",
          "types": null
        },
        {
          "name": "transAffine",
          "types": null
        },
        {
          "name": "transAxes",
          "types": null
        },
        {
          "name": "transData",
          "types": null
        },
        {
          "name": "_xaxis_pretransform",
          "types": null
        },
        {
          "name": "_xaxis_transform",
          "types": null
        },
        {
          "name": "_xaxis_text1_transform",
          "types": null
        },
        {
          "name": "_xaxis_text2_transform",
          "types": null
        },
        {
          "name": "_yaxis_transform",
          "types": null
        },
        {
          "name": "_yaxis_text1_transform",
          "types": null
        },
        {
          "name": "_yaxis_text2_transform",
          "types": null
        },
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes",
      "name": "HammerAxes",
      "qname": "lib.matplotlib.projections.geo.HammerAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/HammerAxes/_get_core_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class HammerAxes(GeoAxes):\n    name = 'hammer'\n\n    class HammerTransform(_GeoTransform):\n        \"\"\"The base Hammer transform.\"\"\"\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2.0)\n            alpha = np.sqrt(1.0 + cos_latitude * np.cos(half_long))\n            x = (2.0 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])\n\n        def inverted(self):\n            # docstring inherited\n            return HammerAxes.InvertedHammerTransform(self._resolution)\n\n    class InvertedHammerTransform(_GeoTransform):\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            # docstring inherited\n            return HammerAxes.HammerTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.cla()\n\n    def _get_core_transform(self, resolution):\n        return self.HammerTransform(resolution)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes",
      "name": "LambertAxes",
      "qname": "lib.matplotlib.projections.geo.LambertAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/cla",
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/_get_core_transform",
        "matplotlib/lib.matplotlib.projections.geo/LambertAxes/_get_affine_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class LambertAxes(GeoAxes):\n    name = 'lambert'\n\n    class LambertTransform(_GeoTransform):\n        \"\"\"The base Lambert transform.\"\"\"\n\n        def __init__(self, center_longitude, center_latitude, resolution):\n            \"\"\"\n            Create a new Lambert transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Lambert space.\n            \"\"\"\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            cos_lat = np.cos(latitude)\n            sin_lat = np.sin(latitude)\n            diff_long = longitude - clong\n            cos_diff_long = np.cos(diff_long)\n\n            inner_k = np.maximum(  # Prevent divide-by-zero problems\n                1 + np.sin(clat)*sin_lat + np.cos(clat)*cos_lat*cos_diff_long,\n                1e-15)\n            k = np.sqrt(2 / inner_k)\n            x = k * cos_lat*np.sin(diff_long)\n            y = k * (np.cos(clat)*sin_lat - np.sin(clat)*cos_lat*cos_diff_long)\n\n            return np.column_stack([x, y])\n\n        def inverted(self):\n            # docstring inherited\n            return LambertAxes.InvertedLambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)\n\n    class InvertedLambertTransform(_GeoTransform):\n\n        def __init__(self, center_longitude, center_latitude, resolution):\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            p = np.maximum(np.hypot(x, y), 1e-9)\n            c = 2 * np.arcsin(0.5 * p)\n            sin_c = np.sin(c)\n            cos_c = np.cos(c)\n\n            latitude = np.arcsin(cos_c*np.sin(clat) +\n                                 ((y*sin_c*np.cos(clat)) / p))\n            longitude = clong + np.arctan(\n                (x*sin_c) / (p*np.cos(clat)*cos_c - y*np.sin(clat)*sin_c))\n\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            # docstring inherited\n            return LambertAxes.LambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)\n\n    def __init__(self, *args, center_longitude=0, center_latitude=0, **kwargs):\n        self._longitude_cap = np.pi / 2\n        self._center_longitude = center_longitude\n        self._center_latitude = center_latitude\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.cla()\n\n    def cla(self):\n        GeoAxes.cla(self)\n        self.yaxis.set_major_formatter(NullFormatter())\n\n    def _get_core_transform(self, resolution):\n        return self.LambertTransform(\n            self._center_longitude,\n            self._center_latitude,\n            resolution)\n\n    def _get_affine_transform(self):\n        return Affine2D() \\\n            .scale(0.25) \\\n            .translate(0.5, 0.5)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        },
        {
          "name": "_center_longitude",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_center_latitude",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes",
      "name": "MollweideAxes",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes",
      "decorators": [],
      "superclasses": [
        "GeoAxes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__",
        "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/_get_core_transform"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class MollweideAxes(GeoAxes):\n    name = 'mollweide'\n\n    class MollweideTransform(_GeoTransform):\n        \"\"\"The base Mollweide transform.\"\"\"\n\n        def transform_non_affine(self, ll):\n            # docstring inherited\n            def d(theta):\n                delta = (-(theta + np.sin(theta) - pi_sin_l)\n                         / (1 + np.cos(theta)))\n                return delta, np.abs(delta) > 0.001\n\n            longitude, latitude = ll.T\n\n            clat = np.pi/2 - np.abs(latitude)\n            ihigh = clat < 0.087  # within 5 degrees of the poles\n            ilow = ~ihigh\n            aux = np.empty(latitude.shape, dtype=float)\n\n            if ilow.any():  # Newton-Raphson iteration\n                pi_sin_l = np.pi * np.sin(latitude[ilow])\n                theta = 2.0 * latitude[ilow]\n                delta, large_delta = d(theta)\n                while np.any(large_delta):\n                    theta[large_delta] += delta[large_delta]\n                    delta, large_delta = d(theta)\n                aux[ilow] = theta / 2\n\n            if ihigh.any():  # Taylor series-based approx. solution\n                e = clat[ihigh]\n                d = 0.5 * (3 * np.pi * e**2) ** (1.0/3)\n                aux[ihigh] = (np.pi/2 - d) * np.sign(latitude[ihigh])\n\n            xy = np.empty(ll.shape, dtype=float)\n            xy[:, 0] = (2.0 * np.sqrt(2.0) / np.pi) * longitude * np.cos(aux)\n            xy[:, 1] = np.sqrt(2.0) * np.sin(aux)\n\n            return xy\n\n        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.InvertedMollweideTransform(self._resolution)\n\n    class InvertedMollweideTransform(_GeoTransform):\n\n        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            # from Equations (7, 8) of\n            # https://mathworld.wolfram.com/MollweideProjection.html\n            theta = np.arcsin(y / np.sqrt(2))\n            longitude = (np.pi / (2 * np.sqrt(2))) * x / np.cos(theta)\n            latitude = np.arcsin((2 * theta + np.sin(2 * theta)) / np.pi)\n            return np.column_stack([longitude, latitude])\n\n        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.MollweideTransform(self._resolution)\n\n    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.cla()\n\n    def _get_core_transform(self, resolution):\n        return self.MollweideTransform(resolution)",
      "instance_attributes": [
        {
          "name": "_longitude_cap",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform",
      "name": "InvertedPolarTransform",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform",
      "decorators": [],
      "superclasses": [
        "mtransforms.Transform"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__",
        "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine",
        "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/inverted"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The inverse of the polar transform, mapping Cartesian\ncoordinate space *x* and *y* back to *theta* and *r*.",
      "docstring": "The inverse of the polar transform, mapping Cartesian\ncoordinate space *x* and *y* back to *theta* and *r*.",
      "code": "class InvertedPolarTransform(mtransforms.Transform):\n    \"\"\"\n    The inverse of the polar transform, mapping Cartesian\n    coordinate space *x* and *y* back to *theta* and *r*.\n    \"\"\"\n    input_dims = output_dims = 2\n\n    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        mtransforms.Transform.__init__(self)\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms\n\n    __str__ = mtransforms._make_str_method(\n        \"_axis\",\n        use_rmin=\"_use_rmin\",\n        _apply_theta_transforms=\"_apply_theta_transforms\")\n\n    def transform_non_affine(self, xy):\n        # docstring inherited\n        x, y = xy.T\n        r = np.hypot(x, y)\n        theta = (np.arctan2(y, x) + 2 * np.pi) % (2 * np.pi)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            theta -= self._axis.get_theta_offset()\n            theta *= self._axis.get_theta_direction()\n            theta %= 2 * np.pi\n        if self._use_rmin and self._axis is not None:\n            r += self._axis.get_rorigin()\n            r *= self._axis.get_rsign()\n        return np.column_stack([theta, r])\n\n    def inverted(self):\n        # docstring inherited\n        return PolarAxes.PolarTransform(self._axis, self._use_rmin,\n                                        self._apply_theta_transforms)",
      "instance_attributes": [
        {
          "name": "_axis",
          "types": null
        },
        {
          "name": "_use_rmin",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_apply_theta_transforms",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine",
      "name": "PolarAffine",
      "qname": "lib.matplotlib.projections.polar.PolarAffine",
      "decorators": [],
      "superclasses": [
        "mtransforms.Affine2DBase"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__",
        "matplotlib/lib.matplotlib.projections.polar/PolarAffine/get_matrix"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The affine part of the polar projection.  Scales the output so\nthat maximum radius rests on the edge of the axes circle.",
      "docstring": "The affine part of the polar projection.  Scales the output so\nthat maximum radius rests on the edge of the axes circle.",
      "code": "class PolarAffine(mtransforms.Affine2DBase):\n    \"\"\"\n    The affine part of the polar projection.  Scales the output so\n    that maximum radius rests on the edge of the axes circle.\n    \"\"\"\n    def __init__(self, scale_transform, limits):\n        \"\"\"\n        *limits* is the view limit of the data.  The only part of\n        its bounds that is used is the y limits (for the radius limits).\n        The theta range is handled by the non-affine transform.\n        \"\"\"\n        mtransforms.Affine2DBase.__init__(self)\n        self._scale_transform = scale_transform\n        self._limits = limits\n        self.set_children(scale_transform, limits)\n        self._mtx = None\n\n    __str__ = mtransforms._make_str_method(\"_scale_transform\", \"_limits\")\n\n    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            limits_scaled = self._limits.transformed(self._scale_transform)\n            yscale = limits_scaled.ymax - limits_scaled.ymin\n            affine = mtransforms.Affine2D() \\\n                .scale(0.5 / yscale) \\\n                .translate(0.5, 0.5)\n            self._mtx = affine.get_matrix()\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx",
      "instance_attributes": [
        {
          "name": "_scale_transform",
          "types": null
        },
        {
          "name": "_limits",
          "types": null
        },
        {
          "name": "_mtx",
          "types": null
        },
        {
          "name": "_inverted",
          "types": null
        },
        {
          "name": "_invalid",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes",
      "name": "PolarAxes",
      "qname": "lib.matplotlib.projections.polar.PolarAxes",
      "decorators": [],
      "superclasses": [
        "Axes"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/cla",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_init_axis",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_set_lim_and_transforms",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_gen_axes_patch",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/_gen_axes_spines",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_offset",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_direction",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmax",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rorigin",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rsign",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rlabel_position",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_xscale",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_data_ratio",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_zoom",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_pan",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/end_pan",
        "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A polar graph projection, where the input dimensions are *theta*, *r*.\n\nTheta starts pointing east and goes anti-clockwise.",
      "docstring": "A polar graph projection, where the input dimensions are *theta*, *r*.\n\nTheta starts pointing east and goes anti-clockwise.",
      "code": "class PolarAxes(Axes):\n    \"\"\"\n    A polar graph projection, where the input dimensions are *theta*, *r*.\n\n    Theta starts pointing east and goes anti-clockwise.\n    \"\"\"\n    name = 'polar'\n\n    def __init__(self, *args,\n                 theta_offset=0, theta_direction=1, rlabel_position=22.5,\n                 **kwargs):\n        # docstring inherited\n        self._default_theta_offset = theta_offset\n        self._default_theta_direction = theta_direction\n        self._default_rlabel_position = np.deg2rad(rlabel_position)\n        super().__init__(*args, **kwargs)\n        self.use_sticky_edges = True\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.cla()\n\n    def cla(self):\n        Axes.cla(self)\n\n        self.title.set_y(1.05)\n\n        start = self.spines.get('start', None)\n        if start:\n            start.set_visible(False)\n        end = self.spines.get('end', None)\n        if end:\n            end.set_visible(False)\n        self.set_xlim(0.0, 2 * np.pi)\n\n        self.grid(rcParams['polaraxes.grid'])\n        inner = self.spines.get('inner', None)\n        if inner:\n            inner.set_visible(False)\n\n        self.set_rorigin(None)\n        self.set_theta_offset(self._default_theta_offset)\n        self.set_theta_direction(self._default_theta_direction)\n\n    def _init_axis(self):\n        # This is moved out of __init__ because non-separable axes don't use it\n        self.xaxis = ThetaAxis(self)\n        self.yaxis = RadialAxis(self)\n        # Calling polar_axes.xaxis.cla() or polar_axes.xaxis.cla()\n        # results in weird artifacts. Therefore we disable this for\n        # now.\n        # self.spines['polar'].register_axis(self.yaxis)\n        self._update_transScale()\n\n    def _set_lim_and_transforms(self):\n        # A view limit where the minimum radius can be locked if the user\n        # specifies an alternate origin.\n        self._originViewLim = mtransforms.LockableBbox(self.viewLim)\n\n        # Handle angular offset and direction.\n        self._direction = mtransforms.Affine2D() \\\n            .scale(self._default_theta_direction, 1.0)\n        self._theta_offset = mtransforms.Affine2D() \\\n            .translate(self._default_theta_offset, 0.0)\n        self.transShift = self._direction + self._theta_offset\n        # A view limit shifted to the correct location after accounting for\n        # orientation and offset.\n        self._realViewLim = mtransforms.TransformedBbox(self.viewLim,\n                                                        self.transShift)\n\n        # Transforms the x and y axis separately by a scale factor\n        # It is assumed that this part will have non-linear components\n        self.transScale = mtransforms.TransformWrapper(\n            mtransforms.IdentityTransform())\n\n        # Scale view limit into a bbox around the selected wedge. This may be\n        # smaller than the usual unit axes rectangle if not plotting the full\n        # circle.\n        self.axesLim = _WedgeBbox((0.5, 0.5),\n                                  self._realViewLim, self._originViewLim)\n\n        # Scale the wedge to fill the axes.\n        self.transWedge = mtransforms.BboxTransformFrom(self.axesLim)\n\n        # Scale the axes to fill the figure.\n        self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n\n        # A (possibly non-linear) projection on the (already scaled)\n        # data.  This one is aware of rmin\n        self.transProjection = self.PolarTransform(\n            self,\n            _apply_theta_transforms=False)\n        # Add dependency on rorigin.\n        self.transProjection.set_children(self._originViewLim)\n\n        # An affine transformation on the data, generally to limit the\n        # range of the axes\n        self.transProjectionAffine = self.PolarAffine(self.transScale,\n                                                      self._originViewLim)\n\n        # The complete data transformation stack -- from data all the\n        # way to display coordinates\n        self.transData = (\n            self.transScale + self.transShift + self.transProjection +\n            (self.transProjectionAffine + self.transWedge + self.transAxes))\n\n        # This is the transform for theta-axis ticks.  It is\n        # equivalent to transData, except it always puts r == 0.0 and r == 1.0\n        # at the edge of the axis circles.\n        self._xaxis_transform = (\n            mtransforms.blended_transform_factory(\n                mtransforms.IdentityTransform(),\n                mtransforms.BboxTransformTo(self.viewLim)) +\n            self.transData)\n        # The theta labels are flipped along the radius, so that text 1 is on\n        # the outside by default. This should work the same as before.\n        flipr_transform = mtransforms.Affine2D() \\\n            .translate(0.0, -0.5) \\\n            .scale(1.0, -1.0) \\\n            .translate(0.0, 0.5)\n        self._xaxis_text_transform = flipr_transform + self._xaxis_transform\n\n        # This is the transform for r-axis ticks.  It scales the theta\n        # axis so the gridlines from 0.0 to 1.0, now go from thetamin to\n        # thetamax.\n        self._yaxis_transform = (\n            mtransforms.blended_transform_factory(\n                mtransforms.BboxTransformTo(self.viewLim),\n                mtransforms.IdentityTransform()) +\n            self.transData)\n        # The r-axis labels are put at an angle and padded in the r-direction\n        self._r_label_position = mtransforms.Affine2D() \\\n            .translate(self._default_rlabel_position, 0.0)\n        self._yaxis_text_transform = mtransforms.TransformWrapper(\n            self._r_label_position + self.transData)\n\n    def get_xaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform\n\n    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'\n\n    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'\n\n    def get_yaxis_transform(self, which='grid'):\n        if which in ('tick1', 'tick2'):\n            return self._yaxis_text_transform\n        elif which == 'grid':\n            return self._yaxis_transform\n        else:\n            cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n\n    def get_yaxis_text1_transform(self, pad):\n        thetamin, thetamax = self._realViewLim.intervalx\n        if _is_full_circle_rad(thetamin, thetamax):\n            return self._yaxis_text_transform, 'bottom', 'left'\n        elif self.get_theta_direction() > 0:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        else:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        return self._yaxis_text_transform + pad_shift, 'center', halign\n\n    def get_yaxis_text2_transform(self, pad):\n        if self.get_theta_direction() > 0:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        else:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        return self._yaxis_text_transform + pad_shift, 'center', halign\n\n    @cbook._delete_parameter(\"3.3\", \"args\")\n    @cbook._delete_parameter(\"3.3\", \"kwargs\")\n    def draw(self, renderer, *args, **kwargs):\n        self._unstale_viewLim()\n        thetamin, thetamax = np.rad2deg(self._realViewLim.intervalx)\n        if thetamin > thetamax:\n            thetamin, thetamax = thetamax, thetamin\n        rmin, rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *\n                      self.get_rsign())\n        if isinstance(self.patch, mpatches.Wedge):\n            # Backwards-compatibility: Any subclassed Axes might override the\n            # patch to not be the Wedge that PolarAxes uses.\n            center = self.transWedge.transform((0.5, 0.5))\n            self.patch.set_center(center)\n            self.patch.set_theta1(thetamin)\n            self.patch.set_theta2(thetamax)\n\n            edge, _ = self.transWedge.transform((1, 0))\n            radius = edge - center[0]\n            width = min(radius * (rmax - rmin) / rmax, radius)\n            self.patch.set_radius(radius)\n            self.patch.set_width(width)\n\n            inner_width = radius - width\n            inner = self.spines.get('inner', None)\n            if inner:\n                inner.set_visible(inner_width != 0.0)\n\n        visible = not _is_full_circle_deg(thetamin, thetamax)\n        # For backwards compatibility, any subclassed Axes might override the\n        # spines to not include start/end that PolarAxes uses.\n        start = self.spines.get('start', None)\n        end = self.spines.get('end', None)\n        if start:\n            start.set_visible(visible)\n        if end:\n            end.set_visible(visible)\n        if visible:\n            yaxis_text_transform = self._yaxis_transform\n        else:\n            yaxis_text_transform = self._r_label_position + self.transData\n        if self._yaxis_text_transform != yaxis_text_transform:\n            self._yaxis_text_transform.set(yaxis_text_transform)\n            self.yaxis.reset_ticks()\n            self.yaxis.set_clip_path(self.patch)\n\n        Axes.draw(self, renderer, *args, **kwargs)\n\n    def _gen_axes_patch(self):\n        return mpatches.Wedge((0.5, 0.5), 0.5, 0.0, 360.0)\n\n    def _gen_axes_spines(self):\n        spines = OrderedDict([\n            ('polar', mspines.Spine.arc_spine(self, 'top',\n                                              (0.5, 0.5), 0.5, 0.0, 360.0)),\n            ('start', mspines.Spine.linear_spine(self, 'left')),\n            ('end', mspines.Spine.linear_spine(self, 'right')),\n            ('inner', mspines.Spine.arc_spine(self, 'bottom',\n                                              (0.5, 0.5), 0.0, 0.0, 360.0))\n        ])\n        spines['polar'].set_transform(self.transWedge + self.transAxes)\n        spines['inner'].set_transform(self.transWedge + self.transAxes)\n        spines['start'].set_transform(self._yaxis_transform)\n        spines['end'].set_transform(self._yaxis_transform)\n        return spines\n\n    def set_thetamax(self, thetamax):\n        \"\"\"Set the maximum theta limit in degrees.\"\"\"\n        self.viewLim.x1 = np.deg2rad(thetamax)\n\n    def get_thetamax(self):\n        \"\"\"Return the maximum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmax)\n\n    def set_thetamin(self, thetamin):\n        \"\"\"Set the minimum theta limit in degrees.\"\"\"\n        self.viewLim.x0 = np.deg2rad(thetamin)\n\n    def get_thetamin(self):\n        \"\"\"Get the minimum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmin)\n\n    def set_thetalim(self, *args, **kwargs):\n        r\"\"\"\n        Set the minimum and maximum theta values.\n\n        Can take the following signatures:\n\n        - ``set_thetalim(minval, maxval)``: Set the limits in radians.\n        - ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n          in degrees.\n\n        where minval and maxval are the minimum and maximum limits. Values are\n        wrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\n        it is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\n        an axes symmetric around 0. A ValueError is raised if the absolute\n        angle difference is larger than :math:`2\\pi`.\n        \"\"\"\n        thetamin = None\n        thetamax = None\n        left = None\n        right = None\n\n        if len(args) == 2:\n            if args[0] is not None and args[1] is not None:\n                left, right = args\n                if abs(right - left) > 2 * np.pi:\n                    raise ValueError('The angle range must be <= 2 pi')\n\n        if 'thetamin' in kwargs:\n            thetamin = np.deg2rad(kwargs.pop('thetamin'))\n        if 'thetamax' in kwargs:\n            thetamax = np.deg2rad(kwargs.pop('thetamax'))\n\n        if thetamin is not None and thetamax is not None:\n            if abs(thetamax - thetamin) > 2 * np.pi:\n                raise ValueError('The angle range must be <= 360 degrees')\n        return tuple(np.rad2deg(self.set_xlim(left=left, right=right,\n                                              xmin=thetamin, xmax=thetamax)))\n\n    def set_theta_offset(self, offset):\n        \"\"\"\n        Set the offset for the location of 0 in radians.\n        \"\"\"\n        mtx = self._theta_offset.get_matrix()\n        mtx[0, 2] = offset\n        self._theta_offset.invalidate()\n\n    def get_theta_offset(self):\n        \"\"\"\n        Get the offset for the location of 0 in radians.\n        \"\"\"\n        return self._theta_offset.get_matrix()[0, 2]\n\n    def set_theta_zero_location(self, loc, offset=0.0):\n        \"\"\"\n        Set the location of theta's zero.\n\n        This simply calls `set_theta_offset` with the correct value in radians.\n\n        Parameters\n        ----------\n        loc : str\n            May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\".\n        offset : float, default: 0\n            An offset in degrees to apply from the specified *loc*. **Note:**\n            this offset is *always* applied counter-clockwise regardless of\n            the direction setting.\n        \"\"\"\n        mapping = {\n            'N': np.pi * 0.5,\n            'NW': np.pi * 0.75,\n            'W': np.pi,\n            'SW': np.pi * 1.25,\n            'S': np.pi * 1.5,\n            'SE': np.pi * 1.75,\n            'E': 0,\n            'NE': np.pi * 0.25}\n        return self.set_theta_offset(mapping[loc] + np.deg2rad(offset))\n\n    def set_theta_direction(self, direction):\n        \"\"\"\n        Set the direction in which theta increases.\n\n        clockwise, -1:\n           Theta increases in the clockwise direction\n\n        counterclockwise, anticlockwise, 1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        mtx = self._direction.get_matrix()\n        if direction in ('clockwise', -1):\n            mtx[0, 0] = -1\n        elif direction in ('counterclockwise', 'anticlockwise', 1):\n            mtx[0, 0] = 1\n        else:\n            cbook._check_in_list(\n                [-1, 1, 'clockwise', 'counterclockwise', 'anticlockwise'],\n                direction=direction)\n        self._direction.invalidate()\n\n    def get_theta_direction(self):\n        \"\"\"\n        Get the direction in which theta increases.\n\n        -1:\n           Theta increases in the clockwise direction\n\n        1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        return self._direction.get_matrix()[0, 0]\n\n    def set_rmax(self, rmax):\n        \"\"\"\n        Set the outer radial limit.\n\n        Parameters\n        ----------\n        rmax : float\n        \"\"\"\n        self.viewLim.y1 = rmax\n\n    def get_rmax(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            Outer radial limit.\n        \"\"\"\n        return self.viewLim.ymax\n\n    def set_rmin(self, rmin):\n        \"\"\"\n        Set the inner radial limit.\n\n        Parameters\n        ----------\n        rmin : float\n        \"\"\"\n        self.viewLim.y0 = rmin\n\n    def get_rmin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The inner radial limit.\n        \"\"\"\n        return self.viewLim.ymin\n\n    def set_rorigin(self, rorigin):\n        \"\"\"\n        Update the radial origin.\n\n        Parameters\n        ----------\n        rorigin : float\n        \"\"\"\n        self._originViewLim.locked_y0 = rorigin\n\n    def get_rorigin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n        \"\"\"\n        return self._originViewLim.y0\n\n    def get_rsign(self):\n        return np.sign(self._originViewLim.y1 - self._originViewLim.y0)\n\n    def set_rlim(self, bottom=None, top=None, emit=True, auto=False, **kwargs):\n        \"\"\"\n        See `~.polar.PolarAxes.set_ylim`.\n        \"\"\"\n        if 'rmin' in kwargs:\n            if bottom is None:\n                bottom = kwargs.pop('rmin')\n            else:\n                raise ValueError('Cannot supply both positional \"bottom\"'\n                                 'argument and kwarg \"rmin\"')\n        if 'rmax' in kwargs:\n            if top is None:\n                top = kwargs.pop('rmax')\n            else:\n                raise ValueError('Cannot supply both positional \"top\"'\n                                 'argument and kwarg \"rmax\"')\n        return self.set_ylim(bottom=bottom, top=top, emit=emit, auto=auto,\n                             **kwargs)\n\n    def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 *, ymin=None, ymax=None):\n        \"\"\"\n        Set the data limits for the radial axis.\n\n        Parameters\n        ----------\n        bottom : float, optional\n            The bottom limit (default: None, which leaves the bottom\n            limit unchanged).\n            The bottom and top ylims may be passed as the tuple\n            (*bottom*, *top*) as the first positional argument (or as\n            the *bottom* keyword argument).\n\n        top : float, optional\n            The top limit (default: None, which leaves the top limit\n            unchanged).\n\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n\n        auto : bool or None, default: False\n            Whether to turn on autoscaling of the y-axis. True turns on,\n            False turns off, None leaves unchanged.\n\n        ymin, ymax : float, optional\n            These arguments are deprecated and will be removed in a future\n            version.  They are equivalent to *bottom* and *top* respectively,\n            and it is an error to pass both *ymin* and *bottom* or\n            *ymax* and *top*.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The new y-axis limits in data coordinates.\n        \"\"\"\n        if ymin is not None:\n            if bottom is not None:\n                raise ValueError('Cannot supply both positional \"bottom\" '\n                                 'argument and kwarg \"ymin\"')\n            else:\n                bottom = ymin\n        if ymax is not None:\n            if top is not None:\n                raise ValueError('Cannot supply both positional \"top\" '\n                                 'argument and kwarg \"ymax\"')\n            else:\n                top = ymax\n        if top is None and np.iterable(bottom):\n            bottom, top = bottom[0], bottom[1]\n        return super().set_ylim(bottom=bottom, top=top, emit=emit, auto=auto)\n\n    def get_rlabel_position(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The theta position of the radius labels in degrees.\n        \"\"\"\n        return np.rad2deg(self._r_label_position.get_matrix()[0, 2])\n\n    def set_rlabel_position(self, value):\n        \"\"\"\n        Update the theta position of the radius labels.\n\n        Parameters\n        ----------\n        value : number\n            The angular position of the radius labels in degrees.\n        \"\"\"\n        self._r_label_position.clear().translate(np.deg2rad(value), 0.0)\n\n    def set_yscale(self, *args, **kwargs):\n        Axes.set_yscale(self, *args, **kwargs)\n        self.yaxis.set_major_locator(\n            self.RadialLocator(self.yaxis.get_major_locator(), self))\n\n    def set_rscale(self, *args, **kwargs):\n        return Axes.set_yscale(self, *args, **kwargs)\n\n    def set_rticks(self, *args, **kwargs):\n        return Axes.set_yticks(self, *args, **kwargs)\n\n    def set_thetagrids(self, angles, labels=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the theta gridlines in a polar plot.\n\n        Parameters\n        ----------\n        angles : tuple with floats, degrees\n            The angles of the theta gridlines.\n\n        labels : tuple with strings or None\n            The labels to use at each theta gridline. The\n            `.projections.polar.ThetaFormatter` will be used if None.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'. Note that the angle that is used is in\n            radians.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The theta gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `~.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_rgrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n\n        # Make sure we take into account unitized data\n        angles = self.convert_yunits(angles)\n        angles = np.deg2rad(angles)\n        self.set_xticks(angles)\n        if labels is not None:\n            self.set_xticklabels(labels)\n        elif fmt is not None:\n            self.xaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        for t in self.xaxis.get_ticklabels():\n            t.update(kwargs)\n        return self.xaxis.get_ticklines(), self.xaxis.get_ticklabels()\n\n    def set_rgrids(self, radii, labels=None, angle=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the radial gridlines on a polar plot.\n\n        Parameters\n        ----------\n        radii : tuple with floats\n            The radii for the radial gridlines\n\n        labels : tuple with strings or None\n            The labels to use at each radial gridline. The\n            `matplotlib.ticker.ScalarFormatter` will be used if None.\n\n        angle : float\n            The angular position of the radius labels in degrees.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The radial gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `~.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_thetagrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n        # Make sure we take into account unitized data\n        radii = self.convert_xunits(radii)\n        radii = np.asarray(radii)\n\n        self.set_yticks(radii)\n        if labels is not None:\n            self.set_yticklabels(labels)\n        elif fmt is not None:\n            self.yaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        if angle is None:\n            angle = self.get_rlabel_position()\n        self.set_rlabel_position(angle)\n        for t in self.yaxis.get_ticklabels():\n            t.update(kwargs)\n        return self.yaxis.get_gridlines(), self.yaxis.get_ticklabels()\n\n    def set_xscale(self, scale, *args, **kwargs):\n        if scale != 'linear':\n            raise NotImplementedError(\n                \"You can not set the xscale on a polar plot.\")\n\n    def format_coord(self, theta, r):\n        # docstring inherited\n        if theta < 0:\n            theta += 2 * np.pi\n        theta /= np.pi\n        return ('\\N{GREEK SMALL LETTER THETA}=%0.3f\\N{GREEK SMALL LETTER PI} '\n                '(%0.3f\\N{DEGREE SIGN}), r=%0.3f') % (theta, theta * 180.0, r)\n\n    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.  For a polar plot,\n        this should always be 1.0\n        \"\"\"\n        return 1.0\n\n    # # # Interactive panning\n\n    def can_zoom(self):\n        \"\"\"\n        Return *True* if this axes supports the zoom box button functionality.\n\n        Polar axes do not support zoom boxes.\n        \"\"\"\n        return False\n\n    def can_pan(self):\n        \"\"\"\n        Return *True* if this axes supports the pan/zoom button functionality.\n\n        For polar axes, this is slightly misleading. Both panning and\n        zooming are performed by the same button. Panning is performed\n        in azimuth while zooming is done along the radial.\n        \"\"\"\n        return True\n\n    def start_pan(self, x, y, button):\n        angle = np.deg2rad(self.get_rlabel_position())\n        mode = ''\n        if button == 1:\n            epsilon = np.pi / 45.0\n            t, r = self.transData.inverted().transform((x, y))\n            if angle - epsilon <= t <= angle + epsilon:\n                mode = 'drag_r_labels'\n        elif button == 3:\n            mode = 'zoom'\n\n        self._pan_start = types.SimpleNamespace(\n            rmax=self.get_rmax(),\n            trans=self.transData.frozen(),\n            trans_inverse=self.transData.inverted().frozen(),\n            r_label_angle=self.get_rlabel_position(),\n            x=x,\n            y=y,\n            mode=mode)\n\n    def end_pan(self):\n        del self._pan_start\n\n    def drag_pan(self, button, key, x, y):\n        p = self._pan_start\n\n        if p.mode == 'drag_r_labels':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with theta\n            dt = np.rad2deg(startt - t)\n            self.set_rlabel_position(p.r_label_angle - dt)\n\n            trans, vert1, horiz1 = self.get_yaxis_text1_transform(0.0)\n            trans, vert2, horiz2 = self.get_yaxis_text2_transform(0.0)\n            for t in self.yaxis.majorTicks + self.yaxis.minorTicks:\n                t.label1.set_va(vert1)\n                t.label1.set_ha(horiz1)\n                t.label2.set_va(vert2)\n                t.label2.set_ha(horiz2)\n\n        elif p.mode == 'zoom':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with r\n            scale = r / startr\n            self.set_rmax(p.rmax / scale)",
      "instance_attributes": [
        {
          "name": "_default_theta_offset",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_default_theta_direction",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_default_rlabel_position",
          "types": null
        },
        {
          "name": "use_sticky_edges",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "xaxis",
          "types": {
            "kind": "NamedType",
            "name": "ThetaAxis"
          }
        },
        {
          "name": "yaxis",
          "types": {
            "kind": "NamedType",
            "name": "RadialAxis"
          }
        },
        {
          "name": "_originViewLim",
          "types": null
        },
        {
          "name": "_direction",
          "types": null
        },
        {
          "name": "_theta_offset",
          "types": null
        },
        {
          "name": "transShift",
          "types": null
        },
        {
          "name": "_realViewLim",
          "types": null
        },
        {
          "name": "transScale",
          "types": null
        },
        {
          "name": "axesLim",
          "types": {
            "kind": "NamedType",
            "name": "_WedgeBbox"
          }
        },
        {
          "name": "transWedge",
          "types": null
        },
        {
          "name": "transAxes",
          "types": null
        },
        {
          "name": "transProjection",
          "types": {
            "kind": "NamedType",
            "name": "PolarTransform"
          }
        },
        {
          "name": "transProjectionAffine",
          "types": {
            "kind": "NamedType",
            "name": "PolarAffine"
          }
        },
        {
          "name": "transData",
          "types": null
        },
        {
          "name": "_xaxis_transform",
          "types": null
        },
        {
          "name": "_xaxis_text_transform",
          "types": null
        },
        {
          "name": "_yaxis_transform",
          "types": null
        },
        {
          "name": "_r_label_position",
          "types": null
        },
        {
          "name": "_yaxis_text_transform",
          "types": null
        },
        {
          "name": "_pan_start",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform",
      "name": "PolarTransform",
      "qname": "lib.matplotlib.projections.polar.PolarTransform",
      "decorators": [],
      "superclasses": [
        "mtransforms.Transform"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__",
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine",
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine",
        "matplotlib/lib.matplotlib.projections.polar/PolarTransform/inverted"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "The base polar transform.  This handles projection *theta* and\n*r* into Cartesian coordinate space *x* and *y*, but does not\nperform the ultimate affine transformation into the correct\nposition.",
      "docstring": "The base polar transform.  This handles projection *theta* and\n*r* into Cartesian coordinate space *x* and *y*, but does not\nperform the ultimate affine transformation into the correct\nposition.",
      "code": "class PolarTransform(mtransforms.Transform):\n    \"\"\"\n    The base polar transform.  This handles projection *theta* and\n    *r* into Cartesian coordinate space *x* and *y*, but does not\n    perform the ultimate affine transformation into the correct\n    position.\n    \"\"\"\n    input_dims = output_dims = 2\n\n    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        mtransforms.Transform.__init__(self)\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms\n\n    __str__ = mtransforms._make_str_method(\n        \"_axis\",\n        use_rmin=\"_use_rmin\",\n        _apply_theta_transforms=\"_apply_theta_transforms\")\n\n    def transform_non_affine(self, tr):\n        # docstring inherited\n        t, r = np.transpose(tr)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            t *= self._axis.get_theta_direction()\n            t += self._axis.get_theta_offset()\n        if self._use_rmin and self._axis is not None:\n            r = (r - self._axis.get_rorigin()) * self._axis.get_rsign()\n        r = np.where(r >= 0, r, np.nan)\n        return np.column_stack([r * np.cos(t), r * np.sin(t)])\n\n    def transform_path_non_affine(self, path):\n        # docstring inherited\n        if not len(path) or path._interpolation_steps == 1:\n            return Path(self.transform_non_affine(path.vertices), path.codes)\n        xys = []\n        codes = []\n        last_t = last_r = None\n        for trs, c in path.iter_segments():\n            trs = trs.reshape((-1, 2))\n            if c == Path.LINETO:\n                (t, r), = trs\n                if t == last_t:  # Same angle: draw a straight line.\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.append(Path.LINETO)\n                elif r == last_r:  # Same radius: draw an arc.\n                    # The following is complicated by Path.arc() being\n                    # \"helpful\" and unwrapping the angles, but we don't want\n                    # that behavior here.\n                    last_td, td = np.rad2deg([last_t, t])\n                    if self._use_rmin and self._axis is not None:\n                        r = ((r - self._axis.get_rorigin())\n                             * self._axis.get_rsign())\n                    if last_td <= td:\n                        while td - last_td > 360:\n                            arc = Path.arc(last_td, last_td + 360)\n                            xys.extend(arc.vertices[1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td += 360\n                        arc = Path.arc(last_td, td)\n                        xys.extend(arc.vertices[1:] * r)\n                        codes.extend(arc.codes[1:])\n                    else:\n                        # The reverse version also relies on the fact that all\n                        # codes but the first one are the same.\n                        while last_td - td > 360:\n                            arc = Path.arc(last_td - 360, last_td)\n                            xys.extend(arc.vertices[::-1][1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td -= 360\n                        arc = Path.arc(td, last_td)\n                        xys.extend(arc.vertices[::-1][1:] * r)\n                        codes.extend(arc.codes[1:])\n                else:  # Interpolate.\n                    trs = cbook.simple_linear_interpolation(\n                        np.row_stack([(last_t, last_r), trs]),\n                        path._interpolation_steps)[1:]\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.extend([Path.LINETO] * len(trs))\n            else:  # Not a straight line.\n                xys.extend(self.transform_non_affine(trs))\n                codes.extend([c] * len(trs))\n            last_t, last_r = trs[-1]\n        return Path(xys, codes)\n\n    def inverted(self):\n        # docstring inherited\n        return PolarAxes.InvertedPolarTransform(self._axis, self._use_rmin,\n                                                self._apply_theta_transforms)",
      "instance_attributes": [
        {
          "name": "_axis",
          "types": null
        },
        {
          "name": "_use_rmin",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "_apply_theta_transforms",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis",
      "name": "RadialAxis",
      "qname": "lib.matplotlib.projections.polar.RadialAxis",
      "decorators": [],
      "superclasses": [
        "maxis.YAxis"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/_get_tick",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/_wrap_locator_formatter",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/cla",
        "matplotlib/lib.matplotlib.projections.polar/RadialAxis/_set_scale"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial Axis.\n\nThis overrides certain properties of a `.YAxis` to provide special-casing\nfor a radial axis.",
      "docstring": "A radial Axis.\n\nThis overrides certain properties of a `.YAxis` to provide special-casing\nfor a radial axis.",
      "code": "class RadialAxis(maxis.YAxis):\n    \"\"\"\n    A radial Axis.\n\n    This overrides certain properties of a `.YAxis` to provide special-casing\n    for a radial axis.\n    \"\"\"\n    __name__ = 'radialaxis'\n    axis_name = 'radius'  #: Read-only name identifying the axis.\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.sticky_edges.y.append(0)\n\n    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return RadialTick(self.axes, 0, major=major, **tick_kw)\n\n    def _wrap_locator_formatter(self):\n        self.set_major_locator(RadialLocator(self.get_major_locator(),\n                                             self.axes))\n        self.isDefault_majloc = True\n\n    def cla(self):\n        super().cla()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()\n\n    def _set_scale(self, value, **kwargs):\n        super()._set_scale(value, **kwargs)\n        self._wrap_locator_formatter()",
      "instance_attributes": [
        {
          "name": "isDefault_majloc",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator",
      "name": "RadialLocator",
      "qname": "lib.matplotlib.projections.polar.RadialLocator",
      "decorators": [],
      "superclasses": [
        "mticker.Locator"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__call__",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/autoscale",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/pan",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/zoom",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/refresh",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular",
        "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate radius ticks.\n\nEnsures that all ticks are strictly positive.  For all other\ntasks, it delegates to the base\n:class:`~matplotlib.ticker.Locator` (which may be different\ndepending on the scale of the *r*-axis.",
      "docstring": "Used to locate radius ticks.\n\nEnsures that all ticks are strictly positive.  For all other\ntasks, it delegates to the base\n:class:`~matplotlib.ticker.Locator` (which may be different\ndepending on the scale of the *r*-axis.",
      "code": "class RadialLocator(mticker.Locator):\n    \"\"\"\n    Used to locate radius ticks.\n\n    Ensures that all ticks are strictly positive.  For all other\n    tasks, it delegates to the base\n    :class:`~matplotlib.ticker.Locator` (which may be different\n    depending on the scale of the *r*-axis.\n    \"\"\"\n\n    def __init__(self, base, axes=None):\n        self.base = base\n        self._axes = axes\n\n    def __call__(self):\n        show_all = True\n        # Ensure previous behaviour with full circle non-annular views.\n        if self._axes:\n            if _is_full_circle_rad(*self._axes.viewLim.intervalx):\n                rorigin = self._axes.get_rorigin() * self._axes.get_rsign()\n                if self._axes.get_rmin() <= rorigin:\n                    show_all = False\n        if show_all:\n            return self.base()\n        else:\n            return [tick for tick in self.base() if tick > rorigin]\n\n    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        return self.base.autoscale()\n\n    @cbook.deprecated(\"3.3\")\n    def pan(self, numsteps):\n        return self.base.pan(numsteps)\n\n    @cbook.deprecated(\"3.3\")\n    def zoom(self, direction):\n        return self.base.zoom(direction)\n\n    @cbook.deprecated(\"3.3\")\n    def refresh(self):\n        # docstring inherited\n        return self.base.refresh()\n\n    def nonsingular(self, vmin, vmax):\n        # docstring inherited\n        return ((0, 1) if (vmin, vmax) == (-np.inf, np.inf)  # Init. limits.\n                else self.base.nonsingular(vmin, vmax))\n\n    def view_limits(self, vmin, vmax):\n        vmin, vmax = self.base.view_limits(vmin, vmax)\n        if vmax > vmin:\n            # this allows inverted r/y-lims\n            vmin = min(0, vmin)\n        return mtransforms.nonsingular(vmin, vmax)",
      "instance_attributes": [
        {
          "name": "base",
          "types": null
        },
        {
          "name": "_axes",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick",
      "name": "RadialTick",
      "qname": "lib.matplotlib.projections.polar.RadialTick",
      "decorators": [],
      "superclasses": [
        "maxis.YTick"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__",
        "matplotlib/lib.matplotlib.projections.polar/RadialTick/_determine_anchor",
        "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial-axis tick.\n\nThis subclass of `.YTick` provides radial ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\naxes limits.  This results in ticks that are correctly perpendicular to\nthe spine. Labels are also rotated to be perpendicular to the spine, when\n'auto' rotation is enabled.",
      "docstring": "A radial-axis tick.\n\nThis subclass of `.YTick` provides radial ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\naxes limits.  This results in ticks that are correctly perpendicular to\nthe spine. Labels are also rotated to be perpendicular to the spine, when\n'auto' rotation is enabled.",
      "code": "class RadialTick(maxis.YTick):\n    \"\"\"\n    A radial-axis tick.\n\n    This subclass of `.YTick` provides radial ticks with some small\n    modification to their re-positioning such that ticks are rotated based on\n    axes limits.  This results in ticks that are correctly perpendicular to\n    the spine. Labels are also rotated to be perpendicular to the spine, when\n    'auto' rotation is enabled.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.label1.set_rotation_mode('anchor')\n        self.label2.set_rotation_mode('anchor')\n\n    def _determine_anchor(self, mode, angle, start):\n        # Note: angle is the (spine angle - 90) because it's used for the tick\n        # & text setup, so all numbers below are -90 from (normed) spine angle.\n        if mode == 'auto':\n            if start:\n                if -90 <= angle <= 90:\n                    return 'left', 'center'\n                else:\n                    return 'right', 'center'\n            else:\n                if -90 <= angle <= 90:\n                    return 'right', 'center'\n                else:\n                    return 'left', 'center'\n        else:\n            if start:\n                if angle < -68.5:\n                    return 'center', 'top'\n                elif angle < -23.5:\n                    return 'left', 'top'\n                elif angle < 22.5:\n                    return 'left', 'center'\n                elif angle < 67.5:\n                    return 'left', 'bottom'\n                elif angle < 112.5:\n                    return 'center', 'bottom'\n                elif angle < 157.5:\n                    return 'right', 'bottom'\n                elif angle < 202.5:\n                    return 'right', 'center'\n                elif angle < 247.5:\n                    return 'right', 'top'\n                else:\n                    return 'center', 'top'\n            else:\n                if angle < -68.5:\n                    return 'center', 'bottom'\n                elif angle < -23.5:\n                    return 'right', 'bottom'\n                elif angle < 22.5:\n                    return 'right', 'center'\n                elif angle < 67.5:\n                    return 'right', 'top'\n                elif angle < 112.5:\n                    return 'center', 'top'\n                elif angle < 157.5:\n                    return 'left', 'top'\n                elif angle < 202.5:\n                    return 'left', 'center'\n                elif angle < 247.5:\n                    return 'left', 'bottom'\n                else:\n                    return 'center', 'bottom'\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        if full:\n            self.label2.set_visible(False)\n            self.tick2line.set_visible(False)\n        angle = (thetamax * direction + offset) % 360 - 90\n        if direction > 0:\n            tick_angle = np.deg2rad(angle)\n        else:\n            tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        ha, va = self._determine_anchor(mode, angle, direction < 0)\n        self.label2.set_ha(ha)\n        self.label2.set_va(va)\n        self.label2.set_rotation(text_angle)\n\n        marker = self.tick2line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaAxis",
      "name": "ThetaAxis",
      "qname": "lib.matplotlib.projections.polar.ThetaAxis",
      "decorators": [],
      "superclasses": [
        "maxis.XAxis"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_get_tick",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_wrap_locator_formatter",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/cla",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_set_scale",
        "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/_copy_tick_props"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A theta Axis.\n\nThis overrides certain properties of an `.XAxis` to provide special-casing\nfor an angular axis.",
      "docstring": "A theta Axis.\n\nThis overrides certain properties of an `.XAxis` to provide special-casing\nfor an angular axis.",
      "code": "class ThetaAxis(maxis.XAxis):\n    \"\"\"\n    A theta Axis.\n\n    This overrides certain properties of an `.XAxis` to provide special-casing\n    for an angular axis.\n    \"\"\"\n    __name__ = 'thetaaxis'\n    axis_name = 'theta'  #: Read-only name identifying the axis.\n\n    def _get_tick(self, major):\n        if major:\n            tick_kw = self._major_tick_kw\n        else:\n            tick_kw = self._minor_tick_kw\n        return ThetaTick(self.axes, 0, major=major, **tick_kw)\n\n    def _wrap_locator_formatter(self):\n        self.set_major_locator(ThetaLocator(self.get_major_locator()))\n        self.set_major_formatter(ThetaFormatter())\n        self.isDefault_majloc = True\n        self.isDefault_majfmt = True\n\n    def cla(self):\n        super().cla()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()\n\n    def _set_scale(self, value, **kwargs):\n        super()._set_scale(value, **kwargs)\n        self._wrap_locator_formatter()\n\n    def _copy_tick_props(self, src, dest):\n        \"\"\"Copy the props from src tick to dest tick.\"\"\"\n        if src is None or dest is None:\n            return\n        super()._copy_tick_props(src, dest)\n\n        # Ensure that tick transforms are independent so that padding works.\n        trans = dest._get_text1_transform()[0]\n        dest.label1.set_transform(trans + dest._text1_translate)\n        trans = dest._get_text2_transform()[0]\n        dest.label2.set_transform(trans + dest._text2_translate)",
      "instance_attributes": [
        {
          "name": "isDefault_majloc",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "name": "isDefault_majfmt",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter",
      "name": "ThetaFormatter",
      "qname": "lib.matplotlib.projections.polar.ThetaFormatter",
      "decorators": [],
      "superclasses": [
        "mticker.Formatter"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to format the *theta* tick labels.  Converts the native\nunit of radians into degrees and adds a degree symbol.",
      "docstring": "Used to format the *theta* tick labels.  Converts the native\nunit of radians into degrees and adds a degree symbol.",
      "code": "class ThetaFormatter(mticker.Formatter):\n    \"\"\"\n    Used to format the *theta* tick labels.  Converts the native\n    unit of radians into degrees and adds a degree symbol.\n    \"\"\"\n    def __call__(self, x, pos=None):\n        vmin, vmax = self.axis.get_view_interval()\n        d = np.rad2deg(abs(vmax - vmin))\n        digits = max(-int(np.log10(d) - 1.5), 0)\n        # Use unicode rather than mathtext with \\circ, so that it will work\n        # correctly with any arbitrary font (assuming it has a degree sign),\n        # whereas $5\\circ$ will only work correctly with one of the supported\n        # math fonts (Computer Modern and STIX).\n        return (\"{value:0.{digits:d}f}\\N{DEGREE SIGN}\"\n                .format(value=np.rad2deg(x), digits=digits))",
      "instance_attributes": []
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator",
      "name": "ThetaLocator",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator",
      "decorators": [],
      "superclasses": [
        "mticker.Locator"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__call__",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/autoscale",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/pan",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/refresh",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits",
        "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/zoom"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate theta ticks.\n\nThis will work the same as the base locator except in the case that the\nview spans the entire circle. In such cases, the previously used default\nlocations of every 45 degrees are returned.",
      "docstring": "Used to locate theta ticks.\n\nThis will work the same as the base locator except in the case that the\nview spans the entire circle. In such cases, the previously used default\nlocations of every 45 degrees are returned.",
      "code": "class ThetaLocator(mticker.Locator):\n    \"\"\"\n    Used to locate theta ticks.\n\n    This will work the same as the base locator except in the case that the\n    view spans the entire circle. In such cases, the previously used default\n    locations of every 45 degrees are returned.\n    \"\"\"\n    def __init__(self, base):\n        self.base = base\n        self.axis = self.base.axis = _AxisWrapper(self.base.axis)\n\n    def set_axis(self, axis):\n        self.axis = _AxisWrapper(axis)\n        self.base.set_axis(self.axis)\n\n    def __call__(self):\n        lim = self.axis.get_view_interval()\n        if _is_full_circle_deg(lim[0], lim[1]):\n            return np.arange(8) * 2 * np.pi / 8\n        else:\n            return np.deg2rad(self.base())\n\n    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        return self.base.autoscale()\n\n    @cbook.deprecated(\"3.3\")\n    def pan(self, numsteps):\n        return self.base.pan(numsteps)\n\n    def refresh(self):\n        # docstring inherited\n        return self.base.refresh()\n\n    def view_limits(self, vmin, vmax):\n        vmin, vmax = np.rad2deg((vmin, vmax))\n        return np.deg2rad(self.base.view_limits(vmin, vmax))\n\n    @cbook.deprecated(\"3.3\")\n    def zoom(self, direction):\n        return self.base.zoom(direction)",
      "instance_attributes": [
        {
          "name": "base",
          "types": null
        },
        {
          "name": "axis",
          "types": {
            "kind": "NamedType",
            "name": "_AxisWrapper"
          }
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick",
      "name": "ThetaTick",
      "qname": "lib.matplotlib.projections.polar.ThetaTick",
      "decorators": [],
      "superclasses": [
        "maxis.XTick"
      ],
      "methods": [
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__",
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/_apply_params",
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/_update_padding",
        "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A theta-axis tick.\n\nThis subclass of `.XTick` provides angular ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\ntick location. This results in ticks that are correctly perpendicular to\nthe arc spine.\n\nWhen 'auto' rotation is enabled, labels are also rotated to be parallel to\nthe spine. The label padding is also applied here since it's not possible\nto use a generic axes transform to produce tick-specific padding.",
      "docstring": "A theta-axis tick.\n\nThis subclass of `.XTick` provides angular ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\ntick location. This results in ticks that are correctly perpendicular to\nthe arc spine.\n\nWhen 'auto' rotation is enabled, labels are also rotated to be parallel to\nthe spine. The label padding is also applied here since it's not possible\nto use a generic axes transform to produce tick-specific padding.",
      "code": "class ThetaTick(maxis.XTick):\n    \"\"\"\n    A theta-axis tick.\n\n    This subclass of `.XTick` provides angular ticks with some small\n    modification to their re-positioning such that ticks are rotated based on\n    tick location. This results in ticks that are correctly perpendicular to\n    the arc spine.\n\n    When 'auto' rotation is enabled, labels are also rotated to be parallel to\n    the spine. The label padding is also applied here since it's not possible\n    to use a generic axes transform to produce tick-specific padding.\n    \"\"\"\n\n    def __init__(self, axes, *args, **kwargs):\n        self._text1_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        self._text2_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        super().__init__(axes, *args, **kwargs)\n        self.label1.set(\n            rotation_mode='anchor',\n            transform=self.label1.get_transform() + self._text1_translate)\n        self.label2.set(\n            rotation_mode='anchor',\n            transform=self.label2.get_transform() + self._text2_translate)\n\n    def _apply_params(self, **kw):\n        super()._apply_params(**kw)\n\n        # Ensure transform is correct; sometimes this gets reset.\n        trans = self.label1.get_transform()\n        if not trans.contains_branch(self._text1_translate):\n            self.label1.set_transform(trans + self._text1_translate)\n        trans = self.label2.get_transform()\n        if not trans.contains_branch(self._text2_translate):\n            self.label2.set_transform(trans + self._text2_translate)\n\n    def _update_padding(self, pad, angle):\n        padx = pad * np.cos(angle) / 72\n        pady = pad * np.sin(angle) / 72\n        self._text1_translate._t = (padx, pady)\n        self._text1_translate.invalidate()\n        self._text2_translate._t = (-padx, -pady)\n        self._text2_translate.invalidate()\n\n    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding(pad,\n                             self._loc * axes.get_theta_direction() +\n                             axes.get_theta_offset())",
      "instance_attributes": [
        {
          "name": "_text1_translate",
          "types": null
        },
        {
          "name": "_text2_translate",
          "types": null
        }
      ]
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry",
      "name": "ProjectionRegistry",
      "qname": "lib.matplotlib.projections.ProjectionRegistry",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/__init__",
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register",
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class",
        "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_names"
      ],
      "is_public": true,
      "reexported_by": [],
      "description": "A mapping of registered projection names to projection classes.",
      "docstring": "A mapping of registered projection names to projection classes.",
      "code": "class ProjectionRegistry:\n    \"\"\"A mapping of registered projection names to projection classes.\"\"\"\n\n    def __init__(self):\n        self._all_projection_types = {}\n\n    def register(self, *projections):\n        \"\"\"Register a new set of projections.\"\"\"\n        for projection in projections:\n            name = projection.name\n            self._all_projection_types[name] = projection\n\n    def get_projection_class(self, name):\n        \"\"\"Get a projection class from its *name*.\"\"\"\n        return self._all_projection_types[name]\n\n    def get_projection_names(self):\n        \"\"\"Return the names of all projections currently registered.\"\"\"\n        return sorted(self._all_projection_types)",
      "instance_attributes": [
        {
          "name": "_all_projection_types",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba",
      "name": "buffer_rgba",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/buffer_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.buffer_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as a `memoryview` to the renderer's buffer.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as a `memoryview` to the renderer's buffer.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def buffer_rgba(self):\n        \"\"\"\n        Get the image as a `memoryview` to the renderer's buffer.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.buffer_rgba()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox",
      "name": "copy_from_bbox",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/copy_from_bbox/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.copy_from_bbox.bbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def copy_from_bbox(self, bbox):\n        renderer = self.get_renderer()\n        return renderer.copy_from_bbox(bbox)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        self.renderer = self.get_renderer(cleared=True)\n        # Acquire a lock on the shared font cache.\n        with RendererAgg.lock, \\\n             (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self.figure.draw(self.renderer)\n            # A GUI class may be need to update a window using this draw, so\n            # don't forget to call the superclass.\n            super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/get_renderer/cleared",
          "name": "cleared",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.get_renderer.cleared",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self, cleared=False):\n        w, h = self.figure.bbox.size\n        key = w, h, self.figure.dpi\n        reuse_renderer = (hasattr(self, \"renderer\")\n                          and getattr(self, \"_lastKey\", None) == key)\n        if not reuse_renderer:\n            self.renderer = RendererAgg(w, h, self.figure.dpi)\n            self._lastKey = key\n        elif cleared:\n            self.renderer.clear()\n        return self.renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg",
      "name": "print_jpg",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg",
      "decorators": [
        "_check_savefig_extra_args(extra_kwargs=['quality', 'optimize', 'progressive'])",
        "cbook._delete_parameter('3.2', 'dryrun')",
        "cbook._delete_parameter('3.3', 'quality', alternative=\"pil_kwargs={'quality': ...}\")",
        "cbook._delete_parameter('3.3', 'optimize', alternative=\"pil_kwargs={'optimize': ...}\")",
        "cbook._delete_parameter('3.3', 'progressive', alternative=\"pil_kwargs={'progressive': ...}\")"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "The file to write to."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/dryrun",
          "name": "dryrun",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.dryrun",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_jpg/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_jpg.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write the figure to a JPEG file.",
      "docstring": "Write the figure to a JPEG file.\n\nParameters\n----------\nfilename_or_obj : str or path-like or file-like\n    The file to write to.\n\nOther Parameters\n----------------\nquality : int, default: :rc:`savefig.jpeg_quality`\n    The image quality, on a scale from 1 (worst) to 95 (best).\n    Values above 95 should be avoided; 100 disables portions of\n    the JPEG compression algorithm, and results in large files\n    with hardly any gain in image quality.  This parameter is\n    deprecated.\n\noptimize : bool, default: False\n    Whether the encoder should make an extra pass over the image\n    in order to select optimal encoder settings.  This parameter is\n    deprecated.\n\nprogressive : bool, default: False\n    Whether the image should be stored as a progressive JPEG file.\n    This parameter is deprecated.\n\npil_kwargs : dict, optional\n    Additional keyword arguments that are passed to\n    `PIL.Image.Image.save` when saving the figure.  These take\n    precedence over *quality*, *optimize* and *progressive*.",
      "code": "    @_check_savefig_extra_args(\n        extra_kwargs=[\"quality\", \"optimize\", \"progressive\"])\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    @cbook._delete_parameter(\"3.3\", \"quality\",\n                             alternative=\"pil_kwargs={'quality': ...}\")\n    @cbook._delete_parameter(\"3.3\", \"optimize\",\n                             alternative=\"pil_kwargs={'optimize': ...}\")\n    @cbook._delete_parameter(\"3.3\", \"progressive\",\n                             alternative=\"pil_kwargs={'progressive': ...}\")\n    def print_jpg(self, filename_or_obj, *args, dryrun=False, pil_kwargs=None,\n                  **kwargs):\n        \"\"\"\n        Write the figure to a JPEG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        Other Parameters\n        ----------------\n        quality : int, default: :rc:`savefig.jpeg_quality`\n            The image quality, on a scale from 1 (worst) to 95 (best).\n            Values above 95 should be avoided; 100 disables portions of\n            the JPEG compression algorithm, and results in large files\n            with hardly any gain in image quality.  This parameter is\n            deprecated.\n\n        optimize : bool, default: False\n            Whether the encoder should make an extra pass over the image\n            in order to select optimal encoder settings.  This parameter is\n            deprecated.\n\n        progressive : bool, default: False\n            Whether the image should be stored as a progressive JPEG file.\n            This parameter is deprecated.\n\n        pil_kwargs : dict, optional\n            Additional keyword arguments that are passed to\n            `PIL.Image.Image.save` when saving the figure.  These take\n            precedence over *quality*, *optimize* and *progressive*.\n        \"\"\"\n        # Remove transparency by alpha-blending on an assumed white background.\n        r, g, b, a = mcolors.to_rgba(self.figure.get_facecolor())\n        try:\n            self.figure.set_facecolor(a * np.array([r, g, b]) + 1 - a)\n            FigureCanvasAgg.draw(self)\n        finally:\n            self.figure.set_facecolor((r, g, b, a))\n        if dryrun:\n            return\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        for k in [\"quality\", \"optimize\", \"progressive\"]:\n            if k in kwargs:\n                pil_kwargs.setdefault(k, kwargs.pop(k))\n        if \"quality\" not in pil_kwargs:\n            quality = pil_kwargs[\"quality\"] = \\\n                dict.__getitem__(mpl.rcParams, \"savefig.jpeg_quality\")\n            if quality not in [0, 75, 95]:  # default qualities.\n                cbook.warn_deprecated(\n                    \"3.3\", name=\"savefig.jpeg_quality\", obj_type=\"rcParam\",\n                    addendum=\"Set the quality using \"\n                    \"`pil_kwargs={'quality': ...}`; the future default \"\n                    \"quality will be 75, matching the default of Pillow and \"\n                    \"libjpeg.\")\n        pil_kwargs.setdefault(\"dpi\", (self.figure.dpi, self.figure.dpi))\n        # Drop alpha channel now.\n        return (Image.fromarray(np.asarray(self.buffer_rgba())[..., :3])\n                .save(filename_or_obj, format='jpeg', **pil_kwargs))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png",
      "decorators": [
        "_check_savefig_extra_args"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "The file to write to."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Metadata in the PNG file as key-value pairs of bytes or latin-1\nencodable strings.\nAccording to the PNG specification, keys must be shorter than 79\nchars.\n\nThe `PNG specification`_ defines some common keywords that may be\nused as appropriate:\n\n- Title: Short (one line) title or caption for image.\n- Author: Name of image's creator.\n- Description: Description of image (possibly long).\n- Copyright: Copyright notice.\n- Creation Time: Time of original image creation\n  (usually RFC 1123 format).\n- Software: Software used to create the image.\n- Disclaimer: Legal disclaimer.\n- Warning: Warning of nature of content.\n- Source: Device used to create the image.\n- Comment: Miscellaneous comment;\n  conversion from other image format.\n\nOther keywords may be invented for other purposes.\n\nIf 'Software' is not given, an autogenerated value for Matplotlib\nwill be used.  This can be removed by setting it to *None*.\n\nFor more details see the `PNG specification`_.\n\n.. _PNG specification:                 https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords"
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_png/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_png.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Keyword arguments passed to `PIL.Image.Image.save`.\n\nIf the 'pnginfo' key is present, it completely overrides\n*metadata*, including the default 'Software' key."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write the figure to a PNG file.",
      "docstring": "Write the figure to a PNG file.\n\nParameters\n----------\nfilename_or_obj : str or path-like or file-like\n    The file to write to.\n\nmetadata : dict, optional\n    Metadata in the PNG file as key-value pairs of bytes or latin-1\n    encodable strings.\n    According to the PNG specification, keys must be shorter than 79\n    chars.\n\n    The `PNG specification`_ defines some common keywords that may be\n    used as appropriate:\n\n    - Title: Short (one line) title or caption for image.\n    - Author: Name of image's creator.\n    - Description: Description of image (possibly long).\n    - Copyright: Copyright notice.\n    - Creation Time: Time of original image creation\n      (usually RFC 1123 format).\n    - Software: Software used to create the image.\n    - Disclaimer: Legal disclaimer.\n    - Warning: Warning of nature of content.\n    - Source: Device used to create the image.\n    - Comment: Miscellaneous comment;\n      conversion from other image format.\n\n    Other keywords may be invented for other purposes.\n\n    If 'Software' is not given, an autogenerated value for Matplotlib\n    will be used.  This can be removed by setting it to *None*.\n\n    For more details see the `PNG specification`_.\n\n    .. _PNG specification:                 https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\npil_kwargs : dict, optional\n    Keyword arguments passed to `PIL.Image.Image.save`.\n\n    If the 'pnginfo' key is present, it completely overrides\n    *metadata*, including the default 'Software' key.",
      "code": "    @_check_savefig_extra_args\n    def print_png(self, filename_or_obj, *args,\n                  metadata=None, pil_kwargs=None):\n        \"\"\"\n        Write the figure to a PNG file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or path-like or file-like\n            The file to write to.\n\n        metadata : dict, optional\n            Metadata in the PNG file as key-value pairs of bytes or latin-1\n            encodable strings.\n            According to the PNG specification, keys must be shorter than 79\n            chars.\n\n            The `PNG specification`_ defines some common keywords that may be\n            used as appropriate:\n\n            - Title: Short (one line) title or caption for image.\n            - Author: Name of image's creator.\n            - Description: Description of image (possibly long).\n            - Copyright: Copyright notice.\n            - Creation Time: Time of original image creation\n              (usually RFC 1123 format).\n            - Software: Software used to create the image.\n            - Disclaimer: Legal disclaimer.\n            - Warning: Warning of nature of content.\n            - Source: Device used to create the image.\n            - Comment: Miscellaneous comment;\n              conversion from other image format.\n\n            Other keywords may be invented for other purposes.\n\n            If 'Software' is not given, an autogenerated value for Matplotlib\n            will be used.  This can be removed by setting it to *None*.\n\n            For more details see the `PNG specification`_.\n\n            .. _PNG specification: \\\n                https://www.w3.org/TR/2003/REC-PNG-20031110/#11keywords\n\n        pil_kwargs : dict, optional\n            Keyword arguments passed to `PIL.Image.Image.save`.\n\n            If the 'pnginfo' key is present, it completely overrides\n            *metadata*, including the default 'Software' key.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n        mpl.image.imsave(\n            filename_or_obj, self.buffer_rgba(), format=\"png\", origin=\"upper\",\n            dpi=self.figure.dpi, metadata=metadata, pil_kwargs=pil_kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw",
      "name": "print_raw",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw",
      "decorators": [
        "_check_savefig_extra_args"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_raw/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_raw.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_check_savefig_extra_args\n    def print_raw(self, filename_or_obj, *args):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        with cbook.open_file_cm(filename_or_obj, \"wb\") as fh:\n            fh.write(renderer.buffer_rgba())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif",
      "name": "print_tif",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif",
      "decorators": [
        "_check_savefig_extra_args",
        "cbook._delete_parameter('3.2', 'dryrun')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/filename_or_obj",
          "name": "filename_or_obj",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.filename_or_obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/dryrun",
          "name": "dryrun",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.dryrun",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_tif/pil_kwargs",
          "name": "pil_kwargs",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_tif.pil_kwargs",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_check_savefig_extra_args\n    @cbook._delete_parameter(\"3.2\", \"dryrun\")\n    def print_tif(self, filename_or_obj, *, dryrun=False, pil_kwargs=None):\n        FigureCanvasAgg.draw(self)\n        if dryrun:\n            return\n        if pil_kwargs is None:\n            pil_kwargs = {}\n        pil_kwargs.setdefault(\"dpi\", (self.figure.dpi, self.figure.dpi))\n        return (Image.fromarray(np.asarray(self.buffer_rgba()))\n                .save(filename_or_obj, format='tiff', **pil_kwargs))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer",
      "name": "print_to_buffer",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_to_buffer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/print_to_buffer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.print_to_buffer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_to_buffer(self):\n        FigureCanvasAgg.draw(self)\n        renderer = self.get_renderer()\n        return (bytes(renderer.buffer_rgba()),\n                (int(renderer.width), int(renderer.height)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/restore_region/xy",
          "name": "xy",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.restore_region.xy",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore_region(self, region, bbox=None, xy=None):\n        renderer = self.get_renderer()\n        return renderer.restore_region(region, bbox, xy)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb",
      "name": "tostring_argb",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_argb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_argb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_argb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as ARGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as ARGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def tostring_argb(self):\n        \"\"\"\n        Get the image as ARGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_argb()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb",
      "name": "tostring_rgb",
      "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/FigureCanvasAgg/tostring_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.FigureCanvasAgg.tostring_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the image as RGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "docstring": "Get the image as RGB `bytes`.\n\n`draw` must be called at least once before this function will work and\nto update the renderer for any subsequent changes to the Figure.",
      "code": "    def tostring_rgb(self):\n        \"\"\"\n        Get the image as RGB `bytes`.\n\n        `draw` must be called at least once before this function will work and\n        to update the renderer for any subsequent changes to the Figure.\n        \"\"\"\n        return self.renderer.tostring_rgb()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        # We only want to preserve the init keywords of the Renderer.\n        # Anything else can be re-created.\n        return {'width': self.width, 'height': self.height, 'dpi': self.dpi}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles",
      "docstring": "",
      "code": "    def __init__(self, width, height, dpi):\n        RendererBase.__init__(self)\n\n        self.dpi = dpi\n        self.width = width\n        self.height = height\n        self._renderer = _RendererAgg(int(width), int(height), dpi)\n        self._filter_renderers = []\n\n        self._update_methods()\n        self.mathtext_parser = MathTextParser('Agg')\n\n        self.bbox = Bbox.from_bounds(0, 0, self.width, self.height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__",
      "name": "__setstate__",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/__setstate__/state",
          "name": "state",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.__setstate__.state",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setstate__(self, state):\n        self.__init__(state['width'], state['height'], state['dpi'])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba",
      "name": "buffer_rgba",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/buffer_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.buffer_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def buffer_rgba(self):\n        return memoryview(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear",
      "name": "clear",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def clear(self):\n        self._renderer.clear()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw mathtext using :mod:`matplotlib.mathtext`.",
      "docstring": "Draw mathtext using :mod:`matplotlib.mathtext`.",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw mathtext using :mod:`matplotlib.mathtext`.\"\"\"\n        ox, oy, width, height, descent, font_image, used_characters = \\\n            self.mathtext_parser.parse(s, self.dpi, prop)\n\n        xd = descent * sin(radians(angle))\n        yd = descent * cos(radians(angle))\n        x = round(x + ox + xd)\n        y = round(y - oy + yd)\n        self._renderer.draw_text_image(font_image, x, y + 1, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        nmax = mpl.rcParams['agg.path.chunksize']  # here at least for testing\n        npts = path.vertices.shape[0]\n\n        if (npts > nmax > 100 and path.should_simplify and\n                rgbFace is None and gc.get_hatch() is None):\n            nch = np.ceil(npts / nmax)\n            chsize = int(np.ceil(npts / nch))\n            i0 = np.arange(0, npts, chsize)\n            i1 = np.zeros_like(i0)\n            i1[:-1] = i0[1:] - 1\n            i1[-1] = npts\n            for ii0, ii1 in zip(i0, i1):\n                v = path.vertices[ii0:ii1, :]\n                c = path.codes\n                if c is not None:\n                    c = c[ii0:ii1]\n                    c[0] = Path.MOVETO  # move to end of last chunk\n                p = Path(v, c)\n                try:\n                    self._renderer.draw_path(gc, p, transform, rgbFace)\n                except OverflowError as err:\n                    raise OverflowError(\n                        \"Exceeded cell block limit (set 'agg.path.chunksize' \"\n                        \"rcparam)\") from err\n        else:\n            try:\n                self._renderer.draw_path(gc, path, transform, rgbFace)\n            except OverflowError as err:\n                raise OverflowError(\"Exceeded cell block limit (set \"\n                                    \"'agg.path.chunksize' rcparam)\") from err"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/offsetTrans",
          "name": "offsetTrans",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.offsetTrans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        if offset_position == \"data\":\n            cbook.warn_deprecated(\n                \"3.3\", message=\"Support for offset_position='data' is \"\n                \"deprecated since %(since)s and will be removed %(removal)s.\")\n        return self._renderer.draw_path_collection(\n            gc, master_transform, paths, all_transforms, offsets, offsetTrans,\n            facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls,\n            offset_position)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex",
      "decorators": [
        "cbook._delete_parameter('3.2', 'ismath')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.ismath",
          "default_value": "'TeX!'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook._delete_parameter(\"3.2\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        # todo, handle props, angle, origins\n        size = prop.get_size_in_points()\n\n        texmanager = self.get_texmanager()\n\n        Z = texmanager.get_grey(s, size, self.dpi)\n        Z = np.array(Z * 255.0, np.uint8)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xd)\n        y = round(y + yd)\n        self._renderer.draw_text_image(Z, x, y, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n\n        if font is None:\n            return None\n        # We pass '0' for angle here, since it will be rotated (in raster\n        # space) in the following call to draw_text_image).\n        font.set_text(s, 0, flags=flags)\n        font.draw_glyphs_to_bitmap(\n            antialiased=mpl.rcParams['text.antialiased'])\n        d = font.get_descent() / 64.0\n        # The descent needs to be adjusted for the angle.\n        xo, yo = font.get_bitmap_offset()\n        xo /= 64.0\n        yo /= 64.0\n        xd = d * sin(radians(angle))\n        yd = d * cos(radians(angle))\n        x = round(x + xo + xd)\n        y = round(y + yo + yd)\n        self._renderer.draw_text_image(font, x, y + 1, angle, gc)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath in [\"TeX\", \"TeX!\"]:\n            if ismath == \"TeX!\":\n                cbook._warn_deprecated(\n                    \"3.3\", message=\"Support for ismath='TeX!' is deprecated \"\n                    \"since %(since)s and will be removed %(removal)s; use \"\n                    \"ismath='TeX' instead.\")\n            # todo: handle props\n            texmanager = self.get_texmanager()\n            fontsize = prop.get_size_in_points()\n            w, h, d = texmanager.get_text_width_height_descent(\n                s, fontsize, renderer=self)\n            return w, h, d\n\n        if ismath:\n            ox, oy, width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        flags = get_hinting_flag()\n        font = self._get_agg_font(prop)\n        font.set_text(s, 0.0, flags=flags)\n        w, h = font.get_width_height()  # width and height of unrotated string\n        d = font.get_descent()\n        w /= 64.0  # convert from subpixels\n        h /= 64.0\n        d /= 64.0\n        return w, h, d"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n\n        # It is generally faster to composite each image directly to\n        # the Figure, and there's no file size benefit to compositing\n        # with the Agg backend\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * self.dpi / 72"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/restore_region/xy",
          "name": "xy",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.restore_region.xy",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Restore the saved region. If bbox (instance of BboxBase, or\nits extents) is given, only the region specified by the bbox\nwill be restored. *xy* (a pair of floats) optionally\nspecifies the new position (the LLC of the original region,\nnot the LLC of the bbox) where the region will be restored.\n\n>>> region = renderer.copy_from_bbox()\n>>> x1, y1, x2, y2 = region.get_extents()\n>>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n...                         xy=(x1-dx, y1))",
      "docstring": "Restore the saved region. If bbox (instance of BboxBase, or\nits extents) is given, only the region specified by the bbox\nwill be restored. *xy* (a pair of floats) optionally\nspecifies the new position (the LLC of the original region,\nnot the LLC of the bbox) where the region will be restored.\n\n>>> region = renderer.copy_from_bbox()\n>>> x1, y1, x2, y2 = region.get_extents()\n>>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n...                         xy=(x1-dx, y1))",
      "code": "    def restore_region(self, region, bbox=None, xy=None):\n        \"\"\"\n        Restore the saved region. If bbox (instance of BboxBase, or\n        its extents) is given, only the region specified by the bbox\n        will be restored. *xy* (a pair of floats) optionally\n        specifies the new position (the LLC of the original region,\n        not the LLC of the bbox) where the region will be restored.\n\n        >>> region = renderer.copy_from_bbox()\n        >>> x1, y1, x2, y2 = region.get_extents()\n        >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),\n        ...                         xy=(x1-dx, y1))\n\n        \"\"\"\n        if bbox is not None or xy is not None:\n            if bbox is None:\n                x1, y1, x2, y2 = region.get_extents()\n            elif isinstance(bbox, BboxBase):\n                x1, y1, x2, y2 = bbox.extents\n            else:\n                x1, y1, x2, y2 = bbox\n\n            if xy is None:\n                ox, oy = x1, y1\n            else:\n                ox, oy = xy\n\n            # The incoming data is float, but the _renderer type-checking wants\n            # to see integers.\n            self._renderer.restore_region(region, int(x1), int(y1),\n                                          int(x2), int(y2), int(ox), int(oy))\n\n        else:\n            self._renderer.restore_region(region)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter",
      "name": "start_filter",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/start_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.start_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Start filtering. It simply create a new canvas (the old one is saved).",
      "docstring": "Start filtering. It simply create a new canvas (the old one is saved).",
      "code": "    def start_filter(self):\n        \"\"\"\n        Start filtering. It simply create a new canvas (the old one is saved).\n        \"\"\"\n        self._filter_renderers.append(self._renderer)\n        self._renderer = _RendererAgg(int(self.width), int(self.height),\n                                      self.dpi)\n        self._update_methods()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter",
      "name": "stop_filter",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/stop_filter/post_processing",
          "name": "post_processing",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.stop_filter.post_processing",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the plot in the current canvas as a image and apply\nthe *post_processing* function.\n\n   def post_processing(image, dpi):\n     # ny, nx, depth = image.shape\n     # image (numpy array) has RGBA channels and has a depth of 4.\n     ...\n     # create a new_image (numpy array of 4 channels, size can be\n     # different). The resulting image may have offsets from\n     # lower-left corner of the original image\n     return new_image, offset_x, offset_y\n\nThe saved renderer is restored and the returned image from\npost_processing is plotted (using draw_image) on it.",
      "docstring": "Save the plot in the current canvas as a image and apply\nthe *post_processing* function.\n\n   def post_processing(image, dpi):\n     # ny, nx, depth = image.shape\n     # image (numpy array) has RGBA channels and has a depth of 4.\n     ...\n     # create a new_image (numpy array of 4 channels, size can be\n     # different). The resulting image may have offsets from\n     # lower-left corner of the original image\n     return new_image, offset_x, offset_y\n\nThe saved renderer is restored and the returned image from\npost_processing is plotted (using draw_image) on it.",
      "code": "    def stop_filter(self, post_processing):\n        \"\"\"\n        Save the plot in the current canvas as a image and apply\n        the *post_processing* function.\n\n           def post_processing(image, dpi):\n             # ny, nx, depth = image.shape\n             # image (numpy array) has RGBA channels and has a depth of 4.\n             ...\n             # create a new_image (numpy array of 4 channels, size can be\n             # different). The resulting image may have offsets from\n             # lower-left corner of the original image\n             return new_image, offset_x, offset_y\n\n        The saved renderer is restored and the returned image from\n        post_processing is plotted (using draw_image) on it.\n        \"\"\"\n\n        width, height = int(self.width), int(self.height)\n\n        buffer, (l, b, w, h) = self.tostring_rgba_minimized()\n\n        self._renderer = self._filter_renderers.pop()\n        self._update_methods()\n\n        if w > 0 and h > 0:\n            img = np.frombuffer(buffer, np.uint8)\n            img, ox, oy = post_processing(img.reshape((h, w, 4)) / 255.,\n                                          self.dpi)\n            gc = self.new_gc()\n            if img.dtype.kind == 'f':\n                img = np.asarray(img * 255., np.uint8)\n            img = img[::-1]\n            self._renderer.draw_image(gc, l + ox, height - b - h + oy, img)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb",
      "name": "tostring_argb",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_argb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_argb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_argb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_argb(self):\n        return np.asarray(self._renderer).take([3, 0, 1, 2], axis=2).tobytes()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb",
      "name": "tostring_rgb",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_rgb(self):\n        return np.asarray(self._renderer).take([0, 1, 2], axis=2).tobytes()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgba_minimized",
      "name": "tostring_rgba_minimized",
      "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgba_minimized",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_agg/RendererAgg/tostring_rgba_minimized/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_agg.RendererAgg.tostring_rgba_minimized.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def tostring_rgba_minimized(self):\n        extents = self.get_content_extents()\n        bbox = [[extents[0], self.height - (extents[1] + extents[3])],\n                [extents[0] + extents[2], self.height - extents[1]]]\n        region = self.copy_from_bbox(bbox)\n        return np.array(region), extents"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_agg/get_hinting_flag",
      "name": "get_hinting_flag",
      "qname": "lib.matplotlib.backends.backend_agg.get_hinting_flag",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def get_hinting_flag():\n    mapping = {\n        'default': LOAD_DEFAULT,\n        'no_autohint': LOAD_NO_AUTOHINT,\n        'force_autohint': LOAD_FORCE_AUTOHINT,\n        'no_hinting': LOAD_NO_HINTING,\n        True: LOAD_FORCE_AUTOHINT,\n        False: LOAD_NO_HINTING,\n        'either': LOAD_DEFAULT,\n        'native': LOAD_NO_AUTOHINT,\n        'auto': LOAD_FORCE_AUTOHINT,\n        'none': LOAD_NO_HINTING,\n    }\n    return mapping[mpl.rcParams['text.hinting']]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox",
      "name": "copy_from_bbox",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/copy_from_bbox/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.copy_from_bbox.bbox",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def copy_from_bbox(self, bbox):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"copy_from_bbox only works when rendering to an ImageSurface\")\n        sw = surface.get_width()\n        sh = surface.get_height()\n        x0 = math.ceil(bbox.x0)\n        x1 = math.floor(bbox.x1)\n        y0 = math.ceil(sh - bbox.y1)\n        y1 = math.floor(sh - bbox.y0)\n        if not (0 <= x0 and x1 <= sw and bbox.x0 <= bbox.x1\n                and 0 <= y0 and y1 <= sh and bbox.y0 <= bbox.y1):\n            raise ValueError(\"Invalid bbox\")\n        sls = slice(y0, y0 + max(y1 - y0, 0)), slice(x0, x0 + max(x1 - x0, 0))\n        data = (np.frombuffer(surface.get_data(), np.uint32)\n                .reshape((sh, sw))[sls].copy())\n        return _CairoRegion(sls, data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_pdf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_pdf/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_pdf.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_pdf/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_pdf.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_pdf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_pdf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_pdf(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'pdf', *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png",
      "decorators": [
        "_check_savefig_extra_args"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_png/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_png.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_check_savefig_extra_args\n    def print_png(self, fobj):\n        self._get_printed_image_surface().write_to_png(fobj)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_ps",
      "name": "print_ps",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_ps",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_ps/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_ps.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_ps/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_ps.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_ps/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_ps.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_ps/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_ps.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_ps(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'ps', *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba",
      "name": "print_rgba",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba",
      "decorators": [
        "_check_savefig_extra_args"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_rgba/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_rgba.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_check_savefig_extra_args\n    def print_rgba(self, fobj):\n        width, height = self.get_width_height()\n        buf = self._get_printed_image_surface().get_data()\n        fobj.write(cbook._premultiplied_argb32_to_unmultiplied_rgba8888(\n            np.asarray(buf).reshape((width, height, 4))))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svg",
      "name": "print_svg",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svg",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svg/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svg.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svg/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svg.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_svg(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'svg', *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svgz",
      "name": "print_svgz",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svgz",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svgz/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svgz.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svgz/fobj",
          "name": "fobj",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svgz.fobj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svgz/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svgz.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/print_svgz/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.print_svgz.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_svgz(self, fobj, *args, **kwargs):\n        return self._save(fobj, 'svgz', *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region",
      "name": "restore_region",
      "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/FigureCanvasCairo/restore_region/region",
          "name": "region",
          "qname": "lib.matplotlib.backends.backend_cairo.FigureCanvasCairo.restore_region.region",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore_region(self, region):\n        surface = self._renderer.gc.ctx.get_target()\n        if not isinstance(surface, cairo.ImageSurface):\n            raise RuntimeError(\n                \"restore_region only works when rendering to an ImageSurface\")\n        surface.flush()\n        sw = surface.get_width()\n        sh = surface.get_height()\n        sly, slx = region._slices\n        (np.frombuffer(surface.get_data(), np.uint32)\n         .reshape((sh, sw))[sly, slx]) = region._data\n        surface.mark_dirty_rectangle(\n            slx.start, sly.start, slx.stop - slx.start, sly.stop - sly.start)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/__init__/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.__init__.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, renderer):\n        GraphicsContextBase.__init__(self)\n        self.renderer = renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb",
      "name": "get_rgb",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.get_rgb",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/get_rgb/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.get_rgb.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_rgb(self):\n        return self.ctx.get_source().get_rgba()[:3]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore",
      "name": "restore",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.restore",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/restore/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.restore.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def restore(self):\n        self.ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha",
      "name": "set_alpha",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_alpha/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_alpha.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_alpha(self, alpha):\n        GraphicsContextBase.set_alpha(self, alpha)\n        _alpha = self.get_alpha()\n        rgb = self._rgb\n        if self.get_forced_alpha():\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], _alpha)\n        else:\n            self.ctx.set_source_rgba(rgb[0], rgb[1], rgb[2], rgb[3])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle",
      "name": "set_capstyle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_capstyle/cs",
          "name": "cs",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_capstyle.cs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_capstyle(self, cs):\n        self.ctx.set_line_cap(cbook._check_getitem(self._capd, capstyle=cs))\n        self._capstyle = cs"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path",
      "name": "set_clip_path",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_path(self, path):\n        if not path:\n            return\n        tpath, affine = path.get_transformed_path_and_affine()\n        ctx = self.ctx\n        ctx.new_path()\n        affine = (affine\n                  + Affine2D().scale(1, -1).translate(0, self.renderer.height))\n        _append_path(ctx, tpath, affine)\n        ctx.clip()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle",
      "name": "set_clip_rectangle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_clip_rectangle/rectangle",
          "name": "rectangle",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_clip_rectangle.rectangle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_clip_rectangle(self, rectangle):\n        if not rectangle:\n            return\n        x, y, w, h = np.round(rectangle.bounds)\n        ctx = self.ctx\n        ctx.new_path()\n        ctx.rectangle(x, self.renderer.height - h - y, w, h)\n        ctx.clip()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes",
      "name": "set_dashes",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/offset",
          "name": "offset",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_dashes/dashes",
          "name": "dashes",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_dashes.dashes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_dashes(self, offset, dashes):\n        self._dashes = offset, dashes\n        if dashes is None:\n            self.ctx.set_dash([], 0)  # switch dashes off\n        else:\n            self.ctx.set_dash(\n                list(self.renderer.points_to_pixels(np.asarray(dashes))),\n                offset)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground",
      "name": "set_foreground",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/fg",
          "name": "fg",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.fg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_foreground/isRGBA",
          "name": "isRGBA",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_foreground.isRGBA",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_foreground(self, fg, isRGBA=None):\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n        if len(self._rgb) == 3:\n            self.ctx.set_source_rgb(*self._rgb)\n        else:\n            self.ctx.set_source_rgba(*self._rgb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle",
      "name": "set_joinstyle",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_joinstyle/js",
          "name": "js",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_joinstyle.js",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_joinstyle(self, js):\n        self.ctx.set_line_join(cbook._check_getitem(self._joind, joinstyle=js))\n        self._joinstyle = js"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/GraphicsContextCairo/set_linewidth/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_cairo.GraphicsContextCairo.set_linewidth.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, w):\n        self._linewidth = float(w)\n        self.ctx.set_line_width(self.renderer.points_to_pixels(w))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, dpi):\n        self.dpi = dpi\n        self.gc = GraphicsContextCairo(renderer=self)\n        self.text_ctx = cairo.Context(\n           cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1))\n        self.mathtext_parser = MathTextParser('Cairo')\n        RendererBase.__init__(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        im = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(im[::-1])\n        surface = cairo.ImageSurface.create_for_data(\n            im.ravel().data, cairo.FORMAT_ARGB32,\n            im.shape[1], im.shape[0], im.shape[1] * 4)\n        ctx = gc.ctx\n        y = self.height - y - im.shape[0]\n\n        ctx.save()\n        ctx.set_source_surface(surface, float(x), float(y))\n        ctx.paint()\n        ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, transform,\n                     rgbFace=None):\n        # docstring inherited\n\n        ctx = gc.ctx\n        ctx.new_path()\n        # Create the path for the marker; it needs to be flipped here already!\n        _append_path(ctx, marker_path, marker_trans + Affine2D().scale(1, -1))\n        marker_path = ctx.copy_path_flat()\n\n        # Figure out whether the path has a fill\n        x1, y1, x2, y2 = ctx.fill_extents()\n        if x1 == 0 and y1 == 0 and x2 == 0 and y2 == 0:\n            filled = False\n            # No fill, just unset this (so we don't try to fill it later on)\n            rgbFace = None\n        else:\n            filled = True\n\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n\n        ctx.new_path()\n        for i, (vertices, codes) in enumerate(\n                path.iter_segments(transform, simplify=False)):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ctx.save()\n\n                # Translate and apply path\n                ctx.translate(x, y)\n                ctx.append_path(marker_path)\n\n                ctx.restore()\n\n                # Slower code path if there is a fill; we need to draw\n                # the fill and stroke for each marker at the same time.\n                # Also flush out the drawing every once in a while to\n                # prevent the paths from getting way too long.\n                if filled or i % 1000 == 0:\n                    self._fill_and_stroke(\n                        ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())\n\n        # Fast path, if there is no fill, draw everything in one step\n        if not filled:\n            self._fill_and_stroke(\n                ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        ctx = gc.ctx\n        # Clip the path to the actual rendering extents if it isn't filled.\n        clip = (ctx.clip_extents()\n                if rgbFace is None and gc.get_hatch() is None\n                else None)\n        transform = (transform\n                     + Affine2D().scale(1, -1).translate(0, self.height))\n        ctx.new_path()\n        _append_path(ctx, path, transform, clip)\n        self._fill_and_stroke(\n            ctx, rgbFace, gc.get_alpha(), gc.get_forced_alpha())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # Note: (x, y) are device/display coords, not user-coords, unlike other\n        # draw_* methods\n        if ismath:\n            self._draw_mathtext(gc, x, y, s, prop, angle)\n\n        else:\n            ctx = gc.ctx\n            ctx.new_path()\n            ctx.move_to(x, y)\n\n            ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n            ctx.save()\n            ctx.set_font_size(prop.get_size_in_points() * self.dpi / 72)\n            if angle:\n                ctx.rotate(np.deg2rad(-angle))\n            ctx.show_text(s)\n            ctx.restore()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/fontangles@getter",
      "name": "fontangles",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.fontangles",
      "decorators": [
        "cbook.deprecated('3.3')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/fontangles@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.fontangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    @property\n    def fontangles(self):\n        return {\n            'italic':  cairo.FONT_SLANT_ITALIC,\n            'normal':  cairo.FONT_SLANT_NORMAL,\n            'oblique': cairo.FONT_SLANT_OBLIQUE,\n        }"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/fontweights@getter",
      "name": "fontweights",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.fontweights",
      "decorators": [
        "cbook.deprecated('3.3')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/fontweights@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.fontweights.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    @property\n    def fontweights(self):\n        return {\n            100:          cairo.FONT_WEIGHT_NORMAL,\n            200:          cairo.FONT_WEIGHT_NORMAL,\n            300:          cairo.FONT_WEIGHT_NORMAL,\n            400:          cairo.FONT_WEIGHT_NORMAL,\n            500:          cairo.FONT_WEIGHT_NORMAL,\n            600:          cairo.FONT_WEIGHT_BOLD,\n            700:          cairo.FONT_WEIGHT_BOLD,\n            800:          cairo.FONT_WEIGHT_BOLD,\n            900:          cairo.FONT_WEIGHT_BOLD,\n            'ultralight': cairo.FONT_WEIGHT_NORMAL,\n            'light':      cairo.FONT_WEIGHT_NORMAL,\n            'normal':     cairo.FONT_WEIGHT_NORMAL,\n            'medium':     cairo.FONT_WEIGHT_NORMAL,\n            'regular':    cairo.FONT_WEIGHT_NORMAL,\n            'semibold':   cairo.FONT_WEIGHT_BOLD,\n            'bold':       cairo.FONT_WEIGHT_BOLD,\n            'heavy':      cairo.FONT_WEIGHT_BOLD,\n            'ultrabold':  cairo.FONT_WEIGHT_BOLD,\n            'black':      cairo.FONT_WEIGHT_BOLD,\n        }"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            width, height, descent, fonts, used_characters = \\\n                self.mathtext_parser.parse(s, self.dpi, prop)\n            return width, height, descent\n\n        ctx = self.text_ctx\n        # problem - scale remembers last setting and font can become\n        # enormous causing program to crash\n        # save/restore prevents the problem\n        ctx.save()\n        ctx.select_font_face(*_cairo_font_args_from_font_prop(prop))\n        # Cairo (says it) uses 1/96 inch user space units, ref: cairo_gstate.c\n        # but if /96.0 is used the font is too small\n        ctx.set_font_size(prop.get_size_in_points() * self.dpi / 72)\n\n        y_bearing, w, h = ctx.text_extents(s)[1:4]\n        ctx.restore()\n\n        return w, h, h + y_bearing"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        self.gc.ctx.save()\n        self.gc._alpha = 1\n        self.gc._forced_alpha = False  # if True, _alpha overrides A from RGBA\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points / 72 * self.dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface",
      "name": "set_ctx_from_surface",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_ctx_from_surface/surface",
          "name": "surface",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_ctx_from_surface.surface",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_ctx_from_surface(self, surface):\n        self.gc.ctx = cairo.Context(surface)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height",
      "name": "set_width_height",
      "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_cairo/RendererCairo/set_width_height/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_cairo.RendererCairo.set_width_height.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_width_height(self, width, height):\n        self.width = width\n        self.height = height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.destroy",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def destroy(self, *args):\n        self.window.destroy()\n        self.window = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/init_window",
      "name": "init_window",
      "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.init_window",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/init_window/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.init_window.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def init_window(self):\n        if self.window:\n            return\n        self.window = Gtk.Window(title=\"Subplot Configuration Tool\")\n\n        try:\n            self.window.window.set_icon_from_file(window_icon)\n        except Exception:\n            # we presumably already logged a message on the\n            # failure of the main plot, don't keep reporting\n            pass\n\n        self.vbox = Gtk.Box()\n        self.vbox.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.window.add(self.vbox)\n        self.vbox.show()\n        self.window.connect('destroy', self.destroy)\n\n        toolfig = Figure(figsize=(6, 3))\n        canvas = self.figure.canvas.__class__(toolfig)\n\n        toolfig.subplots_adjust(top=0.9)\n        SubplotTool(self.figure, toolfig)\n\n        w = int(toolfig.bbox.width)\n        h = int(toolfig.bbox.height)\n\n        self.window.set_default_size(w, h)\n\n        canvas.show()\n        self.vbox.pack_start(canvas, True, True, 0)\n        self.window.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2GTK3.configure_subplots(\n            self._make_classic_style_pseudo_toolbar(), None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@getter",
      "name": "window",
      "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.window",
      "decorators": [
        "cbook.deprecated('3.2')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.window.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    @property\n    def window(self):\n        if not hasattr(self, \"_window\"):\n            self._window = None\n        return self._window"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@setter",
      "name": "window",
      "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.window",
      "decorators": [
        "window.setter",
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.window.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ConfigureSubplotsGTK3/window@setter/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_gtk3.ConfigureSubplotsGTK3.window.window",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @window.setter\n    @cbook.deprecated(\"3.2\")\n    def window(self, window):\n        self._window = window"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        FigureCanvasBase.__init__(self, figure)\n        GObject.GObject.__init__(self)\n\n        self._idle_draw_id = 0\n        self._lastCursor = None\n        self._rubberband_rect = None\n\n        self.connect('scroll_event',         self.scroll_event)\n        self.connect('button_press_event',   self.button_press_event)\n        self.connect('button_release_event', self.button_release_event)\n        self.connect('configure_event',      self.configure_event)\n        self.connect('draw',                 self.on_draw_event)\n        self.connect('draw',                 self._post_draw)\n        self.connect('key_press_event',      self.key_press_event)\n        self.connect('key_release_event',    self.key_release_event)\n        self.connect('motion_notify_event',  self.motion_notify_event)\n        self.connect('leave_notify_event',   self.leave_notify_event)\n        self.connect('enter_notify_event',   self.enter_notify_event)\n        self.connect('size_allocate',        self.size_allocate)\n\n        self.set_events(self.__class__.event_mask)\n\n        self.set_double_buffered(True)\n        self.set_can_focus(True)\n\n        renderer_init = cbook._deprecate_method_override(\n            __class__._renderer_init, self, allow_empty=True, since=\"3.3\",\n            addendum=\"Please initialize the renderer, if needed, in the \"\n            \"subclass' __init__; a fully empty _renderer_init implementation \"\n            \"may be kept for compatibility with earlier versions of \"\n            \"Matplotlib.\")\n        if renderer_init:\n            renderer_init()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event",
      "name": "button_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_press_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_press_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_press_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        FigureCanvasBase.button_press_event(\n            self, x, y, event.button, guiEvent=event)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event",
      "name": "button_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/button_release_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.button_release_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def button_release_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        FigureCanvasBase.button_release_event(\n            self, x, y, event.button, guiEvent=event)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event",
      "name": "configure_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/configure_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.configure_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_event(self, widget, event):\n        if widget.get_property(\"window\") is None:\n            return\n        w, h = event.width, event.height\n        if w < 3 or h < 3:\n            return  # empty fig\n        # resize the figure (in inches)\n        dpi = self.figure.dpi\n        self.figure.set_size_inches(w / dpi, h / dpi, forward=False)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        #Gtk.DrawingArea.destroy(self)\n        self.close_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        if self.is_drawable():\n            self.queue_draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        # docstring inherited\n        if self._idle_draw_id != 0:\n            return\n        def idle_draw(*args):\n            try:\n                self.draw()\n            finally:\n                self._idle_draw_id = 0\n            return False\n        self._idle_draw_id = GLib.idle_add(idle_draw)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event",
      "name": "enter_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/enter_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.enter_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enter_notify_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        FigureCanvasBase.enter_notify_event(self, guiEvent=event, xy=(x, y))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        Gdk.threads_enter()\n        while Gtk.events_pending():\n            Gtk.main_iteration()\n        Gdk.flush()\n        Gdk.threads_leave()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event",
      "name": "key_press_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_press_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_press_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_press_event(self, widget, event):\n        key = self._get_key(event)\n        FigureCanvasBase.key_press_event(self, key, guiEvent=event)\n        return True  # stop event propagation"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event",
      "name": "key_release_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/key_release_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.key_release_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def key_release_event(self, widget, event):\n        key = self._get_key(event)\n        FigureCanvasBase.key_release_event(self, key, guiEvent=event)\n        return True  # stop event propagation"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event",
      "name": "leave_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/leave_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.leave_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leave_notify_event(self, widget, event):\n        FigureCanvasBase.leave_notify_event(self, event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event",
      "name": "motion_notify_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/motion_notify_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.motion_notify_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def motion_notify_event(self, widget, event):\n        if event.is_hint:\n            t, x, y, state = event.window.get_pointer()\n        else:\n            x, y = event.x, event.y\n\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - y\n        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_draw_event(self, widget, ctx):\n        # to be overwritten by GTK3Agg or GTK3Cairo\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event",
      "name": "scroll_event",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/scroll_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.scroll_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def scroll_event(self, widget, event):\n        x = event.x\n        # flipy so y=0 is bottom of canvas\n        y = self.get_allocation().height - event.y\n        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n        FigureCanvasBase.scroll_event(self, x, y, step, guiEvent=event)\n        return False  # finish event propagation?"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate",
      "name": "size_allocate",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureCanvasGTK3/size_allocate/allocation",
          "name": "allocation",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureCanvasGTK3.size_allocate.allocation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def size_allocate(self, widget, allocation):\n        dpival = self.figure.dpi\n        winch = allocation.width / dpival\n        hinch = allocation.height / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        FigureCanvasBase.resize_event(self)\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n\n        self.window = Gtk.Window()\n        self.window.set_wmclass(\"matplotlib\", \"Matplotlib\")\n        self.set_window_title(\"Figure %d\" % num)\n        try:\n            self.window.set_icon_from_file(window_icon)\n        except Exception:\n            # Some versions of gtk throw a glib.GError but not all, so I am not\n            # sure how to catch it.  I am unhappy doing a blanket catch here,\n            # but am not sure what a better way is - JDH\n            _log.info('Could not load matplotlib icon: %s', sys.exc_info()[1])\n\n        self.vbox = Gtk.Box()\n        self.vbox.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        self.window.add(self.vbox)\n        self.vbox.show()\n\n        self.canvas.show()\n\n        self.vbox.pack_start(self.canvas, True, True, 0)\n        # calculate size for window\n        w = int(self.canvas.figure.bbox.width)\n        h = int(self.canvas.figure.bbox.height)\n\n        self.toolbar = self._get_toolbar()\n\n        def add_widget(child):\n            child.show()\n            self.vbox.pack_end(child, False, False, 0)\n            size_request = child.size_request()\n            return size_request.height\n\n        if self.toolmanager:\n            backend_tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                backend_tools.add_tools_to_container(self.toolbar)\n\n        if self.toolbar is not None:\n            self.toolbar.show()\n            h += add_widget(self.toolbar)\n\n        self.window.set_default_size(w, h)\n\n        self._destroying = False\n        self.window.connect(\"destroy\", lambda *args: Gcf.destroy(self))\n        self.window.connect(\"delete_event\", lambda *args: Gcf.destroy(self))\n        if mpl.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        self.canvas.grab_focus()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        if self._destroying:\n            # Otherwise, this can be called twice when the user presses 'q',\n            # which calls Gcf.destroy(self), then this destroy(), then triggers\n            # Gcf.destroy(self) once again via\n            # `connect(\"destroy\", lambda *args: Gcf.destroy(self))`.\n            return\n        self._destroying = True\n        self.vbox.destroy()\n        self.window.destroy()\n        self.canvas.destroy()\n        if self.toolbar:\n            self.toolbar.destroy()\n\n        if (Gcf.get_num_fig_managers() == 0 and not mpl.is_interactive() and\n                Gtk.main_level() >= 1):\n            Gtk.main_quit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/full_screen_toggle",
      "name": "full_screen_toggle",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.full_screen_toggle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/full_screen_toggle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.full_screen_toggle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def full_screen_toggle(self):\n        self._full_screen_flag = not self._full_screen_flag\n        if self._full_screen_flag:\n            self.window.fullscreen()\n        else:\n            self.window.unfullscreen()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        return self.window.get_title()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the canvas size in pixels.",
      "docstring": "Set the canvas size in pixels.",
      "code": "    def resize(self, width, height):\n        \"\"\"Set the canvas size in pixels.\"\"\"\n        if self.toolbar:\n            toolbar_size = self.toolbar.size_request()\n            height += toolbar_size.height\n        canvas_size = self.canvas.get_allocation()\n        if canvas_size.width == canvas_size.height == 1:\n            # A canvas size of (1, 1) cannot exist in most cases, because\n            # window decorations would prevent such a small window. This call\n            # must be before the window has been mapped and widgets have been\n            # sized, so just change the window's starting size.\n            self.window.set_default_size(width, height)\n        else:\n            self.window.resize(width, height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self.window.set_title(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/FigureManagerGTK3/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.FigureManagerGTK3.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # show the figure window\n        self.window.show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.window.present()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/HelpGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.HelpGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        if Gtk.check_version(3, 20, 0) is None:\n            self._show_shortcuts_window()\n        else:\n            self._show_shortcuts_dialog()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/__init__/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.__init__.window",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, window):\n        self.win = window\n        GObject.GObject.__init__(self)\n\n        self.set_style(Gtk.ToolbarStyle.ICONS)\n\n        self._gtk_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.insert(Gtk.SeparatorToolItem(), -1)\n                continue\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(\n                    str(cbook._get_data_path('images',\n                                             f'{image_file}-symbolic.svg'))),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            self._gtk_ids[text] = tbutton = (\n                Gtk.ToggleToolButton() if callback in ['zoom', 'pan'] else\n                Gtk.ToolButton())\n            tbutton.set_label(text)\n            tbutton.set_icon_widget(image)\n            self.insert(tbutton, -1)\n            # Save the handler id, so that we can block it as needed.\n            tbutton._signal_handler = tbutton.connect(\n                'clicked', getattr(self, callback))\n            tbutton.set_tooltip_text(tooltip_text)\n\n        toolitem = Gtk.SeparatorToolItem()\n        self.insert(toolitem, -1)\n        toolitem.set_draw(False)\n        toolitem.set_expand(True)\n\n        # This filler item ensures the toolbar is always at least two text\n        # lines high. Otherwise the canvas gets redrawn as the mouse hovers\n        # over images because those use two-line messages which resize the\n        # toolbar.\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        label = Gtk.Label()\n        label.set_markup(\n            '<small>\\N{NO-BREAK SPACE}\\n\\N{NO-BREAK SPACE}</small>')\n        toolitem.add(label)\n\n        toolitem = Gtk.ToolItem()\n        self.insert(toolitem, -1)\n        self.message = Gtk.Label()\n        toolitem.add(self.message)\n\n        self.show_all()\n\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/configure_subplots",
      "name": "configure_subplots",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.configure_subplots",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/configure_subplots/button",
          "name": "button",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.configure_subplots.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_subplots(self, button):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = type(self.canvas)(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n\n        w = int(toolfig.bbox.width)\n        h = int(toolfig.bbox.height)\n\n        window = Gtk.Window()\n        try:\n            window.set_icon_from_file(window_icon)\n        except Exception:\n            # we presumably already logged a message on the\n            # failure of the main plot, don't keep reporting\n            pass\n        window.set_title(\"Subplot Configuration Tool\")\n        window.set_default_size(w, h)\n        vbox = Gtk.Box()\n        vbox.set_property(\"orientation\", Gtk.Orientation.VERTICAL)\n        window.add(vbox)\n        vbox.show()\n\n        canvas.show()\n        vbox.pack_start(canvas, True, True, 0)\n        window.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/ctx@getter",
      "name": "ctx",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.ctx",
      "decorators": [
        "cbook.deprecated('3.3')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/ctx@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.ctx.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    @property\n    def ctx(self):\n        return self.canvas.get_property(\"window\").cairo_create()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas._draw_rubberband(rect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas._draw_rubberband(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        dialog = Gtk.FileChooserDialog(\n            title=\"Save the figure\",\n            parent=self.canvas.get_toplevel(),\n            action=Gtk.FileChooserAction.SAVE,\n            buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,\n                     Gtk.STOCK_SAVE,   Gtk.ResponseType.OK),\n        )\n        for name, fmts \\\n                in self.canvas.get_supported_filetypes_grouped().items():\n            ff = Gtk.FileFilter()\n            ff.set_name(name)\n            for fmt in fmts:\n                ff.add_pattern(\"*.\" + fmt)\n            dialog.add_filter(ff)\n            if self.canvas.get_default_filetype() in fmts:\n                dialog.set_filter(ff)\n\n        @functools.partial(dialog.connect, \"notify::filter\")\n        def on_notify_filter(*args):\n            name = dialog.get_filter().get_name()\n            fmt = self.canvas.get_supported_filetypes_grouped()[name][0]\n            dialog.set_current_name(\n                str(Path(dialog.get_current_name()).with_suffix(\".\" + fmt)))\n\n        dialog.set_current_folder(mpl.rcParams[\"savefig.directory\"])\n        dialog.set_current_name(self.canvas.get_default_filename())\n        dialog.set_do_overwrite_confirmation(True)\n\n        response = dialog.run()\n        fname = dialog.get_filename()\n        ff = dialog.get_filter()  # Doesn't autoadjust to filename :/\n        fmt = self.canvas.get_supported_filetypes_grouped()[ff.get_name()][0]\n        dialog.destroy()\n        if response != Gtk.ResponseType.OK:\n            return\n        # Save dir for next time, unless empty str (which means use cwd).\n        if mpl.rcParams['savefig.directory']:\n            mpl.rcParams['savefig.directory'] = os.path.dirname(fname)\n        try:\n            self.canvas.figure.savefig(fname, format=fmt)\n        except Exception as e:\n            error_msg_gtk(str(e), parent=self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        window = self.canvas.get_property(\"window\")\n        if window is not None:\n            window.set_cursor(cursord[cursor])\n            Gtk.main_iteration()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self._gtk_ids:\n            self._gtk_ids['Back'].set_sensitive(can_backward)\n        if 'Forward' in self._gtk_ids:\n            self._gtk_ids['Forward'].set_sensitive(can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        escaped = GLib.markup_escape_text(s)\n        self.message.set_markup(f'<small>{escaped}</small>')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/NavigationToolbar2GTK3/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.NavigationToolbar2GTK3.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2GTK3.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/RubberbandGTK3/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.RubberbandGTK3.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        NavigationToolbar2GTK3.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SaveFigureGTK3/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.SaveFigureGTK3.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n\n        class PseudoToolbar:\n            canvas = self.figure.canvas\n\n        return NavigationToolbar2GTK3.save_figure(PseudoToolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/SetCursorGTK3/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_gtk3.SetCursorGTK3.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2GTK3.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        StatusbarBase.__init__(self, *args, **kwargs)\n        Gtk.Statusbar.__init__(self)\n        self._context = self.get_context_id('message')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/StatusbarGTK3/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk3.StatusbarGTK3.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.pop(self._context)\n        self.push(self._context, s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.TimerGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.TimerGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.TimerGTK3.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/TimerGTK3/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.TimerGTK3.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using GTK3 timer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = None\n        TimerBase.__init__(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolCopyToClipboardGTK3/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolCopyToClipboardGTK3.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)\n        window = self.canvas.get_window()\n        x, y, width, height = window.get_geometry()\n        pb = Gdk.pixbuf_get_from_window(window, x, y, width, height)\n        clipboard.set_image(pb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager):\n        ToolContainerBase.__init__(self, toolmanager)\n        Gtk.Box.__init__(self)\n        self.set_property('orientation', Gtk.Orientation.HORIZONTAL)\n        self._message = Gtk.Label()\n        self.pack_end(self._message, False, False, 0)\n        self.show_all()\n        self._groups = {}\n        self._toolitems = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        if toggle:\n            tbutton = Gtk.ToggleToolButton()\n        else:\n            tbutton = Gtk.ToolButton()\n        tbutton.set_label(name)\n\n        if image_file is not None:\n            image = Gtk.Image.new_from_gicon(\n                Gio.Icon.new_for_string(image_file),\n                Gtk.IconSize.LARGE_TOOLBAR)\n            tbutton.set_icon_widget(image)\n\n        if position is None:\n            position = -1\n\n        self._add_button(tbutton, group, position)\n        signal = tbutton.connect('clicked', self._call_tool, name)\n        tbutton.set_tooltip_text(description)\n        tbutton.show_all()\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tbutton, signal))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        if name not in self._toolitems:\n            self.toolmanager.message_event('%s Not in toolbar' % name, self)\n            return\n\n        for group in self._groups:\n            for toolitem, _signal in self._toolitems[name]:\n                if toolitem in self._groups[group]:\n                    self._groups[group].remove(toolitem)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._message.set_label(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/ToolbarGTK3/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_gtk3.ToolbarGTK3.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for toolitem, signal in self._toolitems[name]:\n            toolitem.handler_block(signal)\n            toolitem.set_active(toggled)\n            toolitem.handler_unblock(signal)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk",
      "name": "error_msg_gtk",
      "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk/msg",
          "name": "msg",
          "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk.msg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3/error_msg_gtk/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_gtk3.error_msg_gtk.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def error_msg_gtk(msg, parent=None):\n    if parent is not None:  # find the toplevel Gtk.Window\n        parent = parent.get_toplevel()\n        if not parent.is_toplevel():\n            parent = None\n    if not isinstance(msg, str):\n        msg = ','.join(map(str, msg))\n    dialog = Gtk.MessageDialog(\n        parent=parent, type=Gtk.MessageType.ERROR, buttons=Gtk.ButtonsType.OK,\n        message_format=msg)\n    dialog.run()\n    dialog.destroy()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        backend_gtk3.FigureCanvasGTK3.__init__(self, figure)\n        self._bbox_queue = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # If bbox is None, blit the entire canvas to gtk. Otherwise\n        # blit only the area defined by the bbox.\n        if bbox is None:\n            bbox = self.figure.bbox\n\n        allocation = self.get_allocation()\n        x = int(bbox.x0)\n        y = allocation.height - int(bbox.y1)\n        width = int(bbox.x1) - int(bbox.x0)\n        height = int(bbox.y1) - int(bbox.y0)\n\n        self._bbox_queue.append(bbox)\n        self.queue_draw_area(x, y, width, height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        backend_agg.FigureCanvasAgg.draw(self)\n        super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "GtkDrawable draw event, like expose_event in GTK 2.X.",
      "docstring": "GtkDrawable draw event, like expose_event in GTK 2.X.",
      "code": "    def on_draw_event(self, widget, ctx):\n        \"\"\"GtkDrawable draw event, like expose_event in GTK 2.X.\"\"\"\n        allocation = self.get_allocation()\n        w, h = allocation.width, allocation.height\n\n        if not len(self._bbox_queue):\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            bbox_queue = [transforms.Bbox([[0, 0], [w, h]])]\n        else:\n            bbox_queue = self._bbox_queue\n\n        ctx = backend_cairo._to_context(ctx)\n\n        for bbox in bbox_queue:\n            x = int(bbox.x0)\n            y = h - int(bbox.y1)\n            width = int(bbox.x1) - int(bbox.x0)\n            height = int(bbox.y1) - int(bbox.y0)\n\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                np.asarray(self.copy_from_bbox(bbox)))\n            image = cairo.ImageSurface.create_for_data(\n                buf.ravel().data, cairo.FORMAT_ARGB32, width, height)\n            ctx.set_source_surface(image, x, y)\n            ctx.paint()\n\n        if len(self._bbox_queue):\n            self._bbox_queue = []\n\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/print_png/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.print_png.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/print_png/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.print_png.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3agg/FigureCanvasGTK3Agg/print_png/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_gtk3agg.FigureCanvasGTK3Agg.print_png.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_png(self, filename, *args, **kwargs):\n        # Do this so we can save the resolution of figure in the PNG file\n        agg = self.switch_backends(backend_agg.FigureCanvasAgg)\n        return agg.print_png(filename, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        super().__init__(figure)\n        self._renderer = RendererGTK3Cairo(self.figure.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event",
      "name": "on_draw_event",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/widget",
          "name": "widget",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.widget",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/FigureCanvasGTK3Cairo/on_draw_event/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.FigureCanvasGTK3Cairo.on_draw_event.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "GtkDrawable draw event.",
      "docstring": "GtkDrawable draw event.",
      "code": "    def on_draw_event(self, widget, ctx):\n        \"\"\"GtkDrawable draw event.\"\"\"\n        with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar\n              else nullcontext()):\n            self._renderer.set_context(ctx)\n            allocation = self.get_allocation()\n            Gtk.render_background(\n                self.get_style_context(), ctx,\n                allocation.x, allocation.y,\n                allocation.width, allocation.height)\n            self._renderer.set_width_height(\n                allocation.width, allocation.height)\n            self.figure.draw(self._renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/RendererGTK3Cairo/set_context",
      "name": "set_context",
      "qname": "lib.matplotlib.backends.backend_gtk3cairo.RendererGTK3Cairo.set_context",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/RendererGTK3Cairo/set_context/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.RendererGTK3Cairo.set_context.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_gtk3cairo/RendererGTK3Cairo/set_context/ctx",
          "name": "ctx",
          "qname": "lib.matplotlib.backends.backend_gtk3cairo.RendererGTK3Cairo.set_context.ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_context(self, ctx):\n        self.gc.ctx = backend_cairo._to_context(ctx)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The canvas the figure renders into.  Calls the draw and print fig\nmethods, creates the renderers, etc...\n\nEvents such as button presses, mouse movements, and key presses\nare handled in the C code and the base class methods\nbutton_press_event, button_release_event, motion_notify_event,\nkey_press_event, and key_release_event are called from there.",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        FigureCanvasBase.__init__(self, figure)\n        width, height = self.get_width_height()\n        _macosx.FigureCanvas.__init__(self, width, height)\n        self._dpi_ratio = 1.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        # docstring inherited\n        self.draw_idle()\n        self.flush_events()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/invalidate",
      "name": "invalidate",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.invalidate",
      "decorators": [
        "cbook.deprecated('3.2', alternative='draw_idle()')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/invalidate/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.invalidate.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\", alternative=\"draw_idle()\")\n    def invalidate(self):\n        return self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureCanvasMac/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureCanvasMac.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        dpi = self.figure.dpi\n        width /= dpi\n        height /= dpi\n        self.figure.set_size_inches(width * self._dpi_ratio,\n                                    height * self._dpi_ratio,\n                                    forward=False)\n        FigureCanvasBase.resize_event(self)\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Wrap everything up into a window for the pylab interface",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n        title = \"Figure %d\" % num\n        _macosx.FigureManager.__init__(self, canvas, title)\n        if mpl.rcParams['toolbar'] == 'toolbar2':\n            self.toolbar = NavigationToolbar2Mac(canvas)\n        else:\n            self.toolbar = None\n        if self.toolbar is not None:\n            self.toolbar.update()\n\n        if mpl.is_interactive():\n            self.show()\n            self.canvas.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/FigureManagerMac/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.FigureManagerMac.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def close(self):\n        Gcf.destroy(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas):\n        self.canvas = canvas  # Needed by the _macosx __init__.\n        data_path = cbook._get_data_path('images')\n        _, tooltips, image_names, _ = zip(*NavigationToolbar2.toolitems)\n        _macosx.NavigationToolbar2.__init__(\n            self,\n            tuple(str(data_path / image_name) + \".pdf\"\n                  for image_name in image_names if image_name is not None),\n            tuple(tooltip for tooltip in tooltips if tooltip is not None))\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.set_rubberband(int(x0), int(y0), int(x1), int(y1))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots",
      "name": "prepare_configure_subplots",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.prepare_configure_subplots",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/prepare_configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.prepare_configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def prepare_configure_subplots(self):\n        toolfig = Figure(figsize=(6, 3))\n        canvas = FigureCanvasMac(toolfig)\n        toolfig.subplots_adjust(top=0.9)\n        # Need to keep a reference to the tool.\n        _tool = SubplotTool(self.canvas.figure, toolfig)\n        return canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/release_zoom",
      "name": "release_zoom",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.release_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/release_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.release_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/release_zoom/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.release_zoom.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def release_zoom(self, event):\n        super().release_zoom(event)\n        self.canvas.remove_rubberband()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        filename = _macosx.choose_save_file('Save the figure',\n                                            self.canvas.get_default_filename())\n        if filename is None:  # Cancel\n            return\n        self.canvas.figure.savefig(filename)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        _macosx.set_cursor(cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_macosx/NavigationToolbar2Mac/set_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_macosx.NavigationToolbar2Mac.set_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, message):\n        _macosx.NavigationToolbar2.set_message(self, message.encode('utf-8'))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__",
      "name": "__getattr__",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__getattr__/attr",
          "name": "attr",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__getattr__.attr",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getattr__(self, attr):\n        # Proxy everything that hasn't been overridden to the base\n        # renderer. Things that *are* overridden can call methods\n        # on self._renderer directly, but must not cache/store\n        # methods (because things like RendererAgg change their\n        # methods on the fly in order to optimise proxying down\n        # to the underlying C implementation).\n        return getattr(self._renderer, attr)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/vector_renderer",
          "name": "vector_renderer",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.vector_renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/raster_renderer_class",
          "name": "raster_renderer_class",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.raster_renderer_class",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/__init__/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.__init__.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper class to implement a renderer that switches between\nvector and raster drawing.  An example may be a PDF writer, where\nmost things are drawn with PDF vector commands, but some very\ncomplex objects, such as quad meshes, are rasterised and then\noutput as images.",
      "docstring": "Parameters\n----------\nfigure : `matplotlib.figure.Figure`\n    The figure instance.\n\nwidth : scalar\n    The width of the canvas in logical units\n\nheight : scalar\n    The height of the canvas in logical units\n\ndpi : float\n    The dpi of the canvas\n\nvector_renderer : `matplotlib.backend_bases.RendererBase`\n    An instance of a subclass of\n    `~matplotlib.backend_bases.RendererBase` that will be used for the\n    vector drawing.\n\nraster_renderer_class : `matplotlib.backend_bases.RendererBase`\n    The renderer class to use for the raster drawing.  If not provided,\n    this will use the Agg backend (which is currently the only viable\n    option anyway.)",
      "code": "    def __init__(self, figure, width, height, dpi, vector_renderer,\n                 raster_renderer_class=None,\n                 bbox_inches_restore=None):\n        \"\"\"\n        Parameters\n        ----------\n        figure : `matplotlib.figure.Figure`\n            The figure instance.\n\n        width : scalar\n            The width of the canvas in logical units\n\n        height : scalar\n            The height of the canvas in logical units\n\n        dpi : float\n            The dpi of the canvas\n\n        vector_renderer : `matplotlib.backend_bases.RendererBase`\n            An instance of a subclass of\n            `~matplotlib.backend_bases.RendererBase` that will be used for the\n            vector drawing.\n\n        raster_renderer_class : `matplotlib.backend_bases.RendererBase`\n            The renderer class to use for the raster drawing.  If not provided,\n            this will use the Agg backend (which is currently the only viable\n            option anyway.)\n\n        \"\"\"\n        if raster_renderer_class is None:\n            raster_renderer_class = RendererAgg\n\n        self._raster_renderer_class = raster_renderer_class\n        self._width = width\n        self._height = height\n        self.dpi = dpi\n\n        self._vector_renderer = vector_renderer\n\n        self._raster_renderer = None\n        self._rasterizing = 0\n\n        # A reference to the figure is needed as we need to change\n        # the figure dpi before and after the rasterization. Although\n        # this looks ugly, I couldn't find a better solution. -JJL\n        self.figure = figure\n        self._figdpi = figure.get_dpi()\n\n        self._bbox_inches_restore = bbox_inches_restore\n\n        self._renderer = vector_renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing",
      "name": "start_rasterizing",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.start_rasterizing",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/start_rasterizing/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.start_rasterizing.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Enter \"raster\" mode.  All subsequent drawing commands (until\n`stop_rasterizing` is called) will be drawn with the raster backend.",
      "docstring": "Enter \"raster\" mode.  All subsequent drawing commands (until\n`stop_rasterizing` is called) will be drawn with the raster backend.",
      "code": "    def start_rasterizing(self):\n        \"\"\"\n        Enter \"raster\" mode.  All subsequent drawing commands (until\n        `stop_rasterizing` is called) will be drawn with the raster backend.\n        \"\"\"\n        # change the dpi of the figure temporarily.\n        self.figure.set_dpi(self.dpi)\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore)\n            self._bbox_inches_restore = r\n        if self._rasterizing == 0:\n            self._raster_renderer = self._raster_renderer_class(\n                self._width*self.dpi, self._height*self.dpi, self.dpi)\n            self._renderer = self._raster_renderer\n        self._rasterizing += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing",
      "name": "stop_rasterizing",
      "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.stop_rasterizing",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_mixed/MixedModeRenderer/stop_rasterizing/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_mixed.MixedModeRenderer.stop_rasterizing.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Exit \"raster\" mode.  All of the drawing that was done since\nthe last `start_rasterizing` call will be copied to the\nvector backend by calling draw_image.\n\nIf `start_rasterizing` has been called multiple times,\n`stop_rasterizing` must be called the same number of times before\n\"raster\" mode is exited.",
      "docstring": "Exit \"raster\" mode.  All of the drawing that was done since\nthe last `start_rasterizing` call will be copied to the\nvector backend by calling draw_image.\n\nIf `start_rasterizing` has been called multiple times,\n`stop_rasterizing` must be called the same number of times before\n\"raster\" mode is exited.",
      "code": "    def stop_rasterizing(self):\n        \"\"\"\n        Exit \"raster\" mode.  All of the drawing that was done since\n        the last `start_rasterizing` call will be copied to the\n        vector backend by calling draw_image.\n\n        If `start_rasterizing` has been called multiple times,\n        `stop_rasterizing` must be called the same number of times before\n        \"raster\" mode is exited.\n        \"\"\"\n        self._rasterizing -= 1\n        if self._rasterizing == 0:\n            self._renderer = self._vector_renderer\n\n            height = self._height * self.dpi\n            buffer, bounds = self._raster_renderer.tostring_rgba_minimized()\n            l, b, w, h = bounds\n            if w > 0 and h > 0:\n                image = np.frombuffer(buffer, dtype=np.uint8)\n                image = image.reshape((h, w, 4))\n                image = image[::-1]\n                gc = self._renderer.new_gc()\n                # TODO: If the mixedmode resolution differs from the figure's\n                #       dpi, the image must be scaled (dpi->_figdpi). Not all\n                #       backends support this.\n                self._renderer.draw_image(\n                    gc,\n                    l * self._figdpi / self.dpi,\n                    (height-b-h) * self._figdpi / self.dpi,\n                    image)\n            self._raster_renderer = None\n            self._rasterizing = False\n\n            # restore the figure dpi.\n            self.figure.set_dpi(self._figdpi)\n\n        if self._bbox_inches_restore:  # when tight bbox is used\n            r = process_figure_for_rasterizing(self.figure,\n                                               self._bbox_inches_restore,\n                                               self._figdpi)\n            self._bbox_inches_restore = r"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/__init__/manager",
          "name": "manager",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.__init__.manager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Manages the Comm connection between IPython and the browser (client).\n\nComms are 2 way, with the CommSocket being able to publish a message\nvia the send_json method, and handle a message with on_message. On the\nJS side figure.send_message and figure.ws.onmessage do the sending and\nreceiving respectively.",
      "docstring": "",
      "code": "    def __init__(self, manager):\n        self.supports_binary = None\n        self.manager = manager\n        self.uuid = str(uuid.uuid4())\n        # Publish an output area with a unique ID. The javascript can then\n        # hook into this area.\n        display(HTML(\"<div id=%r></div>\" % self.uuid))\n        try:\n            self.comm = Comm('matplotlib', data={'id': self.uuid})\n        except AttributeError as err:\n            raise RuntimeError('Unable to create an IPython notebook Comm '\n                               'instance. Are you in the IPython '\n                               'notebook?') from err\n        self.comm.on_msg(self.on_message)\n\n        manager = self.manager\n        self._ext_close = False\n\n        def _on_close(close_message):\n            self._ext_close = True\n            manager.remove_comm(close_message['content']['comm_id'])\n            manager.clearup_closed()\n\n        self.comm.on_close(_on_close)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open",
      "name": "is_open",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.is_open",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/is_open/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.is_open.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_open(self):\n        return not (self._ext_close or self.comm._closed)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close",
      "name": "on_close",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_close(self):\n        # When the socket is closed, deregister the websocket with\n        # the FigureManager.\n        if self.is_open():\n            try:\n                self.comm.close()\n            except KeyError:\n                # apparently already cleaned it up?\n                pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message",
      "name": "on_message",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/on_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.on_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def on_message(self, message):\n        # The 'supports_binary' message is relevant to the\n        # websocket itself.  The other messages get passed along\n        # to matplotlib as-is.\n\n        # Every message has a \"type\" and a \"figure_id\".\n        message = json.loads(message['content']['data'])\n        if message['type'] == 'closing':\n            self.on_close()\n            self.manager.clearup_closed()\n        elif message['type'] == 'supports_binary':\n            self.supports_binary = message['value']\n        else:\n            self.manager.handle_json(message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary",
      "name": "send_binary",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_binary/blob",
          "name": "blob",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_binary.blob",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_binary(self, blob):\n        # The comm is ascii, so we always send the image in base64\n        # encoded data URL form.\n        data = b64encode(blob).decode('ascii')\n        data_uri = \"data:image/png;base64,{0}\".format(data)\n        self.comm.send({'data': data_uri})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json",
      "name": "send_json",
      "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/CommSocket/send_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_nbagg.CommSocket.send_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_json(self, content):\n        self.comm.send({'data': json.dumps(content)})"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        self._shown = False\n        FigureManagerWebAgg.__init__(self, canvas, num)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed",
      "name": "clearup_closed",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.clearup_closed",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/clearup_closed/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.clearup_closed.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clear up any closed Comms.",
      "docstring": "Clear up any closed Comms.",
      "code": "    def clearup_closed(self):\n        \"\"\"Clear up any closed Comms.\"\"\"\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.is_open()}\n\n        if len(self.web_sockets) == 0:\n            self.canvas.close_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter",
      "name": "connected",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.connected",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/connected@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.connected.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def connected(self):\n        return bool(self.web_sockets)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self):\n        self._send_event('close')\n        # need to copy comms as callbacks will modify this list\n        for comm in list(self.web_sockets):\n            comm.on_close()\n        self.clearup_closed()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js",
      "name": "display_js",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.display_js",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/display_js/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.display_js.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def display_js(self):\n        # XXX How to do this just once? It has to deal with multiple\n        # browser instances using the same kernel (require.js - but the\n        # file isn't static?).\n        display(Javascript(FigureManagerNbAgg.get_javascript()))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript",
      "name": "get_javascript",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/get_javascript/stream",
          "name": "stream",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.get_javascript.stream",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = io.StringIO()\n        else:\n            output = stream\n        super().get_javascript(stream=output)\n        output.write((pathlib.Path(__file__).parent\n                      / \"web_backend/js/nbagg_mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n        if stream is None:\n            return output.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm",
      "name": "remove_comm",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/remove_comm/comm_id",
          "name": "comm_id",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.remove_comm.comm_id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_comm(self, comm_id):\n        self.web_sockets = {socket for socket in self.web_sockets\n                            if socket.comm.comm_id != comm_id}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow",
      "name": "reshow",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.reshow",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/reshow/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.reshow.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A special method to re-show the figure in the notebook.",
      "docstring": "A special method to re-show the figure in the notebook.",
      "code": "    def reshow(self):\n        \"\"\"\n        A special method to re-show the figure in the notebook.\n\n        \"\"\"\n        self._shown = False\n        self.show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/FigureManagerNbAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_nbagg.FigureManagerNbAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        if not self._shown:\n            self.display_js()\n            self._create_comm()\n        else:\n            self.canvas.draw_idle()\n        self._shown = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_nbagg/connection_info",
      "name": "connection_info",
      "qname": "lib.matplotlib.backends.backend_nbagg.connection_info",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a string showing the figure and connection status for the backend.\n\nThis is intended as a diagnostic tool, and not for general use.",
      "docstring": "Return a string showing the figure and connection status for the backend.\n\nThis is intended as a diagnostic tool, and not for general use.",
      "code": "def connection_info():\n    \"\"\"\n    Return a string showing the figure and connection status for the backend.\n\n    This is intended as a diagnostic tool, and not for general use.\n    \"\"\"\n    result = [\n        '{fig} - {socket}'.format(\n            fig=(manager.canvas.figure.get_label()\n                 or \"Figure {}\".format(manager.num)),\n            socket=manager.web_sockets)\n        for manager in Gcf.get_all_fig_managers()\n    ]\n    if not is_interactive():\n        result.append(f'Figures pending show: {len(Gcf.figs)}')\n    return '\\n'.join(result)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'pdf'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf",
      "decorators": [
        "_check_savefig_extra_args"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.dpi",
          "default_value": "72",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/bbox_inches_restore",
          "name": "bbox_inches_restore",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.bbox_inches_restore",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/FigureCanvasPdf/print_pdf/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.FigureCanvasPdf.print_pdf.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_check_savefig_extra_args\n    def print_pdf(self, filename, *,\n                  dpi=72,  # dpi to use for images\n                  bbox_inches_restore=None, metadata=None):\n\n        self.figure.set_dpi(72)            # there are 72 pdf points to an inch\n        width, height = self.figure.get_size_inches()\n        if isinstance(filename, PdfPages):\n            file = filename._file\n        else:\n            file = PdfFile(filename, metadata=metadata)\n        try:\n            file.newPage(width, height)\n            renderer = MixedModeRenderer(\n                self.figure, width, height, dpi,\n                RendererPdf(file, dpi, height, width),\n                bbox_inches_restore=bbox_inches_restore)\n            self.figure.draw(renderer)\n            renderer.finalize()\n            if not isinstance(filename, PdfPages):\n                file.finalize()\n        finally:\n            if isinstance(filename, PdfPages):  # finish off this page\n                file.endStream()\n            else:            # we opened the file above; now finish it off\n                file.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file):\n        GraphicsContextBase.__init__(self)\n        self._fillcolor = (0.0, 0.0, 0.0)\n        self._effective_alphas = (1.0, 1.0)\n        self.file = file\n        self.parent = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        d = dict(self.__dict__)\n        del d['file']\n        del d['parent']\n        return repr(d)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd",
      "name": "alpha_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/forced",
          "name": "forced",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.forced",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/alpha_cmd/effective_alphas",
          "name": "effective_alphas",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.alpha_cmd.effective_alphas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def alpha_cmd(self, alpha, forced, effective_alphas):\n        name = self.file.alphaState(effective_alphas)\n        return [name, Op.setgstate]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd",
      "name": "capstyle_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/capstyle_cmd/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.capstyle_cmd.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def capstyle_cmd(self, style):\n        return [self.capstyles[style], Op.setlinecap]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd",
      "name": "clip_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/cliprect",
          "name": "cliprect",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.cliprect",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/clip_cmd/clippath",
          "name": "clippath",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.clip_cmd.clippath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set clip rectangle. Calls `.pop()` and `.push()`.",
      "docstring": "Set clip rectangle. Calls `.pop()` and `.push()`.",
      "code": "    def clip_cmd(self, cliprect, clippath):\n        \"\"\"Set clip rectangle. Calls `.pop()` and `.push()`.\"\"\"\n        cmds = []\n        # Pop graphics state until we hit the right one or the stack is empty\n        while ((self._cliprect, self._clippath) != (cliprect, clippath)\n                and self.parent is not None):\n            cmds.extend(self.pop())\n        # Unless we hit the right one, set the clip polygon\n        if ((self._cliprect, self._clippath) != (cliprect, clippath) or\n                self.parent is None):\n            cmds.extend(self.push())\n            if self._cliprect != cliprect:\n                cmds.extend([cliprect, Op.rectangle, Op.clip, Op.endpath])\n            if self._clippath != clippath:\n                path, affine = clippath.get_transformed_path_and_affine()\n                cmds.extend(\n                    PdfFile.pathOperations(path, affine, simplify=False) +\n                    [Op.clip, Op.endpath])\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties",
      "name": "copy_properties",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/copy_properties/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.copy_properties.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties of other into self.",
      "docstring": "Copy properties of other into self.",
      "code": "    def copy_properties(self, other):\n        \"\"\"\n        Copy properties of other into self.\n        \"\"\"\n        GraphicsContextBase.copy_properties(self, other)\n        fillcolor = getattr(other, '_fillcolor', self._fillcolor)\n        effective_alphas = getattr(other, '_effective_alphas',\n                                   self._effective_alphas)\n        self._fillcolor = fillcolor\n        self._effective_alphas = effective_alphas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd",
      "name": "dash_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/dash_cmd/dashes",
          "name": "dashes",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.dash_cmd.dashes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def dash_cmd(self, dashes):\n        offset, dash = dashes\n        if dash is None:\n            dash = []\n            offset = 0\n        return [list(dash), offset, Op.setdash]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta",
      "name": "delta",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/delta/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.delta.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy properties of other into self and return PDF commands\nneeded to transform self into other.",
      "docstring": "Copy properties of other into self and return PDF commands\nneeded to transform self into other.",
      "code": "    def delta(self, other):\n        \"\"\"\n        Copy properties of other into self and return PDF commands\n        needed to transform self into other.\n        \"\"\"\n        cmds = []\n        fill_performed = False\n        for params, cmd in self.commands:\n            different = False\n            for p in params:\n                ours = getattr(self, p)\n                theirs = getattr(other, p)\n                try:\n                    if ours is None or theirs is None:\n                        different = ours is not theirs\n                    else:\n                        different = bool(ours != theirs)\n                except ValueError:\n                    ours = np.asarray(ours)\n                    theirs = np.asarray(theirs)\n                    different = (ours.shape != theirs.shape or\n                                 np.any(ours != theirs))\n                if different:\n                    break\n\n            # Need to update hatching if we also updated fillcolor\n            if params == ('_hatch', '_hatch_color') and fill_performed:\n                different = True\n\n            if different:\n                if params == ('_fillcolor',):\n                    fill_performed = True\n                theirs = [getattr(other, p) for p in params]\n                cmds.extend(cmd(self, *theirs))\n                for p in params:\n                    setattr(self, p, getattr(other, p))\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill",
      "name": "fill",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fill/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fill.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Predicate: does the path need to be filled?\n\nAn optional argument can be used to specify an alternative\n_fillcolor, as needed by RendererPdf.draw_markers.",
      "docstring": "Predicate: does the path need to be filled?\n\nAn optional argument can be used to specify an alternative\n_fillcolor, as needed by RendererPdf.draw_markers.",
      "code": "    def fill(self, *args):\n        \"\"\"\n        Predicate: does the path need to be filled?\n\n        An optional argument can be used to specify an alternative\n        _fillcolor, as needed by RendererPdf.draw_markers.\n        \"\"\"\n        if len(args):\n            _fillcolor = args[0]\n        else:\n            _fillcolor = self._fillcolor\n        return (self._hatch or\n                (_fillcolor is not None and\n                 (len(_fillcolor) <= 3 or _fillcolor[3] != 0.0)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd",
      "name": "fillcolor_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/fillcolor_cmd/rgb",
          "name": "rgb",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.fillcolor_cmd.rgb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def fillcolor_cmd(self, rgb):\n        if rgb is None or mpl.rcParams['pdf.inheritcolor']:\n            return []\n        elif rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_nonstroke]\n        else:\n            return [*rgb[:3], Op.setrgb_nonstroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Make sure every pushed graphics state is popped.",
      "docstring": "Make sure every pushed graphics state is popped.",
      "code": "    def finalize(self):\n        \"\"\"\n        Make sure every pushed graphics state is popped.\n        \"\"\"\n        cmds = []\n        while self.parent is not None:\n            cmds.extend(self.pop())\n        return cmds"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd",
      "name": "hatch_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/hatch",
          "name": "hatch",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.hatch",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/hatch_cmd/hatch_color",
          "name": "hatch_color",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.hatch_cmd.hatch_color",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def hatch_cmd(self, hatch, hatch_color):\n        if not hatch:\n            if self._fillcolor is not None:\n                return self.fillcolor_cmd(self._fillcolor)\n            else:\n                return [Name('DeviceRGB'), Op.setcolorspace_nonstroke]\n        else:\n            hatch_style = (hatch_color, self._fillcolor, hatch)\n            name = self.file.hatchPattern(hatch_style)\n            return [Name('Pattern'), Op.setcolorspace_nonstroke,\n                    name, Op.setcolor_nonstroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd",
      "name": "joinstyle_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/joinstyle_cmd/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.joinstyle_cmd.style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def joinstyle_cmd(self, style):\n        return [self.joinstyles[style], Op.setlinejoin]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd",
      "name": "linewidth_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/linewidth_cmd/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.linewidth_cmd.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def linewidth_cmd(self, width):\n        return [width, Op.setlinewidth]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint",
      "name": "paint",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/paint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.paint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the appropriate pdf operator to cause the path to be\nstroked, filled, or both.",
      "docstring": "Return the appropriate pdf operator to cause the path to be\nstroked, filled, or both.",
      "code": "    def paint(self):\n        \"\"\"\n        Return the appropriate pdf operator to cause the path to be\n        stroked, filled, or both.\n        \"\"\"\n        return Op.paint_path(self.fill(), self.stroke())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop",
      "name": "pop",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/pop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.pop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pop(self):\n        assert self.parent is not None\n        self.copy_properties(self.parent)\n        self.parent = self.parent.parent\n        return [Op.grestore]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push",
      "name": "push",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/push/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.push.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def push(self):\n        parent = GraphicsContextPdf(self.file)\n        parent.copy_properties(self)\n        parent.parent = self.parent\n        self.parent = parent\n        return [Op.gsave]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd",
      "name": "rgb_cmd",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/rgb_cmd/rgb",
          "name": "rgb",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.rgb_cmd.rgb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def rgb_cmd(self, rgb):\n        if mpl.rcParams['pdf.inheritcolor']:\n            return []\n        if rgb[0] == rgb[1] == rgb[2]:\n            return [rgb[0], Op.setgray_stroke]\n        else:\n            return [*rgb[:3], Op.setrgb_stroke]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke",
      "name": "stroke",
      "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/GraphicsContextPdf/stroke/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.GraphicsContextPdf.stroke.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Predicate: does the path need to be stroked (its outline drawn)?\nThis tests for the various conditions that disable stroking\nthe path, in which case it would presumably be filled.",
      "docstring": "Predicate: does the path need to be stroked (its outline drawn)?\nThis tests for the various conditions that disable stroking\nthe path, in which case it would presumably be filled.",
      "code": "    def stroke(self):\n        \"\"\"\n        Predicate: does the path need to be stroked (its outline drawn)?\n        This tests for the various conditions that disable stroking\n        the path, in which case it would presumably be filled.\n        \"\"\"\n        # _linewidth > 0: in pdf a line of width 0 is drawn at minimum\n        #   possible device width, but e.g., agg doesn't draw at all\n        return (self._linewidth > 0 and self._alpha > 0 and\n                (len(self._rgb) <= 3 or self._rgb[3] != 0.0))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__",
      "name": "__eq__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__eq__/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other):\n        return isinstance(other, Name) and self.name == other.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__",
      "name": "__hash__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__hash__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self):\n        return hash(self.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__init__/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF name object.",
      "docstring": "",
      "code": "    def __init__(self, name):\n        if isinstance(name, Name):\n            self.name = name.name\n        else:\n            if isinstance(name, bytes):\n                name = name.decode('ascii')\n            self.name = self._regex.sub(Name.hexify, name).encode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__",
      "name": "__lt__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__lt__/other",
          "name": "other",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__lt__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __lt__(self, other):\n        return isinstance(other, Name) and self.name < other.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return \"<Name %s>\" % self.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__",
      "name": "__str__",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/__str__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self):\n        return '/' + str(self.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify",
      "name": "hexify",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.hexify",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/hexify/match",
          "name": "match",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.hexify.match",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def hexify(match):\n        return '#%02x' % ord(match.group())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Name/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Name.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return b'/' + self.name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__init__/op",
          "name": "op",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__init__.op",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF operator object.",
      "docstring": "",
      "code": "    def __init__(self, op):\n        self.op = op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return '<Operator %s>' % self.op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Operator.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Operator/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Operator.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self.op"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF file object.",
      "docstring": "Parameters\n----------\n\nfilename : str or path-like or file-like\n    Output target; if a string, a file will be opened for writing.\nmetadata : dict from strings to strings and dates\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, metadata=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n        metadata : dict from strings to strings and dates\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        super().__init__()\n\n        self._object_seq = itertools.count(1)  # consumed by reserveObject\n        self.xrefTable = [[0, 65535, 'the zero object']]\n        self.passed_in_file_object = False\n        self.original_file_like = None\n        self.tell_base = 0\n        fh, opened = cbook.to_filehandle(filename, \"wb\", return_opened=True)\n        if not opened:\n            try:\n                self.tell_base = filename.tell()\n            except IOError:\n                fh = BytesIO()\n                self.original_file_like = filename\n            else:\n                fh = filename\n                self.passed_in_file_object = True\n\n        self.fh = fh\n        self.currentstream = None  # stream object to write to, if any\n        fh.write(b\"%PDF-1.4\\n\")    # 1.4 is the first version to have alpha\n        # Output some eight-bit chars as a comment so various utilities\n        # recognize the file as binary by looking at the first few\n        # lines (see note in section 3.4.1 of the PDF reference).\n        fh.write(b\"%\\254\\334 \\253\\272\\n\")\n\n        self.rootObject = self.reserveObject('root')\n        self.pagesObject = self.reserveObject('pages')\n        self.pageList = []\n        self.fontObject = self.reserveObject('fonts')\n        self._extGStateObject = self.reserveObject('extended graphics states')\n        self.hatchObject = self.reserveObject('tiling patterns')\n        self.gouraudObject = self.reserveObject('Gouraud triangles')\n        self.XObjectObject = self.reserveObject('external objects')\n        self.resourceObject = self.reserveObject('resources')\n\n        root = {'Type': Name('Catalog'),\n                'Pages': self.pagesObject}\n        self.writeObject(self.rootObject, root)\n\n        self.infoDict = _create_pdf_info_dict('pdf', metadata or {})\n\n        self.fontNames = {}     # maps filenames to internal font names\n        self._internal_font_seq = (Name(f'F{i}') for i in itertools.count(1))\n        self.dviFontInfo = {}   # maps dvi font names to embedding information\n        # differently encoded Type-1 fonts may share the same descriptor\n        self.type1Descriptors = {}\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n\n        self.alphaStates = {}   # maps alpha values to graphics state objects\n        self._alpha_state_seq = (Name(f'A{i}') for i in itertools.count(1))\n        self._soft_mask_states = {}\n        self._soft_mask_seq = (Name(f'SM{i}') for i in itertools.count(1))\n        self._soft_mask_groups = []\n        # reproducible writeHatches needs an ordered dict:\n        self.hatchPatterns = collections.OrderedDict()\n        self._hatch_pattern_seq = (Name(f'H{i}') for i in itertools.count(1))\n        self.gouraudTriangles = []\n\n        self._images = collections.OrderedDict()   # reproducible writeImages\n        self._image_seq = (Name(f'I{i}') for i in itertools.count(1))\n\n        self.markers = collections.OrderedDict()   # reproducible writeMarkers\n        self.multi_byte_charprocs = {}\n\n        self.paths = []\n\n        self.pageAnnotations = []  # A list of annotations for the current page\n\n        # The PDF spec recommends to include every procset\n        procsets = [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]\n\n        # Write resource dictionary.\n        # Possibly TODO: more general ExtGState (graphics state dictionaries)\n        #                ColorSpace Pattern Shading Properties\n        resources = {'Font': self.fontObject,\n                     'XObject': self.XObjectObject,\n                     'ExtGState': self._extGStateObject,\n                     'Pattern': self.hatchObject,\n                     'Shading': self.gouraudObject,\n                     'ProcSet': procsets}\n        self.writeObject(self.resourceObject, resources)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles",
      "name": "addGouraudTriangles",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "np.ndarray",
            "default_value": "",
            "description": "Triangle vertices, shape (n, 3, 2)\nwhere n = number of triangles, 3 = vertices, 2 = x, y."
          },
          "type": {
            "kind": "NamedType",
            "name": "np.ndarray"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/addGouraudTriangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.addGouraudTriangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "np.ndarray",
            "default_value": "",
            "description": "Vertex colors, shape (n, 3, 1) or (n, 3, 4)\nas with points, but last dimension is either (gray,)\nor (r, g, b, alpha)."
          },
          "type": {
            "kind": "NamedType",
            "name": "np.ndarray"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a Gouraud triangle shading.",
      "docstring": "Add a Gouraud triangle shading.\n\nParameters\n----------\npoints : np.ndarray\n    Triangle vertices, shape (n, 3, 2)\n    where n = number of triangles, 3 = vertices, 2 = x, y.\ncolors : np.ndarray\n    Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n    as with points, but last dimension is either (gray,)\n    or (r, g, b, alpha).\n\nReturns\n-------\nName, Reference",
      "code": "    def addGouraudTriangles(self, points, colors):\n        \"\"\"\n        Add a Gouraud triangle shading.\n\n        Parameters\n        ----------\n        points : np.ndarray\n            Triangle vertices, shape (n, 3, 2)\n            where n = number of triangles, 3 = vertices, 2 = x, y.\n        colors : np.ndarray\n            Vertex colors, shape (n, 3, 1) or (n, 3, 4)\n            as with points, but last dimension is either (gray,)\n            or (r, g, b, alpha).\n\n        Returns\n        -------\n        Name, Reference\n        \"\"\"\n        name = Name('GT%d' % len(self.gouraudTriangles))\n        ob = self.reserveObject(f'Gouraud triangle {name}')\n        self.gouraudTriangles.append((name, ob, points, colors))\n        return name, ob"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState",
      "name": "alphaState",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/alphaState/alpha",
          "name": "alpha",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.alphaState.alpha",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of an ExtGState that sets alpha to the given value.",
      "docstring": "Return name of an ExtGState that sets alpha to the given value.",
      "code": "    def alphaState(self, alpha):\n        \"\"\"Return name of an ExtGState that sets alpha to the given value.\"\"\"\n\n        state = self.alphaStates.get(alpha, None)\n        if state is not None:\n            return state[0]\n\n        name = next(self._alpha_state_seq)\n        self.alphaStates[alpha] = \\\n            (name, {'Type': Name('ExtGState'),\n                    'CA': alpha[0], 'ca': alpha[1]})\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream",
      "name": "beginStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/len",
          "name": "len",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.len",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.extra",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/beginStream/png",
          "name": "png",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.beginStream.png",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def beginStream(self, id, len, extra=None, png=None):\n        assert self.currentstream is None\n        self.currentstream = Stream(id, len, self, extra, png)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Flush all buffers and free all resources.",
      "docstring": "Flush all buffers and free all resources.",
      "code": "    def close(self):\n        \"\"\"Flush all buffers and free all resources.\"\"\"\n\n        self.endStream()\n        if self.passed_in_file_object:\n            self.fh.flush()\n        else:\n            if self.original_file_like is not None:\n                self.original_file_like.write(self.fh.getvalue())\n            self.fh.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor",
      "name": "createType1Descriptor",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/t1font",
          "name": "t1font",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.t1font",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/createType1Descriptor/fontfile",
          "name": "fontfile",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.createType1Descriptor.fontfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def createType1Descriptor(self, t1font, fontfile):\n        # Create and write the font descriptor and the font file\n        # of a Type-1 font\n        fontdescObject = self.reserveObject('font descriptor')\n        fontfileObject = self.reserveObject('font file')\n\n        italic_angle = t1font.prop['ItalicAngle']\n        fixed_pitch = t1font.prop['isFixedPitch']\n\n        flags = 0\n        # fixed width\n        if fixed_pitch:\n            flags |= 1 << 0\n        # TODO: serif\n        if 0:\n            flags |= 1 << 1\n        # TODO: symbolic (most TeX fonts are)\n        if 1:\n            flags |= 1 << 2\n        # non-symbolic\n        else:\n            flags |= 1 << 5\n        # italic\n        if italic_angle:\n            flags |= 1 << 6\n        # TODO: all caps\n        if 0:\n            flags |= 1 << 16\n        # TODO: small caps\n        if 0:\n            flags |= 1 << 17\n        # TODO: force bold\n        if 0:\n            flags |= 1 << 18\n\n        ft2font = get_font(fontfile)\n\n        descriptor = {\n            'Type':        Name('FontDescriptor'),\n            'FontName':    Name(t1font.prop['FontName']),\n            'Flags':       flags,\n            'FontBBox':    ft2font.bbox,\n            'ItalicAngle': italic_angle,\n            'Ascent':      ft2font.ascender,\n            'Descent':     ft2font.descender,\n            'CapHeight':   1000,  # TODO: find this out\n            'XHeight':     500,  # TODO: this one too\n            'FontFile':    fontfileObject,\n            'FontFamily':  t1font.prop['FamilyName'],\n            'StemV':       50,  # TODO\n            # (see also revision 3874; but not all TeX distros have AFM files!)\n            # 'FontWeight': a number where 400 = Regular, 700 = Bold\n            }\n\n        self.writeObject(fontdescObject, descriptor)\n\n        self.beginStream(fontfileObject.id, None,\n                         {'Length1': len(t1font.parts[0]),\n                          'Length2': len(t1font.parts[1]),\n                          'Length3': 0})\n        self.currentstream.write(t1font.parts[0])\n        self.currentstream.write(t1font.parts[1])\n        self.endStream()\n\n        return fontdescObject"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName",
      "name": "dviFontName",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/dviFontName/dvifont",
          "name": "dvifont",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.dviFontName.dvifont",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Given a dvi font object, return a name suitable for Op.selectfont.\nThis registers the font information in ``self.dviFontInfo`` if not yet\nregistered.",
      "docstring": "Given a dvi font object, return a name suitable for Op.selectfont.\nThis registers the font information in ``self.dviFontInfo`` if not yet\nregistered.",
      "code": "    def dviFontName(self, dvifont):\n        \"\"\"\n        Given a dvi font object, return a name suitable for Op.selectfont.\n        This registers the font information in ``self.dviFontInfo`` if not yet\n        registered.\n        \"\"\"\n\n        dvi_info = self.dviFontInfo.get(dvifont.texname)\n        if dvi_info is not None:\n            return dvi_info.pdfname\n\n        tex_font_map = dviread.PsfontsMap(dviread.find_tex_file('pdftex.map'))\n        psfont = tex_font_map[dvifont.texname]\n        if psfont.filename is None:\n            raise ValueError(\n                \"No usable font file found for {} (TeX: {}); \"\n                \"the font may lack a Type-1 version\"\n                .format(psfont.psname, dvifont.texname))\n\n        pdfname = next(self._internal_font_seq)\n        _log.debug('Assigning font %s = %s (dvi)', pdfname, dvifont.texname)\n        self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(\n            dvifont=dvifont,\n            pdfname=pdfname,\n            fontfile=psfont.filename,\n            basefont=psfont.psname,\n            encodingfile=psfont.encoding,\n            effects=psfont.effects)\n        return pdfname"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF",
      "name": "embedTTF",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/embedTTF/characters",
          "name": "characters",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.embedTTF.characters",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Embed the TTF font from the named file into the document.",
      "docstring": "Embed the TTF font from the named file into the document.",
      "code": "    def embedTTF(self, filename, characters):\n        \"\"\"Embed the TTF font from the named file into the document.\"\"\"\n\n        font = get_font(filename)\n        fonttype = mpl.rcParams['pdf.fonttype']\n\n        def cvt(length, upe=font.units_per_EM, nearest=True):\n            \"\"\"Convert font coordinates to PDF glyph coordinates.\"\"\"\n            value = length / upe * 1000\n            if nearest:\n                return round(value)\n            # Best(?) to round away from zero for bounding boxes and the like.\n            if value < 0:\n                return math.floor(value)\n            else:\n                return math.ceil(value)\n\n        def embedTTFType3(font, characters, descriptor):\n            \"\"\"The Type 3-specific part of embedding a Truetype font\"\"\"\n            widthsObject = self.reserveObject('font widths')\n            fontdescObject = self.reserveObject('font descriptor')\n            fontdictObject = self.reserveObject('font dictionary')\n            charprocsObject = self.reserveObject('character procs')\n            differencesArray = []\n            firstchar, lastchar = 0, 255\n            bbox = [cvt(x, nearest=False) for x in font.bbox]\n\n            fontdict = {\n                'Type': Name('Font'),\n                'BaseFont': ps_name,\n                'FirstChar': firstchar,\n                'LastChar': lastchar,\n                'FontDescriptor': fontdescObject,\n                'Subtype': Name('Type3'),\n                'Name': descriptor['FontName'],\n                'FontBBox': bbox,\n                'FontMatrix': [.001, 0, 0, .001, 0, 0],\n                'CharProcs': charprocsObject,\n                'Encoding': {\n                    'Type': Name('Encoding'),\n                    'Differences': differencesArray},\n                'Widths': widthsObject\n                }\n\n            from encodings import cp1252\n\n            # Make the \"Widths\" array\n            def get_char_width(charcode):\n                s = ord(cp1252.decoding_table[charcode])\n                width = font.load_char(\n                    s, flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance\n                return cvt(width)\n\n            with warnings.catch_warnings():\n                # Ignore 'Required glyph missing from current font' warning\n                # from ft2font: here we're just building the widths table, but\n                # the missing glyphs may not even be used in the actual string.\n                warnings.filterwarnings(\"ignore\")\n                widths = [get_char_width(charcode)\n                          for charcode in range(firstchar, lastchar+1)]\n            descriptor['MaxWidth'] = max(widths)\n\n            # Make the \"Differences\" array, sort the ccodes < 255 from\n            # the multi-byte ccodes, and build the whole set of glyph ids\n            # that we need from this font.\n            glyph_ids = []\n            differences = []\n            multi_byte_chars = set()\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph_ids.append(gind)\n                glyph_name = font.get_glyph_name(gind)\n                if ccode <= 255:\n                    differences.append((ccode, glyph_name))\n                else:\n                    multi_byte_chars.add(glyph_name)\n            differences.sort()\n\n            last_c = -2\n            for c, name in differences:\n                if c != last_c + 1:\n                    differencesArray.append(c)\n                differencesArray.append(Name(name))\n                last_c = c\n\n            # Make the charprocs array (using ttconv to generate the\n            # actual outlines)\n            try:\n                rawcharprocs = _ttconv.get_pdf_charprocs(\n                    os.fsencode(filename), glyph_ids)\n            except RuntimeError:\n                _log.warning(\"The PDF backend does not currently support the \"\n                             \"selected font.\")\n                raise\n            charprocs = {}\n            for charname in sorted(rawcharprocs):\n                stream = rawcharprocs[charname]\n                charprocDict = {'Length': len(stream)}\n                # The 2-byte characters are used as XObjects, so they\n                # need extra info in their dictionary\n                if charname in multi_byte_chars:\n                    charprocDict['Type'] = Name('XObject')\n                    charprocDict['Subtype'] = Name('Form')\n                    charprocDict['BBox'] = bbox\n                    # Each glyph includes bounding box information,\n                    # but xpdf and ghostscript can't handle it in a\n                    # Form XObject (they segfault!!!), so we remove it\n                    # from the stream here.  It's not needed anyway,\n                    # since the Form XObject includes it in its BBox\n                    # value.\n                    stream = stream[stream.find(b\"d1\") + 2:]\n                charprocObject = self.reserveObject('charProc')\n                self.beginStream(charprocObject.id, None, charprocDict)\n                self.currentstream.write(stream)\n                self.endStream()\n\n                # Send the glyphs with ccode > 255 to the XObject dictionary,\n                # and the others to the font itself\n                if charname in multi_byte_chars:\n                    name = self._get_xobject_symbol_name(filename, charname)\n                    self.multi_byte_charprocs[name] = charprocObject\n                else:\n                    charprocs[charname] = charprocObject\n\n            # Write everything out\n            self.writeObject(fontdictObject, fontdict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(widthsObject, widths)\n            self.writeObject(charprocsObject, charprocs)\n\n            return fontdictObject\n\n        def embedTTFType42(font, characters, descriptor):\n            \"\"\"The Type 42-specific part of embedding a Truetype font\"\"\"\n            fontdescObject = self.reserveObject('font descriptor')\n            cidFontDictObject = self.reserveObject('CID font dictionary')\n            type0FontDictObject = self.reserveObject('Type 0 font dictionary')\n            cidToGidMapObject = self.reserveObject('CIDToGIDMap stream')\n            fontfileObject = self.reserveObject('font file stream')\n            wObject = self.reserveObject('Type 0 widths')\n            toUnicodeMapObject = self.reserveObject('ToUnicode map')\n\n            cidFontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('CIDFontType2'),\n                'BaseFont': ps_name,\n                'CIDSystemInfo': {\n                    'Registry': 'Adobe',\n                    'Ordering': 'Identity',\n                    'Supplement': 0},\n                'FontDescriptor': fontdescObject,\n                'W': wObject,\n                'CIDToGIDMap': cidToGidMapObject\n                }\n\n            type0FontDict = {\n                'Type': Name('Font'),\n                'Subtype': Name('Type0'),\n                'BaseFont': ps_name,\n                'Encoding': Name('Identity-H'),\n                'DescendantFonts': [cidFontDictObject],\n                'ToUnicode': toUnicodeMapObject\n                }\n\n            # Make fontfile stream\n            descriptor['FontFile2'] = fontfileObject\n            length1Object = self.reserveObject('decoded length of a font')\n            self.beginStream(\n                fontfileObject.id,\n                self.reserveObject('length of font stream'),\n                {'Length1': length1Object})\n            with open(filename, 'rb') as fontfile:\n                length1 = 0\n                while True:\n                    data = fontfile.read(4096)\n                    if not data:\n                        break\n                    length1 += len(data)\n                    self.currentstream.write(data)\n            self.endStream()\n            self.writeObject(length1Object, length1)\n\n            # Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap\n            # at the same time\n            cid_to_gid_map = ['\\0'] * 65536\n            widths = []\n            max_ccode = 0\n            for c in characters:\n                ccode = c\n                gind = font.get_char_index(ccode)\n                glyph = font.load_char(ccode,\n                                       flags=LOAD_NO_SCALE | LOAD_NO_HINTING)\n                widths.append((ccode, cvt(glyph.horiAdvance)))\n                if ccode < 65536:\n                    cid_to_gid_map[ccode] = chr(gind)\n                max_ccode = max(ccode, max_ccode)\n            widths.sort()\n            cid_to_gid_map = cid_to_gid_map[:max_ccode + 1]\n\n            last_ccode = -2\n            w = []\n            max_width = 0\n            unicode_groups = []\n            for ccode, width in widths:\n                if ccode != last_ccode + 1:\n                    w.append(ccode)\n                    w.append([width])\n                    unicode_groups.append([ccode, ccode])\n                else:\n                    w[-1].append(width)\n                    unicode_groups[-1][1] = ccode\n                max_width = max(max_width, width)\n                last_ccode = ccode\n\n            unicode_bfrange = []\n            for start, end in unicode_groups:\n                unicode_bfrange.append(\n                    b\"<%04x> <%04x> [%s]\" %\n                    (start, end,\n                     b\" \".join(b\"<%04x>\" % x for x in range(start, end+1))))\n            unicode_cmap = (self._identityToUnicodeCMap %\n                            (len(unicode_groups), b\"\\n\".join(unicode_bfrange)))\n\n            # CIDToGIDMap stream\n            cid_to_gid_map = \"\".join(cid_to_gid_map).encode(\"utf-16be\")\n            self.beginStream(cidToGidMapObject.id,\n                             None,\n                             {'Length': len(cid_to_gid_map)})\n            self.currentstream.write(cid_to_gid_map)\n            self.endStream()\n\n            # ToUnicode CMap\n            self.beginStream(toUnicodeMapObject.id,\n                             None,\n                             {'Length': unicode_cmap})\n            self.currentstream.write(unicode_cmap)\n            self.endStream()\n\n            descriptor['MaxWidth'] = max_width\n\n            # Write everything out\n            self.writeObject(cidFontDictObject, cidFontDict)\n            self.writeObject(type0FontDictObject, type0FontDict)\n            self.writeObject(fontdescObject, descriptor)\n            self.writeObject(wObject, w)\n\n            return type0FontDictObject\n\n        # Beginning of main embedTTF function...\n\n        ps_name = font.postscript_name.encode('ascii', 'replace')\n        ps_name = Name(ps_name)\n        pclt = font.get_sfnt_table('pclt') or {'capHeight': 0, 'xHeight': 0}\n        post = font.get_sfnt_table('post') or {'italicAngle': (0, 0)}\n        ff = font.face_flags\n        sf = font.style_flags\n\n        flags = 0\n        symbolic = False  # ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')\n        if ff & FIXED_WIDTH:\n            flags |= 1 << 0\n        if 0:  # TODO: serif\n            flags |= 1 << 1\n        if symbolic:\n            flags |= 1 << 2\n        else:\n            flags |= 1 << 5\n        if sf & ITALIC:\n            flags |= 1 << 6\n        if 0:  # TODO: all caps\n            flags |= 1 << 16\n        if 0:  # TODO: small caps\n            flags |= 1 << 17\n        if 0:  # TODO: force bold\n            flags |= 1 << 18\n\n        descriptor = {\n            'Type': Name('FontDescriptor'),\n            'FontName': ps_name,\n            'Flags': flags,\n            'FontBBox': [cvt(x, nearest=False) for x in font.bbox],\n            'Ascent': cvt(font.ascender, nearest=False),\n            'Descent': cvt(font.descender, nearest=False),\n            'CapHeight': cvt(pclt['capHeight'], nearest=False),\n            'XHeight': cvt(pclt['xHeight']),\n            'ItalicAngle': post['italicAngle'][1],  # ???\n            'StemV': 0  # ???\n            }\n\n        # The font subsetting to a Type 3 font does not work for\n        # OpenType (.otf) that embed a Postscript CFF font, so avoid that --\n        # save as a (non-subsetted) Type 42 font instead.\n        if is_opentype_cff_font(filename):\n            fonttype = 42\n            _log.warning(\"%r can not be subsetted into a Type 3 font. The \"\n                         \"entire font will be embedded in the output.\",\n                         os.path.basename(filename))\n\n        if fonttype == 3:\n            return embedTTFType3(font, characters, descriptor)\n        elif fonttype == 42:\n            return embedTTFType42(font, characters, descriptor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream",
      "name": "endStream",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/endStream/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.endStream.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def endStream(self):\n        if self.currentstream is not None:\n            self.currentstream.end()\n            self.currentstream = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the various deferred objects and the pdf end matter.",
      "docstring": "Write out the various deferred objects and the pdf end matter.",
      "code": "    def finalize(self):\n        \"\"\"Write out the various deferred objects and the pdf end matter.\"\"\"\n\n        self.endStream()\n        self.writeFonts()\n        self.writeExtGSTates()\n        self._write_soft_mask_groups()\n        self.writeHatches()\n        self.writeGouraudTriangles()\n        xobjects = {\n            name: ob for image, name, ob in self._images.values()}\n        for tup in self.markers.values():\n            xobjects[tup[0]] = tup[1]\n        for name, value in self.multi_byte_charprocs.items():\n            xobjects[name] = value\n        for name, path, trans, ob, join, cap, padding, filled, stroked \\\n                in self.paths:\n            xobjects[name] = ob\n        self.writeObject(self.XObjectObject, xobjects)\n        self.writeImages()\n        self.writeMarkers()\n        self.writePathCollectionTemplates()\n        self.writeObject(self.pagesObject,\n                         {'Type': Name('Pages'),\n                          'Kids': self.pageList,\n                          'Count': len(self.pageList)})\n        self.writeInfoDict()\n\n        # Finalize the file\n        self.writeXref()\n        self.writeTrailer()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName",
      "name": "fontName",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/fontName/fontprop",
          "name": "fontprop",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.fontName.fontprop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select a font based on fontprop and return a name suitable for\nOp.selectfont. If fontprop is a string, it will be interpreted\nas the filename of the font.",
      "docstring": "Select a font based on fontprop and return a name suitable for\nOp.selectfont. If fontprop is a string, it will be interpreted\nas the filename of the font.",
      "code": "    def fontName(self, fontprop):\n        \"\"\"\n        Select a font based on fontprop and return a name suitable for\n        Op.selectfont. If fontprop is a string, it will be interpreted\n        as the filename of the font.\n        \"\"\"\n\n        if isinstance(fontprop, str):\n            filename = fontprop\n        elif mpl.rcParams['pdf.use14corefonts']:\n            filename = findfont(\n                fontprop, fontext='afm', directory=RendererPdf._afm_font_dir)\n        else:\n            filename = findfont(fontprop)\n\n        Fx = self.fontNames.get(filename)\n        if Fx is None:\n            Fx = next(self._internal_font_seq)\n            self.fontNames[filename] = Fx\n            _log.debug('Assigning font %s = %r', Fx, filename)\n\n        return Fx"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern",
      "name": "hatchPattern",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/hatchPattern/hatch_style",
          "name": "hatch_style",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.hatchPattern.hatch_style",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def hatchPattern(self, hatch_style):\n        # The colors may come in as numpy arrays, which aren't hashable\n        if hatch_style is not None:\n            edge, face, hatch = hatch_style\n            if edge is not None:\n                edge = tuple(edge)\n            if face is not None:\n                face = tuple(face)\n            hatch_style = (edge, face, hatch)\n\n        pattern = self.hatchPatterns.get(hatch_style, None)\n        if pattern is not None:\n            return pattern\n\n        name = next(self._hatch_pattern_seq)\n        self.hatchPatterns[hatch_style] = name\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject",
      "name": "imageObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/imageObject/image",
          "name": "image",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.imageObject.image",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of an image XObject representing the given image.",
      "docstring": "Return name of an image XObject representing the given image.",
      "code": "    def imageObject(self, image):\n        \"\"\"Return name of an image XObject representing the given image.\"\"\"\n\n        entry = self._images.get(id(image), None)\n        if entry is not None:\n            return entry[1]\n\n        name = next(self._image_seq)\n        ob = self.reserveObject(f'image {name}')\n        self._images[id(image)] = (image, name, ob)\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject",
      "name": "markerObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/fill",
          "name": "fill",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.fill",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/stroke",
          "name": "stroke",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.stroke",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/lw",
          "name": "lw",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.lw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/joinstyle",
          "name": "joinstyle",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.joinstyle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/markerObject/capstyle",
          "name": "capstyle",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.markerObject.capstyle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return name of a marker XObject representing the given path.",
      "docstring": "Return name of a marker XObject representing the given path.",
      "code": "    def markerObject(self, path, trans, fill, stroke, lw, joinstyle,\n                     capstyle):\n        \"\"\"Return name of a marker XObject representing the given path.\"\"\"\n        # self.markers used by markerObject, writeMarkers, close:\n        # mapping from (path operations, fill?, stroke?) to\n        #   [name, object reference, bounding box, linewidth]\n        # This enables different draw_markers calls to share the XObject\n        # if the gc is sufficiently similar: colors etc can vary, but\n        # the choices of whether to fill and whether to stroke cannot.\n        # We need a bounding box enclosing all of the XObject path,\n        # but since line width may vary, we store the maximum of all\n        # occurring line widths in self.markers.\n        # close() is somewhat tightly coupled in that it expects the\n        # first two components of each value in self.markers to be the\n        # name and object reference.\n        pathops = self.pathOperations(path, trans, simplify=False)\n        key = (tuple(pathops), bool(fill), bool(stroke), joinstyle, capstyle)\n        result = self.markers.get(key)\n        if result is None:\n            name = Name('M%d' % len(self.markers))\n            ob = self.reserveObject('marker %d' % len(self.markers))\n            bbox = path.get_extents(trans)\n            self.markers[key] = [name, ob, bbox, lw]\n        else:\n            if result[-1] < lw:\n                result[-1] = lw\n            name = result[0]\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage",
      "name": "newPage",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newPage/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newPage.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def newPage(self, width, height):\n        self.endStream()\n\n        self.width, self.height = width, height\n        contentObject = self.reserveObject('page contents')\n        thePage = {'Type': Name('Page'),\n                   'Parent': self.pagesObject,\n                   'Resources': self.resourceObject,\n                   'MediaBox': [0, 0, 72 * width, 72 * height],\n                   'Contents': contentObject,\n                   'Group': {'Type': Name('Group'),\n                             'S': Name('Transparency'),\n                             'CS': Name('DeviceRGB')},\n                   'Annots': self.pageAnnotations,\n                   }\n        pageObject = self.reserveObject('page')\n        self.writeObject(pageObject, thePage)\n        self.pageList.append(pageObject)\n\n        self.beginStream(contentObject.id,\n                         self.reserveObject('length of content stream'))\n        # Initialize the pdf graphics state to match the default mpl\n        # graphics context: currently only the join style needs to be set\n        self.output(GraphicsContextPdf.joinstyles['round'], Op.setlinejoin)\n\n        # Clear the list of annotations for the next page\n        self.pageAnnotations = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote",
      "name": "newTextnote",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/newTextnote/positionRect",
          "name": "positionRect",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.newTextnote.positionRect",
          "default_value": "[-100, -100, 0, 0]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def newTextnote(self, text, positionRect=[-100, -100, 0, 0]):\n        # Create a new annotation of type text\n        theNote = {'Type': Name('Annot'),\n                   'Subtype': Name('Text'),\n                   'Contents': text,\n                   'Rect': positionRect,\n                   }\n        annotObject = self.reserveObject('annotation')\n        self.writeObject(annotObject, theNote)\n        self.pageAnnotations.append(annotObject)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output",
      "name": "output",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/output/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.output.data",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def output(self, *data):\n        self.write(fill([pdfRepr(x) for x in data]))\n        self.write(b'\\n')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject",
      "name": "pathCollectionObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/padding",
          "name": "padding",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.padding",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/filled",
          "name": "filled",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.filled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathCollectionObject/stroked",
          "name": "stroked",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathCollectionObject.stroked",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked):\n        name = Name('P%d' % len(self.paths))\n        ob = self.reserveObject('path %d' % len(self.paths))\n        self.paths.append(\n            (name, path, trans, ob, gc.get_joinstyle(), gc.get_capstyle(),\n             padding, filled, stroked))\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations",
      "name": "pathOperations",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/clip",
          "name": "clip",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.clip",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/simplify",
          "name": "simplify",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.simplify",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/pathOperations/sketch",
          "name": "sketch",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.pathOperations.sketch",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def pathOperations(path, transform, clip=None, simplify=None, sketch=None):\n        return [Verbatim(_path.convert_to_string(\n            path, transform, clip, simplify, sketch,\n            6,\n            [Op.moveto.op, Op.lineto.op, b'', Op.curveto.op, Op.closepath.op],\n            True))]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref",
      "name": "recordXref",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/recordXref/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.recordXref.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def recordXref(self, id):\n        self.xrefTable[id][0] = self.fh.tell() - self.tell_base"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject",
      "name": "reserveObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/reserveObject/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.reserveObject.name",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Reserve an ID for an indirect object.\n\nThe name is used for debugging in case we forget to print out\nthe object with writeObject.",
      "docstring": "Reserve an ID for an indirect object.\n\nThe name is used for debugging in case we forget to print out\nthe object with writeObject.",
      "code": "    def reserveObject(self, name=''):\n        \"\"\"\n        Reserve an ID for an indirect object.\n\n        The name is used for debugging in case we forget to print out\n        the object with writeObject.\n        \"\"\"\n        id = next(self._object_seq)\n        self.xrefTable.append([None, 0, name])\n        return Reference(id)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/used_characters@getter",
      "name": "used_characters",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.used_characters",
      "decorators": [
        "cbook.deprecated('3.3')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/used_characters@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.used_characters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    @property\n    def used_characters(self):\n        return self.file._character_tracker.used_characters"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/write/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.write.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def write(self, data):\n        if self.currentstream is None:\n            self.fh.write(data)\n        else:\n            self.currentstream.write(data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates",
      "name": "writeExtGSTates",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeExtGSTates/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeExtGSTates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeExtGSTates(self):\n        self.writeObject(\n            self._extGStateObject,\n            dict([\n                *self.alphaStates.values(),\n                *self._soft_mask_states.values()\n            ])\n        )"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts",
      "name": "writeFonts",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeFonts/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeFonts.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeFonts(self):\n        fonts = {}\n        for dviname, info in sorted(self.dviFontInfo.items()):\n            Fx = info.pdfname\n            _log.debug('Embedding Type-1 font %s from dvi.', dviname)\n            fonts[Fx] = self._embedTeXFont(info)\n        for filename in sorted(self.fontNames):\n            Fx = self.fontNames[filename]\n            _log.debug('Embedding font %s.', filename)\n            if filename.endswith('.afm'):\n                # from pdf.use14corefonts\n                _log.debug('Writing AFM font.')\n                fonts[Fx] = self._write_afm_font(filename)\n            else:\n                # a normal TrueType font\n                _log.debug('Writing TrueType font.')\n                chars = self._character_tracker.used.get(filename)\n                if chars:\n                    fonts[Fx] = self.embedTTF(filename, chars)\n        self.writeObject(self.fontObject, fonts)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles",
      "name": "writeGouraudTriangles",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeGouraudTriangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeGouraudTriangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeGouraudTriangles(self):\n        gouraudDict = dict()\n        for name, ob, points, colors in self.gouraudTriangles:\n            gouraudDict[name] = ob\n            shape = points.shape\n            flat_points = points.reshape((shape[0] * shape[1], 2))\n            colordim = colors.shape[2]\n            assert colordim in (1, 4)\n            flat_colors = colors.reshape((shape[0] * shape[1], colordim))\n            if colordim == 4:\n                # strip the alpha channel\n                colordim = 3\n            points_min = np.min(flat_points, axis=0) - (1 << 8)\n            points_max = np.max(flat_points, axis=0) + (1 << 8)\n            factor = 0xffffffff / (points_max - points_min)\n\n            self.beginStream(\n                ob.id, None,\n                {'ShadingType': 4,\n                 'BitsPerCoordinate': 32,\n                 'BitsPerComponent': 8,\n                 'BitsPerFlag': 8,\n                 'ColorSpace': Name(\n                     'DeviceRGB' if colordim == 3 else 'DeviceGray'\n                 ),\n                 'AntiAlias': False,\n                 'Decode': ([points_min[0], points_max[0],\n                             points_min[1], points_max[1]]\n                            + [0, 1] * colordim),\n                 })\n\n            streamarr = np.empty(\n                (shape[0] * shape[1],),\n                dtype=[('flags', 'u1'),\n                       ('points', '>u4', (2,)),\n                       ('colors', 'u1', (colordim,))])\n            streamarr['flags'] = 0\n            streamarr['points'] = (flat_points - points_min) * factor\n            streamarr['colors'] = flat_colors[:, :colordim] * 255.0\n\n            self.write(streamarr.tobytes())\n            self.endStream()\n        self.writeObject(self.gouraudObject, gouraudDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches",
      "name": "writeHatches",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeHatches/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeHatches.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeHatches(self):\n        hatchDict = dict()\n        sidelen = 72.0\n        for hatch_style, name in self.hatchPatterns.items():\n            ob = self.reserveObject('hatch pattern')\n            hatchDict[name] = ob\n            res = {'Procsets':\n                   [Name(x) for x in \"PDF Text ImageB ImageC ImageI\".split()]}\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('Pattern'),\n                 'PatternType': 1, 'PaintType': 1, 'TilingType': 1,\n                 'BBox': [0, 0, sidelen, sidelen],\n                 'XStep': sidelen, 'YStep': sidelen,\n                 'Resources': res,\n                 # Change origin to match Agg at top-left.\n                 'Matrix': [1, 0, 0, 1, 0, self.height * 72]})\n\n            stroke_rgb, fill_rgb, path = hatch_style\n            self.output(stroke_rgb[0], stroke_rgb[1], stroke_rgb[2],\n                        Op.setrgb_stroke)\n            if fill_rgb is not None:\n                self.output(fill_rgb[0], fill_rgb[1], fill_rgb[2],\n                            Op.setrgb_nonstroke,\n                            0, 0, sidelen, sidelen, Op.rectangle,\n                            Op.fill)\n\n            self.output(mpl.rcParams['hatch.linewidth'], Op.setlinewidth)\n\n            self.output(*self.pathOperations(\n                Path.hatch(path),\n                Affine2D().scale(sidelen),\n                simplify=False))\n            self.output(Op.fill_stroke)\n\n            self.endStream()\n        self.writeObject(self.hatchObject, hatchDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages",
      "name": "writeImages",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeImages/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeImages.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeImages(self):\n        for img, name, ob in self._images.values():\n            data, adata = self._unpack(img)\n            if adata is not None:\n                smaskObject = self.reserveObject(\"smask\")\n                self._writeImg(adata, smaskObject.id)\n            else:\n                smaskObject = None\n            self._writeImg(data, ob.id, smaskObject)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict",
      "name": "writeInfoDict",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeInfoDict/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeInfoDict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the info dictionary, checking it for good form",
      "docstring": "Write out the info dictionary, checking it for good form",
      "code": "    def writeInfoDict(self):\n        \"\"\"Write out the info dictionary, checking it for good form\"\"\"\n\n        self.infoObject = self.reserveObject('info')\n        self.writeObject(self.infoObject, self.infoDict)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers",
      "name": "writeMarkers",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeMarkers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeMarkers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeMarkers(self):\n        for ((pathops, fill, stroke, joinstyle, capstyle),\n             (name, ob, bbox, lw)) in self.markers.items():\n            # bbox wraps the exact limits of the control points, so half a line\n            # will appear outside it. If the join style is miter and the line\n            # is not parallel to the edge, then the line will extend even\n            # further. From the PDF specification, Section 8.4.3.5, the miter\n            # limit is miterLength / lineWidth and from Table 52, the default\n            # is 10. With half the miter length outside, that works out to the\n            # following padding:\n            bbox = bbox.padded(lw * 5)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': list(bbox.extents)})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(fill, stroke))\n            self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject",
      "name": "writeObject",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/object",
          "name": "object",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.object",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeObject/contents",
          "name": "contents",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeObject.contents",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writeObject(self, object, contents):\n        self.recordXref(object.id)\n        object.write(contents, self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath",
      "name": "writePath",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/clip",
          "name": "clip",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.clip",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePath/sketch",
          "name": "sketch",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePath.sketch",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writePath(self, path, transform, clip=False, sketch=None):\n        if clip:\n            clip = (0.0, 0.0, self.width * 72, self.height * 72)\n            simplify = path.should_simplify\n        else:\n            clip = None\n            simplify = False\n        cmds = self.pathOperations(path, transform, clip, simplify=simplify,\n                                   sketch=sketch)\n        self.output(*cmds)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates",
      "name": "writePathCollectionTemplates",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writePathCollectionTemplates/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writePathCollectionTemplates.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def writePathCollectionTemplates(self):\n        for (name, path, trans, ob, joinstyle, capstyle, padding, filled,\n             stroked) in self.paths:\n            pathops = self.pathOperations(path, trans, simplify=False)\n            bbox = path.get_extents(trans)\n            if not np.all(np.isfinite(bbox.extents)):\n                extents = [0, 0, 0, 0]\n            else:\n                bbox = bbox.padded(padding)\n                extents = list(bbox.extents)\n            self.beginStream(\n                ob.id, None,\n                {'Type': Name('XObject'), 'Subtype': Name('Form'),\n                 'BBox': extents})\n            self.output(GraphicsContextPdf.joinstyles[joinstyle],\n                        Op.setlinejoin)\n            self.output(GraphicsContextPdf.capstyles[capstyle], Op.setlinecap)\n            self.output(*pathops)\n            self.output(Op.paint_path(filled, stroked))\n            self.endStream()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer",
      "name": "writeTrailer",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeTrailer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeTrailer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the PDF trailer.",
      "docstring": "Write out the PDF trailer.",
      "code": "    def writeTrailer(self):\n        \"\"\"Write out the PDF trailer.\"\"\"\n\n        self.write(b\"trailer\\n\")\n        self.write(pdfRepr(\n            {'Size': len(self.xrefTable),\n             'Root': self.rootObject,\n             'Info': self.infoObject}))\n        # Could add 'ID'\n        self.write(b\"\\nstartxref\\n%d\\n%%%%EOF\\n\" % self.startxref)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref",
      "name": "writeXref",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfFile/writeXref/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfFile.writeXref.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out the xref table.",
      "docstring": "Write out the xref table.",
      "code": "    def writeXref(self):\n        \"\"\"Write out the xref table.\"\"\"\n        self.startxref = self.fh.tell() - self.tell_base\n        self.write(b\"xref\\n0 %d\\n\" % len(self.xrefTable))\n        for i, (offset, generation, name) in enumerate(self.xrefTable):\n            if offset is None:\n                raise AssertionError(\n                    'No offset for object %d (%s)' % (i, name))\n            else:\n                key = b\"f\" if name == 'the zero object' else b\"n\"\n                text = b\"%010d %05d %b \\n\" % (offset, generation, key)\n                self.write(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__",
      "name": "__enter__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__enter__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__enter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter__(self):\n        return self"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__",
      "name": "__exit__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_type",
          "name": "exc_type",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_val",
          "name": "exc_val",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__exit__/exc_tb",
          "name": "exc_tb",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__exit__.exc_tb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/keep_empty",
          "name": "keep_empty",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.keep_empty",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.__init__.metadata",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file.",
      "docstring": "Create a new PdfPages object.\n\nParameters\n----------\nfilename : str or path-like or file-like\n    Plots using `PdfPages.savefig` will be written to a file at this\n    location. The file is opened at once and any older file with the\n    same name is overwritten.\nkeep_empty : bool, optional\n    If set to False, then empty pdf files will be deleted automatically\n    when closed.\nmetadata : dict, optional\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. The file is opened at once and any older file with the\n            same name is overwritten.\n        keep_empty : bool, optional\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._file = PdfFile(filename, metadata=metadata)\n        self.keep_empty = keep_empty"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note",
      "name": "attach_note",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/attach_note/positionRect",
          "name": "positionRect",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.attach_note.positionRect",
          "default_value": "[-100, -100, 0, 0]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a new text note to the page to be saved next. The optional\npositionRect specifies the position of the new note on the\npage. It is outside the page per default to make sure it is\ninvisible on printouts.",
      "docstring": "Add a new text note to the page to be saved next. The optional\npositionRect specifies the position of the new note on the\npage. It is outside the page per default to make sure it is\ninvisible on printouts.",
      "code": "    def attach_note(self, text, positionRect=[-100, -100, 0, 0]):\n        \"\"\"\n        Add a new text note to the page to be saved next. The optional\n        positionRect specifies the position of the new note on the\n        page. It is outside the page per default to make sure it is\n        invisible on printouts.\n        \"\"\"\n        self._file.newTextnote(text, positionRect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize this object, making the underlying file a complete\nPDF file.",
      "docstring": "Finalize this object, making the underlying file a complete\nPDF file.",
      "code": "    def close(self):\n        \"\"\"\n        Finalize this object, making the underlying file a complete\n        PDF file.\n        \"\"\"\n        self._file.finalize()\n        self._file.close()\n        if (self.get_pagecount() == 0 and not self.keep_empty and\n                not self._file.passed_in_file_object):\n            os.remove(self._file.fh.name)\n        self._file = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount",
      "name": "get_pagecount",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/get_pagecount/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.get_pagecount.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current number of pages in the multipage pdf file.",
      "docstring": "Return the current number of pages in the multipage pdf file.",
      "code": "    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return len(self._file.pageList)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict",
      "name": "infodict",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.infodict",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/infodict/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.infodict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a modifiable information dictionary object\n(see PDF reference section 10.2.1 'Document Information\nDictionary').",
      "docstring": "Return a modifiable information dictionary object\n(see PDF reference section 10.2.1 'Document Information\nDictionary').",
      "code": "    def infodict(self):\n        \"\"\"\n        Return a modifiable information dictionary object\n        (see PDF reference section 10.2.1 'Document Information\n        Dictionary').\n        \"\"\"\n        return self._file.infoDict"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig",
      "name": "savefig",
      "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure` or int",
            "default_value": "",
            "description": "Specifies what figure is saved to file. If not specified, the\nactive figure is saved. If a `.Figure` instance is provided, this\nfigure is saved. If an int is specified, the figure instance to\nsave is looked up by number."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Figure`"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/PdfPages/savefig/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pdf.PdfPages.savefig.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.",
      "docstring": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.\n\nParameters\n----------\nfigure : `.Figure` or int, optional\n    Specifies what figure is saved to file. If not specified, the\n    active figure is saved. If a `.Figure` instance is provided, this\n    figure is saved. If an int is specified, the figure instance to\n    save is looked up by number.",
      "code": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a `.Figure` instance is provided, this\n            figure is saved. If an int is specified, the figure instance to\n            save is looked up by number.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n        # Force use of pdf backend, as PdfPages is tightly coupled with it.\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPdf(figure)\n            figure.savefig(self, format=\"pdf\", **kwargs)\n        finally:\n            figure.canvas = orig_canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF reference object.\n\nUse PdfFile.reserveObject() to create References.",
      "docstring": "",
      "code": "    def __init__(self, id):\n        self.id = id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return \"<Reference %d>\" % self.id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return b\"%d 0 R\" % self.id"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.Reference.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/contents",
          "name": "contents",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.contents",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Reference/write/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.Reference.write.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def write(self, contents, file):\n        write = file.write\n        write(b\"%d 0 obj\\n\" % self.id)\n        write(pdfRepr(contents))\n        write(b\"\\nendobj\\n\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/image_dpi",
          "name": "image_dpi",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.image_dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file, image_dpi, height, width):\n        super().__init__(width, height)\n        self.file = file\n        self.gc = self.new_gc()\n        self.mathtext_parser = MathTextParser(\"Pdf\")\n        self.image_dpi = image_dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc",
      "name": "check_gc",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/check_gc/fillcolor",
          "name": "fillcolor",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.check_gc.fillcolor",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def check_gc(self, gc, fillcolor=None):\n        orig_fill = getattr(gc, '_fillcolor', (0., 0., 0.))\n        gc._fillcolor = fillcolor\n\n        orig_alphas = getattr(gc, '_effective_alphas', (1.0, 1.0))\n\n        if gc.get_rgb() is None:\n            # It should not matter what color here since linewidth should be\n            # 0 unless affected by global settings in rcParams, hence setting\n            # zero alpha just in case.\n            gc.set_foreground((0, 0, 0, 0), isRGBA=True)\n\n        if gc._forced_alpha:\n            gc._effective_alphas = (gc._alpha, gc._alpha)\n        elif fillcolor is None or len(fillcolor) < 4:\n            gc._effective_alphas = (gc._rgb[3], 1.0)\n        else:\n            gc._effective_alphas = (gc._rgb[3], fillcolor[3])\n\n        delta = self.gc.delta(gc)\n        if delta:\n            self.file.output(*delta)\n\n        # Restore gc to avoid unwanted side effects\n        gc._fillcolor = orig_fill\n        gc._effective_alphas = orig_alphas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_gouraud_triangles/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_gouraud_triangles.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        if len(points) == 0:\n            return\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] in (1, 4)\n\n        shape = points.shape\n        points = points.reshape((shape[0] * shape[1], 2))\n        tpoints = trans.transform(points)\n        tpoints = tpoints.reshape(shape)\n        name, _ = self.file.addGouraudTriangles(tpoints, colors)\n        output = self.file.output\n\n        if colors.shape[2] == 1:\n            # grayscale\n            gc.set_alpha(1.0)\n            self.check_gc(gc)\n            output(name, Op.shading)\n            return\n\n        alpha = colors[0, 0, 3]\n        if np.allclose(alpha, colors[:, :, 3]):\n            # single alpha value\n            gc.set_alpha(alpha)\n            self.check_gc(gc)\n            output(name, Op.shading)\n        else:\n            # varying alpha: use a soft mask\n            alpha = colors[:, :, 3][:, :, None]\n            _, smask_ob = self.file.addGouraudTriangles(tpoints, alpha)\n            gstate = self.file._soft_mask_state(smask_ob)\n            output(Op.gsave, gstate, Op.setgstate,\n                   name, Op.shading,\n                   Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if transform is None:\n            # If there's no transform, alpha has already been applied\n            gc.set_alpha(1.0)\n\n        self.check_gc(gc)\n\n        w = 72.0 * w / self.image_dpi\n        h = 72.0 * h / self.image_dpi\n\n        imob = self.file.imageObject(im)\n\n        if transform is None:\n            self.file.output(Op.gsave,\n                             w, 0, 0, h, x, y, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n\n            self.file.output(Op.gsave,\n                             1, 0, 0, 1, x, y, Op.concat_matrix,\n                             tr1, tr2, tr3, tr4, tr5, tr6, Op.concat_matrix,\n                             imob, Op.use_xobject, Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        # Same logic as in draw_path_collection\n        len_marker_path = len(marker_path)\n        uses = len(path)\n        if len_marker_path * uses < len_marker_path + uses + 5:\n            RendererBase.draw_markers(self, gc, marker_path, marker_trans,\n                                      path, trans, rgbFace)\n            return\n\n        self.check_gc(gc, rgbFace)\n        fill = gc.fill(rgbFace)\n        stroke = gc.stroke()\n\n        output = self.file.output\n        marker = self.file.markerObject(\n            marker_path, marker_trans, fill, stroke, self.gc._linewidth,\n            gc.get_joinstyle(), gc.get_capstyle())\n\n        output(Op.gsave)\n        lastx, lasty = 0, 0\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.file.width*72, self.file.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                if not (0 <= x <= self.file.width * 72\n                        and 0 <= y <= self.file.height * 72):\n                    continue\n                dx, dy = x - lastx, y - lasty\n                output(1, 0, 0, 1, dx, dy, Op.concat_matrix,\n                       marker, Op.use_xobject)\n                lastx, lasty = x, y\n        output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        # TODO: fix positioning and encoding\n        width, height, descent, glyphs, rects, used_characters = \\\n            self.mathtext_parser.parse(s, 72, prop)\n        self.file._character_tracker.merge(used_characters)\n\n        # When using Type 3 fonts, we can't use character codes higher\n        # than 255, so we use the \"Do\" command to render those\n        # instead.\n        global_fonttype = mpl.rcParams['pdf.fonttype']\n\n        # Set up a global transformation matrix for the whole math expression\n        a = math.radians(angle)\n        self.file.output(Op.gsave)\n        self.file.output(math.cos(a), math.sin(a),\n                         -math.sin(a), math.cos(a),\n                         x, y, Op.concat_matrix)\n\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        prev_font = None, None\n        oldx, oldy = 0, 0\n        for ox, oy, fontname, fontsize, num, symbol_name in glyphs:\n            if is_opentype_cff_font(fontname):\n                fonttype = 42\n            else:\n                fonttype = global_fonttype\n\n            if fonttype == 42 or num <= 255:\n                self._setup_textpos(ox, oy, 0, oldx, oldy)\n                oldx, oldy = ox, oy\n                if (fontname, fontsize) != prev_font:\n                    self.file.output(self.file.fontName(fontname), fontsize,\n                                     Op.selectfont)\n                    prev_font = fontname, fontsize\n                self.file.output(self.encode_string(chr(num), fonttype),\n                                 Op.show)\n        self.file.output(Op.end_text)\n\n        # If using Type 3 fonts, render all of the multi-byte characters\n        # as XObjects using the 'Do' command.\n        if global_fonttype == 3:\n            for ox, oy, fontname, fontsize, num, symbol_name in glyphs:\n                if is_opentype_cff_font(fontname):\n                    fonttype = 42\n                else:\n                    fonttype = global_fonttype\n\n                if fonttype == 3 and num > 255:\n                    self.file.fontName(fontname)\n                    self.file.output(Op.gsave,\n                                     0.001 * fontsize, 0,\n                                     0, 0.001 * fontsize,\n                                     ox, oy, Op.concat_matrix)\n                    name = self.file._get_xobject_symbol_name(\n                        fontname, symbol_name)\n                    self.file.output(Name(name), Op.use_xobject)\n                    self.file.output(Op.grestore)\n\n        # Draw any horizontal lines in the math layout\n        for ox, oy, width, height in rects:\n            self.file.output(Op.gsave, ox, oy, width, height,\n                             Op.rectangle, Op.fill, Op.grestore)\n\n        # Pop off the global transformation\n        self.file.output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        self.check_gc(gc, rgbFace)\n        self.file.writePath(\n            path, transform,\n            rgbFace is None and gc.get_hatch_path() is None,\n            gc.get_sketch_params())\n        self.file.output(self.gc.paint())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offsetTrans",
          "name": "offsetTrans",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offsetTrans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # We can only reuse the objects if the presence of fill and\n        # stroke (and the amount of alpha for each) is the same for\n        # all of them\n        can_do_optimization = True\n        facecolors = np.asarray(facecolors)\n        edgecolors = np.asarray(edgecolors)\n\n        if not len(facecolors):\n            filled = False\n            can_do_optimization = not gc.get_hatch()\n        else:\n            if np.all(facecolors[:, 3] == facecolors[0, 3]):\n                filled = facecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        if not len(edgecolors):\n            stroked = False\n        else:\n            if np.all(np.asarray(linewidths) == 0.0):\n                stroked = False\n            elif np.all(edgecolors[:, 3] == edgecolors[0, 3]):\n                stroked = edgecolors[0, 3] != 0.0\n            else:\n                can_do_optimization = False\n\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is len_path * uses_per_path\n        # cost of XObject is len_path + 5 for the definition,\n        #    uses_per_path for the uses\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + uses_per_path + 5 < len_path * uses_per_path\n\n        if (not can_do_optimization) or (not should_do_optimization):\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        padding = np.max(linewidths)\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = self.file.pathCollectionObject(\n                gc, path, transform, padding, filled, stroked)\n            path_codes.append(name)\n\n        output = self.file.output\n        output(*self.gc.push())\n        lastx, lasty = 0, 0\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n\n            self.check_gc(gc0, rgbFace)\n            dx, dy = xo - lastx, yo - lasty\n            output(1, 0, 0, 1, dx, dy, Op.concat_matrix, path_id,\n                   Op.use_xobject)\n            lastx, lasty = xo, yo\n        output(*self.gc.pop())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex",
      "decorators": [
        "cbook._delete_parameter('3.3', 'ismath')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.ismath",
          "default_value": "'TeX!'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook._delete_parameter(\"3.3\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        texmanager = self.get_texmanager()\n        fontsize = prop.get_size_in_points()\n        dvifile = texmanager.make_dvi(s, fontsize)\n        with dviread.Dvi(dvifile, 72) as dvi:\n            page, = dvi\n\n        # Gather font information and do some setup for combining\n        # characters into strings. The variable seq will contain a\n        # sequence of font and text entries. A font entry is a list\n        # ['font', name, size] where name is a Name object for the\n        # font. A text entry is ['text', x, y, glyphs, x+w] where x\n        # and y are the starting coordinates, w is the width, and\n        # glyphs is a list; in this phase it will always contain just\n        # one one-character string, but later it may have longer\n        # strings interspersed with kern amounts.\n        oldfont, seq = None, []\n        for x1, y1, dvifont, glyph, width in page.text:\n            if dvifont != oldfont:\n                pdfname = self.file.dviFontName(dvifont)\n                seq += [['font', pdfname, dvifont.size]]\n                oldfont = dvifont\n            seq += [['text', x1, y1, [bytes([glyph])], x1+width]]\n\n        # Find consecutive text strings with constant y coordinate and\n        # combine into a sequence of strings and kerns, or just one\n        # string (if any kerns would be less than 0.1 points).\n        i, curx, fontsize = 0, 0, None\n        while i < len(seq)-1:\n            elt, nxt = seq[i:i+2]\n            if elt[0] == 'font':\n                fontsize = elt[2]\n            elif elt[0] == nxt[0] == 'text' and elt[2] == nxt[2]:\n                offset = elt[4] - nxt[1]\n                if abs(offset) < 0.1:\n                    elt[3][-1] += nxt[3][0]\n                    elt[4] += nxt[4]-nxt[1]\n                else:\n                    elt[3] += [offset*1000.0/fontsize, nxt[3][0]]\n                    elt[4] = nxt[4]\n                del seq[i+1]\n                continue\n            i += 1\n\n        # Create a transform to map the dvi contents to the canvas.\n        mytrans = Affine2D().rotate_deg(angle).translate(x, y)\n\n        # Output the text.\n        self.check_gc(gc, gc._rgb)\n        self.file.output(Op.begin_text)\n        curx, cury, oldx, oldy = 0, 0, 0, 0\n        for elt in seq:\n            if elt[0] == 'font':\n                self.file.output(elt[1], elt[2], Op.selectfont)\n            elif elt[0] == 'text':\n                curx, cury = mytrans.transform((elt[1], elt[2]))\n                self._setup_textpos(curx, cury, angle, oldx, oldy)\n                oldx, oldy = curx, cury\n                if len(elt[3]) == 1:\n                    self.file.output(elt[3][0], Op.show)\n                else:\n                    self.file.output(elt[3], Op.showkern)\n            else:\n                assert False\n        self.file.output(Op.end_text)\n\n        # Then output the boxes (e.g., variable-length lines of square\n        # roots).\n        boxgc = self.new_gc()\n        boxgc.copy_properties(gc)\n        boxgc.set_linewidth(0)\n        pathops = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO,\n                   Path.CLOSEPOLY]\n        for x1, y1, h, w in page.boxes:\n            path = Path([[x1, y1], [x1+w, y1], [x1+w, y1+h], [x1, y1+h],\n                         [0, 0]], pathops)\n            self.draw_path(boxgc, path, mytrans, gc._rgb)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # TODO: combine consecutive texts into one BT/ET delimited section\n\n        self.check_gc(gc, gc._rgb)\n        if ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        fontsize = prop.get_size_in_points()\n\n        if mpl.rcParams['pdf.use14corefonts']:\n            font = self._get_font_afm(prop)\n            fonttype = 1\n        else:\n            font = self._get_font_ttf(prop)\n            self.file._character_tracker.track(font, s)\n            fonttype = mpl.rcParams['pdf.fonttype']\n            # We can't subset all OpenType fonts, so switch to Type 42\n            # in that case.\n            if is_opentype_cff_font(font.fname):\n                fonttype = 42\n\n        # If fonttype != 3 or there are no multibyte characters, emit the whole\n        # string at once.\n        if fonttype != 3 or all(ord(char) <= 255 for char in s):\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            self._setup_textpos(x, y, angle)\n            self.file.output(self.encode_string(s, fonttype), Op.show,\n                             Op.end_text)\n\n        # There is no way to access multibyte characters of Type 3 fonts, as\n        # they cannot have a CIDMap.  Therefore, in this case we break the\n        # string into chunks, where each chunk contains either a string of\n        # consecutive 1-byte characters or a single multibyte character.  Each\n        # chunk is emitted with a separate command: 1-byte characters use the\n        # regular text show command (Tj), whereas multibyte characters use\n        # the XObject command (Do).  (If using Type 42 fonts, all of this\n        # complication is avoided, but of course, those fonts can not be\n        # subsetted.)\n        else:\n            singlebyte_chunks = []  # List of (start_x, list-of-1-byte-chars).\n            multibyte_glyphs = []  # List of (start_x, glyph_index).\n            prev_was_singlebyte = False\n            for char, (glyph_idx, glyph_x) in zip(\n                    s,\n                    _text_layout.layout(s, font, kern_mode=KERNING_UNFITTED)):\n                if ord(char) <= 255:\n                    if prev_was_singlebyte:\n                        singlebyte_chunks[-1][1].append(char)\n                    else:\n                        singlebyte_chunks.append((glyph_x, [char]))\n                    prev_was_singlebyte = True\n                else:\n                    multibyte_glyphs.append((glyph_x, glyph_idx))\n                    prev_was_singlebyte = False\n            # Do the rotation and global translation as a single matrix\n            # concatenation up front\n            self.file.output(Op.gsave)\n            a = math.radians(angle)\n            self.file.output(math.cos(a), math.sin(a),\n                             -math.sin(a), math.cos(a),\n                             x, y, Op.concat_matrix)\n            # Emit all the 1-byte characters in a BT/ET group.\n            self.file.output(Op.begin_text,\n                             self.file.fontName(prop), fontsize, Op.selectfont)\n            prev_start_x = 0\n            for start_x, chars in singlebyte_chunks:\n                self._setup_textpos(start_x, 0, 0, prev_start_x, 0, 0)\n                self.file.output(self.encode_string(''.join(chars), fonttype),\n                                 Op.show)\n                prev_start_x = start_x\n            self.file.output(Op.end_text)\n            # Then emit all the multibyte characters, one at a time.\n            for start_x, glyph_idx in multibyte_glyphs:\n                glyph_name = font.get_glyph_name(glyph_idx)\n                self.file.output(Op.gsave)\n                self.file.output(0.001 * fontsize, 0,\n                                 0, 0.001 * fontsize,\n                                 start_x, 0, Op.concat_matrix)\n                name = self.file._get_xobject_symbol_name(\n                    font.fname, glyph_name)\n                self.file.output(Name(name), Op.use_xobject)\n                self.file.output(Op.grestore)\n            self.file.output(Op.grestore)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string",
      "name": "encode_string",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/encode_string/fonttype",
          "name": "fonttype",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.encode_string.fonttype",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def encode_string(self, s, fonttype):\n        if fonttype in (1, 3):\n            return s.encode('cp1252', 'replace')\n        return s.encode('utf-16be', 'replace')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finalize(self):\n        self.file.output(*self.gc.finalize())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_image_magnification(self):\n        return self.image_dpi/72.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/merge_used_characters",
      "name": "merge_used_characters",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.merge_used_characters",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/merge_used_characters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.merge_used_characters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/merge_used_characters/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.merge_used_characters.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/merge_used_characters/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.merge_used_characters.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def merge_used_characters(self, *args, **kwargs):\n        self.file._character_tracker.merge(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPdf(self.file)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/track_characters",
      "name": "track_characters",
      "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.track_characters",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/track_characters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.track_characters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/track_characters/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.track_characters.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/RendererPdf/track_characters/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pdf.RendererPdf.track_characters.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Keep track of which characters are required from each font.",
      "docstring": "Keep track of which characters are required from each font.",
      "code": "    @cbook.deprecated(\"3.3\")\n    def track_characters(self, *args, **kwargs):\n        \"\"\"Keep track of which characters are required from each font.\"\"\"\n        self.file._character_tracker.track(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/len",
          "name": "len",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.len",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.extra",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/__init__/png",
          "name": "png",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.__init__.png",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "PDF stream object.\n\nThis has no pdfRepr method. Instead, call begin(), then output the\ncontents of the stream by calling write(), and finally call end().",
      "docstring": "Parameters\n----------\n\nid : int\n    Object id of the stream.\nlen : Reference or None\n    An unused Reference object for the length of the stream;\n    None means to use a memory buffer so the length can be inlined.\nfile : PdfFile\n    The underlying object to write the stream to.\nextra : dict from Name to anything, or None\n    Extra key-value pairs to include in the stream header.\npng : dict or None\n    If the data is already png encoded, the decode parameters.",
      "code": "    def __init__(self, id, len, file, extra=None, png=None):\n        \"\"\"\n        Parameters\n        ----------\n\n        id : int\n            Object id of the stream.\n        len : Reference or None\n            An unused Reference object for the length of the stream;\n            None means to use a memory buffer so the length can be inlined.\n        file : PdfFile\n            The underlying object to write the stream to.\n        extra : dict from Name to anything, or None\n            Extra key-value pairs to include in the stream header.\n        png : dict or None\n            If the data is already png encoded, the decode parameters.\n        \"\"\"\n        self.id = id            # object id\n        self.len = len          # id of length object\n        self.pdfFile = file\n        self.file = file.fh      # file to which the stream is written\n        self.compressobj = None  # compression object\n        if extra is None:\n            self.extra = dict()\n        else:\n            self.extra = extra.copy()\n        if png is not None:\n            self.extra.update({'Filter':      Name('FlateDecode'),\n                               'DecodeParms': png})\n\n        self.pdfFile.recordXref(self.id)\n        if mpl.rcParams['pdf.compression'] and not png:\n            self.compressobj = zlib.compressobj(\n                mpl.rcParams['pdf.compression'])\n        if self.len is None:\n            self.file = BytesIO()\n        else:\n            self._writeHeader()\n            self.pos = self.file.tell()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end",
      "name": "end",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.end",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/end/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.end.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize stream.",
      "docstring": "Finalize stream.",
      "code": "    def end(self):\n        \"\"\"Finalize stream.\"\"\"\n\n        self._flush()\n        if self.len is None:\n            contents = self.file.getvalue()\n            self.len = len(contents)\n            self.file = self.pdfFile.fh\n            self._writeHeader()\n            self.file.write(contents)\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n        else:\n            length = self.file.tell() - self.pos\n            self.file.write(b\"\\nendstream\\nendobj\\n\")\n            self.pdfFile.writeObject(self.len, length)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write",
      "name": "write",
      "qname": "lib.matplotlib.backends.backend_pdf.Stream.write",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.write.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Stream/write/data",
          "name": "data",
          "qname": "lib.matplotlib.backends.backend_pdf.Stream.write.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write some data on the stream.",
      "docstring": "Write some data on the stream.",
      "code": "    def write(self, data):\n        \"\"\"Write some data on the stream.\"\"\"\n\n        if self.compressobj is None:\n            self.file.write(data)\n        else:\n            compressed = self.compressobj.compress(data)\n            self.file.write(compressed)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/__init__/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.__init__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Store verbatim PDF command content for later inclusion in the stream.",
      "docstring": "",
      "code": "    def __init__(self, x):\n        self._x = x"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/Verbatim/pdfRepr/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pdf.Verbatim.pdfRepr.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pdfRepr(self):\n        return self._x"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill",
      "name": "fill",
      "qname": "lib.matplotlib.backends.backend_pdf.fill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill/strings",
          "name": "strings",
          "qname": "lib.matplotlib.backends.backend_pdf.fill.strings",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/fill/linelen",
          "name": "linelen",
          "qname": "lib.matplotlib.backends.backend_pdf.fill.linelen",
          "default_value": "75",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Make one string from sequence of strings, with whitespace in between.\n\nThe whitespace is chosen to form lines of at most *linelen* characters,\nif possible.",
      "docstring": "Make one string from sequence of strings, with whitespace in between.\n\nThe whitespace is chosen to form lines of at most *linelen* characters,\nif possible.",
      "code": "def fill(strings, linelen=75):\n    \"\"\"\n    Make one string from sequence of strings, with whitespace in between.\n\n    The whitespace is chosen to form lines of at most *linelen* characters,\n    if possible.\n    \"\"\"\n    currpos = 0\n    lasti = 0\n    result = []\n    for i, s in enumerate(strings):\n        length = len(s)\n        if currpos + length < linelen:\n            currpos += length + 1\n        else:\n            result.append(b' '.join(strings[lasti:i]))\n            lasti = i\n            currpos = length\n    result.append(b' '.join(strings[lasti:]))\n    return b'\\n'.join(result)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pdf/pdfRepr",
      "name": "pdfRepr",
      "qname": "lib.matplotlib.backends.backend_pdf.pdfRepr",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pdf/pdfRepr/obj",
          "name": "obj",
          "qname": "lib.matplotlib.backends.backend_pdf.pdfRepr.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Map Python objects to PDF syntax.",
      "docstring": "Map Python objects to PDF syntax.",
      "code": "def pdfRepr(obj):\n    \"\"\"Map Python objects to PDF syntax.\"\"\"\n\n    # Some objects defined later have their own pdfRepr method.\n    if hasattr(obj, 'pdfRepr'):\n        return obj.pdfRepr()\n\n    # Floats. PDF does not have exponential notation (1.0e-10) so we\n    # need to use %f with some precision.  Perhaps the precision\n    # should adapt to the magnitude of the number?\n    elif isinstance(obj, (float, np.floating)):\n        if not np.isfinite(obj):\n            raise ValueError(\"Can only output finite numbers in PDF\")\n        r = b\"%.10f\" % obj\n        return r.rstrip(b'0').rstrip(b'.')\n\n    # Booleans. Needs to be tested before integers since\n    # isinstance(True, int) is true.\n    elif isinstance(obj, bool):\n        return [b'false', b'true'][obj]\n\n    # Integers are written as such.\n    elif isinstance(obj, (int, np.integer)):\n        return b\"%d\" % obj\n\n    # Unicode strings are encoded in UTF-16BE with byte-order mark.\n    elif isinstance(obj, str):\n        try:\n            # But maybe it's really ASCII?\n            s = obj.encode('ASCII')\n            return pdfRepr(s)\n        except UnicodeEncodeError:\n            s = codecs.BOM_UTF16_BE + obj.encode('UTF-16BE')\n            return pdfRepr(s)\n\n    # Strings are written in parentheses, with backslashes and parens\n    # escaped. Actually balanced parens are allowed, but it is\n    # simpler to escape them all. TODO: cut long strings into lines;\n    # I believe there is some maximum line length in PDF.\n    elif isinstance(obj, bytes):\n        return b'(' + _string_escape_regex.sub(_string_escape, obj) + b')'\n\n    # Dictionaries. The keys must be PDF names, so if we find strings\n    # there, we make Name objects from them. The values may be\n    # anything, so the caller must ensure that PDF names are\n    # represented as Name objects.\n    elif isinstance(obj, dict):\n        return fill([\n            b\"<<\",\n            *[Name(key).pdfRepr() + b\" \" + pdfRepr(obj[key])\n              for key in sorted(obj)],\n            b\">>\",\n        ])\n\n    # Lists.\n    elif isinstance(obj, (list, tuple)):\n        return fill([b\"[\", *[pdfRepr(val) for val in obj], b\"]\"])\n\n    # The null keyword.\n    elif obj is None:\n        return b'null'\n\n    # A date.\n    elif isinstance(obj, datetime):\n        return pdfRepr(_datetime_to_pdf(obj))\n\n    # A bounding box\n    elif isinstance(obj, BboxBase):\n        return fill([pdfRepr(val) for val in obj.bounds])\n\n    else:\n        raise TypeError(\"Don't know a PDF representation for {} objects\"\n                        .format(type(obj)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'pdf'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self):\n        return RendererPgf(self.figure, None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf",
      "name": "print_pdf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pdf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pdf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use LaTeX to compile a Pgf generated figure to PDF.",
      "docstring": "Use LaTeX to compile a Pgf generated figure to PDF.",
      "code": "    def print_pdf(self, fname_or_fh, *args, **kwargs):\n        \"\"\"Use LaTeX to compile a Pgf generated figure to PDF.\"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n        with cbook.open_file_cm(fname_or_fh, \"wb\") as file:\n            self._print_pdf_to_fh(file, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf",
      "name": "print_pgf",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_pgf/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_pgf.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Output pgf macros for drawing the figure so it can be included and\nrendered in latex documents.",
      "docstring": "Output pgf macros for drawing the figure so it can be included and\nrendered in latex documents.",
      "code": "    def print_pgf(self, fname_or_fh, *args, **kwargs):\n        \"\"\"\n        Output pgf macros for drawing the figure so it can be included and\n        rendered in latex documents.\n        \"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n        with cbook.open_file_cm(fname_or_fh, \"w\", encoding=\"utf-8\") as file:\n            if not cbook.file_requires_unicode(file):\n                file = codecs.getwriter(\"utf-8\")(file)\n            self._print_pgf_to_fh(file, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/fname_or_fh",
          "name": "fname_or_fh",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.fname_or_fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/FigureCanvasPgf/print_png/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.FigureCanvasPgf.print_png.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use LaTeX to compile a pgf figure to pdf and convert it to png.",
      "docstring": "Use LaTeX to compile a pgf figure to pdf and convert it to png.",
      "code": "    def print_png(self, fname_or_fh, *args, **kwargs):\n        \"\"\"Use LaTeX to compile a pgf figure to pdf and convert it to png.\"\"\"\n        if kwargs.get(\"dryrun\", False):\n            self._print_pgf_to_fh(None, *args, **kwargs)\n            return\n        with cbook.open_file_cm(fname_or_fh, \"wb\") as file:\n            self._print_png_to_fh(file, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexError/__init__/latex_output",
          "name": "latex_output",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexError.__init__.latex_output",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, message, latex_output=\"\"):\n        super().__init__(message)\n        self.latex_output = latex_output"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The LatexManager opens an instance of the LaTeX application for\ndetermining the metrics of text elements. The LaTeX environment can be\nmodified by setting fonts and/or a custom preamble in `.rcParams`.",
      "docstring": "",
      "code": "    def __init__(self):\n        # create a tmp directory for running latex, register it for deletion\n        self._tmpdir = TemporaryDirectory()\n        self.tmpdir = self._tmpdir.name\n        self._finalize_tmpdir = weakref.finalize(self, self._tmpdir.cleanup)\n\n        # test the LaTeX setup to ensure a clean startup of the subprocess\n        self.texcommand = mpl.rcParams[\"pgf.texsystem\"]\n        self.latex_header = LatexManager._build_latex_header()\n        latex_end = \"\\n\\\\makeatletter\\n\\\\@@end\\n\"\n        try:\n            latex = subprocess.Popen(\n                [self.texcommand, \"-halt-on-error\"],\n                stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                encoding=\"utf-8\", cwd=self.tmpdir)\n        except FileNotFoundError as err:\n            raise RuntimeError(\n                f\"{self.texcommand} not found.  Install it or change \"\n                f\"rcParams['pgf.texsystem'] to an available TeX \"\n                f\"implementation.\") from err\n        except OSError as err:\n            raise RuntimeError(\"Error starting process %r\" %\n                               self.texcommand) from err\n        test_input = self.latex_header + latex_end\n        stdout, stderr = latex.communicate(test_input)\n        if latex.returncode != 0:\n            raise LatexError(\"LaTeX returned an error, probably missing font \"\n                             \"or error in preamble:\\n%s\" % stdout)\n\n        self.latex = None  # Will be set up on first use.\n        self.str_cache = {}  # cache for strings already processed"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent",
      "name": "get_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/get_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.get_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the width, total height and descent for a text typeset by the\ncurrent LaTeX environment.",
      "docstring": "Get the width, total height and descent for a text typeset by the\ncurrent LaTeX environment.",
      "code": "    def get_width_height_descent(self, text, prop):\n        \"\"\"\n        Get the width, total height and descent for a text typeset by the\n        current LaTeX environment.\n        \"\"\"\n\n        # apply font properties and define textbox\n        prop_cmds = _font_properties_str(prop)\n        textbox = \"\\\\sbox0{%s %s}\" % (prop_cmds, text)\n\n        # check cache\n        if textbox in self.str_cache:\n            return self.str_cache[textbox]\n\n        # send textbox to LaTeX and wait for prompt\n        self._stdin_writeln(textbox)\n        try:\n            self._expect_prompt()\n        except LatexError as e:\n            raise ValueError(\"Error processing '{}'\\nLaTeX Output:\\n{}\"\n                             .format(text, e.latex_output)) from e\n\n        # typeout width, height and text offset of the last textbox\n        self._stdin_writeln(r\"\\typeout{\\the\\wd0,\\the\\ht0,\\the\\dp0}\")\n        # read answer from latex and advance to the next prompt\n        try:\n            answer = self._expect_prompt()\n        except LatexError as e:\n            raise ValueError(\"Error processing '{}'\\nLaTeX Output:\\n{}\"\n                             .format(text, e.latex_output)) from e\n\n        # parse metrics from the answer string\n        try:\n            width, height, offset = answer.splitlines()[0].split(\",\")\n        except Exception as err:\n            raise ValueError(\"Error processing '{}'\\nLaTeX Output:\\n{}\"\n                             .format(text, answer)) from err\n        w, h, o = float(width[:-2]), float(height[:-2]), float(offset[:-2])\n\n        # the height returned from LaTeX goes from base to top.\n        # the height matplotlib expects goes from bottom to top.\n        self.str_cache[textbox] = (w, h + o, o)\n        return w, h + o, o"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/latex_stdin_utf8",
      "name": "latex_stdin_utf8",
      "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.latex_stdin_utf8",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/LatexManager/latex_stdin_utf8/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.LatexManager.latex_stdin_utf8.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def latex_stdin_utf8(self):\n        return self.latex.stdin"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__",
      "name": "__enter__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__enter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__enter__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__enter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __enter__(self):\n        return self"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__",
      "name": "__exit__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_type",
          "name": "exc_type",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_val",
          "name": "exc_val",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__exit__/exc_tb",
          "name": "exc_tb",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__exit__.exc_tb",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/keep_empty",
          "name": "keep_empty",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.keep_empty",
          "default_value": "True",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.__init__.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A multi-page PDF file using the pgf backend",
      "docstring": "Create a new PdfPages object.\n\nParameters\n----------\nfilename : str or path-like\n    Plots using `PdfPages.savefig` will be written to a file at this\n    location. Any older file with the same name is overwritten.\nkeep_empty : bool, default: True\n    If set to False, then empty pdf files will be deleted automatically\n    when closed.\nmetadata : dict, optional\n    Information dictionary object (see PDF reference section 10.2.1\n    'Document Information Dictionary'), e.g.:\n    ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n    The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n    'Creator', 'Producer', 'CreationDate', 'ModDate', and\n    'Trapped'. Values have been predefined for 'Creator', 'Producer'\n    and 'CreationDate'. They can be removed by setting them to `None`.",
      "code": "    def __init__(self, filename, *, keep_empty=True, metadata=None):\n        \"\"\"\n        Create a new PdfPages object.\n\n        Parameters\n        ----------\n        filename : str or path-like\n            Plots using `PdfPages.savefig` will be written to a file at this\n            location. Any older file with the same name is overwritten.\n        keep_empty : bool, default: True\n            If set to False, then empty pdf files will be deleted automatically\n            when closed.\n        metadata : dict, optional\n            Information dictionary object (see PDF reference section 10.2.1\n            'Document Information Dictionary'), e.g.:\n            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.\n\n            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',\n            'Creator', 'Producer', 'CreationDate', 'ModDate', and\n            'Trapped'. Values have been predefined for 'Creator', 'Producer'\n            and 'CreationDate'. They can be removed by setting them to `None`.\n        \"\"\"\n        self._outputfile = filename\n        self._n_figures = 0\n        self.keep_empty = keep_empty\n        self._metadata = (metadata or {}).copy()\n        if metadata:\n            for key in metadata:\n                canonical = {\n                    'creationdate': 'CreationDate',\n                    'moddate': 'ModDate',\n                }.get(key.lower(), key.lower().title())\n                if canonical != key:\n                    cbook.warn_deprecated(\n                        '3.3', message='Support for setting PDF metadata keys '\n                        'case-insensitively is deprecated since %(since)s and '\n                        'will be removed %(removal)s; '\n                        f'set {canonical} instead of {key}.')\n                    self._metadata[canonical] = self._metadata.pop(key)\n        self._info_dict = _create_pdf_info_dict('pgf', self._metadata)\n\n        # create temporary directory for compiling the figure\n        self._tmpdir = tempfile.mkdtemp(prefix=\"mpl_pgf_pdfpages_\")\n        self._basename = 'pdf_pages'\n        self._fname_tex = os.path.join(self._tmpdir, self._basename + \".tex\")\n        self._fname_pdf = os.path.join(self._tmpdir, self._basename + \".pdf\")\n        self._file = open(self._fname_tex, 'wb')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Finalize this object, running LaTeX in a temporary directory\nand moving the final pdf file to *filename*.",
      "docstring": "Finalize this object, running LaTeX in a temporary directory\nand moving the final pdf file to *filename*.",
      "code": "    def close(self):\n        \"\"\"\n        Finalize this object, running LaTeX in a temporary directory\n        and moving the final pdf file to *filename*.\n        \"\"\"\n        self._file.write(rb'\\end{document}\\n')\n        self._file.close()\n\n        if self._n_figures > 0:\n            try:\n                self._run_latex()\n            finally:\n                try:\n                    shutil.rmtree(self._tmpdir)\n                except:\n                    TmpDirCleaner.add(self._tmpdir)\n        elif self.keep_empty:\n            open(self._outputfile, 'wb').close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount",
      "name": "get_pagecount",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.get_pagecount",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/get_pagecount/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.get_pagecount.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current number of pages in the multipage pdf file.",
      "docstring": "Return the current number of pages in the multipage pdf file.",
      "code": "    def get_pagecount(self):\n        \"\"\"Return the current number of pages in the multipage pdf file.\"\"\"\n        return self._n_figures"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/metadata@getter",
      "name": "metadata",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.metadata",
      "decorators": [
        "cbook.deprecated('3.3')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/metadata@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.metadata.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated('3.3')\n    @property\n    def metadata(self):\n        return self._metadata"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig",
      "name": "savefig",
      "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.figure",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "`.Figure` or int",
            "default_value": "",
            "description": "Specifies what figure is saved to file. If not specified, the\nactive figure is saved. If a `.Figure` instance is provided, this\nfigure is saved. If an int is specified, the figure instance to\nsave is looked up by number."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "`.Figure`"
              },
              {
                "kind": "NamedType",
                "name": "int"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/PdfPages/savefig/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_pgf.PdfPages.savefig.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.",
      "docstring": "Save a `.Figure` to this file as a new page.\n\nAny other keyword arguments are passed to `~.Figure.savefig`.\n\nParameters\n----------\nfigure : `.Figure` or int, optional\n    Specifies what figure is saved to file. If not specified, the\n    active figure is saved. If a `.Figure` instance is provided, this\n    figure is saved. If an int is specified, the figure instance to\n    save is looked up by number.",
      "code": "    def savefig(self, figure=None, **kwargs):\n        \"\"\"\n        Save a `.Figure` to this file as a new page.\n\n        Any other keyword arguments are passed to `~.Figure.savefig`.\n\n        Parameters\n        ----------\n        figure : `.Figure` or int, optional\n            Specifies what figure is saved to file. If not specified, the\n            active figure is saved. If a `.Figure` instance is provided, this\n            figure is saved. If an int is specified, the figure instance to\n            save is looked up by number.\n        \"\"\"\n        if not isinstance(figure, Figure):\n            if figure is None:\n                manager = Gcf.get_active()\n            else:\n                manager = Gcf.get_fig_manager(figure)\n            if manager is None:\n                raise ValueError(\"No figure {}\".format(figure))\n            figure = manager.canvas.figure\n\n        try:\n            orig_canvas = figure.canvas\n            figure.canvas = FigureCanvasPgf(figure)\n\n            width, height = figure.get_size_inches()\n            if self._n_figures == 0:\n                self._write_header(width, height)\n            else:\n                # \\pdfpagewidth and \\pdfpageheight exist on pdftex, xetex, and\n                # luatex<0.85; they were renamed to \\pagewidth and \\pageheight\n                # on luatex>=0.85.\n                self._file.write(\n                    br'\\newpage'\n                    br'\\ifdefined\\pdfpagewidth\\pdfpagewidth'\n                    br'\\else\\pagewidth\\fi=%ain'\n                    br'\\ifdefined\\pdfpageheight\\pdfpageheight'\n                    br'\\else\\pageheight\\fi=%ain'\n                    b'%%\\n' % (width, height)\n                )\n\n            figure.savefig(self._file, format=\"pgf\", **kwargs)\n            self._n_figures += 1\n        finally:\n            figure.canvas = orig_canvas"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__",
      "decorators": [
        "cbook._delete_parameter('3.3', 'dummy')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/fh",
          "name": "fh",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/__init__/dummy",
          "name": "dummy",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.__init__.dummy",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Create a new PGF renderer that translates any drawing instruction\ninto text commands to be interpreted in a latex pgfpicture environment.\n\nAttributes\n----------\nfigure : `matplotlib.figure.Figure`\n    Matplotlib figure to initialize height, width and dpi from.\nfh : file-like\n    File handle for the output of the drawing commands.",
      "code": "    @cbook._delete_parameter(\"3.3\", \"dummy\")\n    def __init__(self, figure, fh, dummy=False):\n        \"\"\"\n        Create a new PGF renderer that translates any drawing instruction\n        into text commands to be interpreted in a latex pgfpicture environment.\n\n        Attributes\n        ----------\n        figure : `matplotlib.figure.Figure`\n            Matplotlib figure to initialize height, width and dpi from.\n        fh : file-like\n            File handle for the output of the drawing commands.\n        \"\"\"\n\n        RendererBase.__init__(self)\n        self.dpi = figure.dpi\n        self.fh = fh\n        self.figure = figure\n        self.image_counter = 0\n\n        self._latexManager = LatexManager._get_cached_or_new()  # deprecated\n\n        if dummy:\n            # dummy==True deactivate all methods\n            for m in RendererPgf.__dict__:\n                if m.startswith(\"draw_\"):\n                    self.__dict__[m] = lambda *args, **kwargs: None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        if w == 0 or h == 0:\n            return\n\n        if not os.path.exists(getattr(self.fh, \"name\", \"\")):\n            cbook._warn_external(\n                \"streamed pgf-code does not support raster graphics, consider \"\n                \"using the pgf-to-pdf option.\")\n\n        # save the images to png files\n        path = pathlib.Path(self.fh.name)\n        fname_img = \"%s-img%d.png\" % (path.stem, self.image_counter)\n        Image.fromarray(im[::-1]).save(path.parent / fname_img)\n        self.image_counter += 1\n\n        # reference the image in the pgf picture\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n        self._print_pgf_clip(gc)\n        f = 1. / self.dpi  # from display coords to inch\n        if transform is None:\n            writeln(self.fh,\n                    r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x * f, y * f))\n            w, h = w * f, h * f\n        else:\n            tr1, tr2, tr3, tr4, tr5, tr6 = transform.frozen().to_values()\n            writeln(self.fh,\n                    r\"\\pgfsys@transformcm{%f}{%f}{%f}{%f}{%fin}{%fin}\" %\n                    (tr1 * f, tr2 * f, tr3 * f, tr4 * f,\n                     (tr5 + x) * f, (tr6 + y) * f))\n            w = h = 1  # scale is already included in the transform\n        interp = str(transform is None).lower()  # interpolation in PDF reader\n        writeln(self.fh,\n                r\"\\pgftext[left,bottom]\"\n                r\"{%s[interpolate=%s,width=%fin,height=%fin]{%s}}\" %\n                (_get_image_inclusion_command(),\n                 interp, w, h, fname_img))\n        writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(self, gc, marker_path, marker_trans, path, trans,\n                     rgbFace=None):\n        # docstring inherited\n\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        # convert from display units to in\n        f = 1. / self.dpi\n\n        # set style and clip\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n\n        # build marker definition\n        bl, tr = marker_path.get_extents(marker_trans).get_points()\n        coords = bl[0] * f, bl[1] * f, tr[0] * f, tr[1] * f\n        writeln(self.fh,\n                r\"\\pgfsys@defobject{currentmarker}\"\n                r\"{\\pgfqpoint{%fin}{%fin}}{\\pgfqpoint{%fin}{%fin}}{\" % coords)\n        self._print_pgf_path(None, marker_path, marker_trans)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        writeln(self.fh, r\"}\")\n\n        # draw marker for each vertex\n        for point, code in path.iter_segments(trans, simplify=False):\n            x, y = point[0] * f, point[1] * f\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            writeln(self.fh, r\"\\pgfsys@transformshift{%fin}{%fin}\" % (x, y))\n            writeln(self.fh, r\"\\pgfsys@useobject{currentmarker}{}\")\n            writeln(self.fh, r\"\\end{pgfscope}\")\n\n        writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n        # draw the path\n        self._print_pgf_clip(gc)\n        self._print_pgf_path_styles(gc, rgbFace)\n        self._print_pgf_path(gc, path, transform, rgbFace)\n        self._pgf_path_draw(stroke=gc.get_linewidth() != 0.0,\n                            fill=rgbFace is not None)\n        writeln(self.fh, r\"\\end{pgfscope}\")\n\n        # if present, draw pattern on top\n        if gc.get_hatch():\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            self._print_pgf_path_styles(gc, rgbFace)\n\n            # combine clip and path for clipping\n            self._print_pgf_clip(gc)\n            self._print_pgf_path(gc, path, transform, rgbFace)\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n\n            # build pattern definition\n            writeln(self.fh,\n                    r\"\\pgfsys@defobject{currentpattern}\"\n                    r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}{\")\n            writeln(self.fh, r\"\\begin{pgfscope}\")\n            writeln(self.fh,\n                    r\"\\pgfpathrectangle\"\n                    r\"{\\pgfqpoint{0in}{0in}}{\\pgfqpoint{1in}{1in}}\")\n            writeln(self.fh, r\"\\pgfusepath{clip}\")\n            scale = mpl.transforms.Affine2D().scale(self.dpi)\n            self._print_pgf_path(None, gc.get_hatch_path(), scale)\n            self._pgf_path_draw(stroke=True)\n            writeln(self.fh, r\"\\end{pgfscope}\")\n            writeln(self.fh, r\"}\")\n            # repeat pattern, filling the bounding rect of the path\n            f = 1. / self.dpi\n            (xmin, ymin), (xmax, ymax) = \\\n                path.get_extents(transform).get_points()\n            xmin, xmax = f * xmin, f * xmax\n            ymin, ymax = f * ymin, f * ymax\n            repx, repy = math.ceil(xmax - xmin), math.ceil(ymax - ymin)\n            writeln(self.fh,\n                    r\"\\pgfsys@transformshift{%fin}{%fin}\" % (xmin, ymin))\n            for iy in range(repy):\n                for ix in range(repx):\n                    writeln(self.fh, r\"\\pgfsys@useobject{currentpattern}{}\")\n                    writeln(self.fh, r\"\\pgfsys@transformshift{1in}{0in}\")\n                writeln(self.fh, r\"\\pgfsys@transformshift{-%din}{0in}\" % repx)\n                writeln(self.fh, r\"\\pgfsys@transformshift{0in}{1in}\")\n\n            writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.ismath",
          "default_value": "'TeX!'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_tex(self, gc, x, y, s, prop, angle, ismath=\"TeX!\", mtext=None):\n        # docstring inherited\n        self.draw_text(gc, x, y, s, prop, angle, ismath, mtext)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        # prepare string for tex\n        s = common_texification(s)\n        prop_cmds = _font_properties_str(prop)\n        s = r\"%s %s\" % (prop_cmds, s)\n\n        writeln(self.fh, r\"\\begin{pgfscope}\")\n\n        alpha = gc.get_alpha()\n        if alpha != 1.0:\n            writeln(self.fh, r\"\\pgfsetfillopacity{%f}\" % alpha)\n            writeln(self.fh, r\"\\pgfsetstrokeopacity{%f}\" % alpha)\n        rgb = tuple(gc.get_rgb())[:3]\n        writeln(self.fh, r\"\\definecolor{textcolor}{rgb}{%f,%f,%f}\" % rgb)\n        writeln(self.fh, r\"\\pgfsetstrokecolor{textcolor}\")\n        writeln(self.fh, r\"\\pgfsetfillcolor{textcolor}\")\n        s = r\"\\color{textcolor}\" + s\n\n        dpi = self.figure.dpi\n        text_args = []\n        if mtext and (\n                (angle == 0 or\n                 mtext.get_rotation_mode() == \"anchor\") and\n                mtext.get_verticalalignment() != \"center_baseline\"):\n            # if text anchoring can be supported, get the original coordinates\n            # and add alignment information\n            pos = mtext.get_unitless_position()\n            x, y = mtext.get_transform().transform(pos)\n            halign = {\"left\": \"left\", \"right\": \"right\", \"center\": \"\"}\n            valign = {\"top\": \"top\", \"bottom\": \"bottom\",\n                      \"baseline\": \"base\", \"center\": \"\"}\n            text_args.extend([\n                f\"x={x/dpi:f}in\",\n                f\"y={y/dpi:f}in\",\n                halign[mtext.get_horizontalalignment()],\n                valign[mtext.get_verticalalignment()],\n            ])\n        else:\n            # if not, use the text layout provided by Matplotlib.\n            text_args.append(f\"x={x/dpi:f}in, y={y/dpi:f}in, left, base\")\n\n        if angle != 0:\n            text_args.append(\"rotate=%f\" % angle)\n\n        writeln(self.fh, r\"\\pgftext[%s]{%s}\" % (\",\".join(text_args), s))\n        writeln(self.fh, r\"\\end{pgfscope}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return (self.figure.get_figwidth() * self.dpi,\n                self.figure.get_figheight() * self.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        # check if the math is supposed to be displaystyled\n        s = common_texification(s)\n\n        # get text metrics in units of latex pt, convert to display units\n        w, h, d = (LatexManager._get_cached_or_new()\n                   .get_width_height_descent(s, prop))\n        # TODO: this should be latex_pt_to_in instead of mpl_pt_to_in\n        # but having a little bit more space around the text looks better,\n        # plus the bounding box reported by LaTeX is VERY narrow\n        f = mpl_pt_to_in * self.dpi\n        return w * f, h * f, d * f"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/RendererPgf/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_pgf.RendererPgf.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * mpl_pt_to_in * self.dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/TmpDirCleaner/add",
      "name": "add",
      "qname": "lib.matplotlib.backends.backend_pgf.TmpDirCleaner.add",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/TmpDirCleaner/add/tmpdir",
          "name": "tmpdir",
          "qname": "lib.matplotlib.backends.backend_pgf.TmpDirCleaner.add.tmpdir",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def add(tmpdir):\n        TmpDirCleaner.remaining_tmpdirs.add(tmpdir)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/TmpDirCleaner/cleanup_remaining_tmpdirs",
      "name": "cleanup_remaining_tmpdirs",
      "qname": "lib.matplotlib.backends.backend_pgf.TmpDirCleaner.cleanup_remaining_tmpdirs",
      "decorators": [
        "staticmethod",
        "atexit.register"
      ],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    @atexit.register\n    def cleanup_remaining_tmpdirs():\n        for tmpdir in TmpDirCleaner.remaining_tmpdirs:\n            error_message = \"error deleting tmp directory {}\".format(tmpdir)\n            shutil.rmtree(\n                tmpdir,\n                onerror=lambda *args: _log.error(error_message))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/common_texification",
      "name": "common_texification",
      "qname": "lib.matplotlib.backends.backend_pgf.common_texification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/common_texification/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_pgf.common_texification.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Do some necessary and/or useful substitutions for texts to be included in\nLaTeX documents.\n\nThis distinguishes text-mode and math-mode by replacing the math separator\n``$`` with ``\\(\\displaystyle %s\\)``. Escaped math separators (``\\$``)\nare ignored.\n\nThe following characters are escaped in text segments: ``_^$%``",
      "docstring": "Do some necessary and/or useful substitutions for texts to be included in\nLaTeX documents.\n\nThis distinguishes text-mode and math-mode by replacing the math separator\n``$`` with ``\\(\\displaystyle %s\\)``. Escaped math separators (``\\$``)\nare ignored.\n\nThe following characters are escaped in text segments: ``_^$%``",
      "code": "def common_texification(text):\n    r\"\"\"\n    Do some necessary and/or useful substitutions for texts to be included in\n    LaTeX documents.\n\n    This distinguishes text-mode and math-mode by replacing the math separator\n    ``$`` with ``\\(\\displaystyle %s\\)``. Escaped math separators (``\\$``)\n    are ignored.\n\n    The following characters are escaped in text segments: ``_^$%``\n    \"\"\"\n    # Sometimes, matplotlib adds the unknown command \\mathdefault.\n    # Not using \\mathnormal instead since this looks odd for the latex cm font.\n    text = _replace_mathdefault(text)\n    # split text into normaltext and inline math parts\n    parts = re_mathsep.split(text)\n    for i, s in enumerate(parts):\n        if not i % 2:\n            # textmode replacements\n            s = _replace_escapetext(s)\n        else:\n            # mathmode replacements\n            s = r\"\\(\\displaystyle %s\\)\" % s\n        parts[i] = s\n    return \"\".join(parts)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/get_fontspec",
      "name": "get_fontspec",
      "qname": "lib.matplotlib.backends.backend_pgf.get_fontspec",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Build fontspec preamble from rc.",
      "docstring": "Build fontspec preamble from rc.",
      "code": "def get_fontspec():\n    \"\"\"Build fontspec preamble from rc.\"\"\"\n    latex_fontspec = []\n    texcommand = mpl.rcParams[\"pgf.texsystem\"]\n\n    if texcommand != \"pdflatex\":\n        latex_fontspec.append(\"\\\\usepackage{fontspec}\")\n\n    if texcommand != \"pdflatex\" and mpl.rcParams[\"pgf.rcfonts\"]:\n        families = [\"serif\", \"sans\\\\-serif\", \"monospace\"]\n        commands = [\"setmainfont\", \"setsansfont\", \"setmonofont\"]\n        for family, command in zip(families, commands):\n            # 1) Forward slashes also work on Windows, so don't mess with\n            # backslashes.  2) The dirname needs to include a separator.\n            path = pathlib.Path(fm.findfont(family))\n            latex_fontspec.append(r\"\\%s{%s}[Path=%s]\" % (\n                command, path.name, path.parent.as_posix() + \"/\"))\n\n    return \"\\n\".join(latex_fontspec)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/get_preamble",
      "name": "get_preamble",
      "qname": "lib.matplotlib.backends.backend_pgf.get_preamble",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get LaTeX preamble from rc.",
      "docstring": "Get LaTeX preamble from rc.",
      "code": "def get_preamble():\n    \"\"\"Get LaTeX preamble from rc.\"\"\"\n    return mpl.rcParams[\"pgf.preamble\"]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/make_pdf_to_png_converter",
      "name": "make_pdf_to_png_converter",
      "qname": "lib.matplotlib.backends.backend_pgf.make_pdf_to_png_converter",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a function that converts a pdf file to a png file.",
      "docstring": "Return a function that converts a pdf file to a png file.",
      "code": "def make_pdf_to_png_converter():\n    \"\"\"Return a function that converts a pdf file to a png file.\"\"\"\n    if shutil.which(\"pdftocairo\"):\n        def cairo_convert(pdffile, pngfile, dpi):\n            cmd = [\"pdftocairo\", \"-singlefile\", \"-png\", \"-r\", \"%d\" % dpi,\n                   pdffile, os.path.splitext(pngfile)[0]]\n            subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return cairo_convert\n    try:\n        gs_info = mpl._get_executable_info(\"gs\")\n    except mpl.ExecutableNotFoundError:\n        pass\n    else:\n        def gs_convert(pdffile, pngfile, dpi):\n            cmd = [gs_info.executable,\n                   '-dQUIET', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dNOPROMPT',\n                   '-dUseCIEColor', '-dTextAlphaBits=4',\n                   '-dGraphicsAlphaBits=4', '-dDOINTERPOLATE',\n                   '-sDEVICE=png16m', '-sOutputFile=%s' % pngfile,\n                   '-r%d' % dpi, pdffile]\n            subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return gs_convert\n    raise RuntimeError(\"No suitable pdf to png renderer found.\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/repl_escapetext",
      "name": "repl_escapetext",
      "qname": "lib.matplotlib.backends.backend_pgf.repl_escapetext",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/repl_escapetext/m",
          "name": "m",
          "qname": "lib.matplotlib.backends.backend_pgf.repl_escapetext.m",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@cbook.deprecated(\"3.2\")\ndef repl_escapetext(m):\n    return \"\\\\\" + m.group(1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/repl_mathdefault",
      "name": "repl_mathdefault",
      "qname": "lib.matplotlib.backends.backend_pgf.repl_mathdefault",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/repl_mathdefault/m",
          "name": "m",
          "qname": "lib.matplotlib.backends.backend_pgf.repl_mathdefault.m",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@cbook.deprecated(\"3.2\")\ndef repl_mathdefault(m):\n    return m.group(0)[:-len(m.group(1))]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln",
      "name": "writeln",
      "qname": "lib.matplotlib.backends.backend_pgf.writeln",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln/fh",
          "name": "fh",
          "qname": "lib.matplotlib.backends.backend_pgf.writeln.fh",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_pgf/writeln/line",
          "name": "line",
          "qname": "lib.matplotlib.backends.backend_pgf.writeln.line",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def writeln(fh, line):\n    # every line of a file included with \\\\input must be terminated with %\n    # if not, latex will create additional vertical spaces for some reason\n    fh.write(line)\n    fh.write(\"%\\n\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'ps'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_eps",
      "name": "print_eps",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_eps",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_eps/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_eps.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_eps/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_eps.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_eps/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_eps.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_eps/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_eps.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_eps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'eps', *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_ps",
      "name": "print_ps",
      "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_ps/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_ps/outfile",
          "name": "outfile",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps.outfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_ps/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/FigureCanvasPS/print_ps/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_ps.FigureCanvasPS.print_ps.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_ps(self, outfile, *args, **kwargs):\n        return self._print_ps(outfile, 'ps', *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS/get_capstyle",
      "name": "get_capstyle",
      "qname": "lib.matplotlib.backends.backend_ps.GraphicsContextPS.get_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS/get_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.GraphicsContextPS.get_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_capstyle(self):\n        return {'butt': 0, 'round': 1, 'projecting': 2}[\n            GraphicsContextBase.get_capstyle(self)]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS/get_joinstyle",
      "name": "get_joinstyle",
      "qname": "lib.matplotlib.backends.backend_ps.GraphicsContextPS.get_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/GraphicsContextPS/get_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.GraphicsContextPS.get_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_joinstyle(self):\n        return {'miter': 0, 'round': 1, 'bevel': 2}[\n            GraphicsContextBase.get_joinstyle(self)]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/PsBackendHelper/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.PsBackendHelper.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self):\n        self._cached = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/pswriter",
          "name": "pswriter",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.pswriter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/__init__/imagedpi",
          "name": "imagedpi",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.__init__.imagedpi",
          "default_value": "72",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles.",
      "docstring": "",
      "code": "    def __init__(self, width, height, pswriter, imagedpi=72):\n        # Although postscript itself is dpi independent, we need to inform the\n        # image code about a requested dpi to generate high resolution images\n        # and them scale them before embedding them.\n        super().__init__(width, height)\n        self._pswriter = pswriter\n        if mpl.rcParams['text.usetex']:\n            self.textcnt = 0\n            self.psfrag = []\n        self.imagedpi = imagedpi\n\n        # current renderer state (None=uninitialised)\n        self.color = None\n        self.linewidth = None\n        self.linejoin = None\n        self.linecap = None\n        self.linedash = None\n        self.fontname = None\n        self.fontsize = None\n        self._hatches = {}\n        self.image_magnification = imagedpi / 72\n        self._clip_paths = {}\n        self._path_collection_id = 0\n\n        self._character_tracker = _backend_pdf_ps.CharacterTracker()\n        self.mathtext_parser = MathTextParser(\"PS\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch",
      "name": "create_hatch",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/create_hatch/hatch",
          "name": "hatch",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.create_hatch.hatch",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def create_hatch(self, hatch):\n        sidelen = 72\n        if hatch in self._hatches:\n            return self._hatches[hatch]\n        name = 'H%d' % len(self._hatches)\n        linewidth = mpl.rcParams['hatch.linewidth']\n        pageheight = self.height * 72\n        self._pswriter.write(f\"\"\"\\\n  << /PatternType 1\n     /PaintType 2\n     /TilingType 2\n     /BBox[0 0 {sidelen:d} {sidelen:d}]\n     /XStep {sidelen:d}\n     /YStep {sidelen:d}\n\n     /PaintProc {{\n        pop\n        {linewidth:f} setlinewidth\n{self._convert_path(\n    Path.hatch(hatch), Affine2D().scale(sidelen), simplify=False)}\n        gsave\n        fill\n        grestore\n        stroke\n     }} bind\n   >>\n   matrix\n   0.0 {pageheight:f} translate\n   makepattern\n   /{name} exch def\n\"\"\")\n        self._hatches[hatch] = name\n        return name"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        self.draw_gouraud_triangles(gc, points.reshape((1, 3, 2)),\n                                    colors.reshape((1, 3, 4)), trans)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_gouraud_triangles/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, points, colors, trans):\n        assert len(points) == len(colors)\n        assert points.ndim == 3\n        assert points.shape[1] == 3\n        assert points.shape[2] == 2\n        assert colors.ndim == 3\n        assert colors.shape[1] == 3\n        assert colors.shape[2] == 4\n\n        shape = points.shape\n        flat_points = points.reshape((shape[0] * shape[1], 2))\n        flat_points = trans.transform(flat_points)\n        flat_colors = colors.reshape((shape[0] * shape[1], 4))\n        points_min = np.min(flat_points, axis=0) - (1 << 12)\n        points_max = np.max(flat_points, axis=0) + (1 << 12)\n        factor = np.ceil((2 ** 32 - 1) / (points_max - points_min))\n\n        xmin, ymin = points_min\n        xmax, ymax = points_max\n\n        streamarr = np.empty(\n            shape[0] * shape[1],\n            dtype=[('flags', 'u1'), ('points', '2>u4'), ('colors', '3u1')])\n        streamarr['flags'] = 0\n        streamarr['points'] = (flat_points - points_min) * factor\n        streamarr['colors'] = flat_colors[:, :3] * 255.0\n        stream = quote_ps_string(streamarr.tobytes())\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n<< /ShadingType 4\n   /ColorSpace [/DeviceRGB]\n   /BitsPerCoordinate 32\n   /BitsPerComponent 8\n   /BitsPerFlag 8\n   /AntiAlias true\n   /Decode [ {xmin:f} {xmax:f} {ymin:f} {ymax:f} 0 1 0 1 0 1 ]\n   /DataSource ({stream})\n>>\nshfill\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n        imagecmd = \"false 3 colorimage\"\n        data = im[::-1, :, :3]  # Vertically flipped rgb values.\n        # data.tobytes().hex() has no spaces, so can be linewrapped by simply\n        # splitting data every nchars. It's equivalent to textwrap.fill only\n        # much faster.\n        nchars = 128\n        data = data.tobytes().hex()\n        hexlines = \"\\n\".join(\n            [\n                data[n * nchars:(n + 1) * nchars]\n                for n in range(math.ceil(len(data) / nchars))\n            ]\n        )\n\n        if transform is None:\n            matrix = \"1 0 0 1 0 0\"\n            xscale = w / self.image_magnification\n            yscale = h / self.image_magnification\n        else:\n            matrix = \" \".join(map(str, transform.frozen().to_values()))\n            xscale = 1.0\n            yscale = 1.0\n\n        bbox = gc.get_clip_rectangle()\n        clippath, clippath_trans = gc.get_clip_path()\n\n        clip = []\n        if bbox is not None:\n            clip.append('%s clipbox' % _nums_to_str(*bbox.size, *bbox.p0))\n        if clippath is not None:\n            id = self._get_clip_path(clippath, clippath_trans)\n            clip.append('%s' % id)\n        clip = '\\n'.join(clip)\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{clip}\n{x:f} {y:f} translate\n[{matrix}] concat\n{xscale:f} {yscale:f} scale\n/DataString {w:d} string def\n{w:d} {h:d} 8 [ {w:d} 0 0 -{h:d} 0 {h:d} ]\n{{\ncurrentfile DataString readhexstring pop\n}} bind {imagecmd}\n{hexlines}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if debugPS:\n            self._pswriter.write('% draw_markers \\n')\n\n        ps_color = (\n            None\n            if _is_transparent(rgbFace)\n            else '%1.3f setgray' % rgbFace[0]\n            if rgbFace[0] == rgbFace[1] == rgbFace[2]\n            else '%1.3f %1.3f %1.3f setrgbcolor' % rgbFace[:3])\n\n        # construct the generic marker command:\n\n        # don't want the translate to be global\n        ps_cmd = ['/o {', 'gsave', 'newpath', 'translate']\n\n        lw = gc.get_linewidth()\n        alpha = (gc.get_alpha()\n                 if gc.get_forced_alpha() or len(gc.get_rgb()) == 3\n                 else gc.get_rgb()[3])\n        stroke = lw > 0 and alpha > 0\n        if stroke:\n            ps_cmd.append('%.1f setlinewidth' % lw)\n            jint = gc.get_joinstyle()\n            ps_cmd.append('%d setlinejoin' % jint)\n            cint = gc.get_capstyle()\n            ps_cmd.append('%d setlinecap' % cint)\n\n        ps_cmd.append(self._convert_path(marker_path, marker_trans,\n                                         simplify=False))\n\n        if rgbFace:\n            if stroke:\n                ps_cmd.append('gsave')\n            if ps_color:\n                ps_cmd.extend([ps_color, 'fill'])\n            if stroke:\n                ps_cmd.append('grestore')\n\n        if stroke:\n            ps_cmd.append('stroke')\n        ps_cmd.extend(['grestore', '} bind def'])\n\n        for vertices, code in path.iter_segments(\n                trans,\n                clip=(0, 0, self.width*72, self.height*72),\n                simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                ps_cmd.append(\"%g %g o\" % (x, y))\n\n        ps = '\\n'.join(ps_cmd)\n        self._draw_ps(ps, gc, rgbFace, fill=False, stroke=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext",
      "name": "draw_mathtext",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_mathtext/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_mathtext.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the math text using matplotlib.mathtext.",
      "docstring": "Draw the math text using matplotlib.mathtext.",
      "code": "    def draw_mathtext(self, gc, x, y, s, prop, angle):\n        \"\"\"Draw the math text using matplotlib.mathtext.\"\"\"\n        if debugPS:\n            self._pswriter.write(\"% mathtext\\n\")\n\n        width, height, descent, pswriter, used_characters = \\\n            self.mathtext_parser.parse(s, 72, prop)\n        self._character_tracker.merge(used_characters)\n        self.set_color(*gc.get_rgb())\n        thetext = pswriter.getvalue()\n        self._pswriter.write(f\"\"\"\\\ngsave\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        clip = rgbFace is None and gc.get_hatch_path() is None\n        simplify = path.should_simplify and clip\n        ps = self._convert_path(path, transform, clip=clip, simplify=simplify)\n        self._draw_ps(ps, gc, rgbFace)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offsetTrans",
          "name": "offsetTrans",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offsetTrans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #     (len_path + 2) * uses_per_path\n        # cost of definition+use is\n        #     (len_path + 3) + 3 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 3 * uses_per_path + 3 < (len_path + 2) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        path_codes = []\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            name = 'p%x_%x' % (self._path_collection_id, i)\n            path_bytes = self._convert_path(path, transform, simplify=False)\n            self._pswriter.write(f\"\"\"\\\n/{name} {{\nnewpath\ntranslate\n{path_bytes}\n}} bind def\n\"\"\")\n            path_codes.append(name)\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            ps = \"%g %g %s\" % (xo, yo, path_id)\n            self._draw_ps(ps, gc0, rgbFace)\n\n        self._path_collection_id += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex",
      "decorators": [
        "cbook._delete_parameter('3.3', 'ismath')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.ismath",
          "default_value": "'TeX!'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook._delete_parameter(\"3.3\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        if not hasattr(self, \"psfrag\"):\n            _log.warning(\n                \"The PS backend determines usetex status solely based on \"\n                \"rcParams['text.usetex'] and does not support having \"\n                \"usetex=True only for some elements; this element will thus \"\n                \"be rendered as if usetex=False.\")\n            self.draw_text(gc, x, y, s, prop, angle, False, mtext)\n            return\n\n        w, h, bl = self.get_text_width_height_descent(s, prop, ismath=\"TeX\")\n        fontsize = prop.get_size_in_points()\n        thetext = 'psmarker%d' % self.textcnt\n        color = '%1.3f,%1.3f,%1.3f' % gc.get_rgb()[:3]\n        fontcmd = {'sans-serif': r'{\\sffamily %s}',\n                   'monospace': r'{\\ttfamily %s}'}.get(\n                       mpl.rcParams['font.family'][0], r'{\\rmfamily %s}')\n        s = fontcmd % s\n        tex = r'\\color[rgb]{%s} %s' % (color, s)\n\n        corr = 0  # w/2*(fontsize-10)/10\n        if dict.__getitem__(mpl.rcParams, 'text.latex.preview'):\n            # use baseline alignment!\n            pos = _nums_to_str(x-corr, y)\n            self.psfrag.append(\n                r'\\psfrag{%s}[Bl][Bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                    thetext, angle, fontsize, fontsize*1.25, tex))\n        else:\n            # Stick to the bottom alignment.\n            pos = _nums_to_str(x-corr, y-bl)\n            self.psfrag.append(\n                r'\\psfrag{%s}[bl][bl][1][%f]{\\fontsize{%f}{%f}%s}' % (\n                    thetext, angle, fontsize, fontsize*1.25, tex))\n\n        self._pswriter.write(f\"\"\"\\\ngsave\n{pos} moveto\n({thetext})\nshow\ngrestore\n\"\"\")\n        self.textcnt += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if debugPS:\n            self._pswriter.write(\"% text\\n\")\n\n        if _is_transparent(gc.get_rgb()):\n            return  # Special handling for fully transparent.\n\n        if ismath == 'TeX':\n            return self.draw_tex(gc, x, y, s, prop, angle)\n\n        elif ismath:\n            return self.draw_mathtext(gc, x, y, s, prop, angle)\n\n        elif mpl.rcParams['ps.useafm']:\n            self.set_color(*gc.get_rgb())\n\n            font = self._get_font_afm(prop)\n            fontname = font.get_fontname()\n            fontsize = prop.get_size_in_points()\n            scale = 0.001 * fontsize\n\n            thisx = 0\n            thisy = font.get_str_bbox_and_descent(s)[4] * scale\n            last_name = None\n            lines = []\n            for c in s:\n                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n                try:\n                    width = font.get_width_from_char_name(name)\n                except KeyError:\n                    name = 'question'\n                    width = font.get_width_char('?')\n                if last_name is not None:\n                    kern = font.get_kern_dist_from_name(last_name, name)\n                else:\n                    kern = 0\n                last_name = name\n                thisx += kern * scale\n\n                lines.append('%f %f m /%s glyphshow' % (thisx, thisy, name))\n\n                thisx += width * scale\n\n            thetext = \"\\n\".join(lines)\n            self._pswriter.write(f\"\"\"\\\ngsave\n/{fontname} findfont\n{fontsize} scalefont\nsetfont\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")\n\n        else:\n            font = self._get_font_ttf(prop)\n            font.set_text(s, 0, flags=LOAD_NO_HINTING)\n            self._character_tracker.track(font, s)\n\n            self.set_color(*gc.get_rgb())\n            ps_name = (font.postscript_name\n                       .encode('ascii', 'replace').decode('ascii'))\n            self.set_font(ps_name, prop.get_size_in_points())\n\n            thetext = '\\n'.join(\n                '%f 0 m /%s glyphshow' % (x, font.get_glyph_name(glyph_idx))\n                for glyph_idx, x in _text_layout.layout(s, font))\n            self._pswriter.write(f\"\"\"\\\ngsave\n{x:f} {y:f} translate\n{angle:f} rotate\n{thetext}\ngrestore\n\"\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the factor by which to magnify images passed to draw_image.\nAllows a backend to have images at a different resolution to other\nartists.",
      "docstring": "Get the factor by which to magnify images passed to draw_image.\nAllows a backend to have images at a different resolution to other\nartists.",
      "code": "    def get_image_magnification(self):\n        \"\"\"\n        Get the factor by which to magnify images passed to draw_image.\n        Allows a backend to have images at a different resolution to other\n        artists.\n        \"\"\"\n        return self.image_magnification"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/merge_used_characters",
      "name": "merge_used_characters",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.merge_used_characters",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/merge_used_characters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.merge_used_characters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/merge_used_characters/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.merge_used_characters.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/merge_used_characters/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.merge_used_characters.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def merge_used_characters(self, *args, **kwargs):\n        self._character_tracker.merge(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextPS()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color",
      "name": "set_color",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/r",
          "name": "r",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.r",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/g",
          "name": "g",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.g",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/b",
          "name": "b",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_color/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_color.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_color(self, r, g, b, store=True):\n        if (r, g, b) != self.color:\n            if r == g and r == b:\n                self._pswriter.write(\"%1.3f setgray\\n\" % r)\n            else:\n                self._pswriter.write(\n                    \"%1.3f %1.3f %1.3f setrgbcolor\\n\" % (r, g, b))\n            if store:\n                self.color = (r, g, b)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font",
      "name": "set_font",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/fontname",
          "name": "fontname",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.fontname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/fontsize",
          "name": "fontsize",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.fontsize",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_font/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_font.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_font(self, fontname, fontsize, store=True):\n        if mpl.rcParams['ps.useafm']:\n            return\n        if (fontname, fontsize) != (self.fontname, self.fontsize):\n            out = (\"/%s findfont\\n\"\n                   \"%1.3f scalefont\\n\"\n                   \"setfont\\n\" % (fontname, fontsize))\n            self._pswriter.write(out)\n            if store:\n                self.fontname = fontname\n                self.fontsize = fontsize"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap",
      "name": "set_linecap",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/linecap",
          "name": "linecap",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.linecap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linecap/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linecap.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linecap(self, linecap, store=True):\n        if linecap != self.linecap:\n            self._pswriter.write(\"%d setlinecap\\n\" % linecap)\n            if store:\n                self.linecap = linecap"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash",
      "name": "set_linedash",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/offset",
          "name": "offset",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/seq",
          "name": "seq",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.seq",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linedash/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linedash.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linedash(self, offset, seq, store=True):\n        if self.linedash is not None:\n            oldo, oldseq = self.linedash\n            if np.array_equal(seq, oldseq) and oldo == offset:\n                return\n\n        if seq is not None and len(seq):\n            s = \"[%s] %d setdash\\n\" % (_nums_to_str(*seq), offset)\n            self._pswriter.write(s)\n        else:\n            self._pswriter.write(\"[] 0 setdash\\n\")\n        if store:\n            self.linedash = (offset, seq)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin",
      "name": "set_linejoin",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/linejoin",
          "name": "linejoin",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.linejoin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linejoin/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linejoin.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linejoin(self, linejoin, store=True):\n        if linejoin != self.linejoin:\n            self._pswriter.write(\"%d setlinejoin\\n\" % linejoin)\n            if store:\n                self.linejoin = linejoin"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/linewidth",
          "name": "linewidth",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.linewidth",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/set_linewidth/store",
          "name": "store",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.set_linewidth.store",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, linewidth, store=True):\n        linewidth = float(linewidth)\n        if linewidth != self.linewidth:\n            self._pswriter.write(\"%1.3f setlinewidth\\n\" % linewidth)\n            if store:\n                self.linewidth = linewidth"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/track_characters",
      "name": "track_characters",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.track_characters",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/track_characters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.track_characters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/track_characters/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.track_characters.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/track_characters/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.track_characters.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Keep track of which characters are required from each font.",
      "docstring": "Keep track of which characters are required from each font.",
      "code": "    @cbook.deprecated(\"3.3\")\n    def track_characters(self, *args, **kwargs):\n        \"\"\"Keep track of which characters are required from each font.\"\"\"\n        self._character_tracker.track(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/used_characters@getter",
      "name": "used_characters",
      "qname": "lib.matplotlib.backends.backend_ps.RendererPS.used_characters",
      "decorators": [
        "cbook.deprecated('3.3')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/RendererPS/used_characters@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_ps.RendererPS.used_characters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    @property\n    def used_characters(self):\n        return self._character_tracker.used_characters"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags",
      "name": "convert_psfrags",
      "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/psfrags",
          "name": "psfrags",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.psfrags",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/font_preamble",
          "name": "font_preamble",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.font_preamble",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/custom_preamble",
          "name": "custom_preamble",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.custom_preamble",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/paper_width",
          "name": "paper_width",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.paper_width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/paper_height",
          "name": "paper_height",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.paper_height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/convert_psfrags/orientation",
          "name": "orientation",
          "qname": "lib.matplotlib.backends.backend_ps.convert_psfrags.orientation",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "When we want to use the LaTeX backend with postscript, we write PSFrag tags\nto a temporary postscript file, each one marking a position for LaTeX to\nrender some text. convert_psfrags generates a LaTeX document containing the\ncommands to convert those tags to text. LaTeX/dvips produces the postscript\nfile that includes the actual text.",
      "docstring": "When we want to use the LaTeX backend with postscript, we write PSFrag tags\nto a temporary postscript file, each one marking a position for LaTeX to\nrender some text. convert_psfrags generates a LaTeX document containing the\ncommands to convert those tags to text. LaTeX/dvips produces the postscript\nfile that includes the actual text.",
      "code": "def convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble,\n                    paper_width, paper_height, orientation):\n    \"\"\"\n    When we want to use the LaTeX backend with postscript, we write PSFrag tags\n    to a temporary postscript file, each one marking a position for LaTeX to\n    render some text. convert_psfrags generates a LaTeX document containing the\n    commands to convert those tags to text. LaTeX/dvips produces the postscript\n    file that includes the actual text.\n    \"\"\"\n    with mpl.rc_context({\n            \"text.latex.preamble\":\n            mpl.rcParams[\"text.latex.preamble\"] +\n            r\"\\usepackage{psfrag,color}\"\"\\n\"\n            r\"\\usepackage[dvips]{graphicx}\"\"\\n\"\n            r\"\\geometry{papersize={%(width)sin,%(height)sin},\"\n            r\"body={%(width)sin,%(height)sin},margin=0in}\"\n            % {\"width\": paper_width, \"height\": paper_height}\n    }):\n        dvifile = TexManager().make_dvi(\n            \"\\n\"\n            r\"\\begin{figure}\"\"\\n\"\n            r\"  \\centering\\leavevmode\"\"\\n\"\n            r\"  %(psfrags)s\"\"\\n\"\n            r\"  \\includegraphics*[angle=%(angle)s]{%(epsfile)s}\"\"\\n\"\n            r\"\\end{figure}\"\n            % {\n                \"psfrags\": \"\\n\".join(psfrags),\n                \"angle\": 90 if orientation == 'landscape' else 0,\n                \"epsfile\": pathlib.Path(tmpfile).resolve().as_posix(),\n            },\n            fontsize=10)  # tex's default fontsize.\n\n    with TemporaryDirectory() as tmpdir:\n        psfile = os.path.join(tmpdir, \"tmp.ps\")\n        cbook._check_and_log_subprocess(\n            ['dvips', '-q', '-R0', '-o', psfile, dvifile], _log)\n        shutil.move(psfile, tmpfile)\n\n    # check if the dvips created a ps in landscape paper.  Somehow,\n    # above latex+dvips results in a ps file in a landscape mode for a\n    # certain figure sizes (e.g., 8.3in, 5.8in which is a5). And the\n    # bounding box of the final output got messed up. We check see if\n    # the generated ps file is in landscape and return this\n    # information. The return value is used in pstoeps step to recover\n    # the correct bounding box. 2010-06-05 JJL\n    with open(tmpfile) as fh:\n        psfrag_rotated = \"Landscape\" in fh.read(1000)\n    return psfrag_rotated"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header",
      "name": "get_bbox_header",
      "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header/lbrt",
          "name": "lbrt",
          "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header.lbrt",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/get_bbox_header/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.get_bbox_header.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a postscript header string for the given bbox lbrt=(l, b, r, t).\nOptionally, return rotate command.",
      "docstring": "Return a postscript header string for the given bbox lbrt=(l, b, r, t).\nOptionally, return rotate command.",
      "code": "def get_bbox_header(lbrt, rotated=False):\n    \"\"\"\n    Return a postscript header string for the given bbox lbrt=(l, b, r, t).\n    Optionally, return rotate command.\n    \"\"\"\n\n    l, b, r, t = lbrt\n    if rotated:\n        rotate = \"%.2f %.2f translate\\n90 rotate\" % (l+r, 0)\n    else:\n        rotate = \"\"\n    bbox_info = '%%%%BoundingBox: %d %d %d %d' % (l, b, np.ceil(r), np.ceil(t))\n    hires_bbox_info = '%%%%HiResBoundingBox: %.6f %.6f %.6f %.6f' % (\n        l, b, r, t)\n\n    return '\\n'.join([bbox_info, hires_bbox_info]), rotate"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill",
      "name": "gs_distill",
      "qname": "lib.matplotlib.backends.backend_ps.gs_distill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/eps",
          "name": "eps",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.eps",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/ptype",
          "name": "ptype",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.ptype",
          "default_value": "'letter'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/gs_distill/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.gs_distill.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use ghostscript's pswrite or epswrite device to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. The output is low-level, converting text to outlines.",
      "docstring": "Use ghostscript's pswrite or epswrite device to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. The output is low-level, converting text to outlines.",
      "code": "def gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's pswrite or epswrite device to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. The output is low-level, converting text to outlines.\n    \"\"\"\n\n    if eps:\n        paper_option = \"-dEPSCrop\"\n    else:\n        paper_option = \"-sPAPERSIZE=%s\" % ptype\n\n    psfile = tmpfile + '.ps'\n    dpi = mpl.rcParams['ps.distiller.res']\n\n    cbook._check_and_log_subprocess(\n        [mpl._get_executable_info(\"gs\").executable,\n         \"-dBATCH\", \"-dNOPAUSE\", \"-r%d\" % dpi, \"-sDEVICE=ps2write\",\n         paper_option, \"-sOutputFile=%s\" % psfile, tmpfile],\n        _log)\n\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n    # While it is best if above steps preserve the original bounding\n    # box, there seem to be cases when it is not. For those cases,\n    # the original bbox can be restored during the pstoeps step.\n\n    if eps:\n        # For some versions of gs, above steps result in an ps file where the\n        # original bbox is no more correct. Do not adjust bbox for now.\n        pstoeps(tmpfile, bbox, rotated=rotated)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps",
      "name": "pstoeps",
      "qname": "lib.matplotlib.backends.backend_ps.pstoeps",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/pstoeps/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.pstoeps.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert the postscript to encapsulated postscript.  The bbox of\nthe eps file will be replaced with the given *bbox* argument. If\nNone, original bbox will be used.",
      "docstring": "Convert the postscript to encapsulated postscript.  The bbox of\nthe eps file will be replaced with the given *bbox* argument. If\nNone, original bbox will be used.",
      "code": "def pstoeps(tmpfile, bbox=None, rotated=False):\n    \"\"\"\n    Convert the postscript to encapsulated postscript.  The bbox of\n    the eps file will be replaced with the given *bbox* argument. If\n    None, original bbox will be used.\n    \"\"\"\n\n    # if rotated==True, the output eps file need to be rotated\n    if bbox:\n        bbox_info, rotate = get_bbox_header(bbox, rotated=rotated)\n    else:\n        bbox_info, rotate = None, None\n\n    epsfile = tmpfile + '.eps'\n    with open(epsfile, 'wb') as epsh, open(tmpfile, 'rb') as tmph:\n        write = epsh.write\n        # Modify the header:\n        for line in tmph:\n            if line.startswith(b'%!PS'):\n                write(b\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n                if bbox:\n                    write(bbox_info.encode('ascii') + b'\\n')\n            elif line.startswith(b'%%EndComments'):\n                write(line)\n                write(b'%%BeginProlog\\n'\n                      b'save\\n'\n                      b'countdictstack\\n'\n                      b'mark\\n'\n                      b'newpath\\n'\n                      b'/showpage {} def\\n'\n                      b'/setpagedevice {pop} def\\n'\n                      b'%%EndProlog\\n'\n                      b'%%Page 1 1\\n')\n                if rotate:\n                    write(rotate.encode('ascii') + b'\\n')\n                break\n            elif bbox and line.startswith((b'%%Bound', b'%%HiResBound',\n                                           b'%%DocumentMedia', b'%%Pages')):\n                pass\n            else:\n                write(line)\n        # Now rewrite the rest of the file, and modify the trailer.\n        # This is done in a second loop such that the header of the embedded\n        # eps file is not modified.\n        for line in tmph:\n            if line.startswith(b'%%EOF'):\n                write(b'cleartomark\\n'\n                      b'countdictstack\\n'\n                      b'exch sub { end } repeat\\n'\n                      b'restore\\n'\n                      b'showpage\\n'\n                      b'%%EOF\\n')\n            elif line.startswith(b'%%PageBoundingBox'):\n                pass\n            else:\n                write(line)\n\n    os.remove(tmpfile)\n    shutil.move(epsfile, tmpfile)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/quote_ps_string",
      "name": "quote_ps_string",
      "qname": "lib.matplotlib.backends.backend_ps.quote_ps_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/quote_ps_string/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_ps.quote_ps_string.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Quote dangerous characters of S for use in a PostScript string constant.",
      "docstring": "Quote dangerous characters of S for use in a PostScript string constant.",
      "code": "def quote_ps_string(s):\n    \"\"\"\n    Quote dangerous characters of S for use in a PostScript string constant.\n    \"\"\"\n    s = s.replace(b\"\\\\\", b\"\\\\\\\\\")\n    s = s.replace(b\"(\", b\"\\\\(\")\n    s = s.replace(b\")\", b\"\\\\)\")\n    s = s.replace(b\"'\", b\"\\\\251\")\n    s = s.replace(b\"`\", b\"\\\\301\")\n    s = re.sub(br\"[^ -~\\n]\", lambda x: br\"\\%03o\" % ord(x.group()), s)\n    return s.decode('ascii')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill",
      "name": "xpdf_distill",
      "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/tmpfile",
          "name": "tmpfile",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.tmpfile",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/eps",
          "name": "eps",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.eps",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/ptype",
          "name": "ptype",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.ptype",
          "default_value": "'letter'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_ps/xpdf_distill/rotated",
          "name": "rotated",
          "qname": "lib.matplotlib.backends.backend_ps.xpdf_distill.rotated",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. This distiller is preferred, generating high-level postscript\noutput that treats text as text.",
      "docstring": "Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\nThis yields smaller files without illegal encapsulated postscript\noperators. This distiller is preferred, generating high-level postscript\noutput that treats text as text.",
      "code": "def xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False):\n    \"\"\"\n    Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file.\n    This yields smaller files without illegal encapsulated postscript\n    operators. This distiller is preferred, generating high-level postscript\n    output that treats text as text.\n    \"\"\"\n    mpl._get_executable_info(\"gs\")  # Effectively checks for ps2pdf.\n    mpl._get_executable_info(\"pdftops\")\n\n    pdffile = tmpfile + '.pdf'\n    psfile = tmpfile + '.ps'\n\n    # Pass options as `-foo#bar` instead of `-foo=bar` to keep Windows happy\n    # (https://www.ghostscript.com/doc/9.22/Use.htm#MS_Windows).\n    cbook._check_and_log_subprocess(\n        [\"ps2pdf\",\n         \"-dAutoFilterColorImages#false\",\n         \"-dAutoFilterGrayImages#false\",\n         \"-sAutoRotatePages#None\",\n         \"-sGrayImageFilter#FlateEncode\",\n         \"-sColorImageFilter#FlateEncode\",\n         \"-dEPSCrop\" if eps else \"-sPAPERSIZE#%s\" % ptype,\n         tmpfile, pdffile], _log)\n    cbook._check_and_log_subprocess(\n        [\"pdftops\", \"-paper\", \"match\", \"-level2\", pdffile, psfile], _log)\n\n    os.remove(tmpfile)\n    shutil.move(psfile, tmpfile)\n\n    if eps:\n        pstoeps(tmpfile)\n\n    for fname in glob.glob(tmpfile+'.*'):\n        os.remove(fname)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ConfigureSubplotsQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt5.ConfigureSubplotsQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ConfigureSubplotsQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ConfigureSubplotsQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ConfigureSubplotsQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.ConfigureSubplotsQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2QT.configure_subplots(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.__init__",
      "decorators": [
        "_allow_super_init"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @_allow_super_init\n    def __init__(self, figure):\n        _create_qApp()\n        super().__init__(figure=figure)\n\n        # We don't want to scale up the figure DPI more than once.\n        # Note, we don't handle a signal for changing DPI yet.\n        figure._original_dpi = figure.dpi\n        self._update_figure_dpi()\n        # In cases with mixed resolution displays, we need to be careful if the\n        # dpi_ratio changes - in this case we need to resize the canvas\n        # accordingly. We could watch for screenChanged events from Qt, but\n        # the issue is that we can't guarantee this will be emitted *before*\n        # the first paintEvent for the canvas, so instead we keep track of the\n        # dpi_ratio value here and in paintEvent we resize the canvas if\n        # needed.\n        self._dpi_ratio_prev = None\n\n        self._draw_pending = False\n        self._is_drawing = False\n        self._draw_rect_callback = lambda painter: None\n\n        self.setAttribute(QtCore.Qt.WA_OpaquePaintEvent)\n        self.setMouseTracking(True)\n        self.resize(*self.get_width_height())\n\n        palette = QtGui.QPalette(QtCore.Qt.white)\n        self.setPalette(palette)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None and self.figure:\n            bbox = self.figure.bbox  # Blit the entire canvas if bbox is None.\n        # repaint uses logical pixels, not physical pixels like the renderer.\n        l, b, w, h = [int(pt / self._dpi_ratio) for pt in bbox.bounds]\n        t = b + h\n        self.repaint(l, self.rect().height() - t, w, h)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure, and queue a request for a Qt draw.",
      "docstring": "Render the figure, and queue a request for a Qt draw.",
      "code": "    def draw(self):\n        \"\"\"Render the figure, and queue a request for a Qt draw.\"\"\"\n        # The renderer draw is done here; delaying causes problems with code\n        # that uses the result of the draw() to update plot elements.\n        if self._is_drawing:\n            return\n        with cbook._setattr_cm(self, _is_drawing=True):\n            super().draw()\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/drawRectangle",
      "name": "drawRectangle",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.drawRectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/drawRectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.drawRectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/drawRectangle/rect",
          "name": "rect",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.drawRectangle.rect",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drawRectangle(self, rect):\n        # Draw the zoom rectangle to the QPainter.  _draw_rect_callback needs\n        # to be called at the end of paintEvent.\n        if rect is not None:\n            x0, y0, w, h = [int(pt / self._dpi_ratio) for pt in rect]\n            x1 = x0 + w\n            y1 = y0 + h\n            def _draw_rect_callback(painter):\n                pen = QtGui.QPen(QtCore.Qt.black, 1 / self._dpi_ratio)\n                pen.setDashPattern([3, 3])\n                for color, offset in [\n                        (QtCore.Qt.black, 0), (QtCore.Qt.white, 3)]:\n                    pen.setDashOffset(offset)\n                    pen.setColor(color)\n                    painter.setPen(pen)\n                    # Draw the lines from x0, y0 towards x1, y1 so that the\n                    # dashes don't \"jump\" when moving the zoom box.\n                    painter.drawLine(x0, y0, x0, y1)\n                    painter.drawLine(x0, y0, x1, y0)\n                    painter.drawLine(x0, y1, x1, y1)\n                    painter.drawLine(x1, y0, x1, y1)\n        else:\n            def _draw_rect_callback(painter):\n                return\n        self._draw_rect_callback = _draw_rect_callback\n        self.update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Queue redraw of the Agg buffer and request Qt paintEvent.",
      "docstring": "Queue redraw of the Agg buffer and request Qt paintEvent.",
      "code": "    def draw_idle(self):\n        \"\"\"Queue redraw of the Agg buffer and request Qt paintEvent.\"\"\"\n        # The Agg draw needs to be handled by the same thread Matplotlib\n        # modifies the scene graph from. Post Agg draw request to the\n        # current event loop in order to ensure thread affinity and to\n        # accumulate multiple draw requests from event handling.\n        # TODO: queued signal connection might be safer than singleShot\n        if not (getattr(self, '_draw_pending', False) or\n                getattr(self, '_is_drawing', False)):\n            self._draw_pending = True\n            QtCore.QTimer.singleShot(0, self._draw_idle)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/enterEvent",
      "name": "enterEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.enterEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/enterEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.enterEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/enterEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.enterEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def enterEvent(self, event):\n        try:\n            x, y = self.mouseEventCoords(event.pos())\n        except AttributeError:\n            # the event from PyQt4 does not include the position\n            x = y = None\n        FigureCanvasBase.enter_notify_event(self, guiEvent=event, xy=(x, y))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/flush_events",
      "name": "flush_events",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.flush_events",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/flush_events/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.flush_events.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flush_events(self):\n        # docstring inherited\n        qApp.processEvents()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/get_width_height",
      "name": "get_width_height",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.get_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/get_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.get_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_width_height(self):\n        w, h = FigureCanvasBase.get_width_height(self)\n        return int(w / self._dpi_ratio), int(h / self._dpi_ratio)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyPressEvent",
      "name": "keyPressEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.keyPressEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyPressEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.keyPressEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyPressEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.keyPressEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def keyPressEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            FigureCanvasBase.key_press_event(self, key, guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyReleaseEvent",
      "name": "keyReleaseEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.keyReleaseEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyReleaseEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.keyReleaseEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/keyReleaseEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.keyReleaseEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def keyReleaseEvent(self, event):\n        key = self._get_key(event)\n        if key is not None:\n            FigureCanvasBase.key_release_event(self, key, guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/leaveEvent",
      "name": "leaveEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.leaveEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/leaveEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.leaveEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/leaveEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.leaveEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def leaveEvent(self, event):\n        QtWidgets.QApplication.restoreOverrideCursor()\n        FigureCanvasBase.leave_notify_event(self, guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/minumumSizeHint",
      "name": "minumumSizeHint",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.minumumSizeHint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/minumumSizeHint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.minumumSizeHint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def minumumSizeHint(self):\n        return QtCore.QSize(10, 10)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseDoubleClickEvent",
      "name": "mouseDoubleClickEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseDoubleClickEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseDoubleClickEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseDoubleClickEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseDoubleClickEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseDoubleClickEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseDoubleClickEvent(self, event):\n        x, y = self.mouseEventCoords(event.pos())\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_press_event(self, x, y,\n                                                button, dblclick=True,\n                                                guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseEventCoords",
      "name": "mouseEventCoords",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseEventCoords",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseEventCoords/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseEventCoords.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseEventCoords/pos",
          "name": "pos",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseEventCoords.pos",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Calculate mouse coordinates in physical pixels.\n\nQt5 use logical pixels, but the figure is scaled to physical\npixels for rendering.  Transform to physical pixels so that\nall of the down-stream transforms work as expected.\n\nAlso, the origin is different and needs to be corrected.",
      "docstring": "Calculate mouse coordinates in physical pixels.\n\nQt5 use logical pixels, but the figure is scaled to physical\npixels for rendering.  Transform to physical pixels so that\nall of the down-stream transforms work as expected.\n\nAlso, the origin is different and needs to be corrected.",
      "code": "    def mouseEventCoords(self, pos):\n        \"\"\"\n        Calculate mouse coordinates in physical pixels.\n\n        Qt5 use logical pixels, but the figure is scaled to physical\n        pixels for rendering.  Transform to physical pixels so that\n        all of the down-stream transforms work as expected.\n\n        Also, the origin is different and needs to be corrected.\n        \"\"\"\n        dpi_ratio = self._dpi_ratio\n        x = pos.x()\n        # flip y so y=0 is bottom of canvas\n        y = self.figure.bbox.height / dpi_ratio - pos.y()\n        return x * dpi_ratio, y * dpi_ratio"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseMoveEvent",
      "name": "mouseMoveEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseMoveEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseMoveEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseMoveEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseMoveEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseMoveEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseMoveEvent(self, event):\n        x, y = self.mouseEventCoords(event)\n        FigureCanvasBase.motion_notify_event(self, x, y, guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mousePressEvent",
      "name": "mousePressEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mousePressEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mousePressEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mousePressEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mousePressEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mousePressEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mousePressEvent(self, event):\n        x, y = self.mouseEventCoords(event.pos())\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_press_event(self, x, y, button,\n                                                guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseReleaseEvent",
      "name": "mouseReleaseEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseReleaseEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseReleaseEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseReleaseEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/mouseReleaseEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.mouseReleaseEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def mouseReleaseEvent(self, event):\n        x, y = self.mouseEventCoords(event)\n        button = self.buttond.get(event.button())\n        if button is not None:\n            FigureCanvasBase.button_release_event(self, x, y, button,\n                                                  guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/resizeEvent",
      "name": "resizeEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.resizeEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/resizeEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.resizeEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/resizeEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.resizeEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resizeEvent(self, event):\n        # _dpi_ratio_prev will be set the first time the canvas is painted, and\n        # the rendered buffer is useless before anyways.\n        if self._dpi_ratio_prev is None:\n            return\n        w = event.size().width() * self._dpi_ratio\n        h = event.size().height() * self._dpi_ratio\n        dpival = self.figure.dpi\n        winch = w / dpival\n        hinch = h / dpival\n        self.figure.set_size_inches(winch, hinch, forward=False)\n        # pass back into Qt to let it finish\n        QtWidgets.QWidget.resizeEvent(self, event)\n        # emit our resize events\n        FigureCanvasBase.resize_event(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/sizeHint",
      "name": "sizeHint",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.sizeHint",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/sizeHint/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.sizeHint.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def sizeHint(self):\n        w, h = self.get_width_height()\n        return QtCore.QSize(w, h)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/start_event_loop",
      "name": "start_event_loop",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.start_event_loop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/start_event_loop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.start_event_loop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/start_event_loop/timeout",
          "name": "timeout",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.start_event_loop.timeout",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_event_loop(self, timeout=0):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\") and self._event_loop.isRunning():\n            raise RuntimeError(\"Event loop already running\")\n        self._event_loop = event_loop = QtCore.QEventLoop()\n        if timeout > 0:\n            timer = QtCore.QTimer.singleShot(int(timeout * 1000),\n                                             event_loop.quit)\n        event_loop.exec_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/stop_event_loop",
      "name": "stop_event_loop",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.stop_event_loop",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/stop_event_loop/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.stop_event_loop.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/stop_event_loop/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.stop_event_loop.event",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def stop_event_loop(self, event=None):\n        # docstring inherited\n        if hasattr(self, \"_event_loop\"):\n            self._event_loop.quit()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/wheelEvent",
      "name": "wheelEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.wheelEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/wheelEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.wheelEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureCanvasQT/wheelEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureCanvasQT.wheelEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def wheelEvent(self, event):\n            x = event.x()\n            # flipy so y=0 is bottom of canvas\n            y = self.figure.bbox.height - event.y()\n            # from QWheelEvent::delta doc\n            steps = event.delta() / 120\n            if event.orientation() == QtCore.Qt.Vertical:\n                FigureCanvasBase.scroll_event(\n                    self, x, y, steps, guiEvent=event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        FigureManagerBase.__init__(self, canvas, num)\n        self.window = MainWindow()\n        self.window.closing.connect(canvas.close_event)\n        self.window.closing.connect(self._widgetclosed)\n\n        self.window.setWindowTitle(\"Figure %d\" % num)\n        image = str(cbook._get_data_path('images/matplotlib.svg'))\n        self.window.setWindowIcon(QtGui.QIcon(image))\n\n        # Give the keyboard focus to the figure instead of the manager:\n        # StrongFocus accepts both tab and click to focus and will enable the\n        # canvas to process event without clicking.\n        # https://doc.qt.io/qt-5/qt.html#FocusPolicy-enum\n        self.canvas.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.canvas.setFocus()\n\n        self.window._destroying = False\n\n        self.toolbar = self._get_toolbar(self.canvas, self.window)\n\n        if self.toolmanager:\n            backend_tools.add_tools_to_manager(self.toolmanager)\n            if self.toolbar:\n                backend_tools.add_tools_to_container(self.toolbar)\n\n        if self.toolbar:\n            self.window.addToolBar(self.toolbar)\n            tbs_height = self.toolbar.sizeHint().height()\n        else:\n            tbs_height = 0\n\n        # resize the main window so it will display the canvas with the\n        # requested size:\n        cs = canvas.sizeHint()\n        cs_height = cs.height()\n        height = cs_height + tbs_height\n        self.window.resize(cs.width(), height)\n\n        self.window.setCentralWidget(self.canvas)\n\n        if matplotlib.is_interactive():\n            self.window.show()\n            self.canvas.draw_idle()\n\n        self.window.raise_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        # check for qApp first, as PySide deletes it in its atexit handler\n        if QtWidgets.QApplication.instance() is None:\n            return\n        if self.window._destroying:\n            return\n        self.window._destroying = True\n        if self.toolbar:\n            self.toolbar.destroy()\n        self.window.close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/full_screen_toggle",
      "name": "full_screen_toggle",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.full_screen_toggle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/full_screen_toggle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.full_screen_toggle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def full_screen_toggle(self):\n        if self.window.isFullScreen():\n            self.window.showNormal()\n        else:\n            self.window.showFullScreen()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        return self.window.windowTitle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # these are Qt methods so they return sizes in 'virtual' pixels\n        # so we do not need to worry about dpi scaling here.\n        extra_width = self.window.width() - self.canvas.width()\n        extra_height = self.window.height() - self.canvas.height()\n        self.canvas.resize(width, height)\n        self.window.resize(width + extra_width, height + extra_height)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self.window.setWindowTitle(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/FigureManagerQT/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.FigureManagerQT.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        self.window.show()\n        if matplotlib.rcParams['figure.raise_window']:\n            self.window.activateWindow()\n            self.window.raise_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/HelpQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt5.HelpQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/HelpQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.HelpQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/HelpQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.HelpQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        QtWidgets.QMessageBox.information(None, \"Help\", self._get_help_html())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/MainWindow/closeEvent",
      "name": "closeEvent",
      "qname": "lib.matplotlib.backends.backend_qt5.MainWindow.closeEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/MainWindow/closeEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.MainWindow.closeEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/MainWindow/closeEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.MainWindow.closeEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def closeEvent(self, event):\n        self.closing.emit()\n        QtWidgets.QMainWindow.closeEvent(self, event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/__init__/coordinates",
          "name": "coordinates",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.__init__.coordinates",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "coordinates: should we show the coordinates on the right?",
      "code": "    def __init__(self, canvas, parent, coordinates=True):\n        \"\"\"coordinates: should we show the coordinates on the right?\"\"\"\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(\n            QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)\n\n        self.coordinates = coordinates\n        self._actions = {}  # mapping of toolitem method names to QActions.\n\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.addSeparator()\n            else:\n                a = self.addAction(self._icon(image_file + '.png'),\n                                   text, getattr(self, callback))\n                self._actions[callback] = a\n                if callback in ['zoom', 'pan']:\n                    a.setCheckable(True)\n                if tooltip_text is not None:\n                    a.setToolTip(tooltip_text)\n\n        # Add the (x, y) location widget at the right side of the toolbar\n        # The stretch factor is 1 which means any resizing of the toolbar\n        # will resize this label instead of the buttons.\n        if self.coordinates:\n            self.locLabel = QtWidgets.QLabel(\"\", self)\n            self.locLabel.setAlignment(\n                QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n            self.locLabel.setSizePolicy(\n                QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                      QtWidgets.QSizePolicy.Ignored))\n            labelAction = self.addWidget(self.locLabel)\n            labelAction.setVisible(True)\n\n        NavigationToolbar2.__init__(self, canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/basedir@getter",
      "name": "basedir",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.basedir",
      "decorators": [
        "cbook.deprecated('3.3', alternative=\"os.path.join(mpl.get_data_path(), 'images')\")",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/basedir@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.basedir.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\n        \"3.3\", alternative=\"os.path.join(mpl.get_data_path(), 'images')\")\n    @property\n    def basedir(self):\n        return str(cbook._get_data_path('images'))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/configure_subplots",
      "name": "configure_subplots",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.configure_subplots",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_subplots(self):\n        image = str(cbook._get_data_path('images/matplotlib.png'))\n        dia = SubplotToolQt(self.canvas.figure, self.canvas.parent())\n        dia.setWindowIcon(QtGui.QIcon(image))\n        dia.exec_()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n        rect = [int(val) for val in (x0, y0, x1 - x0, y1 - y0)]\n        self.canvas.drawRectangle(rect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/edit_parameters",
      "name": "edit_parameters",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.edit_parameters",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/edit_parameters/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.edit_parameters.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def edit_parameters(self):\n        axes = self.canvas.figure.get_axes()\n        if not axes:\n            QtWidgets.QMessageBox.warning(\n                self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\n            return\n        elif len(axes) == 1:\n            ax, = axes\n        else:\n            titles = [\n                ax.get_label() or\n                ax.get_title() or\n                \" - \".join(filter(None, [ax.get_xlabel(), ax.get_ylabel()])) or\n                f\"<anonymous {type(ax).__name__}>\"\n                for ax in axes]\n            duplicate_titles = [\n                title for title in titles if titles.count(title) > 1]\n            for i, ax in enumerate(axes):\n                if titles[i] in duplicate_titles:\n                    titles[i] += f\" (id: {id(ax):#x})\"  # Deduplicate titles.\n            item, ok = QtWidgets.QInputDialog.getItem(\n                self.canvas.parent(),\n                'Customize', 'Select axes:', titles, 0, False)\n            if not ok:\n                return\n            ax = axes[titles.index(item)]\n        figureoptions.figure_edit(ax, self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        super().pan(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@getter",
      "name": "parent",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.parent",
      "decorators": [
        "cbook.deprecated('3.3', alternative='self.canvas.parent()')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.parent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\", alternative=\"self.canvas.parent()\")\n    @property\n    def parent(self):\n        return self.canvas.parent()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@setter",
      "name": "parent",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.parent",
      "decorators": [
        "cbook.deprecated('3.3', alternative='self.canvas.setParent()')",
        "parent.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.parent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/parent@setter/value",
          "name": "value",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.parent.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\", alternative=\"self.canvas.setParent()\")\n    @parent.setter\n    def parent(self, value):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        self.canvas.drawRectangle(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        filetypes = self.canvas.get_supported_filetypes_grouped()\n        sorted_filetypes = sorted(filetypes.items())\n        default_filetype = self.canvas.get_default_filetype()\n\n        startpath = os.path.expanduser(\n            matplotlib.rcParams['savefig.directory'])\n        start = os.path.join(startpath, self.canvas.get_default_filename())\n        filters = []\n        selectedFilter = None\n        for name, exts in sorted_filetypes:\n            exts_list = \" \".join(['*.%s' % ext for ext in exts])\n            filter = '%s (%s)' % (name, exts_list)\n            if default_filetype in exts:\n                selectedFilter = filter\n            filters.append(filter)\n        filters = ';;'.join(filters)\n\n        fname, filter = qt_compat._getSaveFileName(\n            self.canvas.parent(), \"Choose a filename to save to\", start,\n            filters, selectedFilter)\n        if fname:\n            # Save dir for next time, unless empty str (i.e., use cwd).\n            if startpath != \"\":\n                matplotlib.rcParams['savefig.directory'] = (\n                    os.path.dirname(fname))\n            try:\n                self.canvas.figure.savefig(fname)\n            except Exception as e:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Error saving file\", str(e),\n                    QtWidgets.QMessageBox.Ok, QtWidgets.QMessageBox.NoButton)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        self.canvas.setCursor(cursord[cursor])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'back' in self._actions:\n            self._actions['back'].setEnabled(can_backward)\n        if 'forward' in self._actions:\n            self._actions['forward'].setEnabled(can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.message.emit(s)\n        if self.coordinates:\n            self.locLabel.setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/NavigationToolbar2QT/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.NavigationToolbar2QT.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        super().zoom(*args)\n        self._update_buttons_checked()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, x0, y0, x1, y1):\n        NavigationToolbar2QT.draw_rubberband(\n            self._make_classic_style_pseudo_toolbar(), None, x0, y0, x1, y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/RubberbandQt/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.RubberbandQt.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_rubberband(self):\n        NavigationToolbar2QT.remove_rubberband(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SaveFigureQt/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt5.SaveFigureQt.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SaveFigureQt/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.SaveFigureQt.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SaveFigureQt/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.SaveFigureQt.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2QT.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SetCursorQt/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_qt5.SetCursorQt.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SetCursorQt/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.SetCursorQt.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SetCursorQt/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_qt5.SetCursorQt.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2QT.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/__init__/window",
          "name": "window",
          "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.__init__.window",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, window, *args, **kwargs):\n        StatusbarBase.__init__(self, *args, **kwargs)\n        QtWidgets.QLabel.__init__(self)\n        window.statusBar().addWidget(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/StatusbarQt/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt5.StatusbarQt.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.SubplotToolQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.SubplotToolQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/__init__/targetfig",
          "name": "targetfig",
          "qname": "lib.matplotlib.backends.backend_qt5.SubplotToolQt.__init__.targetfig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/SubplotToolQt/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt5.SubplotToolQt.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, targetfig, parent):\n        UiSubplotTool.__init__(self, None)\n\n        self._figure = targetfig\n\n        for lower, higher in [(\"bottom\", \"top\"), (\"left\", \"right\")]:\n            self._widgets[lower].valueChanged.connect(\n                lambda val: self._widgets[higher].setMinimum(val + .001))\n            self._widgets[higher].valueChanged.connect(\n                lambda val: self._widgets[lower].setMaximum(val - .001))\n\n        self._attrs = [\"top\", \"bottom\", \"left\", \"right\", \"hspace\", \"wspace\"]\n        self._defaults = {attr: vars(self._figure.subplotpars)[attr]\n                          for attr in self._attrs}\n\n        # Set values after setting the range callbacks, but before setting up\n        # the redraw callbacks.\n        self._reset()\n\n        for attr in self._attrs:\n            self._widgets[attr].valueChanged.connect(self._on_value_changed)\n        for action, method in [(\"Export values\", self._export_values),\n                               (\"Tight layout\", self._tight_layout),\n                               (\"Reset\", self._reset),\n                               (\"Close\", self.close)]:\n            self._widgets[action].clicked.connect(method)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__del__",
      "name": "__del__",
      "qname": "lib.matplotlib.backends.backend_qt5.TimerQT.__del__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__del__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.TimerQT.__del__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __del__(self):\n        # The check for deletedness is needed to avoid an error at animation\n        # shutdown with PySide2.\n        if not _isdeleted(self._timer):\n            self._timer_stop()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.TimerQT.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.TimerQT.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.TimerQT.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/TimerQT/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt5.TimerQT.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using QTimer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        # Create a new timer and connect the timeout() signal to the\n        # _on_timer method.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self._on_timer)\n        TimerBase.__init__(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolCopyToClipboardQT/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolCopyToClipboardQT.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolCopyToClipboardQT/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolCopyToClipboardQT.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolCopyToClipboardQT/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolCopyToClipboardQT.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolCopyToClipboardQT/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolCopyToClipboardQT.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        pixmap = self.canvas.grab()\n        qApp.clipboard().setPixmap(pixmap)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager, parent):\n        ToolContainerBase.__init__(self, toolmanager)\n        QtWidgets.QToolBar.__init__(self, parent)\n        self.setAllowedAreas(\n            QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)\n        message_label = QtWidgets.QLabel(\"\")\n        message_label.setAlignment(\n            QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        message_label.setSizePolicy(\n            QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,\n                                  QtWidgets.QSizePolicy.Ignored))\n        self._message_action = self.addWidget(message_label)\n        self._toolitems = {}\n        self._groups = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(\n            self, name, group, position, image_file, description, toggle):\n\n        button = QtWidgets.QToolButton(self)\n        if image_file:\n            button.setIcon(NavigationToolbar2QT._icon(self, image_file))\n        button.setText(name)\n        if description:\n            button.setToolTip(description)\n\n        def handler():\n            self.trigger_tool(name)\n        if toggle:\n            button.setCheckable(True)\n            button.toggled.connect(handler)\n        else:\n            button.clicked.connect(handler)\n\n        self._toolitems.setdefault(name, [])\n        self._add_to_group(group, name, button, position)\n        self._toolitems[name].append((button, handler))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        for button, handler in self._toolitems[name]:\n            button.setParent(None)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.widgetForAction(self._message_action).setText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5/ToolbarQt/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_qt5.ToolbarQt.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for button, handler in self._toolitems[name]:\n            button.toggled.disconnect(handler)\n            button.setChecked(toggled)\n            button.toggled.connect(handler)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        # Must pass 'figure' as kwarg to Qt base class.\n        super().__init__(figure=figure)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/paintEvent",
      "name": "paintEvent",
      "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.paintEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/paintEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.paintEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/paintEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.paintEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Copy the image from the Agg canvas to the qt.drawable.\n\nIn Qt, all drawing should be done inside of here when a widget is\nshown onscreen.",
      "docstring": "Copy the image from the Agg canvas to the qt.drawable.\n\nIn Qt, all drawing should be done inside of here when a widget is\nshown onscreen.",
      "code": "    def paintEvent(self, event):\n        \"\"\"\n        Copy the image from the Agg canvas to the qt.drawable.\n\n        In Qt, all drawing should be done inside of here when a widget is\n        shown onscreen.\n        \"\"\"\n        if self._update_dpi():\n            # The dpi update triggered its own paintEvent.\n            return\n        self._draw_idle()  # Only does something if a draw is pending.\n\n        # If the canvas does not have a renderer, then give up and wait for\n        # FigureCanvasAgg.draw(self) to be called.\n        if not hasattr(self, 'renderer'):\n            return\n\n        painter = QtGui.QPainter(self)\n        try:\n            # See documentation of QRect: bottom() and right() are off\n            # by 1, so use left() + width() and top() + height().\n            rect = event.rect()\n            # scale rect dimensions using the screen dpi ratio to get\n            # correct values for the Figure coordinates (rather than\n            # QT5's coords)\n            width = rect.width() * self._dpi_ratio\n            height = rect.height() * self._dpi_ratio\n            left, top = self.mouseEventCoords(rect.topLeft())\n            # shift the \"top\" by the height of the image to get the\n            # correct corner for our coordinate system\n            bottom = top - height\n            # same with the right side of the image\n            right = left + width\n            # create a buffer using the image bounding box\n            bbox = Bbox([[left, bottom], [right, top]])\n            reg = self.copy_from_bbox(bbox)\n            buf = cbook._unmultiplied_rgba8888_to_premultiplied_argb32(\n                memoryview(reg))\n\n            # clear the widget canvas\n            painter.eraseRect(rect)\n\n            qimage = QtGui.QImage(buf, buf.shape[1], buf.shape[0],\n                                  QtGui.QImage.Format_ARGB32_Premultiplied)\n            _setDevicePixelRatioF(qimage, self._dpi_ratio)\n            # set origin using original QT coordinates\n            origin = QtCore.QPoint(rect.left(), rect.top())\n            painter.drawImage(origin, qimage)\n            # Adjust the buf reference count to work around a memory\n            # leak bug in QImage under PySide on Python 3.\n            if QT_API in ('PySide', 'PySide2'):\n                ctypes.c_long.from_address(id(buf)).value = 1\n\n            self._draw_rect_callback(painter)\n        finally:\n            painter.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/print_figure",
      "name": "print_figure",
      "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.print_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/print_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.print_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/print_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.print_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5agg/FigureCanvasQTAgg/print_figure/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_qt5agg.FigureCanvasQTAgg.print_figure.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_figure(self, *args, **kwargs):\n        super().print_figure(*args, **kwargs)\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, figure):\n        super().__init__(figure=figure)\n        self._renderer = RendererCairo(self.figure.dpi)\n        self._renderer.set_width_height(-1, -1)  # Invalid values."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        if hasattr(self._renderer.gc, \"ctx\"):\n            self.figure.draw(self._renderer)\n        super().draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/paintEvent",
      "name": "paintEvent",
      "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.paintEvent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/paintEvent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.paintEvent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_qt5cairo/FigureCanvasQTCairo/paintEvent/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_qt5cairo.FigureCanvasQTCairo.paintEvent.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def paintEvent(self, event):\n        self._update_dpi()\n        dpi_ratio = self._dpi_ratio\n        width = int(dpi_ratio * self.width())\n        height = int(dpi_ratio * self.height())\n        if (width, height) != self._renderer.get_canvas_width_height():\n            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n            self._renderer.set_ctx_from_surface(surface)\n            self._renderer.set_width_height(width, height)\n            self.figure.draw(self._renderer)\n        buf = self._renderer.gc.ctx.get_target().get_data()\n        qimage = QtGui.QImage(buf, width, height,\n                              QtGui.QImage.Format_ARGB32_Premultiplied)\n        # Adjust the buf reference count to work around a memory leak bug in\n        # QImage under PySide on Python 3.\n        if QT_API == 'PySide':\n            ctypes.c_long.from_address(id(buf)).value = 1\n        _setDevicePixelRatioF(qimage, dpi_ratio)\n        painter = QtGui.QPainter(self)\n        painter.eraseRect(event.rect())\n        painter.drawImage(0, 0, qimage)\n        self._draw_rect_callback(painter)\n        painter.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'svg'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg",
      "name": "print_svg",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "Output target; if a string, a file will be opened for writing."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svg/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svg.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Parameters\n----------\nfilename : str or path-like or file-like\n    Output target; if a string, a file will be opened for writing.\nmetadata : Dict[str, Any], optional\n    Metadata in the SVG file defined as key-value pairs of strings,\n    datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n    'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n    The standard keys and their value types are:\n\n    * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n      ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n      ``'Title'``, and ``'Type'``.\n    * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n      ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n    * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n      non-*str*, then it will be formatted as ISO 8601.\n\n    Values have been predefined for ``'Creator'``, ``'Date'``,\n    ``'Format'``, and ``'Type'``. They can be removed by setting them\n    to `None`.\n\n    Information is encoded as `Dublin Core Metadata`__.\n\n    .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n    __ DC_",
      "code": "    def print_svg(self, filename, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        filename : str or path-like or file-like\n            Output target; if a string, a file will be opened for writing.\n        metadata : Dict[str, Any], optional\n            Metadata in the SVG file defined as key-value pairs of strings,\n            datetimes, or lists of strings, e.g., ``{'Creator': 'My software',\n            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``.\n\n            The standard keys and their value types are:\n\n            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``,\n              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``,\n              ``'Title'``, and ``'Type'``.\n            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``,\n              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``.\n            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a\n              non-*str*, then it will be formatted as ISO 8601.\n\n            Values have been predefined for ``'Creator'``, ``'Date'``,\n            ``'Format'``, and ``'Type'``. They can be removed by setting them\n            to `None`.\n\n            Information is encoded as `Dublin Core Metadata`__.\n\n            .. _DC: https://www.dublincore.org/specifications/dublin-core/\n\n            __ DC_\n        \"\"\"\n        with cbook.open_file_cm(filename, \"w\", encoding=\"utf-8\") as fh:\n\n            filename = getattr(fh, 'name', '')\n            if not isinstance(filename, str):\n                filename = ''\n\n            if cbook.file_requires_unicode(fh):\n                detach = False\n            else:\n                fh = TextIOWrapper(fh, 'utf-8')\n                detach = True\n\n            self._print_svg(filename, fh, **kwargs)\n\n            # Detach underlying stream from wrapper so that it remains open in\n            # the caller.\n            if detach:\n                fh.detach()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz",
      "name": "print_svgz",
      "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/FigureCanvasSVG/print_svgz/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_svg.FigureCanvasSVG.print_svgz.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_svgz(self, filename, *args, **kwargs):\n        with cbook.open_file_cm(filename, \"wb\") as fh, \\\n                gzip.GzipFile(mode='w', fileobj=fh) as gzipwriter:\n            return self.print_svg(gzipwriter)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/svgwriter",
          "name": "svgwriter",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.svgwriter",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/basename",
          "name": "basename",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.basename",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/image_dpi",
          "name": "image_dpi",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.image_dpi",
          "default_value": "72",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/__init__/metadata",
          "name": "metadata",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.__init__.metadata",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, width, height, svgwriter, basename=None, image_dpi=72,\n                 *, metadata=None):\n        self.width = width\n        self.height = height\n        self.writer = XMLWriter(svgwriter)\n        self.image_dpi = image_dpi  # actual dpi at which we rasterize stuff\n\n        self._groupd = {}\n        self.basename = basename\n        self._image_counter = itertools.count()\n        self._clipd = OrderedDict()\n        self._markers = {}\n        self._path_collection_id = 0\n        self._hatchd = OrderedDict()\n        self._has_gouraud = False\n        self._n_gradients = 0\n        self._fonts = OrderedDict()\n        self.mathtext_parser = MathTextParser('SVG')\n\n        RendererBase.__init__(self)\n        self._glyph_map = dict()\n        str_height = short_float_fmt(height)\n        str_width = short_float_fmt(width)\n        svgwriter.write(svgProlog)\n        self._start_id = self.writer.start(\n            'svg',\n            width='%spt' % str_width,\n            height='%spt' % str_height,\n            viewBox='0 0 %s %s' % (str_width, str_height),\n            xmlns=\"http://www.w3.org/2000/svg\",\n            version=\"1.1\",\n            attrib={'xmlns:xlink': \"http://www.w3.org/1999/xlink\"})\n        self._write_metadata(metadata)\n        self._write_default_style()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group",
      "name": "close_group",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/close_group/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.close_group.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def close_group(self, s):\n        # docstring inherited\n        self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle",
      "name": "draw_gouraud_triangle",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/colors",
          "name": "colors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.colors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangle/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangle.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangle(self, gc, points, colors, trans):\n        # docstring inherited\n\n        # This uses a method described here:\n        #\n        #   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html\n        #\n        # that uses three overlapping linear gradients to simulate a\n        # Gouraud triangle.  Each gradient goes from fully opaque in\n        # one corner to fully transparent along the opposite edge.\n        # The line between the stop points is perpendicular to the\n        # opposite edge.  Underlying these three gradients is a solid\n        # triangle whose color is the average of all three points.\n\n        writer = self.writer\n        if not self._has_gouraud:\n            self._has_gouraud = True\n            writer.start(\n                'filter',\n                id='colorAdd')\n            writer.element(\n                'feComposite',\n                attrib={'in': 'SourceGraphic'},\n                in2='BackgroundImage',\n                operator='arithmetic',\n                k2=\"1\", k3=\"1\")\n            writer.end('filter')\n            # feColorMatrix filter to correct opacity\n            writer.start(\n                'filter',\n                id='colorMat')\n            writer.element(\n                'feColorMatrix',\n                attrib={'type': 'matrix'},\n                values='1 0 0 0 0 \\n0 1 0 0 0 \\n0 0 1 0 0' +\n                       ' \\n1 1 1 1 0 \\n0 0 0 0 1 ')\n            writer.end('filter')\n\n        avg_color = np.average(colors, axis=0)\n        if avg_color[-1] == 0:\n            # Skip fully-transparent triangles\n            return\n\n        trans_and_flip = self._make_flip_transform(trans)\n        tpoints = trans_and_flip.transform(points)\n\n        writer.start('defs')\n        for i in range(3):\n            x1, y1 = tpoints[i]\n            x2, y2 = tpoints[(i + 1) % 3]\n            x3, y3 = tpoints[(i + 2) % 3]\n            rgba_color = colors[i]\n\n            if x2 == x3:\n                xb = x2\n                yb = y1\n            elif y2 == y3:\n                xb = x1\n                yb = y2\n            else:\n                m1 = (y2 - y3) / (x2 - x3)\n                b1 = y2 - (m1 * x2)\n                m2 = -(1.0 / m1)\n                b2 = y1 - (m2 * x1)\n                xb = (-b1 + b2) / (m1 - m2)\n                yb = m2 * xb + b2\n\n            writer.start(\n                'linearGradient',\n                id=\"GR%x_%d\" % (self._n_gradients, i),\n                gradientUnits=\"userSpaceOnUse\",\n                x1=short_float_fmt(x1), y1=short_float_fmt(y1),\n                x2=short_float_fmt(xb), y2=short_float_fmt(yb))\n            writer.element(\n                'stop',\n                offset='1',\n                style=generate_css({\n                    'stop-color': rgb2hex(avg_color),\n                    'stop-opacity': short_float_fmt(rgba_color[-1])}))\n            writer.element(\n                'stop',\n                offset='0',\n                style=generate_css({'stop-color': rgb2hex(rgba_color),\n                                    'stop-opacity': \"0\"}))\n\n            writer.end('linearGradient')\n\n        writer.end('defs')\n\n        # triangle formation using \"path\"\n        dpath = \"M \" + short_float_fmt(x1)+',' + short_float_fmt(y1)\n        dpath += \" L \" + short_float_fmt(x2) + ',' + short_float_fmt(y2)\n        dpath += \" \" + short_float_fmt(x3) + ',' + short_float_fmt(y3) + \" Z\"\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': rgb2hex(avg_color),\n                    'fill-opacity': '1',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.start(\n                'g',\n                attrib={'stroke': \"none\",\n                        'stroke-width': \"0\",\n                        'shape-rendering': \"crispEdges\",\n                        'filter': \"url(#colorMat)\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_0)' % self._n_gradients,\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_1)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.element(\n            'path',\n            attrib={'d': dpath,\n                    'fill': 'url(#GR%x_2)' % self._n_gradients,\n                    'filter': 'url(#colorAdd)',\n                    'shape-rendering': \"crispEdges\"})\n\n        writer.end('g')\n\n        self._n_gradients += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles",
      "name": "draw_gouraud_triangles",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/triangles_array",
          "name": "triangles_array",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.triangles_array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/colors_array",
          "name": "colors_array",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.colors_array",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_gouraud_triangles/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_gouraud_triangles.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_gouraud_triangles(self, gc, triangles_array, colors_array,\n                               transform):\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n\n        self.writer.start('g', attrib=attrib)\n\n        transform = transform.frozen()\n        for tri, col in zip(triangles_array, colors_array):\n            self.draw_gouraud_triangle(gc, tri, col, transform)\n\n        self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_image/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_image.transform",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im, transform=None):\n        # docstring inherited\n\n        h, w = im.shape[:2]\n\n        if w == 0 or h == 0:\n            return\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Can't apply clip-path directly to the image because the\n            # image has a transformation, which would also be applied\n            # to the clip-path\n            self.writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        oid = gc.get_gid()\n        url = gc.get_url()\n        if url is not None:\n            self.writer.start('a', attrib={'xlink:href': url})\n        if mpl.rcParams['svg.image_inline']:\n            buf = BytesIO()\n            Image.fromarray(im).save(buf, format=\"png\")\n            oid = oid or self._make_id('image', buf.getvalue())\n            attrib['xlink:href'] = (\n                \"data:image/png;base64,\\n\" +\n                base64.b64encode(buf.getvalue()).decode('ascii'))\n        else:\n            if self.basename is None:\n                raise ValueError(\"Cannot save image data to filesystem when \"\n                                 \"writing SVG to an in-memory buffer\")\n            filename = '{}.image{}.png'.format(\n                self.basename, next(self._image_counter))\n            _log.info('Writing image file for inclusion: %s', filename)\n            Image.fromarray(im).save(filename)\n            oid = oid or 'Im_' + self._make_id('image', filename)\n            attrib['xlink:href'] = filename\n\n        attrib['id'] = oid\n\n        if transform is None:\n            w = 72.0 * w / self.image_dpi\n            h = 72.0 * h / self.image_dpi\n\n            self.writer.element(\n                'image',\n                transform=generate_transform([\n                    ('scale', (1, -1)), ('translate', (0, -h))]),\n                x=short_float_fmt(x),\n                y=short_float_fmt(-(self.height - y - h)),\n                width=short_float_fmt(w), height=short_float_fmt(h),\n                attrib=attrib)\n        else:\n            alpha = gc.get_alpha()\n            if alpha != 1.0:\n                attrib['opacity'] = short_float_fmt(alpha)\n\n            flipped = (\n                Affine2D().scale(1.0 / w, 1.0 / h) +\n                transform +\n                Affine2D()\n                .translate(x, y)\n                .scale(1.0, -1.0)\n                .translate(0.0, self.height))\n\n            attrib['transform'] = generate_transform(\n                [('matrix', flipped.frozen())])\n            attrib['style'] = (\n                'image-rendering:crisp-edges;'\n                'image-rendering:pixelated')\n            self.writer.element(\n                'image',\n                width=short_float_fmt(w), height=short_float_fmt(h),\n                attrib=attrib)\n\n        if url is not None:\n            self.writer.end('a')\n        if clipid is not None:\n            self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers",
      "name": "draw_markers",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/marker_path",
          "name": "marker_path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.marker_path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/marker_trans",
          "name": "marker_trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.marker_trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/trans",
          "name": "trans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.trans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_markers/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_markers.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_markers(\n            self, gc, marker_path, marker_trans, path, trans, rgbFace=None):\n        # docstring inherited\n\n        if not len(path.vertices):\n            return\n\n        writer = self.writer\n        path_data = self._convert_path(\n            marker_path,\n            marker_trans + Affine2D().scale(1.0, -1.0),\n            simplify=False)\n        style = self._get_style_dict(gc, rgbFace)\n        dictkey = (path_data, generate_css(style))\n        oid = self._markers.get(dictkey)\n        style = generate_css({k: v for k, v in style.items()\n                              if k.startswith('stroke')})\n\n        if oid is None:\n            oid = self._make_id('m', dictkey)\n            writer.start('defs')\n            writer.element('path', id=oid, d=path_data, style=style)\n            writer.end('defs')\n            self._markers[dictkey] = oid\n\n        attrib = {}\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n        writer.start('g', attrib=attrib)\n\n        trans_and_flip = self._make_flip_transform(trans)\n        attrib = {'xlink:href': '#%s' % oid}\n        clip = (0, 0, self.width*72, self.height*72)\n        for vertices, code in path.iter_segments(\n                trans_and_flip, clip=clip, simplify=False):\n            if len(vertices):\n                x, y = vertices[-2:]\n                attrib['x'] = short_float_fmt(x)\n                attrib['y'] = short_float_fmt(y)\n                attrib['style'] = self._get_style(gc, rgbFace)\n                writer.element('use', attrib=attrib)\n        writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        trans_and_flip = self._make_flip_transform(transform)\n        clip = (rgbFace is None and gc.get_hatch_path() is None)\n        simplify = path.should_simplify and clip\n        path_data = self._convert_path(\n            path, trans_and_flip, clip=clip, simplify=simplify,\n            sketch=gc.get_sketch_params())\n\n        attrib = {}\n        attrib['style'] = self._get_style(gc, rgbFace)\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            attrib['clip-path'] = 'url(#%s)' % clipid\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n        self.writer.element('path', d=path_data, attrib=attrib)\n        if gc.get_url() is not None:\n            self.writer.end('a')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection",
      "name": "draw_path_collection",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/master_transform",
          "name": "master_transform",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.master_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/paths",
          "name": "paths",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.paths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/all_transforms",
          "name": "all_transforms",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.all_transforms",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offsets",
          "name": "offsets",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offsets",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offsetTrans",
          "name": "offsetTrans",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offsetTrans",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/facecolors",
          "name": "facecolors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.facecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/edgecolors",
          "name": "edgecolors",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.edgecolors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/linewidths",
          "name": "linewidths",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.linewidths",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/linestyles",
          "name": "linestyles",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.linestyles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/antialiaseds",
          "name": "antialiaseds",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.antialiaseds",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/urls",
          "name": "urls",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.urls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_path_collection/offset_position",
          "name": "offset_position",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_path_collection.offset_position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path_collection(self, gc, master_transform, paths, all_transforms,\n                             offsets, offsetTrans, facecolors, edgecolors,\n                             linewidths, linestyles, antialiaseds, urls,\n                             offset_position):\n        # Is the optimization worth it? Rough calculation:\n        # cost of emitting a path in-line is\n        #    (len_path + 5) * uses_per_path\n        # cost of definition+use is\n        #    (len_path + 3) + 9 * uses_per_path\n        len_path = len(paths[0].vertices) if len(paths) > 0 else 0\n        uses_per_path = self._iter_collection_uses_per_path(\n            paths, all_transforms, offsets, facecolors, edgecolors)\n        should_do_optimization = \\\n            len_path + 9 * uses_per_path + 3 < (len_path + 5) * uses_per_path\n        if not should_do_optimization:\n            return RendererBase.draw_path_collection(\n                self, gc, master_transform, paths, all_transforms,\n                offsets, offsetTrans, facecolors, edgecolors,\n                linewidths, linestyles, antialiaseds, urls,\n                offset_position)\n\n        writer = self.writer\n        path_codes = []\n        writer.start('defs')\n        for i, (path, transform) in enumerate(self._iter_collection_raw_paths(\n                master_transform, paths, all_transforms)):\n            transform = Affine2D(transform.get_matrix()).scale(1.0, -1.0)\n            d = self._convert_path(path, transform, simplify=False)\n            oid = 'C%x_%x_%s' % (\n                self._path_collection_id, i, self._make_id('', d))\n            writer.element('path', id=oid, d=d)\n            path_codes.append(oid)\n        writer.end('defs')\n\n        for xo, yo, path_id, gc0, rgbFace in self._iter_collection(\n                gc, master_transform, all_transforms, path_codes, offsets,\n                offsetTrans, facecolors, edgecolors, linewidths, linestyles,\n                antialiaseds, urls, offset_position):\n            clipid = self._get_clip(gc0)\n            url = gc0.get_url()\n            if url is not None:\n                writer.start('a', attrib={'xlink:href': url})\n            if clipid is not None:\n                writer.start('g', attrib={'clip-path': 'url(#%s)' % clipid})\n            attrib = {\n                'xlink:href': '#%s' % path_id,\n                'x': short_float_fmt(xo),\n                'y': short_float_fmt(self.height - yo),\n                'style': self._get_style(gc0, rgbFace)\n                }\n            writer.element('use', attrib=attrib)\n            if clipid is not None:\n                writer.end('g')\n            if url is not None:\n                writer.end('a')\n\n        self._path_collection_id += 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex",
      "name": "draw_tex",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex",
      "decorators": [
        "cbook._delete_parameter('3.3', 'ismath')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.ismath",
          "default_value": "'TeX!'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_tex/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_tex.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook._delete_parameter(\"3.3\", \"ismath\")\n    def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None):\n        # docstring inherited\n        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=\"TeX\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        clipid = self._get_clip(gc)\n        if clipid is not None:\n            # Cannot apply clip-path directly to the text, because\n            # is has a transformation\n            self.writer.start(\n                'g', attrib={'clip-path': 'url(#%s)' % clipid})\n\n        if gc.get_url() is not None:\n            self.writer.start('a', {'xlink:href': gc.get_url()})\n\n        if mpl.rcParams['svg.fonttype'] == 'path':\n            self._draw_text_as_path(gc, x, y, s, prop, angle, ismath, mtext)\n        else:\n            self._draw_text_as_text(gc, x, y, s, prop, angle, ismath, mtext)\n\n        if gc.get_url() is not None:\n            self.writer.end('a')\n\n        if clipid is not None:\n            self.writer.end('g')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize",
      "name": "finalize",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/finalize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.finalize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def finalize(self):\n        self._write_clips()\n        self._write_hatches()\n        self.writer.close(self._start_id)\n        self.writer.flush()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification",
      "name": "get_image_magnification",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_image_magnification",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_image_magnification/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_image_magnification.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_image_magnification(self):\n        return self.image_dpi / 72.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n        return self._text2path.get_text_width_height_descent(s, prop, ismath)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group",
      "name": "open_group",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/open_group/gid",
          "name": "gid",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.open_group.gid",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def open_group(self, s, gid=None):\n        # docstring inherited\n        if gid:\n            self.writer.start('g', id=gid)\n        else:\n            self._groupd[s] = self._groupd.get(s, 0) + 1\n            self.writer.start('g', id=\"%s_%d\" % (s, self._groupd[s]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite",
      "name": "option_image_nocomposite",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_image_nocomposite/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_image_nocomposite.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_image_nocomposite(self):\n        # docstring inherited\n        return not mpl.rcParams['image.composite_image']"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image",
      "name": "option_scale_image",
      "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_scale_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/RendererSVG/option_scale_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.RendererSVG.option_scale_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def option_scale_image(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/__init__/file",
          "name": "file",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.__init__.file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "writable text file-like object",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "writable text file-like object"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, file):\n        self.__write = file.write\n        if hasattr(file, \"flush\"):\n            self.flush = file.flush\n        self.__open = 0  # true if start tag is open\n        self.__tags = []\n        self.__data = []\n        self.__indentation = \" \" * 64"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close",
      "name": "close",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/close/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.close.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element identifier, as returned by the :meth:`start` method."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Close open elements, up to (and including) the element identified\nby the given identifier.",
      "docstring": "Close open elements, up to (and including) the element identified\nby the given identifier.\n\nParameters\n----------\nid\n    Element identifier, as returned by the :meth:`start` method.",
      "code": "    def close(self, id):\n        \"\"\"\n        Close open elements, up to (and including) the element identified\n        by the given identifier.\n\n        Parameters\n        ----------\n        id\n            Element identifier, as returned by the :meth:`start` method.\n        \"\"\"\n        while len(self.__tags) > id:\n            self.end()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment",
      "name": "comment",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/comment/comment",
          "name": "comment",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.comment.comment",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Comment text."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add a comment to the output stream.",
      "docstring": "Add a comment to the output stream.\n\nParameters\n----------\ncomment : str\n    Comment text.",
      "code": "    def comment(self, comment):\n        \"\"\"\n        Add a comment to the output stream.\n\n        Parameters\n        ----------\n        comment : str\n            Comment text.\n        \"\"\"\n        self.__flush()\n        self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"<!-- %s -->\\n\" % escape_comment(comment))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data",
      "name": "data",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/data/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.data.text",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Character data."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add character data to the output stream.",
      "docstring": "Add character data to the output stream.\n\nParameters\n----------\ntext : str\n    Character data.",
      "code": "    def data(self, text):\n        \"\"\"\n        Add character data to the output stream.\n\n        Parameters\n        ----------\n        text : str\n            Character data.\n        \"\"\"\n        self.__data.append(text)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element",
      "name": "element",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.tag",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/text",
          "name": "text",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.text",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/element/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.element.extra",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Add an entire element.  This is the same as calling :meth:`start`,\n:meth:`data`, and :meth:`end` in sequence. The *text* argument can be\nomitted.",
      "docstring": "Add an entire element.  This is the same as calling :meth:`start`,\n:meth:`data`, and :meth:`end` in sequence. The *text* argument can be\nomitted.",
      "code": "    def element(self, tag, text=None, attrib={}, **extra):\n        \"\"\"\n        Add an entire element.  This is the same as calling :meth:`start`,\n        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be\n        omitted.\n        \"\"\"\n        self.start(tag, attrib, **extra)\n        if text:\n            self.data(text)\n        self.end(indent=False)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end",
      "name": "end",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.tag",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element tag.  If given, the tag must match the start tag.  If\nomitted, the current element is closed."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/end/indent",
          "name": "indent",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.end.indent",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Close the current element (opened by the most recent call to\n:meth:`start`).",
      "docstring": "Close the current element (opened by the most recent call to\n:meth:`start`).\n\nParameters\n----------\ntag\n    Element tag.  If given, the tag must match the start tag.  If\n    omitted, the current element is closed.",
      "code": "    def end(self, tag=None, indent=True):\n        \"\"\"\n        Close the current element (opened by the most recent call to\n        :meth:`start`).\n\n        Parameters\n        ----------\n        tag\n            Element tag.  If given, the tag must match the start tag.  If\n            omitted, the current element is closed.\n       \"\"\"\n        if tag:\n            assert self.__tags, \"unbalanced end(%s)\" % tag\n            assert escape_cdata(tag) == self.__tags[-1], \\\n                \"expected end(%s), got %s\" % (self.__tags[-1], tag)\n        else:\n            assert self.__tags, \"unbalanced end()\"\n        tag = self.__tags.pop()\n        if self.__data:\n            self.__flush(indent)\n        elif self.__open:\n            self.__open = 0\n            self.__write(\"/>\\n\")\n            return\n        if indent:\n            self.__write(self.__indentation[:len(self.__tags)])\n        self.__write(\"</%s>\\n\" % tag)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush",
      "name": "flush",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.flush",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/flush/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.flush.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Flush the output stream.",
      "docstring": "Flush the output stream.",
      "code": "    def flush(self):\n        \"\"\"Flush the output stream.\"\"\"\n        pass  # replaced by the constructor"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start",
      "name": "start",
      "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/tag",
          "name": "tag",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.tag",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Element tag."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "Attribute dictionary.  Alternatively, attributes can be given as\nkeyword arguments."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/XMLWriter/start/extra",
          "name": "extra",
          "qname": "lib.matplotlib.backends.backend_svg.XMLWriter.start.extra",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Open a new element.  Attributes can be given as keyword\narguments, or as a string/string dictionary. The method returns\nan opaque identifier that can be passed to the :meth:`close`\nmethod, to close all open elements up to and including this one.",
      "docstring": "Open a new element.  Attributes can be given as keyword\narguments, or as a string/string dictionary. The method returns\nan opaque identifier that can be passed to the :meth:`close`\nmethod, to close all open elements up to and including this one.\n\nParameters\n----------\ntag\n    Element tag.\nattrib\n    Attribute dictionary.  Alternatively, attributes can be given as\n    keyword arguments.\n\nReturns\n-------\nAn element identifier.",
      "code": "    def start(self, tag, attrib={}, **extra):\n        \"\"\"\n        Open a new element.  Attributes can be given as keyword\n        arguments, or as a string/string dictionary. The method returns\n        an opaque identifier that can be passed to the :meth:`close`\n        method, to close all open elements up to and including this one.\n\n        Parameters\n        ----------\n        tag\n            Element tag.\n        attrib\n            Attribute dictionary.  Alternatively, attributes can be given as\n            keyword arguments.\n\n        Returns\n        -------\n        An element identifier.\n        \"\"\"\n        self.__flush()\n        tag = escape_cdata(tag)\n        self.__data = []\n        self.__tags.append(tag)\n        self.__write(self.__indentation[:len(self.__tags) - 1])\n        self.__write(\"<%s\" % tag)\n        for k, v in sorted({**attrib, **extra}.items()):\n            if v:\n                k = escape_cdata(k)\n                v = escape_attrib(v)\n                self.__write(' %s=\"%s\"' % (k, v))\n        self.__open = 1\n        return len(self.__tags) - 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_attrib",
      "name": "escape_attrib",
      "qname": "lib.matplotlib.backends.backend_svg.escape_attrib",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_attrib/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_attrib.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def escape_attrib(s):\n    s = s.replace(\"&\", \"&amp;\")\n    s = s.replace(\"'\", \"&apos;\")\n    s = s.replace('\"', \"&quot;\")\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_cdata",
      "name": "escape_cdata",
      "qname": "lib.matplotlib.backends.backend_svg.escape_cdata",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_cdata/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_cdata.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def escape_cdata(s):\n    s = s.replace(\"&\", \"&amp;\")\n    s = s.replace(\"<\", \"&lt;\")\n    s = s.replace(\">\", \"&gt;\")\n    return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_comment",
      "name": "escape_comment",
      "qname": "lib.matplotlib.backends.backend_svg.escape_comment",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/escape_comment/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_svg.escape_comment.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def escape_comment(s):\n    s = escape_cdata(s)\n    return _escape_xml_comment.sub('- ', s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_css",
      "name": "generate_css",
      "qname": "lib.matplotlib.backends.backend_svg.generate_css",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_css/attrib",
          "name": "attrib",
          "qname": "lib.matplotlib.backends.backend_svg.generate_css.attrib",
          "default_value": "{}",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def generate_css(attrib={}):\n    if attrib:\n        output = StringIO()\n        attrib = sorted(attrib.items())\n        for k, v in attrib:\n            k = escape_attrib(k)\n            v = escape_attrib(v)\n            output.write(\"%s:%s;\" % (k, v))\n        return output.getvalue()\n    return ''"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_transform",
      "name": "generate_transform",
      "qname": "lib.matplotlib.backends.backend_svg.generate_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/generate_transform/transform_list",
          "name": "transform_list",
          "qname": "lib.matplotlib.backends.backend_svg.generate_transform.transform_list",
          "default_value": "[]",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def generate_transform(transform_list=[]):\n    if len(transform_list):\n        output = StringIO()\n        for type, value in transform_list:\n            if (type == 'scale' and (value == (1,) or value == (1, 1))\n                    or type == 'translate' and value == (0, 0)\n                    or type == 'rotate' and value == (0,)):\n                continue\n            if type == 'matrix' and isinstance(value, Affine2DBase):\n                value = value.to_values()\n            output.write('%s(%s)' % (\n                type, ' '.join(short_float_fmt(x) for x in value)))\n        return output.getvalue()\n    return ''"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_svg/short_float_fmt",
      "name": "short_float_fmt",
      "qname": "lib.matplotlib.backends.backend_svg.short_float_fmt",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_svg/short_float_fmt/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_svg.short_float_fmt.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create a short string representation of a float, which is %f\nformatting with trailing zeros and the decimal point removed.",
      "docstring": "Create a short string representation of a float, which is %f\nformatting with trailing zeros and the decimal point removed.",
      "code": "def short_float_fmt(x):\n    \"\"\"\n    Create a short string representation of a float, which is %f\n    formatting with trailing zeros and the decimal point removed.\n    \"\"\"\n    return '{0:f}'.format(x).rstrip('0').rstrip('.')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Draw the figure using the renderer.",
      "docstring": "Draw the figure using the renderer.",
      "code": "    def draw(self):\n        \"\"\"Draw the figure using the renderer.\"\"\"\n        renderer = RendererTemplate(self.figure.dpi)\n        self.figure.draw(renderer)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype",
      "name": "get_default_filetype",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/get_default_filetype/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_default_filetype(self):\n        return 'foo'"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo",
      "name": "print_foo",
      "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/FigureCanvasTemplate/print_foo/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Write out format foo.  The dpi, facecolor and edgecolor are restored\nto their original values after this call, so you don't need to\nsave and restore them.",
      "docstring": "Write out format foo.  The dpi, facecolor and edgecolor are restored\nto their original values after this call, so you don't need to\nsave and restore them.",
      "code": "    def print_foo(self, filename, *args, **kwargs):\n        \"\"\"\n        Write out format foo.  The dpi, facecolor and edgecolor are restored\n        to their original values after this call, so you don't need to\n        save and restore them.\n        \"\"\"\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles drawing/rendering operations.\n\nThis is a minimal do-nothing class that can be used to get started when\nwriting a new backend.  Refer to `backend_bases.RendererBase` for\ndocumentation of the methods.",
      "docstring": "",
      "code": "    def __init__(self, dpi):\n        super().__init__()\n        self.dpi = dpi"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return 100, 100"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        return 1, 1, 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        return GraphicsContextTemplate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/RendererTemplate/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_template.RendererTemplate.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # if backend doesn't have dpi, e.g., postscript or svg\n        return points"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/draw_if_interactive",
      "name": "draw_if_interactive",
      "qname": "lib.matplotlib.backends.backend_template.draw_if_interactive",
      "decorators": [],
      "parameters": [],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "For image backends - is not required.\nFor GUI backends - this should be overridden if drawing should be done in\ninteractive python mode.",
      "docstring": "For image backends - is not required.\nFor GUI backends - this should be overridden if drawing should be done in\ninteractive python mode.",
      "code": "def draw_if_interactive():\n    \"\"\"\n    For image backends - is not required.\n    For GUI backends - this should be overridden if drawing should be done in\n    interactive python mode.\n    \"\"\""
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager",
      "name": "new_figure_manager",
      "qname": "lib.matplotlib.backends.backend_template.new_figure_manager",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_template.new_figure_manager.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_template.new_figure_manager.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager/FigureClass",
          "name": "FigureClass",
          "qname": "lib.matplotlib.backends.backend_template.new_figure_manager.FigureClass",
          "default_value": "Figure",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_template.new_figure_manager.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create a new figure manager instance.",
      "docstring": "Create a new figure manager instance.",
      "code": "def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):\n    \"\"\"Create a new figure manager instance.\"\"\"\n    # If a main-level app must be created, this (and\n    # new_figure_manager_given_figure) is the usual place to do it -- see\n    # backend_wx, backend_wxagg and backend_tkagg for examples.  Not all GUIs\n    # require explicit instantiation of a main-level app (e.g., backend_gtk3)\n    # for pylab.\n    thisFig = FigureClass(*args, **kwargs)\n    return new_figure_manager_given_figure(num, thisFig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager_given_figure",
      "name": "new_figure_manager_given_figure",
      "qname": "lib.matplotlib.backends.backend_template.new_figure_manager_given_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager_given_figure/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_template.new_figure_manager_given_figure.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/new_figure_manager_given_figure/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_template.new_figure_manager_given_figure.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Create a new figure manager instance for the given figure.",
      "docstring": "Create a new figure manager instance for the given figure.",
      "code": "def new_figure_manager_given_figure(num, figure):\n    \"\"\"Create a new figure manager instance for the given figure.\"\"\"\n    canvas = FigureCanvasTemplate(figure)\n    manager = FigureManagerTemplate(canvas, num)\n    return manager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_template/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_template.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_template/show/block",
          "name": "block",
          "qname": "lib.matplotlib.backends.backend_template.show.block",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "For image backends - is not required.\nFor GUI backends - show() is usually the last line of a pyplot script and\ntells the backend that it is time to draw.  In interactive mode, this\nshould do nothing.",
      "docstring": "For image backends - is not required.\nFor GUI backends - show() is usually the last line of a pyplot script and\ntells the backend that it is time to draw.  In interactive mode, this\nshould do nothing.",
      "code": "def show(*, block=None):\n    \"\"\"\n    For image backends - is not required.\n    For GUI backends - show() is usually the last line of a pyplot script and\n    tells the backend that it is time to draw.  In interactive mode, this\n    should do nothing.\n    \"\"\"\n    for manager in Gcf.get_all_fig_managers():\n        # do something to display the GUI\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        _backend_tk.blit(\n            self._tkphoto, self.renderer._renderer, (0, 1, 2, 3), bbox=bbox)\n        self._master.update_idletasks()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkagg/FigureCanvasTkAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkagg.FigureCanvasTkAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        super(FigureCanvasTkAgg, self).draw()\n        _backend_tk.blit(self._tkphoto, self.renderer._renderer, (0, 1, 2, 3))\n        self._master.update_idletasks()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super(FigureCanvasTkCairo, self).__init__(*args, **kwargs)\n        self._renderer = RendererCairo(self.figure.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_tkcairo/FigureCanvasTkCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_tkcairo.FigureCanvasTkCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_ctx_from_surface(surface)\n        self._renderer.set_width_height(width, height)\n        self.figure.draw(self._renderer)\n        buf = np.reshape(surface.get_data(), (height, width, 4))\n        _backend_tk.blit(\n            self._tkphoto, buf,\n            (2, 1, 0, 3) if sys.byteorder == \"little\" else (1, 2, 3, 0))\n        self._master.update_idletasks()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureCanvasWebAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg.FigureCanvasWebAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/FigureCanvasWebAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.FigureCanvasWebAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # show the figure window\n        global show  # placates pyflakes: created by @_Backend.export below\n        show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run",
      "name": "run",
      "qname": "lib.matplotlib.backends.backend_webagg.ServerThread.run",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ServerThread/run/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.ServerThread.run.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def run(self):\n        tornado.ioloop.IOLoop.instance().start()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/application",
          "name": "application",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.application",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/request",
          "name": "request",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/AllFiguresPage/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.AllFiguresPage.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"all_figures.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                figures=sorted(Gcf.figs.items()),\n                toolitems=core.NavigationToolbar2WebAgg.toolitems)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/Download/get/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.Download.get.fmt",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self, fignum, fmt):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n            self.set_header(\n                'Content-Type', mimetypes.types_map.get(fmt, 'binary'))\n            buff = BytesIO()\n            manager.canvas.figure.savefig(buff, format=fmt)\n            self.write(buff.getvalue())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/FavIcon/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.FavIcon.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/FavIcon/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.FavIcon.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            self.set_header('Content-Type', 'image/png')\n            self.write(Path(mpl.get_data_path(),\n                            'images/matplotlib.png').read_bytes())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/MplJs/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.MplJs.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/MplJs/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.MplJs.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self):\n            self.set_header('Content-Type', 'application/javascript')\n\n            js_content = core.FigureManagerWebAgg.get_javascript()\n\n            self.write(js_content)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/application",
          "name": "application",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.application",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/request",
          "name": "request",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.request",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, application, request, *, url_prefix='', **kwargs):\n            self.url_prefix = url_prefix\n            super().__init__(application, request, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get",
      "name": "get",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/SingleFigurePage/get/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.SingleFigurePage.get.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def get(self, fignum):\n            fignum = int(fignum)\n            manager = Gcf.get_fig_manager(fignum)\n\n            ws_uri = 'ws://{req.host}{prefix}/'.format(req=self.request,\n                                                       prefix=self.url_prefix)\n            self.render(\n                \"single_figure.html\",\n                prefix=self.url_prefix,\n                ws_uri=ws_uri,\n                fig_id=fignum,\n                toolitems=core.NavigationToolbar2WebAgg.toolitems,\n                canvas=manager.canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_close",
      "name": "on_close",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_close",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_close/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_close.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def on_close(self):\n            self.manager.remove_web_socket(self)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message",
      "name": "on_message",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/on_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.on_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def on_message(self, message):\n            message = json.loads(message)\n            # The 'supports_binary' message is on a client-by-client\n            # basis.  The others affect the (shared) canvas as a\n            # whole.\n            if message['type'] == 'supports_binary':\n                self.supports_binary = message['value']\n            else:\n                manager = Gcf.get_fig_manager(self.fignum)\n                # It is possible for a figure to be closed,\n                # but a stale figure UI is still sending messages\n                # from the browser.\n                if manager is not None:\n                    manager.handle_json(message)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open",
      "name": "open",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/open/fignum",
          "name": "fignum",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.open.fignum",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def open(self, fignum):\n            self.fignum = int(fignum)\n            self.manager = Gcf.get_fig_manager(self.fignum)\n            self.manager.add_web_socket(self)\n            if hasattr(self, 'set_nodelay'):\n                self.set_nodelay(True)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary",
      "name": "send_binary",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_binary/blob",
          "name": "blob",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_binary.blob",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def send_binary(self, blob):\n            if self.supports_binary:\n                self.write_message(blob, binary=True)\n            else:\n                data_uri = \"data:image/png;base64,{0}\".format(\n                    blob.encode('base64').replace('\\n', ''))\n                self.write_message(data_uri)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json",
      "name": "send_json",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/WebSocket/send_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.WebSocket.send_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def send_json(self, content):\n            self.write_message(json.dumps(content))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/__init__/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.__init__.url_prefix",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, url_prefix=''):\n        if url_prefix:\n            assert url_prefix[0] == '/' and url_prefix[-1] != '/', \\\n                'url_prefix must start with a \"/\" and not end with one.'\n\n        super().__init__(\n            [\n                # Static files for the CSS and JS\n                (url_prefix + r'/_static/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': core.FigureManagerWebAgg.get_static_file_path()}),\n\n                # Static images for the toolbar\n                (url_prefix + r'/_images/(.*)',\n                 tornado.web.StaticFileHandler,\n                 {'path': Path(mpl.get_data_path(), 'images')}),\n\n                # A Matplotlib favicon\n                (url_prefix + r'/favicon.ico', self.FavIcon),\n\n                # The page that contains all of the pieces\n                (url_prefix + r'/([0-9]+)', self.SingleFigurePage,\n                 {'url_prefix': url_prefix}),\n\n                # The page that contains all of the figures\n                (url_prefix + r'/?', self.AllFiguresPage,\n                 {'url_prefix': url_prefix}),\n\n                (url_prefix + r'/js/mpl.js', self.MplJs),\n\n                # Sends images and events to the browser, and receives\n                # events from the browser\n                (url_prefix + r'/([0-9]+)/ws', self.WebSocket),\n\n                # Handles the downloading (i.e., saving) of static images\n                (url_prefix + r'/([0-9]+)/download.([a-z0-9.]+)',\n                 self.Download),\n            ],\n            template_path=core.FigureManagerWebAgg.get_static_file_path())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize",
      "name": "initialize",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/url_prefix",
          "name": "url_prefix",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.url_prefix",
          "default_value": "''",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/port",
          "name": "port",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.port",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/initialize/address",
          "name": "address",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.initialize.address",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def initialize(cls, url_prefix='', port=None, address=None):\n        if cls.initialized:\n            return\n\n        # Create the class instance\n        app = cls(url_prefix=url_prefix)\n\n        cls.url_prefix = url_prefix\n\n        # This port selection algorithm is borrowed, more or less\n        # verbatim, from IPython.\n        def random_ports(port, n):\n            \"\"\"\n            Generate a list of n random ports near the given port.\n\n            The first 5 ports will be sequential, and the remaining n-5 will be\n            randomly selected in the range [port-2*n, port+2*n].\n            \"\"\"\n            for i in range(min(5, n)):\n                yield port + i\n            for i in range(n - 5):\n                yield port + random.randint(-2 * n, 2 * n)\n\n        if address is None:\n            cls.address = mpl.rcParams['webagg.address']\n        else:\n            cls.address = address\n        cls.port = mpl.rcParams['webagg.port']\n        for port in random_ports(cls.port,\n                                 mpl.rcParams['webagg.port_retries']):\n            try:\n                app.listen(port, cls.address)\n            except socket.error as e:\n                if e.errno != errno.EADDRINUSE:\n                    raise\n            else:\n                cls.port = port\n                break\n        else:\n            raise SystemExit(\n                \"The webagg server could not be started because an available \"\n                \"port could not be found\")\n\n        cls.initialized = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start",
      "name": "start",
      "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.start",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/WebAggApplication/start/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg.WebAggApplication.start.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def start(cls):\n        if cls.started:\n            return\n\n        \"\"\"\n        IOLoop.running() was removed as of Tornado 2.4; see for example\n        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY\n        Thus there is no correct way to check if the loop has already been\n        launched. We may end up with two concurrently running loops in that\n        unlucky case with all the expected consequences.\n        \"\"\"\n        ioloop = tornado.ioloop.IOLoop.instance()\n\n        def shutdown():\n            ioloop.stop()\n            print(\"Server is stopped\")\n            sys.stdout.flush()\n            cls.started = False\n\n        @contextmanager\n        def catch_sigint():\n            old_handler = signal.signal(\n                signal.SIGINT,\n                lambda sig, frame: ioloop.add_callback_from_signal(shutdown))\n            try:\n                yield\n            finally:\n                signal.signal(signal.SIGINT, old_handler)\n\n        # Set the flag to True *before* blocking on ioloop.start()\n        cls.started = True\n\n        print(\"Press Ctrl+C to stop WebAgg server\")\n        sys.stdout.flush()\n        with catch_sigint():\n            ioloop.start()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ipython_inline_display",
      "name": "ipython_inline_display",
      "qname": "lib.matplotlib.backends.backend_webagg.ipython_inline_display",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg/ipython_inline_display/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_webagg.ipython_inline_display.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def ipython_inline_display(figure):\n    import tornado.template\n\n    WebAggApplication.initialize()\n    if not webagg_server_thread.is_alive():\n        webagg_server_thread.start()\n\n    fignum = figure.number\n    tpl = Path(core.FigureManagerWebAgg.get_static_file_path(),\n               \"ipython_inline_figure.html\").read_text()\n    t = tornado.template.Template(tpl)\n    return t.generate(\n        prefix=WebAggApplication.url_prefix,\n        fig_id=fignum,\n        toolitems=core.NavigationToolbar2WebAgg.toolitems,\n        canvas=figure.canvas,\n        port=WebAggApplication.port).decode('utf-8')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        backend_agg.FigureCanvasAgg.__init__(self, *args, **kwargs)\n\n        # Set to True when the renderer contains data that is newer\n        # than the PNG buffer.\n        self._png_is_old = True\n\n        # Set to True by the `refresh` message so that the next frame\n        # sent to the clients will be a full frame.\n        self._force_full = True\n\n        # Store the current image mode so that at any point, clients can\n        # request the information. This should be changed by calling\n        # self.set_image_mode(mode) so that the notification can be given\n        # to the connected clients.\n        self._current_image_mode = 'full'\n\n        # Store the DPI ratio of the browser.  This is the scaling that\n        # occurs automatically for all images on a HiDPI display.\n        self._dpi_ratio = 1"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self):\n        self._png_is_old = True\n        try:\n            super().draw()\n        finally:\n            self.manager.refresh_all()  # Swap the frames."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle",
      "name": "draw_idle",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw_idle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/draw_idle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.draw_idle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_idle(self):\n        self.send_event(\"draw\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image",
      "name": "get_diff_image",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_diff_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_diff_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_diff_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_diff_image(self):\n        if self._png_is_old:\n            renderer = self.get_renderer()\n\n            # The buffer is created as type uint32 so that entire\n            # pixels can be compared in one numpy call, rather than\n            # needing to compare each plane separately.\n            buff = (np.frombuffer(renderer.buffer_rgba(), dtype=np.uint32)\n                    .reshape((renderer.height, renderer.width)))\n\n            # If any pixels have transparency, we need to force a full\n            # draw as we cannot overlay new on top of old.\n            pixels = buff.view(dtype=np.uint8).reshape(buff.shape + (4,))\n\n            if self._force_full or np.any(pixels[:, :, 3] != 255):\n                self.set_image_mode('full')\n                output = buff\n            else:\n                self.set_image_mode('diff')\n                last_buffer = (np.frombuffer(self._last_renderer.buffer_rgba(),\n                                             dtype=np.uint32)\n                               .reshape((renderer.height, renderer.width)))\n                diff = buff != last_buffer\n                output = np.where(diff, buff, 0)\n\n            buf = BytesIO()\n            data = output.view(dtype=np.uint8).reshape((*output.shape, 4))\n            Image.fromarray(data).save(buf, format=\"png\")\n            # Swap the renderer frames\n            self._renderer, self._last_renderer = (\n                self._last_renderer, renderer)\n            self._force_full = False\n            self._png_is_old = False\n            return buf.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_renderer",
      "name": "get_renderer",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_renderer",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_renderer/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_renderer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/get_renderer/cleared",
          "name": "cleared",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.get_renderer.cleared",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_renderer(self, cleared=None):\n        # Mirrors super.get_renderer, but caches the old one so that we can do\n        # things such as produce a diff image in get_diff_image.\n        w, h = self.figure.bbox.size.astype(int)\n        key = w, h, self.figure.dpi\n        try:\n            self._lastKey, self._renderer\n        except AttributeError:\n            need_new_renderer = True\n        else:\n            need_new_renderer = (self._lastKey != key)\n\n        if need_new_renderer:\n            self._renderer = backend_agg.RendererAgg(\n                w, h, self.figure.dpi)\n            self._last_renderer = backend_agg.RendererAgg(\n                w, h, self.figure.dpi)\n            self._lastKey = key\n\n        elif cleared:\n            self._renderer.clear()\n\n        return self._renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack",
      "name": "handle_ack",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_ack/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_ack.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_ack(self, event):\n        # Network latency tends to decrease if traffic is flowing\n        # in both directions.  Therefore, the browser sends back\n        # an \"ack\" message after each image frame is received.\n        # This could also be used as a simple sanity check in the\n        # future, but for now the performance increase is enough\n        # to justify it, even if the server does nothing with it.\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw",
      "name": "handle_draw",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_draw/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_draw.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_draw(self, event):\n        self.draw()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event",
      "name": "handle_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_event(self, event):\n        e_type = event['type']\n        handler = getattr(self, 'handle_{0}'.format(e_type),\n                          self.handle_unknown_event)\n        return handler(event)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh",
      "name": "handle_refresh",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_refresh/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_refresh.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_refresh(self, event):\n        figure_label = self.figure.get_label()\n        if not figure_label:\n            figure_label = \"Figure {0}\".format(self.manager.num)\n        self.send_event('figure_label', label=figure_label)\n        self._force_full = True\n        if self.toolbar:\n            # Normal toolbar init would refresh this, but it happens before the\n            # browser canvas is set up.\n            self.toolbar.set_history_buttons()\n        self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize",
      "name": "handle_resize",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_resize/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_resize.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_resize(self, event):\n        x, y = event.get('width', 800), event.get('height', 800)\n        x, y = int(x) * self._dpi_ratio, int(y) * self._dpi_ratio\n        fig = self.figure\n        # An attempt at approximating the figure size in pixels.\n        fig.set_size_inches(x / fig.dpi, y / fig.dpi, forward=False)\n        # Acknowledge the resize, and force the viewer to update the\n        # canvas size to the figure's new size (which is hopefully\n        # identical or within a pixel or so).\n        self._png_is_old = True\n        self.manager.resize(*fig.bbox.size, forward=False)\n        self.resize_event()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode",
      "name": "handle_send_image_mode",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_send_image_mode/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_send_image_mode.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_send_image_mode(self, event):\n        # The client requests notification of what the current image mode is.\n        self.send_event('image_mode', mode=self._current_image_mode)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio",
      "name": "handle_set_dpi_ratio",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_set_dpi_ratio/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_set_dpi_ratio.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_set_dpi_ratio(self, event):\n        dpi_ratio = event.get('dpi_ratio', 1)\n        if dpi_ratio != self._dpi_ratio:\n            # We don't want to scale up the figure dpi more than once.\n            if not hasattr(self.figure, '_original_dpi'):\n                self.figure._original_dpi = self.figure.dpi\n            self.figure.dpi = dpi_ratio * self.figure._original_dpi\n            self._dpi_ratio = dpi_ratio\n            self._force_full = True\n            self.draw_idle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button",
      "name": "handle_toolbar_button",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_toolbar_button/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_toolbar_button.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_toolbar_button(self, event):\n        # TODO: Be more suspicious of the input\n        getattr(self.toolbar, event['name'])()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event",
      "name": "handle_unknown_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/handle_unknown_event/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.handle_unknown_event.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_unknown_event(self, event):\n        _log.warning('Unhandled message type {0}. {1}'.format(\n                     event['type'], event))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event",
      "name": "send_event",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/event_type",
          "name": "event_type",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.event_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/send_event/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.send_event.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def send_event(self, event_type, **kwargs):\n        if self.manager:\n            self.manager._send_event(event_type, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode",
      "name": "set_image_mode",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/set_image_mode/mode",
          "name": "mode",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.set_image_mode.mode",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the image mode for any subsequent images which will be sent\nto the clients. The modes may currently be either 'full' or 'diff'.\n\nNote: diff images may not contain transparency, therefore upon\ndraw this mode may be changed if the resulting image has any\ntransparent component.",
      "docstring": "Set the image mode for any subsequent images which will be sent\nto the clients. The modes may currently be either 'full' or 'diff'.\n\nNote: diff images may not contain transparency, therefore upon\ndraw this mode may be changed if the resulting image has any\ntransparent component.",
      "code": "    def set_image_mode(self, mode):\n        \"\"\"\n        Set the image mode for any subsequent images which will be sent\n        to the clients. The modes may currently be either 'full' or 'diff'.\n\n        Note: diff images may not contain transparency, therefore upon\n        draw this mode may be changed if the resulting image has any\n        transparent component.\n        \"\"\"\n        cbook._check_in_list(['full', 'diff'], mode=mode)\n        if self._current_image_mode != mode:\n            self._current_image_mode = mode\n            self.handle_send_image_mode(None)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureCanvasWebAggCore/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureCanvasWebAggCore.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # show the figure window\n        from matplotlib.pyplot import show\n        show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, num):\n        backend_bases.FigureManagerBase.__init__(self, canvas, num)\n\n        self.web_sockets = set()\n\n        self.toolbar = self._get_toolbar(canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket",
      "name": "add_web_socket",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/add_web_socket/web_socket",
          "name": "web_socket",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.add_web_socket.web_socket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_web_socket(self, web_socket):\n        assert hasattr(web_socket, 'send_binary')\n        assert hasattr(web_socket, 'send_json')\n        self.web_sockets.add(web_socket)\n        self.resize(*self.canvas.figure.bbox.size)\n        self._send_event('refresh')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript",
      "name": "get_javascript",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_javascript/stream",
          "name": "stream",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_javascript.stream",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_javascript(cls, stream=None):\n        if stream is None:\n            output = StringIO()\n        else:\n            output = stream\n\n        output.write((Path(__file__).parent / \"web_backend/js/mpl.js\")\n                     .read_text(encoding=\"utf-8\"))\n\n        toolitems = []\n        for name, tooltip, image, method in cls.ToolbarCls.toolitems:\n            if name is None:\n                toolitems.append(['', '', '', ''])\n            else:\n                toolitems.append([name, tooltip, image, method])\n        output.write(\"mpl.toolbar_items = {0};\\n\\n\".format(\n            json.dumps(toolitems)))\n\n        extensions = []\n        for filetype, ext in sorted(FigureCanvasWebAggCore.\n                                    get_supported_filetypes_grouped().\n                                    items()):\n            if ext[0] != 'pgf':  # pgf does not support BytesIO\n                extensions.append(ext[0])\n        output.write(\"mpl.extensions = {0};\\n\\n\".format(\n            json.dumps(extensions)))\n\n        output.write(\"mpl.default_extension = {0};\".format(\n            json.dumps(FigureCanvasWebAggCore.get_default_filetype())))\n\n        if stream is None:\n            return output.getvalue()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path",
      "name": "get_static_file_path",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_static_file_path",
      "decorators": [
        "classmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/get_static_file_path/cls",
          "name": "cls",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.get_static_file_path.cls",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @classmethod\n    def get_static_file_path(cls):\n        return os.path.join(os.path.dirname(__file__), 'web_backend')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json",
      "name": "handle_json",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/handle_json/content",
          "name": "content",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.handle_json.content",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_json(self, content):\n        self.canvas.handle_event(content)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all",
      "name": "refresh_all",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.refresh_all",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/refresh_all/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.refresh_all.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def refresh_all(self):\n        if self.web_sockets:\n            diff = self.canvas.get_diff_image()\n            if diff is not None:\n                for s in self.web_sockets:\n                    s.send_binary(diff)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket",
      "name": "remove_web_socket",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/remove_web_socket/web_socket",
          "name": "web_socket",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.remove_web_socket.web_socket",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_web_socket(self, web_socket):\n        self.web_sockets.remove(web_socket)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/h",
          "name": "h",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.h",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/resize/forward",
          "name": "forward",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.resize.forward",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, w, h, forward=True):\n        self._send_event(\n            'resize',\n            size=(w / self.canvas._dpi_ratio, h / self.canvas._dpi_ratio),\n            forward=forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        self._send_event('figure_label', label=title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/FigureManagerWebAgg/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.FigureManagerWebAgg.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas):\n        self.message = ''\n        self.cursor = 0\n        super().__init__(canvas)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        self.canvas.send_event(\n            \"rubberband\", x0=x0, y0=y0, x1=x1, y1=y1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self):\n        super().pan()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/release_zoom",
      "name": "release_zoom",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.release_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/release_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.release_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/release_zoom/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.release_zoom.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def release_zoom(self, event):\n        backend_bases.NavigationToolbar2.release_zoom(self, event)\n        self.canvas.send_event(\n            \"rubberband\", x0=-1, y0=-1, x1=-1, y1=-1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Save the current figure",
      "docstring": "Save the current figure",
      "code": "    def save_figure(self, *args):\n        \"\"\"Save the current figure\"\"\"\n        self.canvas.send_event('save')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        if cursor != self.cursor:\n            self.canvas.send_event(\"cursor\", cursor=cursor)\n        self.cursor = cursor"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        self.canvas.send_event('history_buttons',\n                               Back=can_backward, Forward=can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/set_message/message",
          "name": "message",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.set_message.message",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, message):\n        if message != self.message:\n            self.canvas.send_event(\"message\", message=message)\n        self.message = message"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/NavigationToolbar2WebAgg/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.NavigationToolbar2WebAgg.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self):\n        super().zoom()\n        self.canvas.send_event('navigate_mode', mode=self.mode.name)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_webagg_core/TimerTornado/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_webagg_core.TimerTornado.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = None\n        super().__init__(*args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/configure_subplots",
      "name": "configure_subplots",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.configure_subplots",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def configure_subplots(self):\n        frame = wx.Frame(None, -1, \"Configure subplots\")\n        _set_frame_icon(frame)\n\n        toolfig = Figure((6, 3))\n        canvas = self.get_canvas(frame, toolfig)\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        frame.SetSizer(sizer)\n        frame.Fit()\n        SubplotTool(self.canvas.figure, toolfig)\n        frame.Show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.get_canvas",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/get_canvas/frame",
          "name": "frame",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.get_canvas.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def get_canvas(self, frame, fig):\n        return type(self.canvas)(frame, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ConfigureSubplotsWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.ConfigureSubplotsWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2Wx.configure_subplots(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/DEBUG_MSG",
      "name": "DEBUG_MSG",
      "qname": "lib.matplotlib.backends.backend_wx.DEBUG_MSG",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/DEBUG_MSG/string",
          "name": "string",
          "qname": "lib.matplotlib.backends.backend_wx.DEBUG_MSG.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/DEBUG_MSG/lvl",
          "name": "lvl",
          "qname": "lib.matplotlib.backends.backend_wx.DEBUG_MSG.lvl",
          "default_value": "3",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/DEBUG_MSG/o",
          "name": "o",
          "qname": "lib.matplotlib.backends.backend_wx.DEBUG_MSG.o",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@cbook.deprecated(\"3.3\")\ndef DEBUG_MSG(string, lvl=3, o=None):\n    if lvl >= _DEBUG:\n        print(f\"{_DEBUG_lvls[lvl]}- {string} in {type(o)}\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure using RendererWx instance renderer, or using a\npreviously defined renderer if none is specified.",
      "docstring": "Render the figure using RendererWx instance renderer, or using a\npreviously defined renderer if none is specified.",
      "code": "    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using RendererWx instance renderer, or using a\n        previously defined renderer if none is specified.\n        \"\"\"\n        _log.debug(\"%s - draw()\", type(self))\n        self.renderer = RendererWx(self.bitmap, self.figure.dpi)\n        self.figure.draw(self.renderer)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_bmp",
      "name": "print_bmp",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_bmp",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_bmp/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_bmp.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_bmp/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_bmp.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_bmp/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_bmp.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_bmp/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_bmp.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_bmp(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_BMP, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_jpeg",
      "name": "print_jpeg",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_jpeg",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_jpeg/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_jpeg.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_jpeg/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_jpeg.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_jpeg/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_jpeg.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_jpeg/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_jpeg.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_jpeg(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_JPEG,\n                                 *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_pcx",
      "name": "print_pcx",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_pcx",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_pcx/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_pcx.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_pcx/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_pcx.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_pcx/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_pcx.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_pcx/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_pcx.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_pcx(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_PCX, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_png",
      "name": "print_png",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_png",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_png/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_png.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_png/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_png.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_png/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_png.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_png/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_png.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_png(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_PNG, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_tiff",
      "name": "print_tiff",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_tiff",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_tiff/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_tiff.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_tiff/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_tiff.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_tiff/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_tiff.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_tiff/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_tiff.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_tiff(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_TIF, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_xpm",
      "name": "print_xpm",
      "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_xpm",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_xpm/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_xpm.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_xpm/filename",
          "name": "filename",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_xpm.filename",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_xpm/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_xpm.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureCanvasWx/print_xpm/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureCanvasWx.print_xpm.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def print_xpm(self, filename, *args, **kwargs):\n        return self._print_image(filename, wx.BITMAP_TYPE_XPM, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/Destroy",
      "name": "Destroy",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.Destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/Destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.Destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/Destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.Destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/Destroy/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.Destroy.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def Destroy(self, *args, **kwargs):\n        try:\n            self.canvas.mpl_disconnect(self.toolbar._id_drag)\n            # Rationale for line above: see issue 2941338.\n        except AttributeError:\n            pass  # classic toolbar lacks the attribute\n        # The \"if self\" check avoids a \"wrapped C/C++ object has been deleted\"\n        # RuntimeError at exit with e.g.\n        # MPLBACKEND=wxagg python -c 'from pylab import *; plot()'.\n        if self and not self.IsBeingDeleted():\n            wx.Frame.Destroy(self, *args, **kwargs)\n            if self.toolbar is not None:\n                self.toolbar.Destroy()\n            wxapp = wx.GetApp()\n            if wxapp:\n                wxapp.Yield()\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/GetToolBar",
      "name": "GetToolBar",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.GetToolBar",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/GetToolBar/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.GetToolBar.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Override wxFrame::GetToolBar as we don't have managed toolbar",
      "docstring": "Override wxFrame::GetToolBar as we don't have managed toolbar",
      "code": "    def GetToolBar(self):\n        \"\"\"Override wxFrame::GetToolBar as we don't have managed toolbar\"\"\"\n        return self.toolbar"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/__init__/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.__init__.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, num, fig):\n        # On non-Windows platform, explicitly set the position - fix\n        # positioning bug on some Linux platforms\n        if wx.Platform == '__WXMSW__':\n            pos = wx.DefaultPosition\n        else:\n            pos = wx.Point(20, 20)\n        wx.Frame.__init__(self, parent=None, id=-1, pos=pos,\n                          title=\"Figure %d\" % num)\n        # Frame will be sized later by the Fit method\n        _log.debug(\"%s - __init__()\", type(self))\n        self.num = num\n        _set_frame_icon(self)\n\n        self.canvas = self.get_canvas(fig)\n        w, h = map(math.ceil, fig.bbox.size)\n        self.canvas.SetInitialSize(wx.Size(w, h))\n        self.canvas.SetFocus()\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.canvas, 1, wx.TOP | wx.LEFT | wx.EXPAND)\n        # By adding toolbar in sizer, we are able to put it at the bottom\n        # of the frame - so appearance is closer to GTK version\n\n        self.figmgr = FigureManagerWx(self.canvas, num, self)\n\n        self.toolbar = self._get_toolbar()\n\n        if self.figmgr.toolmanager:\n            backend_tools.add_tools_to_manager(self.figmgr.toolmanager)\n            if self.toolbar:\n                backend_tools.add_tools_to_container(self.toolbar)\n\n        if self.toolbar is not None:\n            self.toolbar.Realize()\n            # On Windows platform, default window size is incorrect, so set\n            # toolbar width to figure width.\n            tw, th = self.toolbar.GetSize()\n            fw, fh = self.canvas.GetSize()\n            # By adding toolbar in sizer, we are able to put it at the bottom\n            # of the frame - so appearance is closer to GTK version.\n            self.toolbar.SetSize(wx.Size(fw, th))\n            self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)\n        self.SetSizer(self.sizer)\n        self.Fit()\n\n        self.canvas.SetMinSize((2, 2))\n\n        self.Bind(wx.EVT_CLOSE, self._onClose)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWx(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager",
      "name": "get_figure_manager",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_figure_manager",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/get_figure_manager/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.get_figure_manager.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_figure_manager(self):\n        _log.debug(\"%s - get_figure_manager()\", type(self))\n        return self.figmgr"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/statusbar@getter",
      "name": "statusbar",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.statusbar",
      "decorators": [
        "cbook.deprecated('3.2', alternative='self.GetStatusBar()')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/statusbar@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.statusbar.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\", alternative=\"self.GetStatusBar()\")\n    @property\n    def statusbar(self):\n        return self.GetStatusBar()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/toolmanager@getter",
      "name": "toolmanager",
      "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.toolmanager",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureFrameWx/toolmanager@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureFrameWx.toolmanager.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def toolmanager(self):\n        return self.figmgr.toolmanager"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/num",
          "name": "num",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.num",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/__init__/frame",
          "name": "frame",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.__init__.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Container/controller for the FigureCanvas and GUI frame.\n\nIt is instantiated by Gcf whenever a new figure is created.  Gcf is\nresponsible for managing multiple instances of FigureManagerWx.",
      "docstring": "",
      "code": "    def __init__(self, canvas, num, frame):\n        _log.debug(\"%s - __init__()\", type(self))\n        FigureManagerBase.__init__(self, canvas, num)\n        self.frame = frame\n        self.window = frame"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy",
      "name": "destroy",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/destroy/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.destroy.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def destroy(self, *args):\n        # docstring inherited\n        _log.debug(\"%s - destroy()\", type(self))\n        frame = self.frame\n        if frame:  # Else, may have been already deleted, e.g. when closing.\n            frame.Close()\n        wxapp = wx.GetApp()\n        if wxapp:\n            wxapp.Yield()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title",
      "name": "get_window_title",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.get_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/get_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.get_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_window_title(self):\n        # docstring inherited\n        return self.window.GetTitle()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize",
      "name": "resize",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/width",
          "name": "width",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.width",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/resize/height",
          "name": "height",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.resize.height",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def resize(self, width, height):\n        # docstring inherited\n        self.canvas.SetInitialSize(\n            wx.Size(math.ceil(width), math.ceil(height)))\n        self.window.GetSizer().Fit(self.window)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title",
      "name": "set_window_title",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/set_window_title/title",
          "name": "title",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.set_window_title.title",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_window_title(self, title):\n        # docstring inherited\n        self.window.SetTitle(title)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show",
      "name": "show",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.show",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/show/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.show.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def show(self):\n        # docstring inherited\n        self.frame.Show()\n        self.canvas.draw()\n        if mpl.rcParams['figure.raise_window']:\n            self.frame.Raise()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@getter",
      "name": "toolbar",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.toolbar",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.toolbar.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def toolbar(self):\n        return self.frame.GetToolBar()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@setter",
      "name": "toolbar",
      "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.toolbar",
      "decorators": [
        "toolbar.setter"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@setter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.toolbar.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/FigureManagerWx/toolbar@setter/value",
          "name": "value",
          "qname": "lib.matplotlib.backends.backend_wx.FigureManagerWx.toolbar.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @toolbar.setter\n    def toolbar(self, value):\n        # Never allow this, except that base class inits this to None before\n        # the frame is set up.\n        if value is not None or hasattr(self, \"frame\"):\n            raise AttributeError(\"can't set attribute\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/bitmap",
          "name": "bitmap",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.bitmap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/__init__/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.__init__.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The graphics context provides the color, line styles, etc...\n\nThis class stores a reference to a wxMemoryDC, and a\nwxGraphicsContext that draws to it.  Creating a wxGraphicsContext\nseems to be fairly heavy, so these objects are cached based on the\nbitmap object that is passed in.\n\nThe base GraphicsContext stores colors as a RGB tuple on the unit\ninterval, e.g., (0.5, 0.0, 1.0).  wxPython uses an int interval, but\nsince wxPython colour management is rather simple, I have not chosen\nto implement a separate colour manager class.",
      "docstring": "",
      "code": "    def __init__(self, bitmap, renderer):\n        GraphicsContextBase.__init__(self)\n        # assert self.Ok(), \"wxMemoryDC not OK to use\"\n        _log.debug(\"%s - __init__(): %s\", type(self), bitmap)\n\n        dc, gfx_ctx = self._cache.get(bitmap, (None, None))\n        if dc is None:\n            dc = wx.MemoryDC()\n            dc.SelectObject(bitmap)\n            gfx_ctx = wx.GraphicsContext.Create(dc)\n            gfx_ctx._lastcliprect = None\n            self._cache[bitmap] = dc, gfx_ctx\n\n        self.bitmap = bitmap\n        self.dc = dc\n        self.gfx_ctx = gfx_ctx\n        self._pen = wx.Pen('BLACK', 1, wx.SOLID)\n        gfx_ctx.SetPen(self._pen)\n        self.renderer = renderer"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour",
      "name": "get_wxcolour",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/get_wxcolour/color",
          "name": "color",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.get_wxcolour.color",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a RGB(A) color to a wx.Colour.",
      "docstring": "Convert a RGB(A) color to a wx.Colour.",
      "code": "    def get_wxcolour(self, color):\n        \"\"\"Convert a RGB(A) color to a wx.Colour.\"\"\"\n        _log.debug(\"%s - get_wx_color()\", type(self))\n        if len(color) == 3:\n            r, g, b = color\n            r *= 255\n            g *= 255\n            b *= 255\n            return wx.Colour(red=int(r), green=int(g), blue=int(b))\n        else:\n            r, g, b, a = color\n            r *= 255\n            g *= 255\n            b *= 255\n            a *= 255\n            return wx.Colour(\n                red=int(r),\n                green=int(g),\n                blue=int(b),\n                alpha=int(a))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select",
      "name": "select",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.select",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/select/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.select.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select the current bitmap into this wxDC instance.",
      "docstring": "Select the current bitmap into this wxDC instance.",
      "code": "    def select(self):\n        \"\"\"Select the current bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(self.bitmap)\n            self.IsSelected = True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle",
      "name": "set_capstyle",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_capstyle/cs",
          "name": "cs",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_capstyle.cs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_capstyle(self, cs):\n        # docstring inherited\n        _log.debug(\"%s - set_capstyle()\", type(self))\n        self.select()\n        GraphicsContextBase.set_capstyle(self, cs)\n        self._pen.SetCap(GraphicsContextWx._capd[self._capstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground",
      "name": "set_foreground",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/fg",
          "name": "fg",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.fg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_foreground/isRGBA",
          "name": "isRGBA",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_foreground.isRGBA",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_foreground(self, fg, isRGBA=None):\n        # docstring inherited\n        # Implementation note: wxPython has a separate concept of pen and\n        # brush - the brush fills any outline trace left by the pen.\n        # Here we set both to the same colour - if a figure is not to be\n        # filled, the renderer will set the brush to be transparent\n        # Same goes for text foreground...\n        _log.debug(\"%s - set_foreground()\", type(self))\n        self.select()\n        GraphicsContextBase.set_foreground(self, fg, isRGBA)\n\n        self._pen.SetColour(self.get_wxcolour(self.get_rgb()))\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle",
      "name": "set_joinstyle",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_joinstyle/js",
          "name": "js",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_joinstyle.js",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_joinstyle(self, js):\n        # docstring inherited\n        _log.debug(\"%s - set_joinstyle()\", type(self))\n        self.select()\n        GraphicsContextBase.set_joinstyle(self, js)\n        self._pen.SetJoin(GraphicsContextWx._joind[self._joinstyle])\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth",
      "name": "set_linewidth",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/set_linewidth/w",
          "name": "w",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.set_linewidth.w",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_linewidth(self, w):\n        # docstring inherited\n        w = float(w)\n        _log.debug(\"%s - set_linewidth()\", type(self))\n        self.select()\n        if 0 < w < 1:\n            w = 1\n        GraphicsContextBase.set_linewidth(self, w)\n        lw = int(self.renderer.points_to_pixels(self._linewidth))\n        if lw == 0:\n            lw = 1\n        self._pen.SetWidth(lw)\n        self.gfx_ctx.SetPen(self._pen)\n        self.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect",
      "name": "unselect",
      "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.unselect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/GraphicsContextWx/unselect/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.GraphicsContextWx.unselect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Select a Null bitmap into this wxDC instance.",
      "docstring": "Select a Null bitmap into this wxDC instance.",
      "code": "    def unselect(self):\n        \"\"\"Select a Null bitmap into this wxDC instance.\"\"\"\n        if sys.platform == 'win32':\n            self.dc.SelectObject(wx.NullBitmap)\n            self.IsSelected = False"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/HelpWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.HelpWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        _HelpDialog.show(self.figure.canvas.GetTopLevelParent(),\n                         self._get_help_entries())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/canvas",
          "name": "canvas",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.canvas",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/__init__/coordinates",
          "name": "coordinates",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.__init__.coordinates",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, canvas, coordinates=True):\n        wx.ToolBar.__init__(self, canvas.GetParent(), -1)\n\n        if 'wxMac' in wx.PlatformInfo:\n            self.SetToolBitmapSize((24, 24))\n        self.wx_ids = {}\n        for text, tooltip_text, image_file, callback in self.toolitems:\n            if text is None:\n                self.AddSeparator()\n                continue\n            self.wx_ids[text] = (\n                self.AddTool(\n                    -1,\n                    bitmap=self._icon(f\"{image_file}.png\"),\n                    bmpDisabled=wx.NullBitmap,\n                    label=text, shortHelp=tooltip_text,\n                    kind=(wx.ITEM_CHECK if text in [\"Pan\", \"Zoom\"]\n                          else wx.ITEM_NORMAL))\n                .Id)\n            self.Bind(wx.EVT_TOOL, getattr(self, callback),\n                      id=self.wx_ids[text])\n\n        self._coordinates = coordinates\n        if self._coordinates:\n            self.AddStretchableSpace()\n            self._label_text = wx.StaticText(self)\n            self.AddControl(self._label_text)\n\n        self.Realize()\n\n        NavigationToolbar2.__init__(self, canvas)\n        self._idle = True\n        self._prevZoomRect = None\n        # for now, use alternate zoom-rectangle drawing on all\n        # Macs. N.B. In future versions of wx it may be possible to\n        # detect Retina displays with window.GetContentScaleFactor()\n        # and/or dc.GetContentScaleFactor()\n        self._retinaFix = 'wxMac' in wx.PlatformInfo"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/configure_subplots",
      "name": "configure_subplots",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.configure_subplots",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/configure_subplots/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.configure_subplots.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/configure_subplots/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.configure_subplots.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def configure_subplots(self, *args):\n        global FigureManager  # placates pyflakes: created by @_Backend.export\n        frame = wx.Frame(None, -1, \"Configure subplots\")\n        _set_frame_icon(frame)\n\n        toolfig = Figure((6, 3))\n        canvas = type(self.canvas)(frame, -1, toolfig)\n\n        # Create a figure manager to manage things\n        FigureManager(canvas, 1, frame)\n\n        # Now put all into a sizer\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        # This way of adding to sizer allows resizing\n        sizer.Add(canvas, 1, wx.LEFT | wx.TOP | wx.GROW)\n        frame.SetSizer(sizer)\n        frame.Fit()\n        SubplotTool(self.canvas.figure, toolfig)\n        frame.Show()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_rubberband(self, event, x0, y0, x1, y1):\n        if self._retinaFix:  # On Macs, use the following code\n            # wx.DCOverlay does not work properly on Retina displays.\n            rubberBandColor = '#C0C0FF'\n            if self._prevZoomRect:\n                self._prevZoomRect.pop(0).remove()\n            self.canvas.restore_region(self._savedRetinaImage)\n            X0, X1 = self._zoomStartX, event.xdata\n            Y0, Y1 = self._zoomStartY, event.ydata\n            lineX = (X0, X0, X1, X1, X0)\n            lineY = (Y0, Y1, Y1, Y0, Y0)\n            self._prevZoomRect = self._zoomAxes.plot(\n                lineX, lineY, '-', color=rubberBandColor)\n            self._zoomAxes.draw_artist(self._prevZoomRect[0])\n            self.canvas.blit(self._zoomAxes.bbox)\n            return\n\n        # Use an Overlay to draw a rubberband-like bounding box.\n\n        dc = wx.ClientDC(self.canvas)\n        odc = wx.DCOverlay(self._wxoverlay, dc)\n        odc.Clear()\n\n        # Mac's DC is already the same as a GCDC, and it causes\n        # problems with the overlay if we try to use an actual\n        # wx.GCDC so don't try it.\n        if 'wxMac' not in wx.PlatformInfo:\n            dc = wx.GCDC(dc)\n\n        height = self.canvas.figure.bbox.height\n        y1 = height - y1\n        y0 = height - y0\n\n        if y1 < y0:\n            y0, y1 = y1, y0\n        if x1 < x0:\n            x0, x1 = x1, x0\n\n        w = x1 - x0\n        h = y1 - y0\n        rect = wx.Rect(x0, y0, w, h)\n\n        rubberBandColor = '#C0C0FF'  # or load from config?\n\n        # Set a pen for the border\n        color = wx.Colour(rubberBandColor)\n        dc.SetPen(wx.Pen(color, 1))\n\n        # use the same color, plus alpha for the brush\n        r, g, b, a = color.Get(True)\n        color.Set(r, g, b, 0x60)\n        dc.SetBrush(wx.Brush(color))\n        dc.DrawRectangle(rect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/get_canvas/frame",
          "name": "frame",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.get_canvas.frame",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, frame, fig):\n        return type(self.canvas)(frame, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan",
      "name": "pan",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/pan/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.pan.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def pan(self, *args):\n        self.ToggleTool(self.wx_ids['Zoom'], False)\n        NavigationToolbar2.pan(self, *args)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/press_zoom",
      "name": "press_zoom",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.press_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/press_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.press_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/press_zoom/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.press_zoom.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def press_zoom(self, event):\n        super().press_zoom(event)\n        if self.mode.name == 'ZOOM':\n            if not self._retinaFix:\n                self._wxoverlay = wx.Overlay()\n            else:\n                if event.inaxes is not None:\n                    self._savedRetinaImage = self.canvas.copy_from_bbox(\n                        event.inaxes.bbox)\n                    self._zoomStartX = event.xdata\n                    self._zoomStartY = event.ydata\n                    self._zoomAxes = event.inaxes"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/release_zoom",
      "name": "release_zoom",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.release_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/release_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.release_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/release_zoom/event",
          "name": "event",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.release_zoom.event",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def release_zoom(self, event):\n        super().release_zoom(event)\n        if self.mode.name == 'ZOOM':\n            # When the mouse is released we reset the overlay and it\n            # restores the former content to the window.\n            if not self._retinaFix:\n                self._wxoverlay.Reset()\n                del self._wxoverlay\n            else:\n                del self._savedRetinaImage\n                if self._prevZoomRect:\n                    self._prevZoomRect.pop(0).remove()\n                    self._prevZoomRect = None\n                if self._zoomAxes:\n                    self._zoomAxes = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure",
      "name": "save_figure",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/save_figure/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.save_figure.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def save_figure(self, *args):\n        # Fetch the required filename and file type.\n        filetypes, exts, filter_index = self.canvas._get_imagesave_wildcards()\n        default_file = self.canvas.get_default_filename()\n        dlg = wx.FileDialog(\n            self.canvas.GetParent(), \"Save to file\",\n            mpl.rcParams[\"savefig.directory\"], default_file, filetypes,\n            wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)\n        dlg.SetFilterIndex(filter_index)\n        if dlg.ShowModal() == wx.ID_OK:\n            path = pathlib.Path(dlg.GetPath())\n            _log.debug('%s - Save file path: %s', type(self), path)\n            fmt = exts[dlg.GetFilterIndex()]\n            ext = path.suffix[1:]\n            if ext in self.canvas.get_supported_filetypes() and fmt != ext:\n                # looks like they forgot to set the image type drop\n                # down, going with the extension.\n                _log.warning('extension %s did not match the selected '\n                             'image type %s; going with %s',\n                             ext, fmt, ext)\n                fmt = ext\n            # Save dir for next time, unless empty str (which means use cwd).\n            if mpl.rcParams[\"savefig.directory\"]:\n                mpl.rcParams[\"savefig.directory\"] = str(path.parent)\n            try:\n                self.canvas.figure.savefig(str(path), format=fmt)\n            except Exception as e:\n                error_msg_wx(str(e))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        cursor = wx.Cursor(cursord[cursor])\n        self.canvas.SetCursor(cursor)\n        self.canvas.Update()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons",
      "name": "set_history_buttons",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_history_buttons",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_history_buttons/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_history_buttons.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_history_buttons(self):\n        can_backward = self._nav_stack._pos > 0\n        can_forward = self._nav_stack._pos < len(self._nav_stack._elements) - 1\n        if 'Back' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Back'], can_backward)\n        if 'Forward' in self.wx_ids:\n            self.EnableTool(self.wx_ids['Forward'], can_forward)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        if self._coordinates:\n            self._label_text.SetLabel(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_status_bar",
      "name": "set_status_bar",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_status_bar",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_status_bar/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_status_bar.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/set_status_bar/statbar",
          "name": "statbar",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.set_status_bar.statbar",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def set_status_bar(self, statbar):\n        self.GetTopLevelParent().SetStatusBar(statbar)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/statbar@getter",
      "name": "statbar",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.statbar",
      "decorators": [
        "cbook.deprecated('3.2', alternative='self.GetTopLevelParent().GetStatusBar()')",
        "property"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/statbar@getter/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.statbar.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\",\n                      alternative=\"self.GetTopLevelParent().GetStatusBar()\")\n    @property\n    def statbar(self):\n        return self.GetTopLevelParent().GetStatusBar()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/NavigationToolbar2Wx/zoom/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.NavigationToolbar2Wx.zoom.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def zoom(self, *args):\n        self.ToggleTool(self.wx_ids['Pan'], False)\n        NavigationToolbar2.zoom(self, *args)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/bitmap",
          "name": "bitmap",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.bitmap",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/__init__/dpi",
          "name": "dpi",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.__init__.dpi",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The renderer handles all the drawing primitives using a graphics\ncontext instance that controls the colors/styles. It acts as the\n'renderer' instance used by many classes in the hierarchy.",
      "docstring": "Initialise a wxWindows renderer instance.",
      "code": "    def __init__(self, bitmap, dpi):\n        \"\"\"Initialise a wxWindows renderer instance.\"\"\"\n        cbook.warn_deprecated(\n            \"2.0\", name=\"wx\", obj_type=\"backend\", removal=\"the future\",\n            alternative=\"wxagg\", addendum=\"See the Matplotlib usage FAQ for \"\n            \"more info on backends.\")\n        RendererBase.__init__(self)\n        _log.debug(\"%s - __init__()\", type(self))\n        self.width = bitmap.GetWidth()\n        self.height = bitmap.GetHeight()\n        self.bitmap = bitmap\n        self.fontd = {}\n        self.dpi = dpi\n        self.gc = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path",
      "name": "convert_path",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/gfx_ctx",
          "name": "gfx_ctx",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.gfx_ctx",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/convert_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.convert_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @staticmethod\n    def convert_path(gfx_ctx, path, transform):\n        wxpath = gfx_ctx.CreatePath()\n        for points, code in path.iter_segments(transform):\n            if code == Path.MOVETO:\n                wxpath.MoveToPoint(*points)\n            elif code == Path.LINETO:\n                wxpath.AddLineToPoint(*points)\n            elif code == Path.CURVE3:\n                wxpath.AddQuadCurveToPoint(*points)\n            elif code == Path.CURVE4:\n                wxpath.AddCurveToPoint(*points)\n            elif code == Path.CLOSEPOLY:\n                wxpath.CloseSubpath()\n        return wxpath"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image",
      "name": "draw_image",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_image/im",
          "name": "im",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_image.im",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_image(self, gc, x, y, im):\n        bbox = gc.get_clip_rectangle()\n        if bbox is not None:\n            l, b, w, h = bbox.bounds\n        else:\n            l = 0\n            b = 0\n            w = self.width\n            h = self.height\n        rows, cols = im.shape[:2]\n        bitmap = wx.Bitmap.FromBufferRGBA(cols, rows, im.tobytes())\n        gc.select()\n        gc.gfx_ctx.DrawBitmap(bitmap, int(l), int(self.height - b),\n                              int(w), int(-h))\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path",
      "name": "draw_path",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/path",
          "name": "path",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/transform",
          "name": "transform",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_path/rgbFace",
          "name": "rgbFace",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_path.rgbFace",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_path(self, gc, path, transform, rgbFace=None):\n        # docstring inherited\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n        transform = transform + \\\n            Affine2D().scale(1.0, -1.0).translate(0.0, self.height)\n        wxpath = self.convert_path(gfx_ctx, path, transform)\n        if rgbFace is not None:\n            gfx_ctx.SetBrush(wx.Brush(gc.get_wxcolour(rgbFace)))\n            gfx_ctx.DrawPath(wxpath)\n        else:\n            gfx_ctx.StrokePath(wxpath)\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text",
      "name": "draw_text",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/x",
          "name": "x",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/y",
          "name": "y",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/angle",
          "name": "angle",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.angle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.ismath",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/draw_text/mtext",
          "name": "mtext",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.draw_text.mtext",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n        _log.debug(\"%s - draw_text()\", type(self))\n        gc.select()\n        self.handle_clip_rectangle(gc)\n        gfx_ctx = gc.gfx_ctx\n\n        font = self.get_wx_font(s, prop)\n        color = gc.get_wxcolour(gc.get_rgb())\n        gfx_ctx.SetFont(font, color)\n\n        w, h, d = self.get_text_width_height_descent(s, prop, ismath)\n        x = int(x)\n        y = int(y - h)\n\n        if angle == 0.0:\n            gfx_ctx.DrawText(s, x, y)\n        else:\n            rads = math.radians(angle)\n            xo = h * math.sin(rads)\n            yo = h * math.cos(rads)\n            gfx_ctx.DrawRotatedText(s, x - xo, y - yo, rads)\n\n        gc.unselect()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy",
      "name": "flipy",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.flipy",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/flipy/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.flipy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def flipy(self):\n        # docstring inherited\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height",
      "name": "get_canvas_width_height",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_canvas_width_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_canvas_width_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_canvas_width_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas_width_height(self):\n        # docstring inherited\n        return self.width, self.height"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_gc",
      "name": "get_gc",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_gc",
      "decorators": [
        "cbook.deprecated('3.3', alternative='.gc')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Fetch the locally cached gc.",
      "docstring": "Fetch the locally cached gc.",
      "code": "    @cbook.deprecated(\"3.3\", alternative=\".gc\")\n    def get_gc(self):\n        \"\"\"\n        Fetch the locally cached gc.\n        \"\"\"\n        # This is a dirty hack to allow anything with access to a renderer to\n        # access the current graphics context\n        assert self.gc is not None, \"gc must be defined\"\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent",
      "name": "get_text_width_height_descent",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_text_width_height_descent/ismath",
          "name": "ismath",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_text_width_height_descent.ismath",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_text_width_height_descent(self, s, prop, ismath):\n        # docstring inherited\n\n        if ismath:\n            s = cbook.strip_math(s)\n\n        if self.gc is None:\n            gc = self.new_gc()\n        else:\n            gc = self.gc\n        gfx_ctx = gc.gfx_ctx\n        font = self.get_wx_font(s, prop)\n        gfx_ctx.SetFont(font, wx.BLACK)\n        w, h, descent, leading = gfx_ctx.GetFullTextExtent(s)\n\n        return w, h, descent"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font",
      "name": "get_wx_font",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/get_wx_font/prop",
          "name": "prop",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.get_wx_font.prop",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a wx font.  Cache font instances for efficiency.",
      "docstring": "Return a wx font.  Cache font instances for efficiency.",
      "code": "    def get_wx_font(self, s, prop):\n        \"\"\"Return a wx font.  Cache font instances for efficiency.\"\"\"\n        _log.debug(\"%s - get_wx_font()\", type(self))\n        key = hash(prop)\n        font = self.fontd.get(key)\n        if font is not None:\n            return font\n        # Font colour is determined by the active wx.Pen\n        # TODO: It may be wise to cache font information\n        self.fontd[key] = font = wx.Font(  # Cache the font and gc.\n            pointSize=self.points_to_pixels(prop.get_size_in_points()),\n            family=self.fontnames.get(prop.get_name(), wx.ROMAN),\n            style=self.fontangles[prop.get_style()],\n            weight=self.fontweights[prop.get_weight()])\n        return font"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle",
      "name": "handle_clip_rectangle",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/handle_clip_rectangle/gc",
          "name": "gc",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.handle_clip_rectangle.gc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def handle_clip_rectangle(self, gc):\n        new_bounds = gc.get_clip_rectangle()\n        if new_bounds is not None:\n            new_bounds = new_bounds.bounds\n        gfx_ctx = gc.gfx_ctx\n        if gfx_ctx._lastcliprect != new_bounds:\n            gfx_ctx._lastcliprect = new_bounds\n            if new_bounds is None:\n                gfx_ctx.ResetClip()\n            else:\n                gfx_ctx.Clip(new_bounds[0],\n                             self.height - new_bounds[1] - new_bounds[3],\n                             new_bounds[2], new_bounds[3])"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc",
      "name": "new_gc",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.new_gc",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/new_gc/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.new_gc.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def new_gc(self):\n        # docstring inherited\n        _log.debug(\"%s - new_gc()\", type(self))\n        self.gc = GraphicsContextWx(self.bitmap, self)\n        self.gc.select()\n        self.gc.unselect()\n        return self.gc"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height",
      "name": "offset_text_height",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.offset_text_height",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/offset_text_height/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.offset_text_height.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def offset_text_height(self):\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels",
      "name": "points_to_pixels",
      "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RendererWx/points_to_pixels/points",
          "name": "points",
          "qname": "lib.matplotlib.backends.backend_wx.RendererWx.points_to_pixels.points",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def points_to_pixels(self, points):\n        # docstring inherited\n        return points * (PIXELS_PER_INCH / 72.0 * self.dpi / 72.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, *args, **kwargs):\n            backend_tools.RubberbandBase.__init__(self, *args, **kwargs)\n            self._rect = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband",
      "name": "draw_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/x0",
          "name": "x0",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.x0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/y0",
          "name": "y0",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.y0",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/x1",
          "name": "x1",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.x1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/draw_rubberband/y1",
          "name": "y1",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.draw_rubberband.y1",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def draw_rubberband(self, x0, y0, x1, y1):\n            dc = wx.ClientDC(self.canvas)\n            # this would be required if the Canvas is a ScrolledWindow,\n            # which is not the case for now\n            # self.PrepareDC(dc)\n\n            # delete old rubberband\n            if self._rect:\n                self.remove_rubberband(dc)\n\n            # draw new rubberband\n            dc.SetPen(wx.Pen(wx.BLACK, 1, wx.SOLID))\n            dc.SetBrush(wx.TRANSPARENT_BRUSH)\n            self._rect = (x0, self.canvas._height-y0, x1-x0, -y1+y0)\n            dc.DrawRectangle(self._rect)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband",
      "name": "remove_rubberband",
      "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/RubberbandWx/remove_rubberband/dc",
          "name": "dc",
          "qname": "lib.matplotlib.backends.backend_wx.RubberbandWx.remove_rubberband.dc",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def remove_rubberband(self, dc=None):\n            if not self._rect:\n                return\n            if self.canvas.bitmap:\n                if dc is None:\n                    dc = wx.ClientDC(self.canvas)\n                dc.DrawBitmap(self.canvas.bitmap, 0, 0)\n                #  for testing the method on Windows, use this code instead:\n                # img = self.canvas.bitmap.ConvertToImage()\n                # bmp = img.ConvertToBitmap()\n                # dc.DrawBitmap(bmp, 0, 0)\n            self._rect = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SaveFigureWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.SaveFigureWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args):\n        NavigationToolbar2Wx.save_figure(\n            self._make_classic_style_pseudo_toolbar())"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor",
      "name": "set_cursor",
      "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/SetCursorWx/set_cursor/cursor",
          "name": "cursor",
          "qname": "lib.matplotlib.backends.backend_wx.SetCursorWx.set_cursor.cursor",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_cursor(self, cursor):\n        NavigationToolbar2Wx.set_cursor(\n            self._make_classic_style_pseudo_toolbar(), cursor)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A status bar is added to _FigureFrame to allow measurements and the\npreviously selected scroll function to be displayed as a user convenience.",
      "docstring": "",
      "code": "    def __init__(self, parent, *args, **kwargs):\n        wx.StatusBar.__init__(self, parent, -1)\n        self.SetFieldsCount(2)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/set_function",
      "name": "set_function",
      "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.set_function",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/set_function/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.set_function.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusBarWx/set_function/string",
          "name": "string",
          "qname": "lib.matplotlib.backends.backend_wx.StatusBarWx.set_function.string",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_function(self, string):\n        self.SetStatusText(\"%s\" % string, 1)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "For use with ToolManager.",
      "docstring": "",
      "code": "    def __init__(self, parent, *args, **kwargs):\n        StatusbarBase.__init__(self, *args, **kwargs)\n        wx.StatusBar.__init__(self, parent, -1)\n        self.SetFieldsCount(1)\n        self.SetStatusText(\"\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/StatusbarWx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.StatusbarWx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self.SetStatusText(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/TimerWx/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.TimerWx.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Subclass of `.TimerBase` using wx.Timer events.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._timer = wx.Timer()\n        self._timer.Notify = self._on_timer\n        TimerBase.__init__(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger",
      "name": "trigger",
      "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/args",
          "name": "args",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolCopyToClipboardWx/trigger/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.backends.backend_wx.ToolCopyToClipboardWx.trigger.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def trigger(self, *args, **kwargs):\n        if not self.canvas._isDrawn:\n            self.canvas.draw()\n        if not self.canvas.bitmap.IsOk() or not wx.TheClipboard.Open():\n            return\n        try:\n            wx.TheClipboard.SetData(wx.BitmapDataObject(self.canvas.bitmap))\n        finally:\n            wx.TheClipboard.Close()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/toolmanager",
          "name": "toolmanager",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.toolmanager",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/__init__/style",
          "name": "style",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.__init__.style",
          "default_value": "wx.TB_HORIZONTAL",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, toolmanager, parent, style=wx.TB_HORIZONTAL):\n        ToolContainerBase.__init__(self, toolmanager)\n        wx.ToolBar.__init__(self, parent, -1, style=style)\n        self._space = self.AddStretchableSpace()\n        self._label_text = wx.StaticText(self)\n        self.AddControl(self._label_text)\n        self._toolitems = {}\n        self._groups = {}  # Mapping of groups to the separator after them."
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem",
      "name": "add_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/group",
          "name": "group",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.group",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/position",
          "name": "position",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.position",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/image_file",
          "name": "image_file",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.image_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/description",
          "name": "description",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.description",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/add_toolitem/toggle",
          "name": "toggle",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.add_toolitem.toggle",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def add_toolitem(self, name, group, position, image_file, description,\n                     toggle):\n        # Find or create the separator that follows this group.\n        if group not in self._groups:\n            self._groups[group] = self.InsertSeparator(\n                self._get_tool_pos(self._space))\n        sep = self._groups[group]\n        # List all separators.\n        seps = [t for t in map(self.GetToolByPos, range(self.ToolsCount))\n                if t.IsSeparator() and not t.IsStretchableSpace()]\n        # Find where to insert the tool.\n        if position >= 0:\n            # Find the start of the group by looking for the separator\n            # preceding this one; then move forward from it.\n            start = (0 if sep == seps[0]\n                     else self._get_tool_pos(seps[seps.index(sep) - 1]) + 1)\n        else:\n            # Move backwards from this separator.\n            start = self._get_tool_pos(sep) + 1\n        idx = start + position\n        if image_file:\n            bmp = NavigationToolbar2Wx._icon(image_file)\n            kind = wx.ITEM_NORMAL if not toggle else wx.ITEM_CHECK\n            tool = self.InsertTool(idx, -1, name, bmp, wx.NullBitmap, kind,\n                                   description or \"\")\n        else:\n            size = (self.GetTextExtent(name)[0] + 10, -1)\n            if toggle:\n                control = wx.ToggleButton(self, -1, name, size=size)\n            else:\n                control = wx.Button(self, -1, name, size=size)\n            tool = self.InsertControl(idx, control, label=name)\n        self.Realize()\n\n        def handler(event):\n            self.trigger_tool(name)\n\n        if image_file:\n            self.Bind(wx.EVT_TOOL, handler, tool)\n        else:\n            control.Bind(wx.EVT_LEFT_DOWN, handler)\n\n        self._toolitems.setdefault(name, [])\n        self._toolitems[name].append((tool, handler))"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem",
      "name": "remove_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/remove_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.remove_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove_toolitem(self, name):\n        for tool, handler in self._toolitems[name]:\n            self.DeleteTool(tool.Id)\n        del self._toolitems[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message",
      "name": "set_message",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/set_message/s",
          "name": "s",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.set_message.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_message(self, s):\n        self._label_text.SetLabel(s)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem",
      "name": "toggle_toolitem",
      "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/name",
          "name": "name",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/ToolbarWx/toggle_toolitem/toggled",
          "name": "toggled",
          "qname": "lib.matplotlib.backends.backend_wx.ToolbarWx.toggle_toolitem.toggled",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def toggle_toolitem(self, name, toggled):\n        if name not in self._toolitems:\n            return\n        for tool, handler in self._toolitems[name]:\n            if not tool.IsControl():\n                self.ToggleTool(tool.Id, toggled)\n            else:\n                tool.GetControl().SetValue(toggled)\n        self.Refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx",
      "name": "error_msg_wx",
      "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx/msg",
          "name": "msg",
          "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx.msg",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wx/error_msg_wx/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wx.error_msg_wx.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Signal an error condition with a popup error dialog.",
      "docstring": "Signal an error condition with a popup error dialog.",
      "code": "def error_msg_wx(msg, parent=None):\n    \"\"\"Signal an error condition with a popup error dialog.\"\"\"\n    dialog = wx.MessageDialog(parent=parent,\n                              message=msg,\n                              caption='Matplotlib backend_wx error',\n                              style=wx.OK | wx.CENTRE)\n    dialog.ShowModal()\n    dialog.Destroy()\n    return None"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit",
      "name": "blit",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/blit/bbox",
          "name": "bbox",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.blit.bbox",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def blit(self, bbox=None):\n        # docstring inherited\n        if bbox is None:\n            self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n            self.gui_repaint()\n            return\n\n        srcBmp = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n        srcDC = wx.MemoryDC()\n        srcDC.SelectObject(srcBmp)\n\n        destDC = wx.MemoryDC()\n        destDC.SelectObject(self.bitmap)\n\n        x = int(bbox.x0)\n        y = int(self.bitmap.GetHeight() - bbox.y1)\n        destDC.Blit(x, y, int(bbox.width), int(bbox.height), srcDC, x, y)\n\n        destDC.SelectObject(wx.NullBitmap)\n        srcDC.SelectObject(wx.NullBitmap)\n        self.gui_repaint()"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureCanvasWxAgg/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureCanvasWxAgg.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Render the figure using agg.",
      "docstring": "Render the figure using agg.",
      "code": "    def draw(self, drawDC=None):\n        \"\"\"\n        Render the figure using agg.\n        \"\"\"\n        FigureCanvasAgg.draw(self)\n\n        self.bitmap = _convert_agg_to_wx_bitmap(self.get_renderer(), None)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC, origin='WXAgg')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxagg/FigureFrameWxAgg/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wxagg.FigureFrameWxAgg.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWxAgg(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/__init__/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.__init__.parent",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/__init__/id",
          "name": "id",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.__init__.id",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/__init__/figure",
          "name": "figure",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.__init__.figure",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The FigureCanvas contains the figure and does event handling.\n\nIn the wxPython backend, it is derived from wxPanel, and (usually) lives\ninside a frame instantiated by a FigureManagerWx. The parent window\nprobably implements a wxSizer to control the displayed control size - but\nwe give a hint as to our preferred minimum size.",
      "docstring": "",
      "code": "    def __init__(self, parent, id, figure):\n        # _FigureCanvasWxBase should be fixed to have the same signature as\n        # every other FigureCanvas and use cooperative inheritance, but in the\n        # meantime the following will make do.\n        _FigureCanvasWxBase.__init__(self, parent, id, figure)\n        FigureCanvasCairo.__init__(self, figure)\n        self._renderer = RendererCairo(self.figure.dpi)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw",
      "name": "draw",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureCanvasWxCairo/draw/drawDC",
          "name": "drawDC",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureCanvasWxCairo.draw.drawDC",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def draw(self, drawDC=None):\n        width = int(self.figure.bbox.width)\n        height = int(self.figure.bbox.height)\n        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        self._renderer.set_ctx_from_surface(surface)\n        self._renderer.set_width_height(width, height)\n        self.figure.draw(self._renderer)\n        self.bitmap = wxcairo.BitmapFromImageSurface(surface)\n        self._isDrawn = True\n        self.gui_repaint(drawDC=drawDC, origin='WXCairo')"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas",
      "name": "get_canvas",
      "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas/self",
          "name": "self",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.backend_wxcairo/FigureFrameWxCairo/get_canvas/fig",
          "name": "fig",
          "qname": "lib.matplotlib.backends.backend_wxcairo.FigureFrameWxCairo.get_canvas.fig",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_canvas(self, fig):\n        return FigureCanvasWxCairo(self, -1, fig)"
    },
    {
      "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit",
      "name": "figure_edit",
      "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit/axes",
          "name": "axes",
          "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.backends.qt_editor.figureoptions/figure_edit/parent",
          "name": "parent",
          "qname": "lib.matplotlib.backends.qt_editor.figureoptions.figure_edit.parent",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Edit matplotlib figure options",
      "docstring": "Edit matplotlib figure options",
      "code": "def figure_edit(axes, parent=None):\n    \"\"\"Edit matplotlib figure options\"\"\"\n    sep = (None, None)  # separator\n\n    # Get / General\n    # Cast to builtin floats as they have nicer reprs.\n    xmin, xmax = map(float, axes.get_xlim())\n    ymin, ymax = map(float, axes.get_ylim())\n    general = [('Title', axes.get_title()),\n               sep,\n               (None, \"<b>X-Axis</b>\"),\n               ('Left', xmin), ('Right', xmax),\n               ('Label', axes.get_xlabel()),\n               ('Scale', [axes.get_xscale(), 'linear', 'log', 'logit']),\n               sep,\n               (None, \"<b>Y-Axis</b>\"),\n               ('Bottom', ymin), ('Top', ymax),\n               ('Label', axes.get_ylabel()),\n               ('Scale', [axes.get_yscale(), 'linear', 'log', 'logit']),\n               sep,\n               ('(Re-)Generate automatic legend', False),\n               ]\n\n    # Save the unit data\n    xconverter = axes.xaxis.converter\n    yconverter = axes.yaxis.converter\n    xunits = axes.xaxis.get_units()\n    yunits = axes.yaxis.get_units()\n\n    # Sorting for default labels (_lineXXX, _imageXXX).\n    def cmp_key(label):\n        match = re.match(r\"(_line|_image)(\\d+)\", label)\n        if match:\n            return match.group(1), int(match.group(2))\n        else:\n            return label, 0\n\n    # Get / Curves\n    linedict = {}\n    for line in axes.get_lines():\n        label = line.get_label()\n        if label == '_nolegend_':\n            continue\n        linedict[label] = line\n    curves = []\n\n    def prepare_data(d, init):\n        \"\"\"\n        Prepare entry for FormLayout.\n\n        *d* is a mapping of shorthands to style names (a single style may\n        have multiple shorthands, in particular the shorthands `None`,\n        `\"None\"`, `\"none\"` and `\"\"` are synonyms); *init* is one shorthand\n        of the initial style.\n\n        This function returns an list suitable for initializing a\n        FormLayout combobox, namely `[initial_name, (shorthand,\n        style_name), (shorthand, style_name), ...]`.\n        \"\"\"\n        if init not in d:\n            d = {**d, init: str(init)}\n        # Drop duplicate shorthands from dict (by overwriting them during\n        # the dict comprehension).\n        name2short = {name: short for short, name in d.items()}\n        # Convert back to {shorthand: name}.\n        short2name = {short: name for name, short in name2short.items()}\n        # Find the kept shorthand for the style specified by init.\n        canonical_init = name2short[d[init]]\n        # Sort by representation and prepend the initial value.\n        return ([canonical_init] +\n                sorted(short2name.items(),\n                       key=lambda short_and_name: short_and_name[1]))\n\n    curvelabels = sorted(linedict, key=cmp_key)\n    for label in curvelabels:\n        line = linedict[label]\n        color = mcolors.to_hex(\n            mcolors.to_rgba(line.get_color(), line.get_alpha()),\n            keep_alpha=True)\n        ec = mcolors.to_hex(\n            mcolors.to_rgba(line.get_markeredgecolor(), line.get_alpha()),\n            keep_alpha=True)\n        fc = mcolors.to_hex(\n            mcolors.to_rgba(line.get_markerfacecolor(), line.get_alpha()),\n            keep_alpha=True)\n        curvedata = [\n            ('Label', label),\n            sep,\n            (None, '<b>Line</b>'),\n            ('Line style', prepare_data(LINESTYLES, line.get_linestyle())),\n            ('Draw style', prepare_data(DRAWSTYLES, line.get_drawstyle())),\n            ('Width', line.get_linewidth()),\n            ('Color (RGBA)', color),\n            sep,\n            (None, '<b>Marker</b>'),\n            ('Style', prepare_data(MARKERS, line.get_marker())),\n            ('Size', line.get_markersize()),\n            ('Face color (RGBA)', fc),\n            ('Edge color (RGBA)', ec)]\n        curves.append([curvedata, label, \"\"])\n    # Is there a curve displayed?\n    has_curve = bool(curves)\n\n    # Get ScalarMappables.\n    mappabledict = {}\n    for mappable in [*axes.images, *axes.collections]:\n        label = mappable.get_label()\n        if label == '_nolegend_' or mappable.get_array() is None:\n            continue\n        mappabledict[label] = mappable\n    mappablelabels = sorted(mappabledict, key=cmp_key)\n    mappables = []\n    cmaps = [(cmap, name) for name, cmap in sorted(cm._cmap_registry.items())]\n    for label in mappablelabels:\n        mappable = mappabledict[label]\n        cmap = mappable.get_cmap()\n        if cmap not in cm._cmap_registry.values():\n            cmaps = [(cmap, cmap.name), *cmaps]\n        low, high = mappable.get_clim()\n        mappabledata = [\n            ('Label', label),\n            ('Colormap', [cmap.name] + cmaps),\n            ('Min. value', low),\n            ('Max. value', high),\n        ]\n        if hasattr(mappable, \"get_interpolation\"):  # Images.\n            interpolations = [\n                (name, name) for name in sorted(mimage.interpolations_names)]\n            mappabledata.append((\n                'Interpolation',\n                [mappable.get_interpolation(), *interpolations]))\n        mappables.append([mappabledata, label, \"\"])\n    # Is there a scalarmappable displayed?\n    has_sm = bool(mappables)\n\n    datalist = [(general, \"Axes\", \"\")]\n    if curves:\n        datalist.append((curves, \"Curves\", \"\"))\n    if mappables:\n        datalist.append((mappables, \"Images, etc.\", \"\"))\n\n    def apply_callback(data):\n        \"\"\"A callback to apply changes.\"\"\"\n        orig_xlim = axes.get_xlim()\n        orig_ylim = axes.get_ylim()\n\n        general = data.pop(0)\n        curves = data.pop(0) if has_curve else []\n        mappables = data.pop(0) if has_sm else []\n        if data:\n            raise ValueError(\"Unexpected field\")\n\n        # Set / General\n        (title, xmin, xmax, xlabel, xscale, ymin, ymax, ylabel, yscale,\n         generate_legend) = general\n\n        if axes.get_xscale() != xscale:\n            axes.set_xscale(xscale)\n        if axes.get_yscale() != yscale:\n            axes.set_yscale(yscale)\n\n        axes.set_title(title)\n        axes.set_xlim(xmin, xmax)\n        axes.set_xlabel(xlabel)\n        axes.set_ylim(ymin, ymax)\n        axes.set_ylabel(ylabel)\n\n        # Restore the unit data\n        axes.xaxis.converter = xconverter\n        axes.yaxis.converter = yconverter\n        axes.xaxis.set_units(xunits)\n        axes.yaxis.set_units(yunits)\n        axes.xaxis._update_axisinfo()\n        axes.yaxis._update_axisinfo()\n\n        # Set / Curves\n        for index, curve in enumerate(curves):\n            line = linedict[curvelabels[index]]\n            (label, linestyle, drawstyle, linewidth, color, marker, markersize,\n             markerfacecolor, markeredgecolor) = curve\n            line.set_label(label)\n            line.set_linestyle(linestyle)\n            line.set_drawstyle(drawstyle)\n            line.set_linewidth(linewidth)\n            rgba = mcolors.to_rgba(color)\n            line.set_alpha(None)\n            line.set_color(rgba)\n            if marker != 'none':\n                line.set_marker(marker)\n                line.set_markersize(markersize)\n                line.set_markerfacecolor(markerfacecolor)\n                line.set_markeredgecolor(markeredgecolor)\n\n        # Set ScalarMappables.\n        for index, mappable_settings in enumerate(mappables):\n            mappable = mappabledict[mappablelabels[index]]\n            if len(mappable_settings) == 5:\n                label, cmap, low, high, interpolation = mappable_settings\n                mappable.set_interpolation(interpolation)\n            elif len(mappable_settings) == 4:\n                label, cmap, low, high = mappable_settings\n            mappable.set_label(label)\n            mappable.set_cmap(cm.get_cmap(cmap))\n            mappable.set_clim(*sorted([low, high]))\n\n        # re-generate legend, if checkbox is checked\n        if generate_legend:\n            draggable = None\n            ncol = 1\n            if axes.legend_ is not None:\n                old_legend = axes.get_legend()\n                draggable = old_legend._draggable is not None\n                ncol = old_legend._ncol\n            new_legend = axes.legend(ncol=ncol)\n            if new_legend:\n                new_legend.set_draggable(draggable)\n\n        # Redraw\n        figure = axes.get_figure()\n        figure.canvas.draw()\n        if not (axes.get_xlim() == orig_xlim and axes.get_ylim() == orig_ylim):\n            figure.canvas.toolbar.push_current()\n\n    data = _formlayout.fedit(\n        datalist, title=\"Figure options\", parent=parent,\n        icon=QtGui.QIcon(\n            str(cbook._get_data_path('images', 'qt4_editor_options.svg'))),\n        apply=apply_callback)\n    if data is not None:\n        apply_callback(data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated",
      "name": "deprecated",
      "qname": "lib.matplotlib.cbook.deprecation.deprecated",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/since",
          "name": "since",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.since",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The release at which this API became deprecated."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/message",
          "name": "message",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.message",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Override the default deprecation message.  The ``%(since)s``,\n``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\nand ``%(removal)s`` format specifiers will be replaced by the values\nof the respective arguments passed to this function."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/name",
          "name": "name",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.name",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name used in the deprecation message; if not provided, the name\nis automatically determined from the deprecated object."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/alternative",
          "name": "alternative",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.alternative",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "An alternative API that the user may use in place of the deprecated\nAPI.  The deprecation warning will tell the user about this alternative\nif provided."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/pending",
          "name": "pending",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.pending",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, uses a PendingDeprecationWarning instead of a\nDeprecationWarning.  Cannot be used together with *removal*."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/obj_type",
          "name": "obj_type",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.obj_type",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The object type being deprecated; by default, 'class' if decorating\na class, 'attribute' if decorating a property, 'function' otherwise."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/addendum",
          "name": "addendum",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.addendum",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Additional text appended directly to the final message."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/deprecated/removal",
          "name": "removal",
          "qname": "lib.matplotlib.cbook.deprecation.deprecated.removal",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The expected removal version.  With the default (an empty string), a\nremoval version is automatically computed from *since*.  Set to other\nFalsy values to not schedule a removal date.  Cannot be used together\nwith *pending*."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Decorator to mark a function, a class, or a property as deprecated.\n\nWhen deprecating a classmethod, a staticmethod, or a property, the\n``@deprecated`` decorator should go *under* ``@classmethod`` and\n``@staticmethod`` (i.e., `deprecated` should directly decorate the\nunderlying callable), but *over* ``@property``.",
      "docstring": "Decorator to mark a function, a class, or a property as deprecated.\n\nWhen deprecating a classmethod, a staticmethod, or a property, the\n``@deprecated`` decorator should go *under* ``@classmethod`` and\n``@staticmethod`` (i.e., `deprecated` should directly decorate the\nunderlying callable), but *over* ``@property``.\n\nParameters\n----------\nsince : str\n    The release at which this API became deprecated.\n\nmessage : str, optional\n    Override the default deprecation message.  The ``%(since)s``,\n    ``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\n    and ``%(removal)s`` format specifiers will be replaced by the values\n    of the respective arguments passed to this function.\n\nname : str, optional\n    The name used in the deprecation message; if not provided, the name\n    is automatically determined from the deprecated object.\n\nalternative : str, optional\n    An alternative API that the user may use in place of the deprecated\n    API.  The deprecation warning will tell the user about this alternative\n    if provided.\n\npending : bool, optional\n    If True, uses a PendingDeprecationWarning instead of a\n    DeprecationWarning.  Cannot be used together with *removal*.\n\nobj_type : str, optional\n    The object type being deprecated; by default, 'class' if decorating\n    a class, 'attribute' if decorating a property, 'function' otherwise.\n\naddendum : str, optional\n    Additional text appended directly to the final message.\n\nremoval : str, optional\n    The expected removal version.  With the default (an empty string), a\n    removal version is automatically computed from *since*.  Set to other\n    Falsy values to not schedule a removal date.  Cannot be used together\n    with *pending*.\n\nExamples\n--------\nBasic example::\n\n    @deprecated('1.4.0')\n    def the_function_to_deprecate():\n        pass",
      "code": "def deprecated(since, *, message='', name='', alternative='', pending=False,\n               obj_type=None, addendum='', removal=''):\n    \"\"\"\n    Decorator to mark a function, a class, or a property as deprecated.\n\n    When deprecating a classmethod, a staticmethod, or a property, the\n    ``@deprecated`` decorator should go *under* ``@classmethod`` and\n    ``@staticmethod`` (i.e., `deprecated` should directly decorate the\n    underlying callable), but *over* ``@property``.\n\n    Parameters\n    ----------\n    since : str\n        The release at which this API became deprecated.\n\n    message : str, optional\n        Override the default deprecation message.  The ``%(since)s``,\n        ``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\n        and ``%(removal)s`` format specifiers will be replaced by the values\n        of the respective arguments passed to this function.\n\n    name : str, optional\n        The name used in the deprecation message; if not provided, the name\n        is automatically determined from the deprecated object.\n\n    alternative : str, optional\n        An alternative API that the user may use in place of the deprecated\n        API.  The deprecation warning will tell the user about this alternative\n        if provided.\n\n    pending : bool, optional\n        If True, uses a PendingDeprecationWarning instead of a\n        DeprecationWarning.  Cannot be used together with *removal*.\n\n    obj_type : str, optional\n        The object type being deprecated; by default, 'class' if decorating\n        a class, 'attribute' if decorating a property, 'function' otherwise.\n\n    addendum : str, optional\n        Additional text appended directly to the final message.\n\n    removal : str, optional\n        The expected removal version.  With the default (an empty string), a\n        removal version is automatically computed from *since*.  Set to other\n        Falsy values to not schedule a removal date.  Cannot be used together\n        with *pending*.\n\n    Examples\n    --------\n    Basic example::\n\n        @deprecated('1.4.0')\n        def the_function_to_deprecate():\n            pass\n    \"\"\"\n\n    def deprecate(obj, message=message, name=name, alternative=alternative,\n                  pending=pending, obj_type=obj_type, addendum=addendum):\n\n        if isinstance(obj, type):\n            if obj_type is None:\n                obj_type = \"class\"\n            func = obj.__init__\n            name = name or obj.__name__\n            old_doc = obj.__doc__\n\n            def finalize(wrapper, new_doc):\n                try:\n                    obj.__doc__ = new_doc\n                except AttributeError:  # Can't set on some extension objects.\n                    pass\n                obj.__init__ = functools.wraps(obj.__init__)(wrapper)\n                return obj\n\n        elif isinstance(obj, property):\n            obj_type = \"attribute\"\n            func = None\n            name = name or obj.fget.__name__\n            old_doc = obj.__doc__\n\n            class _deprecated_property(property):\n                def __get__(self, instance, owner):\n                    if instance is not None:\n                        from . import _warn_external\n                        _warn_external(warning)\n                    return super().__get__(instance, owner)\n\n                def __set__(self, instance, value):\n                    if instance is not None:\n                        from . import _warn_external\n                        _warn_external(warning)\n                    return super().__set__(instance, value)\n\n                def __delete__(self, instance):\n                    if instance is not None:\n                        from . import _warn_external\n                        _warn_external(warning)\n                    return super().__delete__(instance)\n\n            def finalize(_, new_doc):\n                return _deprecated_property(\n                    fget=obj.fget, fset=obj.fset, fdel=obj.fdel, doc=new_doc)\n\n        else:\n            if obj_type is None:\n                obj_type = \"function\"\n            func = obj\n            name = name or obj.__name__\n            old_doc = func.__doc__\n\n            def finalize(wrapper, new_doc):\n                wrapper = functools.wraps(func)(wrapper)\n                wrapper.__doc__ = new_doc\n                return wrapper\n\n        warning = _generate_deprecation_warning(\n            since, message, name, alternative, pending, obj_type, addendum,\n            removal=removal)\n\n        def wrapper(*args, **kwargs):\n            from . import _warn_external\n            _warn_external(warning)\n            return func(*args, **kwargs)\n\n        old_doc = inspect.cleandoc(old_doc or '').strip('\\n')\n\n        notes_header = '\\nNotes\\n-----'\n        new_doc = (f\"[*Deprecated*] {old_doc}\\n\"\n                   f\"{notes_header if notes_header not in old_doc else ''}\\n\"\n                   f\".. deprecated:: {since}\\n\"\n                   f\"   {message.strip()}\")\n\n        if not old_doc:\n            # This is to prevent a spurious 'unexpected unindent' warning from\n            # docutils when the original docstring was blank.\n            new_doc += r'\\ '\n\n        return finalize(wrapper, new_doc)\n\n    return deprecate"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated",
      "name": "warn_deprecated",
      "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/since",
          "name": "since",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.since",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The release at which this API became deprecated."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/message",
          "name": "message",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.message",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Override the default deprecation message.  The ``%(since)s``,\n``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\nand ``%(removal)s`` format specifiers will be replaced by the values\nof the respective arguments passed to this function."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/name",
          "name": "name",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.name",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the deprecated object."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/alternative",
          "name": "alternative",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.alternative",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "An alternative API that the user may use in place of the deprecated\nAPI.  The deprecation warning will tell the user about this alternative\nif provided."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/pending",
          "name": "pending",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.pending",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, uses a PendingDeprecationWarning instead of a\nDeprecationWarning.  Cannot be used together with *removal*."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/obj_type",
          "name": "obj_type",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.obj_type",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The object type being deprecated."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/addendum",
          "name": "addendum",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.addendum",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Additional text appended directly to the final message."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook.deprecation/warn_deprecated/removal",
          "name": "removal",
          "qname": "lib.matplotlib.cbook.deprecation.warn_deprecated.removal",
          "default_value": "''",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The expected removal version.  With the default (an empty string), a\nremoval version is automatically computed from *since*.  Set to other\nFalsy values to not schedule a removal date.  Cannot be used together\nwith *pending*."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Display a standardized deprecation.",
      "docstring": "Display a standardized deprecation.\n\nParameters\n----------\nsince : str\n    The release at which this API became deprecated.\n\nmessage : str, optional\n    Override the default deprecation message.  The ``%(since)s``,\n    ``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\n    and ``%(removal)s`` format specifiers will be replaced by the values\n    of the respective arguments passed to this function.\n\nname : str, optional\n    The name of the deprecated object.\n\nalternative : str, optional\n    An alternative API that the user may use in place of the deprecated\n    API.  The deprecation warning will tell the user about this alternative\n    if provided.\n\npending : bool, optional\n    If True, uses a PendingDeprecationWarning instead of a\n    DeprecationWarning.  Cannot be used together with *removal*.\n\nobj_type : str, optional\n    The object type being deprecated.\n\naddendum : str, optional\n    Additional text appended directly to the final message.\n\nremoval : str, optional\n    The expected removal version.  With the default (an empty string), a\n    removal version is automatically computed from *since*.  Set to other\n    Falsy values to not schedule a removal date.  Cannot be used together\n    with *pending*.\n\nExamples\n--------\nBasic example::\n\n    # To warn of the deprecation of \"matplotlib.name_of_module\"\n    warn_deprecated('1.4.0', name='matplotlib.name_of_module',\n                    obj_type='module')",
      "code": "def warn_deprecated(\n        since, *, message='', name='', alternative='', pending=False,\n        obj_type='', addendum='', removal=''):\n    \"\"\"\n    Display a standardized deprecation.\n\n    Parameters\n    ----------\n    since : str\n        The release at which this API became deprecated.\n\n    message : str, optional\n        Override the default deprecation message.  The ``%(since)s``,\n        ``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``,\n        and ``%(removal)s`` format specifiers will be replaced by the values\n        of the respective arguments passed to this function.\n\n    name : str, optional\n        The name of the deprecated object.\n\n    alternative : str, optional\n        An alternative API that the user may use in place of the deprecated\n        API.  The deprecation warning will tell the user about this alternative\n        if provided.\n\n    pending : bool, optional\n        If True, uses a PendingDeprecationWarning instead of a\n        DeprecationWarning.  Cannot be used together with *removal*.\n\n    obj_type : str, optional\n        The object type being deprecated.\n\n    addendum : str, optional\n        Additional text appended directly to the final message.\n\n    removal : str, optional\n        The expected removal version.  With the default (an empty string), a\n        removal version is automatically computed from *since*.  Set to other\n        Falsy values to not schedule a removal date.  Cannot be used together\n        with *pending*.\n\n    Examples\n    --------\n    Basic example::\n\n        # To warn of the deprecation of \"matplotlib.name_of_module\"\n        warn_deprecated('1.4.0', name='matplotlib.name_of_module',\n                        obj_type='module')\n    \"\"\"\n    warning = _generate_deprecation_warning(\n        since, message, name, alternative, pending, obj_type, addendum,\n        removal=removal)\n    from . import _warn_external\n    _warn_external(warning, category=MatplotlibDeprecationWarning)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__",
      "name": "__getstate__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__getstate__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__getstate__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__getstate__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getstate__(self):\n        # In general, callbacks may not be pickled, so we just drop them.\n        return {**vars(self), \"callbacks\": {}, \"_func_cid_map\": {}}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/__init__/exception_handler",
          "name": "exception_handler",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.__init__.exception_handler",
          "default_value": "_exception_printer",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "If provided must have signature ::\n\n   def handler(exc: Exception) -> None:\n\nIf not None this function will be called with any `Exception`\nsubclass raised by the callbacks in `CallbackRegistry.process`.\nThe handler may either consume the exception or re-raise.\n\nThe callable must be pickle-able.\n\nThe default handler is ::\n\n   def h(exc):\n       traceback.print_exc()"
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Handle registering and disconnecting for a set of signals and callbacks:\n\n    >>> def oneat(x):\n    ...    print('eat', x)\n    >>> def ondrink(x):\n    ...    print('drink', x)\n\n    >>> from matplotlib.cbook import CallbackRegistry\n    >>> callbacks = CallbackRegistry()\n\n    >>> id_eat = callbacks.connect('eat', oneat)\n    >>> id_drink = callbacks.connect('drink', ondrink)\n\n    >>> callbacks.process('drink', 123)\n    drink 123\n    >>> callbacks.process('eat', 456)\n    eat 456\n    >>> callbacks.process('be merry', 456) # nothing will be called\n    >>> callbacks.disconnect(id_eat)\n    >>> callbacks.process('eat', 456)      # nothing will be called\n\nIn practice, one should always disconnect all callbacks when they are\nno longer needed to avoid dangling references (and thus memory leaks).\nHowever, real code in Matplotlib rarely does so, and due to its design,\nit is rather difficult to place this kind of code.  To get around this,\nand prevent this class of memory leaks, we instead store weak references\nto bound methods only, so when the destination object needs to die, the\nCallbackRegistry won't keep it alive.",
      "docstring": "",
      "code": "    def __init__(self, exception_handler=_exception_printer):\n        self.exception_handler = exception_handler\n        self.callbacks = {}\n        self._cid_gen = itertools.count()\n        self._func_cid_map = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect",
      "name": "connect",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.connect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/connect/func",
          "name": "func",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.connect.func",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Register *func* to be called when signal *s* is generated.",
      "docstring": "Register *func* to be called when signal *s* is generated.",
      "code": "    def connect(self, s, func):\n        \"\"\"Register *func* to be called when signal *s* is generated.\"\"\"\n        self._func_cid_map.setdefault(s, {})\n        try:\n            proxy = weakref.WeakMethod(func, self._remove_proxy)\n        except TypeError:\n            proxy = _StrongRef(func)\n        if proxy in self._func_cid_map[s]:\n            return self._func_cid_map[s][proxy]\n\n        cid = next(self._cid_gen)\n        self._func_cid_map[s][proxy] = cid\n        self.callbacks.setdefault(s, {})\n        self.callbacks[s][cid] = proxy\n        return cid"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect",
      "name": "disconnect",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/disconnect/cid",
          "name": "cid",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.disconnect.cid",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Disconnect the callback registered with callback id *cid*.",
      "docstring": "Disconnect the callback registered with callback id *cid*.",
      "code": "    def disconnect(self, cid):\n        \"\"\"Disconnect the callback registered with callback id *cid*.\"\"\"\n        for eventname, callbackd in list(self.callbacks.items()):\n            try:\n                del callbackd[cid]\n            except KeyError:\n                continue\n            else:\n                for signal, functions in list(self._func_cid_map.items()):\n                    for function, value in list(functions.items()):\n                        if value == cid:\n                            del functions[function]\n                return"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process",
      "name": "process",
      "qname": "lib.matplotlib.cbook.CallbackRegistry.process",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/CallbackRegistry/process/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.cbook.CallbackRegistry.process.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``.",
      "docstring": "Process signal *s*.\n\nAll of the functions registered to receive callbacks on *s* will be\ncalled with ``*args`` and ``**kwargs``.",
      "code": "    def process(self, s, *args, **kwargs):\n        \"\"\"\n        Process signal *s*.\n\n        All of the functions registered to receive callbacks on *s* will be\n        called with ``*args`` and ``**kwargs``.\n        \"\"\"\n        for cid, ref in list(self.callbacks.get(s, {}).items()):\n            func = ref()\n            if func is not None:\n                try:\n                    func(*args, **kwargs)\n                # this does not capture KeyboardInterrupt, SystemExit,\n                # and GeneratorExit\n                except Exception as exc:\n                    if self.exception_handler is not None:\n                        self.exception_handler(exc)\n                    else:\n                        raise"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__",
      "name": "__contains__",
      "qname": "lib.matplotlib.cbook.Grouper.__contains__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__contains__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__contains__/item",
          "name": "item",
          "qname": "lib.matplotlib.cbook.Grouper.__contains__.item",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __contains__(self, item):\n        return weakref.ref(item) in self._mapping"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.Grouper.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__init__/init",
          "name": "init",
          "qname": "lib.matplotlib.cbook.Grouper.__init__.init",
          "default_value": "()",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A disjoint-set data structure.\n\nObjects can be joined using :meth:`join`, tested for connectedness\nusing :meth:`joined`, and all disjoint sets can be retrieved by\nusing the object as an iterator.\n\nThe objects being joined must be hashable and weak-referenceable.",
      "docstring": "",
      "code": "    def __init__(self, init=()):\n        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/__iter__",
      "name": "__iter__",
      "qname": "lib.matplotlib.cbook.Grouper.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/__iter__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Iterate over each of the disjoint sets as a list.\n\nThe iterator is invalid if interleaved with calls to join().",
      "docstring": "Iterate over each of the disjoint sets as a list.\n\nThe iterator is invalid if interleaved with calls to join().",
      "code": "    def __iter__(self):\n        \"\"\"\n        Iterate over each of the disjoint sets as a list.\n\n        The iterator is invalid if interleaved with calls to join().\n        \"\"\"\n        self.clean()\n        unique_groups = {id(group): group for group in self._mapping.values()}\n        for group in unique_groups.values():\n            yield [x() for x in group]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/clean",
      "name": "clean",
      "qname": "lib.matplotlib.cbook.Grouper.clean",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/clean/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.clean.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Clean dead weak references from the dictionary.",
      "docstring": "Clean dead weak references from the dictionary.",
      "code": "    def clean(self):\n        \"\"\"Clean dead weak references from the dictionary.\"\"\"\n        mapping = self._mapping\n        to_drop = [key for key in mapping if key() is None]\n        for key in to_drop:\n            val = mapping.pop(key)\n            val.remove(key)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings",
      "name": "get_siblings",
      "qname": "lib.matplotlib.cbook.Grouper.get_siblings",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.get_siblings.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/get_siblings/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.get_siblings.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return all of the items joined with *a*, including itself.",
      "docstring": "Return all of the items joined with *a*, including itself.",
      "code": "    def get_siblings(self, a):\n        \"\"\"Return all of the items joined with *a*, including itself.\"\"\"\n        self.clean()\n        siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n        return [x() for x in siblings]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/join",
      "name": "join",
      "qname": "lib.matplotlib.cbook.Grouper.join",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.join.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.join.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/join/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.Grouper.join.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Join given arguments into the same set.  Accepts one or more arguments.",
      "docstring": "Join given arguments into the same set.  Accepts one or more arguments.",
      "code": "    def join(self, a, *args):\n        \"\"\"\n        Join given arguments into the same set.  Accepts one or more arguments.\n        \"\"\"\n        mapping = self._mapping\n        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n\n        for arg in args:\n            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n            if set_b is not set_a:\n                if len(set_b) > len(set_a):\n                    set_a, set_b = set_b, set_a\n                set_a.extend(set_b)\n                for elem in set_b:\n                    mapping[elem] = set_a\n\n        self.clean()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined",
      "name": "joined",
      "qname": "lib.matplotlib.cbook.Grouper.joined",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.joined.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.joined.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/joined/b",
          "name": "b",
          "qname": "lib.matplotlib.cbook.Grouper.joined.b",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *a* and *b* are members of the same set.",
      "docstring": "Return whether *a* and *b* are members of the same set.",
      "code": "    def joined(self, a, b):\n        \"\"\"Return whether *a* and *b* are members of the same set.\"\"\"\n        self.clean()\n        return (self._mapping.get(weakref.ref(a), object())\n                is self._mapping.get(weakref.ref(b)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove",
      "name": "remove",
      "qname": "lib.matplotlib.cbook.Grouper.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Grouper.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Grouper/remove/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.Grouper.remove.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def remove(self, a):\n        self.clean()\n        set_a = self._mapping.pop(weakref.ref(a), None)\n        if set_a:\n            set_a.remove(weakref.ref(a))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.cbook.Stack.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the current element, or None.",
      "docstring": "Return the current element, or None.",
      "code": "    def __call__(self):\n        \"\"\"Return the current element, or None.\"\"\"\n        if not self._elements:\n            return self._default\n        else:\n            return self._elements[self._pos]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__",
      "name": "__getitem__",
      "qname": "lib.matplotlib.cbook.Stack.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__getitem__/ind",
          "name": "ind",
          "qname": "lib.matplotlib.cbook.Stack.__getitem__.ind",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, ind):\n        return self._elements[ind]"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.Stack.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__init__/default",
          "name": "default",
          "qname": "lib.matplotlib.cbook.Stack.__init__.default",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Stack of elements with a movable cursor.\n\nMimics home/back/forward in a web browser.",
      "docstring": "",
      "code": "    def __init__(self, default=None):\n        self.clear()\n        self._default = default"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/__len__",
      "name": "__len__",
      "qname": "lib.matplotlib.cbook.Stack.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/__len__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self):\n        return len(self._elements)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/back",
      "name": "back",
      "qname": "lib.matplotlib.cbook.Stack.back",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/back/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.back.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move the position back and return the current element.",
      "docstring": "Move the position back and return the current element.",
      "code": "    def back(self):\n        \"\"\"Move the position back and return the current element.\"\"\"\n        if self._pos > 0:\n            self._pos -= 1\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble",
      "name": "bubble",
      "qname": "lib.matplotlib.cbook.Stack.bubble",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.bubble.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/bubble/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.bubble.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Raise all references of *o* to the top of the stack, and return it.",
      "docstring": "Raise all references of *o* to the top of the stack, and return it.\n\nRaises\n------\nValueError\n    If *o* is not in the stack.",
      "code": "    def bubble(self, o):\n        \"\"\"\n        Raise all references of *o* to the top of the stack, and return it.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        top_elements = []\n        for elem in old_elements:\n            if elem == o:\n                top_elements.append(elem)\n            else:\n                self.push(elem)\n        for _ in top_elements:\n            self.push(o)\n        return o"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/clear",
      "name": "clear",
      "qname": "lib.matplotlib.cbook.Stack.clear",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/clear/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.clear.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Empty the stack.",
      "docstring": "Empty the stack.",
      "code": "    def clear(self):\n        \"\"\"Empty the stack.\"\"\"\n        self._pos = -1\n        self._elements = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/empty",
      "name": "empty",
      "qname": "lib.matplotlib.cbook.Stack.empty",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/empty/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.empty.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the stack is empty.",
      "docstring": "Return whether the stack is empty.",
      "code": "    def empty(self):\n        \"\"\"Return whether the stack is empty.\"\"\"\n        return len(self._elements) == 0"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/forward",
      "name": "forward",
      "qname": "lib.matplotlib.cbook.Stack.forward",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/forward/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.forward.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Move the position forward and return the current element.",
      "docstring": "Move the position forward and return the current element.",
      "code": "    def forward(self):\n        \"\"\"Move the position forward and return the current element.\"\"\"\n        self._pos = min(self._pos + 1, len(self._elements) - 1)\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/home",
      "name": "home",
      "qname": "lib.matplotlib.cbook.Stack.home",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/home/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.home.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Push the first element onto the top of the stack.\n\nThe first element is returned.",
      "docstring": "Push the first element onto the top of the stack.\n\nThe first element is returned.",
      "code": "    def home(self):\n        \"\"\"\n        Push the first element onto the top of the stack.\n\n        The first element is returned.\n        \"\"\"\n        if not self._elements:\n            return\n        self.push(self._elements[0])\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/push",
      "name": "push",
      "qname": "lib.matplotlib.cbook.Stack.push",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/push/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.push.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/push/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.push.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Push *o* to the stack at current position.  Discard all later elements.\n\n*o* is returned.",
      "docstring": "Push *o* to the stack at current position.  Discard all later elements.\n\n*o* is returned.",
      "code": "    def push(self, o):\n        \"\"\"\n        Push *o* to the stack at current position.  Discard all later elements.\n\n        *o* is returned.\n        \"\"\"\n        self._elements = self._elements[:self._pos + 1] + [o]\n        self._pos = len(self._elements) - 1\n        return self()"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/Stack/remove",
      "name": "remove",
      "qname": "lib.matplotlib.cbook.Stack.remove",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/remove/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.Stack.remove.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/Stack/remove/o",
          "name": "o",
          "qname": "lib.matplotlib.cbook.Stack.remove.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove *o* from the stack.",
      "docstring": "Remove *o* from the stack.\n\nRaises\n------\nValueError\n    If *o* is not in the stack.",
      "code": "    def remove(self, o):\n        \"\"\"\n        Remove *o* from the stack.\n\n        Raises\n        ------\n        ValueError\n            If *o* is not in the stack.\n        \"\"\"\n        if o not in self._elements:\n            raise ValueError('Given element not contained in the stack')\n        old_elements = self._elements.copy()\n        self.clear()\n        for elem in old_elements:\n            if elem != o:\n                self.push(elem)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats",
      "name": "boxplot_stats",
      "qname": "lib.matplotlib.cbook.boxplot_stats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/X",
          "name": "X",
          "qname": "lib.matplotlib.cbook.boxplot_stats.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Data that will be represented in the boxplots. Should have 2 or\nfewer dimensions."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/whis",
          "name": "whis",
          "qname": "lib.matplotlib.cbook.boxplot_stats.whis",
          "default_value": "1.5",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float or (float, float)",
            "default_value": "1.5",
            "description": "The position of the whiskers.\n\nIf a float, the lower whisker is at the lowest datum above\n``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\nquartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\noriginal definition of boxplots.\n\nIf a pair of floats, they indicate the percentiles at which to draw the\nwhiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\nresults in whiskers covering the whole range of the data.  \"range\" is\na deprecated synonym for (0, 100).\n\nIn the edge case where ``Q1 == Q3``, *whis* is automatically set to\n(0, 100) (cover the whole range of the data) if *autorange* is True.\n\nBeyond the whiskers, data are considered outliers and are plotted as\nindividual points."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "(float, float)"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/bootstrap",
          "name": "bootstrap",
          "qname": "lib.matplotlib.cbook.boxplot_stats.bootstrap",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Number of times the confidence intervals around the median\nshould be bootstrapped (percentile method)."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/labels",
          "name": "labels",
          "qname": "lib.matplotlib.cbook.boxplot_stats.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Labels for each dataset. Length must be compatible with\ndimensions of *X*."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/boxplot_stats/autorange",
          "name": "autorange",
          "qname": "lib.matplotlib.cbook.boxplot_stats.autorange",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "(False)",
            "description": "When `True` and the data are distributed such that the 25th and 75th\npercentiles are equal, ``whis`` is set to (0, 100) such that the\nwhisker ends are at the minimum and maximum of the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.",
      "docstring": "Return a list of dictionaries of statistics used to draw a series of box\nand whisker plots using `~.Axes.bxp`.\n\nParameters\n----------\nX : array-like\n    Data that will be represented in the boxplots. Should have 2 or\n    fewer dimensions.\n\nwhis : float or (float, float), default: 1.5\n    The position of the whiskers.\n\n    If a float, the lower whisker is at the lowest datum above\n    ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n    ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n    quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n    original definition of boxplots.\n\n    If a pair of floats, they indicate the percentiles at which to draw the\n    whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n    results in whiskers covering the whole range of the data.  \"range\" is\n    a deprecated synonym for (0, 100).\n\n    In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n    (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n    Beyond the whiskers, data are considered outliers and are plotted as\n    individual points.\n\nbootstrap : int, optional\n    Number of times the confidence intervals around the median\n    should be bootstrapped (percentile method).\n\nlabels : array-like, optional\n    Labels for each dataset. Length must be compatible with\n    dimensions of *X*.\n\nautorange : bool, optional (False)\n    When `True` and the data are distributed such that the 25th and 75th\n    percentiles are equal, ``whis`` is set to (0, 100) such that the\n    whisker ends are at the minimum and maximum of the data.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column\n    of data. Keys of each dictionary are the following:\n\n    ========   ===================================\n    Key        Value Description\n    ========   ===================================\n    label      tick label for the boxplot\n    mean       arithmetic mean value\n    med        50th percentile\n    q1         first quartile (25th percentile)\n    q3         third quartile (75th percentile)\n    cilo       lower notch around the median\n    cihi       upper notch around the median\n    whislo     end of the lower whisker\n    whishi     end of the upper whisker\n    fliers     outliers\n    ========   ===================================\n\nNotes\n-----\nNon-bootstrapping approach to confidence interval uses Gaussian-based\nasymptotic approximation:\n\n.. math::\n\n    \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\nGeneral approach from:\nMcGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\nBoxplots\", The American Statistician, 32:12-16.",
      "code": "def boxplot_stats(X, whis=1.5, bootstrap=None, labels=None,\n                  autorange=False):\n    r\"\"\"\n    Return a list of dictionaries of statistics used to draw a series of box\n    and whisker plots using `~.Axes.bxp`.\n\n    Parameters\n    ----------\n    X : array-like\n        Data that will be represented in the boxplots. Should have 2 or\n        fewer dimensions.\n\n    whis : float or (float, float), default: 1.5\n        The position of the whiskers.\n\n        If a float, the lower whisker is at the lowest datum above\n        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below\n        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third\n        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's\n        original definition of boxplots.\n\n        If a pair of floats, they indicate the percentiles at which to draw the\n        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100)\n        results in whiskers covering the whole range of the data.  \"range\" is\n        a deprecated synonym for (0, 100).\n\n        In the edge case where ``Q1 == Q3``, *whis* is automatically set to\n        (0, 100) (cover the whole range of the data) if *autorange* is True.\n\n        Beyond the whiskers, data are considered outliers and are plotted as\n        individual points.\n\n    bootstrap : int, optional\n        Number of times the confidence intervals around the median\n        should be bootstrapped (percentile method).\n\n    labels : array-like, optional\n        Labels for each dataset. Length must be compatible with\n        dimensions of *X*.\n\n    autorange : bool, optional (False)\n        When `True` and the data are distributed such that the 25th and 75th\n        percentiles are equal, ``whis`` is set to (0, 100) such that the\n        whisker ends are at the minimum and maximum of the data.\n\n    Returns\n    -------\n    list of dict\n        A list of dictionaries containing the results for each column\n        of data. Keys of each dictionary are the following:\n\n        ========   ===================================\n        Key        Value Description\n        ========   ===================================\n        label      tick label for the boxplot\n        mean       arithmetic mean value\n        med        50th percentile\n        q1         first quartile (25th percentile)\n        q3         third quartile (75th percentile)\n        cilo       lower notch around the median\n        cihi       upper notch around the median\n        whislo     end of the lower whisker\n        whishi     end of the upper whisker\n        fliers     outliers\n        ========   ===================================\n\n    Notes\n    -----\n    Non-bootstrapping approach to confidence interval uses Gaussian-based\n    asymptotic approximation:\n\n    .. math::\n\n        \\mathrm{med} \\pm 1.57 \\times \\frac{\\mathrm{iqr}}{\\sqrt{N}}\n\n    General approach from:\n    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) \"Variations of\n    Boxplots\", The American Statistician, 32:12-16.\n    \"\"\"\n\n    def _bootstrap_median(data, N=5000):\n        # determine 95% confidence intervals of the median\n        M = len(data)\n        percentiles = [2.5, 97.5]\n\n        bs_index = np.random.randint(M, size=(N, M))\n        bsData = data[bs_index]\n        estimate = np.median(bsData, axis=1, overwrite_input=True)\n\n        CI = np.percentile(estimate, percentiles)\n        return CI\n\n    def _compute_conf_interval(data, med, iqr, bootstrap):\n        if bootstrap is not None:\n            # Do a bootstrap estimate of notch locations.\n            # get conf. intervals around median\n            CI = _bootstrap_median(data, N=bootstrap)\n            notch_min = CI[0]\n            notch_max = CI[1]\n        else:\n\n            N = len(data)\n            notch_min = med - 1.57 * iqr / np.sqrt(N)\n            notch_max = med + 1.57 * iqr / np.sqrt(N)\n\n        return notch_min, notch_max\n\n    # output is a list of dicts\n    bxpstats = []\n\n    # convert X to a list of lists\n    X = _reshape_2D(X, \"X\")\n\n    ncols = len(X)\n    if labels is None:\n        labels = itertools.repeat(None)\n    elif len(labels) != ncols:\n        raise ValueError(\"Dimensions of labels and X must be compatible\")\n\n    input_whis = whis\n    for ii, (x, label) in enumerate(zip(X, labels)):\n\n        # empty dict\n        stats = {}\n        if label is not None:\n            stats['label'] = label\n\n        # restore whis to the input values in case it got changed in the loop\n        whis = input_whis\n\n        # note tricksiness, append up here and then mutate below\n        bxpstats.append(stats)\n\n        # if empty, bail\n        if len(x) == 0:\n            stats['fliers'] = np.array([])\n            stats['mean'] = np.nan\n            stats['med'] = np.nan\n            stats['q1'] = np.nan\n            stats['q3'] = np.nan\n            stats['cilo'] = np.nan\n            stats['cihi'] = np.nan\n            stats['whislo'] = np.nan\n            stats['whishi'] = np.nan\n            stats['med'] = np.nan\n            continue\n\n        # up-convert to an array, just to be safe\n        x = np.asarray(x)\n\n        # arithmetic mean\n        stats['mean'] = np.mean(x)\n\n        # medians and quartiles\n        q1, med, q3 = np.percentile(x, [25, 50, 75])\n\n        # interquartile range\n        stats['iqr'] = q3 - q1\n        if stats['iqr'] == 0 and autorange:\n            whis = (0, 100)\n\n        # conf. interval around median\n        stats['cilo'], stats['cihi'] = _compute_conf_interval(\n            x, med, stats['iqr'], bootstrap\n        )\n\n        # lowest/highest non-outliers\n        if np.isscalar(whis):\n            if np.isreal(whis):\n                loval = q1 - whis * stats['iqr']\n                hival = q3 + whis * stats['iqr']\n            elif whis in ['range', 'limit', 'limits', 'min/max']:\n                warn_deprecated(\n                    \"3.2\", message=f\"Setting whis to {whis!r} is deprecated \"\n                    \"since %(since)s and support for it will be removed \"\n                    \"%(removal)s; set it to [0, 100] to achieve the same \"\n                    \"effect.\")\n                loval = np.min(x)\n                hival = np.max(x)\n            else:\n                raise ValueError('whis must be a float or list of percentiles')\n        else:\n            loval, hival = np.percentile(x, whis)\n\n        # get high extreme\n        wiskhi = x[x <= hival]\n        if len(wiskhi) == 0 or np.max(wiskhi) < q3:\n            stats['whishi'] = q3\n        else:\n            stats['whishi'] = np.max(wiskhi)\n\n        # get low extreme\n        wisklo = x[x >= loval]\n        if len(wisklo) == 0 or np.min(wisklo) > q1:\n            stats['whislo'] = q1\n        else:\n            stats['whislo'] = np.min(wisklo)\n\n        # compute a single array of outliers\n        stats['fliers'] = np.hstack([\n            x[x < stats['whislo']],\n            x[x > stats['whishi']],\n        ])\n\n        # add in the remaining stats\n        stats['q1'], stats['med'], stats['q3'] = q1, med, q3\n\n    return bxpstats"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/contiguous_regions",
      "name": "contiguous_regions",
      "qname": "lib.matplotlib.cbook.contiguous_regions",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/contiguous_regions/mask",
          "name": "mask",
          "qname": "lib.matplotlib.cbook.contiguous_regions.mask",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions.",
      "docstring": "Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\nTrue and we cover all such regions.",
      "code": "def contiguous_regions(mask):\n    \"\"\"\n    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is\n    True and we cover all such regions.\n    \"\"\"\n    mask = np.asarray(mask, dtype=bool)\n\n    if not mask.size:\n        return []\n\n    # Find the indices of region changes, and correct offset\n    idx, = np.nonzero(mask[:-1] != mask[1:])\n    idx += 1\n\n    # List operations are faster for moderately sized arrays\n    idx = idx.tolist()\n\n    # Add first and/or last index if needed\n    if mask[0]:\n        idx = [0] + idx\n    if mask[-1]:\n        idx.append(len(mask))\n\n    return list(zip(idx[::2], idx[1::2]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/delete_masked_points",
      "name": "delete_masked_points",
      "qname": "lib.matplotlib.cbook.delete_masked_points",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/delete_masked_points/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.delete_masked_points.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter().",
      "docstring": "Find all masked and/or non-finite points in a set of arguments,\nand return the arguments with only the unmasked points remaining.\n\nArguments can be in any of 5 categories:\n\n1) 1-D masked arrays\n2) 1-D ndarrays\n3) ndarrays with more than one dimension\n4) other non-string iterables\n5) anything else\n\nThe first argument must be in one of the first four categories;\nany argument with a length differing from that of the first\nargument (and hence anything in category 5) then will be\npassed through unchanged.\n\nMasks are obtained from all arguments of the correct length\nin categories 1, 2, and 4; a point is bad if masked in a masked\narray or if it is a nan or inf.  No attempt is made to\nextract a mask from categories 2, 3, and 4 if `numpy.isfinite`\ndoes not yield a Boolean array.\n\nAll input arguments that are not passed unchanged are returned\nas ndarrays after removing the points or rows corresponding to\nmasks in any of the arguments.\n\nA vastly simpler version of this function was originally\nwritten as a helper for Axes.scatter().",
      "code": "def delete_masked_points(*args):\n    \"\"\"\n    Find all masked and/or non-finite points in a set of arguments,\n    and return the arguments with only the unmasked points remaining.\n\n    Arguments can be in any of 5 categories:\n\n    1) 1-D masked arrays\n    2) 1-D ndarrays\n    3) ndarrays with more than one dimension\n    4) other non-string iterables\n    5) anything else\n\n    The first argument must be in one of the first four categories;\n    any argument with a length differing from that of the first\n    argument (and hence anything in category 5) then will be\n    passed through unchanged.\n\n    Masks are obtained from all arguments of the correct length\n    in categories 1, 2, and 4; a point is bad if masked in a masked\n    array or if it is a nan or inf.  No attempt is made to\n    extract a mask from categories 2, 3, and 4 if `numpy.isfinite`\n    does not yield a Boolean array.\n\n    All input arguments that are not passed unchanged are returned\n    as ndarrays after removing the points or rows corresponding to\n    masks in any of the arguments.\n\n    A vastly simpler version of this function was originally\n    written as a helper for Axes.scatter().\n\n    \"\"\"\n    if not len(args):\n        return ()\n    if is_scalar_or_string(args[0]):\n        raise ValueError(\"First argument must be a sequence\")\n    nrecs = len(args[0])\n    margs = []\n    seqlist = [False] * len(args)\n    for i, x in enumerate(args):\n        if not isinstance(x, str) and np.iterable(x) and len(x) == nrecs:\n            seqlist[i] = True\n            if isinstance(x, np.ma.MaskedArray):\n                if x.ndim > 1:\n                    raise ValueError(\"Masked arrays must be 1-D\")\n            else:\n                x = np.asarray(x)\n        margs.append(x)\n    masks = []    # list of masks that are True where good\n    for i, x in enumerate(margs):\n        if seqlist[i]:\n            if x.ndim > 1:\n                continue  # Don't try to get nan locations unless 1-D.\n            if isinstance(x, np.ma.MaskedArray):\n                masks.append(~np.ma.getmaskarray(x))  # invert the mask\n                xd = x.data\n            else:\n                xd = x\n            try:\n                mask = np.isfinite(xd)\n                if isinstance(mask, np.ndarray):\n                    masks.append(mask)\n            except Exception:  # Fixme: put in tuple of possible exceptions?\n                pass\n    if len(masks):\n        mask = np.logical_and.reduce(masks)\n        igood = mask.nonzero()[0]\n        if len(igood) < nrecs:\n            for i, x in enumerate(margs):\n                if seqlist[i]:\n                    margs[i] = x[igood]\n    for i, x in enumerate(margs):\n        if seqlist[i] and isinstance(x, np.ma.MaskedArray):\n            margs[i] = x.filled()\n    return margs"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/file_requires_unicode",
      "name": "file_requires_unicode",
      "qname": "lib.matplotlib.cbook.file_requires_unicode",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/file_requires_unicode/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.file_requires_unicode.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the given writable file-like object requires Unicode to be\nwritten to it.",
      "docstring": "Return whether the given writable file-like object requires Unicode to be\nwritten to it.",
      "code": "def file_requires_unicode(x):\n    \"\"\"\n    Return whether the given writable file-like object requires Unicode to be\n    written to it.\n    \"\"\"\n    try:\n        x.write(b'')\n    except TypeError:\n        return True\n    else:\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/flatten",
      "name": "flatten",
      "qname": "lib.matplotlib.cbook.flatten",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/flatten/seq",
          "name": "seq",
          "qname": "lib.matplotlib.cbook.flatten.seq",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/flatten/scalarp",
          "name": "scalarp",
          "qname": "lib.matplotlib.cbook.flatten.scalarp",
          "default_value": "is_scalar_or_string",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294/\nand Recipe 1.12 in cookbook",
      "docstring": "Return a generator of flattened nested containers.\n\nFor example:\n\n    >>> from matplotlib.cbook import flatten\n    >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n    >>> print(list(flatten(l)))\n    ['John', 'Hunter', 1, 23, 42, 5, 23]\n\nBy: Composite of Holger Krekel and Luther Blissett\nFrom: https://code.activestate.com/recipes/121294/\nand Recipe 1.12 in cookbook",
      "code": "def flatten(seq, scalarp=is_scalar_or_string):\n    \"\"\"\n    Return a generator of flattened nested containers.\n\n    For example:\n\n        >>> from matplotlib.cbook import flatten\n        >>> l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]])\n        >>> print(list(flatten(l)))\n        ['John', 'Hunter', 1, 23, 42, 5, 23]\n\n    By: Composite of Holger Krekel and Luther Blissett\n    From: https://code.activestate.com/recipes/121294/\n    and Recipe 1.12 in cookbook\n    \"\"\"\n    for item in seq:\n        if scalarp(item) or item is None:\n            yield item\n        else:\n            yield from flatten(item, scalarp)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/get_realpath_and_stat",
      "name": "get_realpath_and_stat",
      "qname": "lib.matplotlib.cbook.get_realpath_and_stat",
      "decorators": [
        "deprecated('3.3', alternative='os.path.realpath and os.stat')",
        "functools.lru_cache()"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_realpath_and_stat/path",
          "name": "path",
          "qname": "lib.matplotlib.cbook.get_realpath_and_stat.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "@deprecated(\"3.3\", alternative=\"os.path.realpath and os.stat\")\n@functools.lru_cache()\ndef get_realpath_and_stat(path):\n    realpath = os.path.realpath(path)\n    stat = os.stat(realpath)\n    stat_key = (stat.st_ino, stat.st_dev)\n    return realpath, stat_key"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/get_sample_data",
      "name": "get_sample_data",
      "qname": "lib.matplotlib.cbook.get_sample_data",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/fname",
          "name": "fname",
          "qname": "lib.matplotlib.cbook.get_sample_data.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/asfileobj",
          "name": "asfileobj",
          "qname": "lib.matplotlib.cbook.get_sample_data.asfileobj",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/get_sample_data/np_load",
          "name": "np_load",
          "qname": "lib.matplotlib.cbook.get_sample_data.np_load",
          "default_value": "False",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\nTrue, the file is loaded with `numpy.load`.  *np_load* currently defaults\nto False but will default to True in a future release.",
      "docstring": "Return a sample data file.  *fname* is a path relative to the\n:file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\nreturn a file object, otherwise just a file path.\n\nSample data files are stored in the 'mpl-data/sample_data' directory within\nthe Matplotlib package.\n\nIf the filename ends in .gz, the file is implicitly ungzipped.  If the\nfilename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\nTrue, the file is loaded with `numpy.load`.  *np_load* currently defaults\nto False but will default to True in a future release.",
      "code": "def get_sample_data(fname, asfileobj=True, *, np_load=False):\n    \"\"\"\n    Return a sample data file.  *fname* is a path relative to the\n    :file:`mpl-data/sample_data` directory.  If *asfileobj* is `True`\n    return a file object, otherwise just a file path.\n\n    Sample data files are stored in the 'mpl-data/sample_data' directory within\n    the Matplotlib package.\n\n    If the filename ends in .gz, the file is implicitly ungzipped.  If the\n    filename ends with .npy or .npz, *asfileobj* is True, and *np_load* is\n    True, the file is loaded with `numpy.load`.  *np_load* currently defaults\n    to False but will default to True in a future release.\n    \"\"\"\n    path = _get_data_path('sample_data', fname)\n    if asfileobj:\n        suffix = path.suffix.lower()\n        if suffix == '.gz':\n            return gzip.open(path)\n        elif suffix in ['.npy', '.npz']:\n            if np_load:\n                return np.load(path)\n            else:\n                warn_deprecated(\n                    \"3.3\", message=\"In a future release, get_sample_data \"\n                    \"will automatically load numpy arrays.  Set np_load to \"\n                    \"True to get the array and suppress this warning.  Set \"\n                    \"asfileobj to False to get the path to the data file and \"\n                    \"suppress this warning.\")\n                return path.open('rb')\n        elif suffix in ['.csv', '.xrc', '.txt']:\n            return path.open('r')\n        else:\n            return path.open('rb')\n    else:\n        return str(path)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/index_of",
      "name": "index_of",
      "qname": "lib.matplotlib.cbook.index_of",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/index_of/y",
          "name": "y",
          "qname": "lib.matplotlib.cbook.index_of.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float or array-like",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "float"
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.",
      "docstring": "A helper function to create reasonable x values for the given *y*.\n\nThis is used for plotting (x, y) if x values are not explicitly given.\n\nFirst try ``y.index`` (assuming *y* is a `pandas.Series`), if that\nfails, use ``range(len(y))``.\n\nThis will be extended in the future to deal with more types of\nlabeled data.\n\nParameters\n----------\ny : float or array-like\n\nReturns\n-------\nx, y : ndarray\n   The x and y values to plot.",
      "code": "def index_of(y):\n    \"\"\"\n    A helper function to create reasonable x values for the given *y*.\n\n    This is used for plotting (x, y) if x values are not explicitly given.\n\n    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that\n    fails, use ``range(len(y))``.\n\n    This will be extended in the future to deal with more types of\n    labeled data.\n\n    Parameters\n    ----------\n    y : float or array-like\n\n    Returns\n    -------\n    x, y : ndarray\n       The x and y values to plot.\n    \"\"\"\n    try:\n        return y.index.values, y.values\n    except AttributeError:\n        pass\n    try:\n        y = _check_1d(y)\n    except (np.VisibleDeprecationWarning, ValueError):\n        # NumPy 1.19 will warn on ragged input, and we can't actually use it.\n        pass\n    else:\n        return np.arange(y.shape[0], dtype=float), y\n    raise ValueError('Input could not be cast to an at-least-1D NumPy array')"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_math_text",
      "name": "is_math_text",
      "qname": "lib.matplotlib.cbook.is_math_text",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_math_text/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.is_math_text.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs.",
      "docstring": "Return whether the string *s* contains math expressions.\n\nThis is done by checking whether *s* contains an even number of\nnon-escaped dollar signs.",
      "code": "def is_math_text(s):\n    \"\"\"\n    Return whether the string *s* contains math expressions.\n\n    This is done by checking whether *s* contains an even number of\n    non-escaped dollar signs.\n    \"\"\"\n    s = str(s)\n    dollar_count = s.count(r'$') - s.count(r'\\$')\n    even_dollars = (dollar_count > 0 and dollar_count % 2 == 0)\n    return even_dollars"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_scalar_or_string",
      "name": "is_scalar_or_string",
      "qname": "lib.matplotlib.cbook.is_scalar_or_string",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_scalar_or_string/val",
          "name": "val",
          "qname": "lib.matplotlib.cbook.is_scalar_or_string.val",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether the given object is a scalar or string like.",
      "docstring": "Return whether the given object is a scalar or string like.",
      "code": "def is_scalar_or_string(val):\n    \"\"\"Return whether the given object is a scalar or string like.\"\"\"\n    return isinstance(val, str) or not np.iterable(val)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/is_writable_file_like",
      "name": "is_writable_file_like",
      "qname": "lib.matplotlib.cbook.is_writable_file_like",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/is_writable_file_like/obj",
          "name": "obj",
          "qname": "lib.matplotlib.cbook.is_writable_file_like.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return whether *obj* looks like a file object with a *write* method.",
      "docstring": "Return whether *obj* looks like a file object with a *write* method.",
      "code": "def is_writable_file_like(obj):\n    \"\"\"Return whether *obj* looks like a file object with a *write* method.\"\"\"\n    return callable(getattr(obj, 'write', None))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/local_over_kwdict",
      "name": "local_over_kwdict",
      "qname": "lib.matplotlib.cbook.local_over_kwdict",
      "decorators": [
        "deprecated('3.3', alternative='normalize_kwargs')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/local_over_kwdict/local_var",
          "name": "local_var",
          "qname": "lib.matplotlib.cbook.local_over_kwdict.local_var",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "any object",
            "default_value": "",
            "description": "The local variable (highest priority)."
          },
          "type": {
            "kind": "NamedType",
            "name": "any object"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/local_over_kwdict/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.cbook.local_over_kwdict.kwargs",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "Dictionary of keyword arguments; modified in place."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/local_over_kwdict/keys",
          "name": "keys",
          "qname": "lib.matplotlib.cbook.local_over_kwdict.keys",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Enforces the priority of a local variable over potentially conflicting\nargument(s) from a kwargs dict. The following possible output values are\nconsidered in order of priority::\n\n    local_var > kwargs[keys[0]] > ... > kwargs[keys[-1]]\n\nThe first of these whose value is not None will be returned. If all are\nNone then None will be returned. Each key in keys will be removed from the\nkwargs dict in place.",
      "docstring": "Enforces the priority of a local variable over potentially conflicting\nargument(s) from a kwargs dict. The following possible output values are\nconsidered in order of priority::\n\n    local_var > kwargs[keys[0]] > ... > kwargs[keys[-1]]\n\nThe first of these whose value is not None will be returned. If all are\nNone then None will be returned. Each key in keys will be removed from the\nkwargs dict in place.\n\nParameters\n----------\nlocal_var : any object\n    The local variable (highest priority).\n\nkwargs : dict\n    Dictionary of keyword arguments; modified in place.\n\nkeys : str(s)\n    Name(s) of keyword arguments to process, in descending order of\n    priority.\n\nReturns\n-------\nany object\n    Either local_var or one of kwargs[key] for key in keys.\n\nRaises\n------\nIgnoredKeywordWarning\n    For each key in keys that is removed from kwargs but not used as\n    the output value.",
      "code": "@deprecated(\"3.3\", alternative=\"normalize_kwargs\")\ndef local_over_kwdict(local_var, kwargs, *keys):\n    \"\"\"\n    Enforces the priority of a local variable over potentially conflicting\n    argument(s) from a kwargs dict. The following possible output values are\n    considered in order of priority::\n\n        local_var > kwargs[keys[0]] > ... > kwargs[keys[-1]]\n\n    The first of these whose value is not None will be returned. If all are\n    None then None will be returned. Each key in keys will be removed from the\n    kwargs dict in place.\n\n    Parameters\n    ----------\n    local_var : any object\n        The local variable (highest priority).\n\n    kwargs : dict\n        Dictionary of keyword arguments; modified in place.\n\n    keys : str(s)\n        Name(s) of keyword arguments to process, in descending order of\n        priority.\n\n    Returns\n    -------\n    any object\n        Either local_var or one of kwargs[key] for key in keys.\n\n    Raises\n    ------\n    IgnoredKeywordWarning\n        For each key in keys that is removed from kwargs but not used as\n        the output value.\n    \"\"\"\n    return _local_over_kwdict(local_var, kwargs, *keys, IgnoredKeywordWarning)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.maxdict.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.maxdict.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__init__/maxsize",
          "name": "maxsize",
          "qname": "lib.matplotlib.cbook.maxdict.__init__.maxsize",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A dictionary with a maximum size.",
      "docstring": "",
      "code": "    def __init__(self, maxsize):\n        dict.__init__(self)\n        self.maxsize = maxsize\n        self._killkeys = []"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__",
      "name": "__setitem__",
      "qname": "lib.matplotlib.cbook.maxdict.__setitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/k",
          "name": "k",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.k",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/maxdict/__setitem__/v",
          "name": "v",
          "qname": "lib.matplotlib.cbook.maxdict.__setitem__.v",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __setitem__(self, k, v):\n        if k not in self:\n            if len(self) >= self.maxsize:\n                del self[self._killkeys[0]]\n                del self._killkeys[0]\n            self._killkeys.append(k)\n        dict.__setitem__(self, k, v)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs",
      "name": "normalize_kwargs",
      "qname": "lib.matplotlib.cbook.normalize_kwargs",
      "decorators": [
        "_delete_parameter('3.3', 'required')",
        "_delete_parameter('3.3', 'forbidden')",
        "_delete_parameter('3.3', 'allowed')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/kw",
          "name": "kw",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.kw",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict",
            "default_value": "",
            "description": "A dict of keyword arguments."
          },
          "type": {
            "kind": "NamedType",
            "name": "dict"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/alias_mapping",
          "name": "alias_mapping",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.alias_mapping",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "dict or Artist subclass or Artist instance",
            "default_value": "",
            "description": "A mapping between a canonical name to a list of\naliases, in order of precedence from lowest to highest.\n\nIf the canonical value is not in the list it is assumed to have\nthe highest priority.\n\nIf an Artist subclass or instance is passed, use its properties alias\nmapping."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict"
              },
              {
                "kind": "NamedType",
                "name": "Artist subclass"
              },
              {
                "kind": "NamedType",
                "name": "Artist instance"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/required",
          "name": "required",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.required",
          "default_value": "()",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list of str",
            "default_value": "",
            "description": "A list of keys that must be in *kws*.  This parameter is deprecated."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/forbidden",
          "name": "forbidden",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.forbidden",
          "default_value": "()",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list of str",
            "default_value": "",
            "description": "A list of keys which may not be in *kw*.  This parameter is deprecated."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/normalize_kwargs/allowed",
          "name": "allowed",
          "qname": "lib.matplotlib.cbook.normalize_kwargs.allowed",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "list of str",
            "default_value": "",
            "description": "A list of allowed fields.  If this not None, then raise if\n*kw* contains any keys not in the union of *required*\nand *allowed*.  To allow only the required fields pass in\nan empty tuple ``allowed=()``.  This parameter is deprecated."
          },
          "type": {
            "kind": "NamedType",
            "name": "list of str"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Helper function to normalize kwarg inputs.\n\nThe order they are resolved are:\n\n1. aliasing\n2. required\n3. forbidden\n4. allowed\n\nThis order means that only the canonical names need appear in\n*allowed*, *forbidden*, *required*.",
      "docstring": "Helper function to normalize kwarg inputs.\n\nThe order they are resolved are:\n\n1. aliasing\n2. required\n3. forbidden\n4. allowed\n\nThis order means that only the canonical names need appear in\n*allowed*, *forbidden*, *required*.\n\nParameters\n----------\nkw : dict\n    A dict of keyword arguments.\n\nalias_mapping : dict or Artist subclass or Artist instance, optional\n    A mapping between a canonical name to a list of\n    aliases, in order of precedence from lowest to highest.\n\n    If the canonical value is not in the list it is assumed to have\n    the highest priority.\n\n    If an Artist subclass or instance is passed, use its properties alias\n    mapping.\n\nrequired : list of str, optional\n    A list of keys that must be in *kws*.  This parameter is deprecated.\n\nforbidden : list of str, optional\n    A list of keys which may not be in *kw*.  This parameter is deprecated.\n\nallowed : list of str, optional\n    A list of allowed fields.  If this not None, then raise if\n    *kw* contains any keys not in the union of *required*\n    and *allowed*.  To allow only the required fields pass in\n    an empty tuple ``allowed=()``.  This parameter is deprecated.\n\nRaises\n------\nTypeError\n    To match what python raises if invalid args/kwargs are passed to\n    a callable.",
      "code": "@_delete_parameter(\"3.3\", \"required\")\n@_delete_parameter(\"3.3\", \"forbidden\")\n@_delete_parameter(\"3.3\", \"allowed\")\ndef normalize_kwargs(kw, alias_mapping=None, required=(), forbidden=(),\n                     allowed=None):\n    \"\"\"\n    Helper function to normalize kwarg inputs.\n\n    The order they are resolved are:\n\n    1. aliasing\n    2. required\n    3. forbidden\n    4. allowed\n\n    This order means that only the canonical names need appear in\n    *allowed*, *forbidden*, *required*.\n\n    Parameters\n    ----------\n    kw : dict\n        A dict of keyword arguments.\n\n    alias_mapping : dict or Artist subclass or Artist instance, optional\n        A mapping between a canonical name to a list of\n        aliases, in order of precedence from lowest to highest.\n\n        If the canonical value is not in the list it is assumed to have\n        the highest priority.\n\n        If an Artist subclass or instance is passed, use its properties alias\n        mapping.\n\n    required : list of str, optional\n        A list of keys that must be in *kws*.  This parameter is deprecated.\n\n    forbidden : list of str, optional\n        A list of keys which may not be in *kw*.  This parameter is deprecated.\n\n    allowed : list of str, optional\n        A list of allowed fields.  If this not None, then raise if\n        *kw* contains any keys not in the union of *required*\n        and *allowed*.  To allow only the required fields pass in\n        an empty tuple ``allowed=()``.  This parameter is deprecated.\n\n    Raises\n    ------\n    TypeError\n        To match what python raises if invalid args/kwargs are passed to\n        a callable.\n    \"\"\"\n    from matplotlib.artist import Artist\n\n    # deal with default value of alias_mapping\n    if alias_mapping is None:\n        alias_mapping = dict()\n    elif (isinstance(alias_mapping, type) and issubclass(alias_mapping, Artist)\n          or isinstance(alias_mapping, Artist)):\n        alias_mapping = getattr(alias_mapping, \"_alias_map\", {})\n\n    to_canonical = {alias: canonical\n                    for canonical, alias_list in alias_mapping.items()\n                    for alias in alias_list}\n    canonical_to_seen = {}\n    ret = {}  # output dictionary\n\n    for k, v in kw.items():\n        canonical = to_canonical.get(k, k)\n        if canonical in canonical_to_seen:\n            raise TypeError(f\"Got both {canonical_to_seen[canonical]!r} and \"\n                            f\"{k!r}, which are aliases of one another\")\n        canonical_to_seen[canonical] = k\n        ret[canonical] = v\n\n    fail_keys = [k for k in required if k not in ret]\n    if fail_keys:\n        raise TypeError(\"The required keys {keys!r} \"\n                        \"are not in kwargs\".format(keys=fail_keys))\n\n    fail_keys = [k for k in forbidden if k in ret]\n    if fail_keys:\n        raise TypeError(\"The forbidden keys {keys!r} \"\n                        \"are in kwargs\".format(keys=fail_keys))\n\n    if allowed is not None:\n        allowed_set = {*required, *allowed}\n        fail_keys = [k for k in ret if k not in allowed_set]\n        if fail_keys:\n            raise TypeError(\n                \"kwargs contains {keys!r} which are not in the required \"\n                \"{req!r} or allowed {allow!r} keys\".format(\n                    keys=fail_keys, req=required, allow=allowed))\n\n    return ret"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/open_file_cm",
      "name": "open_file_cm",
      "qname": "lib.matplotlib.cbook.open_file_cm",
      "decorators": [
        "contextlib.contextmanager"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/path_or_file",
          "name": "path_or_file",
          "qname": "lib.matplotlib.cbook.open_file_cm.path_or_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/mode",
          "name": "mode",
          "qname": "lib.matplotlib.cbook.open_file_cm.mode",
          "default_value": "'r'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/open_file_cm/encoding",
          "name": "encoding",
          "qname": "lib.matplotlib.cbook.open_file_cm.encoding",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Pass through file objects and context-manage path-likes.",
      "docstring": "Pass through file objects and context-manage path-likes.",
      "code": "@contextlib.contextmanager\ndef open_file_cm(path_or_file, mode=\"r\", encoding=None):\n    r\"\"\"Pass through file objects and context-manage path-likes.\"\"\"\n    fh, opened = to_filehandle(path_or_file, mode, True, encoding)\n    if opened:\n        with fh:\n            yield fh\n    else:\n        yield fh"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/print_cycles",
      "name": "print_cycles",
      "qname": "lib.matplotlib.cbook.print_cycles",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/objects",
          "name": "objects",
          "qname": "lib.matplotlib.cbook.print_cycles.objects",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "A list of objects to find cycles in."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/outstream",
          "name": "outstream",
          "qname": "lib.matplotlib.cbook.print_cycles.outstream",
          "default_value": "sys.stdout",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The stream for output."
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/print_cycles/show_progress",
          "name": "show_progress",
          "qname": "lib.matplotlib.cbook.print_cycles.show_progress",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "If True, print the number of objects reached as they are found."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.",
      "docstring": "Print loops of cyclic references in the given *objects*.\n\nIt is often useful to pass in ``gc.garbage`` to find the cycles that are\npreventing some objects from being garbage collected.\n\nParameters\n----------\nobjects\n    A list of objects to find cycles in.\noutstream\n    The stream for output.\nshow_progress : bool\n    If True, print the number of objects reached as they are found.",
      "code": "def print_cycles(objects, outstream=sys.stdout, show_progress=False):\n    \"\"\"\n    Print loops of cyclic references in the given *objects*.\n\n    It is often useful to pass in ``gc.garbage`` to find the cycles that are\n    preventing some objects from being garbage collected.\n\n    Parameters\n    ----------\n    objects\n        A list of objects to find cycles in.\n    outstream\n        The stream for output.\n    show_progress : bool\n        If True, print the number of objects reached as they are found.\n    \"\"\"\n    import gc\n\n    def print_path(path):\n        for i, step in enumerate(path):\n            # next \"wraps around\"\n            next = path[(i + 1) % len(path)]\n\n            outstream.write(\"   %s -- \" % type(step))\n            if isinstance(step, dict):\n                for key, val in step.items():\n                    if val is next:\n                        outstream.write(\"[{!r}]\".format(key))\n                        break\n                    if key is next:\n                        outstream.write(\"[key] = {!r}\".format(val))\n                        break\n            elif isinstance(step, list):\n                outstream.write(\"[%d]\" % step.index(next))\n            elif isinstance(step, tuple):\n                outstream.write(\"( tuple )\")\n            else:\n                outstream.write(repr(step))\n            outstream.write(\" ->\\n\")\n        outstream.write(\"\\n\")\n\n    def recurse(obj, start, all, current_path):\n        if show_progress:\n            outstream.write(\"%d\\r\" % len(all))\n\n        all[id(obj)] = None\n\n        referents = gc.get_referents(obj)\n        for referent in referents:\n            # If we've found our way back to the start, this is\n            # a cycle, so print it out\n            if referent is start:\n                print_path(current_path)\n\n            # Don't go back through the original list of objects, or\n            # through temporary references to the object, since those\n            # are just an artifact of the cycle detector itself.\n            elif referent is objects or isinstance(referent, types.FrameType):\n                continue\n\n            # We haven't seen this object before, so recurse\n            elif id(referent) not in all:\n                recurse(referent, start, all, current_path + [obj])\n\n    for obj in objects:\n        outstream.write(f\"Examining: {obj!r}\\n\")\n        recurse(obj, obj, {}, [])"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep",
      "name": "pts_to_midstep",
      "qname": "lib.matplotlib.cbook.pts_to_midstep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_midstep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_midstep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_midstep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.",
      "docstring": "Convert continuous line to mid-steps.\n\nGiven a set of ``N`` points convert to ``2N`` points which when connected\nlinearly give a step function which changes values at the middle of the\nintervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as\n    ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N``.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)",
      "code": "def pts_to_midstep(x, *args):\n    \"\"\"\n    Convert continuous line to mid-steps.\n\n    Given a set of ``N`` points convert to ``2N`` points which when connected\n    linearly give a step function which changes values at the middle of the\n    intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as\n        ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N``.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), 2 * len(x)))\n    x = np.asanyarray(x)\n    steps[0, 1:-1:2] = steps[0, 2::2] = (x[:-1] + x[1:]) / 2\n    steps[0, :1] = x[:1]  # Also works for zero-sized input.\n    steps[0, -1:] = x[-1:]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0::2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep",
      "name": "pts_to_poststep",
      "qname": "lib.matplotlib.cbook.pts_to_poststep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_poststep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_poststep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_poststep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.",
      "docstring": "Convert continuous line to post-steps.\n\nGiven a set of ``N`` points convert to ``2N + 1`` points, which when\nconnected linearly give a step function which changes values at the end of\nthe intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)",
      "code": "def pts_to_poststep(x, *args):\n    \"\"\"\n    Convert continuous line to post-steps.\n\n    Given a set of ``N`` points convert to ``2N + 1`` points, which when\n    connected linearly give a step function which changes values at the end of\n    the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 2::2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 0:-2:2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep",
      "name": "pts_to_prestep",
      "qname": "lib.matplotlib.cbook.pts_to_prestep",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.pts_to_prestep.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array",
            "default_value": "",
            "description": "The x location of the steps. May be empty."
          },
          "type": {
            "kind": "NamedType",
            "name": "array"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/pts_to_prestep/args",
          "name": "args",
          "qname": "lib.matplotlib.cbook.pts_to_prestep.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.",
      "docstring": "Convert continuous line to pre-steps.\n\nGiven a set of ``N`` points, convert to ``2N - 1`` points, which when\nconnected linearly give a step function which changes values at the\nbeginning of the intervals.\n\nParameters\n----------\nx : array\n    The x location of the steps. May be empty.\n\ny1, ..., yp : array\n    y arrays to be turned into steps; all must be the same length as ``x``.\n\nReturns\n-------\narray\n    The x and y values converted to steps in the same order as the input;\n    can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n    length ``N``, each of these arrays will be length ``2N + 1``. For\n    ``N=0``, the length will be 0.\n\nExamples\n--------\n>>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)",
      "code": "def pts_to_prestep(x, *args):\n    \"\"\"\n    Convert continuous line to pre-steps.\n\n    Given a set of ``N`` points, convert to ``2N - 1`` points, which when\n    connected linearly give a step function which changes values at the\n    beginning of the intervals.\n\n    Parameters\n    ----------\n    x : array\n        The x location of the steps. May be empty.\n\n    y1, ..., yp : array\n        y arrays to be turned into steps; all must be the same length as ``x``.\n\n    Returns\n    -------\n    array\n        The x and y values converted to steps in the same order as the input;\n        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is\n        length ``N``, each of these arrays will be length ``2N + 1``. For\n        ``N=0``, the length will be 0.\n\n    Examples\n    --------\n    >>> x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2)\n    \"\"\"\n    steps = np.zeros((1 + len(args), max(2 * len(x) - 1, 0)))\n    # In all `pts_to_*step` functions, only assign once using *x* and *args*,\n    # as converting to an array may be expensive.\n    steps[0, 0::2] = x\n    steps[0, 1::2] = steps[0, 0:-2:2]\n    steps[1:, 0::2] = args\n    steps[1:, 1::2] = steps[1:, 2::2]\n    return steps"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/report_memory",
      "name": "report_memory",
      "qname": "lib.matplotlib.cbook.report_memory",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/report_memory/i",
          "name": "i",
          "qname": "lib.matplotlib.cbook.report_memory.i",
          "default_value": "0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the memory consumed by the process.",
      "docstring": "Return the memory consumed by the process.",
      "code": "def report_memory(i=0):  # argument may go away\n    \"\"\"Return the memory consumed by the process.\"\"\"\n    def call(command, os_name):\n        try:\n            return subprocess.check_output(command)\n        except subprocess.CalledProcessError as err:\n            raise NotImplementedError(\n                \"report_memory works on %s only if \"\n                \"the '%s' program is found\" % (os_name, command[0])\n            ) from err\n\n    pid = os.getpid()\n    if sys.platform == 'sunos5':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'osz'], 'Sun OS')\n        mem = int(lines[-1].strip())\n    elif sys.platform == 'linux':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'rss,sz'], 'Linux')\n        mem = int(lines[1].split()[1])\n    elif sys.platform == 'darwin':\n        lines = call(['ps', '-p', '%d' % pid, '-o', 'rss,vsz'], 'Mac OS')\n        mem = int(lines[1].split()[0])\n    elif sys.platform == 'win32':\n        lines = call([\"tasklist\", \"/nh\", \"/fi\", \"pid eq %d\" % pid], 'Windows')\n        mem = int(lines.strip().split()[-2].replace(',', ''))\n    else:\n        raise NotImplementedError(\n            \"We don't have a memory monitor for %s\" % sys.platform)\n    return mem"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/safe_first_element",
      "name": "safe_first_element",
      "qname": "lib.matplotlib.cbook.safe_first_element",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_first_element/obj",
          "name": "obj",
          "qname": "lib.matplotlib.cbook.safe_first_element.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the first element in *obj*.\n\nThis is an type-independent way of obtaining the first element, supporting\nboth index access and the iterator protocol.",
      "docstring": "Return the first element in *obj*.\n\nThis is an type-independent way of obtaining the first element, supporting\nboth index access and the iterator protocol.",
      "code": "def safe_first_element(obj):\n    \"\"\"\n    Return the first element in *obj*.\n\n    This is an type-independent way of obtaining the first element, supporting\n    both index access and the iterator protocol.\n    \"\"\"\n    if isinstance(obj, collections.abc.Iterator):\n        # needed to accept `array.flat` as input.\n        # np.flatiter reports as an instance of collections.Iterator\n        # but can still be indexed via [].\n        # This has the side effect of re-setting the iterator, but\n        # that is acceptable.\n        try:\n            return obj[0]\n        except TypeError:\n            pass\n        raise RuntimeError(\"matplotlib does not support generators \"\n                           \"as input\")\n    return next(iter(obj))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid",
      "name": "safe_masked_invalid",
      "qname": "lib.matplotlib.cbook.safe_masked_invalid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid/x",
          "name": "x",
          "qname": "lib.matplotlib.cbook.safe_masked_invalid.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/safe_masked_invalid/copy",
          "name": "copy",
          "qname": "lib.matplotlib.cbook.safe_masked_invalid.copy",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def safe_masked_invalid(x, copy=False):\n    x = np.array(x, subok=True, copy=copy)\n    if not x.dtype.isnative:\n        # If we have already made a copy, do the byteswap in place, else make a\n        # copy with the byte order swapped.\n        x = x.byteswap(inplace=copy).newbyteorder('N')  # Swap to native order.\n    try:\n        xm = np.ma.masked_invalid(x, copy=False)\n        xm.shrink_mask()\n    except TypeError:\n        return x\n    return xm"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/sanitize_sequence",
      "name": "sanitize_sequence",
      "qname": "lib.matplotlib.cbook.sanitize_sequence",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/sanitize_sequence/data",
          "name": "data",
          "qname": "lib.matplotlib.cbook.sanitize_sequence.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert dictview objects to list. Other inputs are returned unchanged.",
      "docstring": "Convert dictview objects to list. Other inputs are returned unchanged.",
      "code": "def sanitize_sequence(data):\n    \"\"\"\n    Convert dictview objects to list. Other inputs are returned unchanged.\n    \"\"\"\n    return (list(data) if isinstance(data, collections.abc.MappingView)\n            else data)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.cbook.silent_list.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/type",
          "name": "type",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__init__/seq",
          "name": "seq",
          "qname": "lib.matplotlib.cbook.silent_list.__init__.seq",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A list with a short ``repr()``.\n\nThis is meant to be used for a homogeneous list of artists, so that they\ndon't cause long, meaningless output.\n\nInstead of ::\n\n    [<matplotlib.lines.Line2D object at 0x7f5749fed3c8>,\n     <matplotlib.lines.Line2D object at 0x7f5749fed4e0>,\n     <matplotlib.lines.Line2D object at 0x7f5758016550>]\n\none will get ::\n\n    <a list of 3 Line2D objects>",
      "docstring": "",
      "code": "    def __init__(self, type, seq=None):\n        self.type = type\n        if seq is not None:\n            self.extend(seq)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/silent_list/__repr__",
      "name": "__repr__",
      "qname": "lib.matplotlib.cbook.silent_list.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/silent_list/__repr__/self",
          "name": "self",
          "qname": "lib.matplotlib.cbook.silent_list.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self):\n        return '<a list of %d %s objects>' % (len(self), self.type)"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation",
      "name": "simple_linear_interpolation",
      "qname": "lib.matplotlib.cbook.simple_linear_interpolation",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation/a",
          "name": "a",
          "qname": "lib.matplotlib.cbook.simple_linear_interpolation.a",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array, shape (n, ...)",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "array"
              },
              {
                "kind": "NamedType",
                "name": "shape (n, ...)"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/simple_linear_interpolation/steps",
          "name": "steps",
          "qname": "lib.matplotlib.cbook.simple_linear_interpolation.steps",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.",
      "docstring": "Resample an array with ``steps - 1`` points between original point pairs.\n\nAlong each column of *a*, ``(steps - 1)`` points are introduced between\neach original values; the values are linearly interpolated.\n\nParameters\n----------\na : array, shape (n, ...)\nsteps : int\n\nReturns\n-------\narray\n    shape ``((n - 1) * steps + 1, ...)``",
      "code": "def simple_linear_interpolation(a, steps):\n    \"\"\"\n    Resample an array with ``steps - 1`` points between original point pairs.\n\n    Along each column of *a*, ``(steps - 1)`` points are introduced between\n    each original values; the values are linearly interpolated.\n\n    Parameters\n    ----------\n    a : array, shape (n, ...)\n    steps : int\n\n    Returns\n    -------\n    array\n        shape ``((n - 1) * steps + 1, ...)``\n    \"\"\"\n    fps = a.reshape((len(a), -1))\n    xp = np.arange(len(a)) * steps\n    x = np.arange((len(a) - 1) * steps + 1)\n    return (np.column_stack([np.interp(x, xp, fp) for fp in fps.T])\n            .reshape((len(x),) + a.shape[1:]))"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/strip_math",
      "name": "strip_math",
      "qname": "lib.matplotlib.cbook.strip_math",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/strip_math/s",
          "name": "s",
          "qname": "lib.matplotlib.cbook.strip_math.s",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings.",
      "docstring": "Remove latex formatting from mathtext.\n\nOnly handles fully math and fully non-math strings.",
      "code": "def strip_math(s):\n    \"\"\"\n    Remove latex formatting from mathtext.\n\n    Only handles fully math and fully non-math strings.\n    \"\"\"\n    if len(s) >= 2 and s[0] == s[-1] == \"$\":\n        s = s[1:-1]\n        for tex, plain in [\n                (r\"\\times\", \"x\"),  # Specifically for Formatter support.\n                (r\"\\mathdefault\", \"\"),\n                (r\"\\rm\", \"\"),\n                (r\"\\cal\", \"\"),\n                (r\"\\tt\", \"\"),\n                (r\"\\it\", \"\"),\n                (\"\\\\\", \"\"),\n                (\"{\", \"\"),\n                (\"}\", \"\"),\n        ]:\n            s = s.replace(tex, plain)\n    return s"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/to_filehandle",
      "name": "to_filehandle",
      "qname": "lib.matplotlib.cbook.to_filehandle",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/fname",
          "name": "fname",
          "qname": "lib.matplotlib.cbook.to_filehandle.fname",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or path-like or file-like",
            "default_value": "",
            "description": "If `str` or `os.PathLike`, the file is opened using the flags specified\nby *flag* and *encoding*.  If a file-like object, it is passed through."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "path-like"
              },
              {
                "kind": "NamedType",
                "name": "file-like"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/flag",
          "name": "flag",
          "qname": "lib.matplotlib.cbook.to_filehandle.flag",
          "default_value": "'r'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "'r'",
            "description": "Passed as the *mode* argument to `open` when *fname* is `str` or\n`os.PathLike`; ignored if *fname* is file-like."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/return_opened",
          "name": "return_opened",
          "qname": "lib.matplotlib.cbook.to_filehandle.return_opened",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "False",
            "description": "If True, return both the file object and a boolean indicating whether\nthis was a new file (that the caller needs to close).  If False, return\nonly the new file."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/to_filehandle/encoding",
          "name": "encoding",
          "qname": "lib.matplotlib.cbook.to_filehandle.encoding",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "None",
            "description": "Passed as the *mode* argument to `open` when *fname* is `str` or\n`os.PathLike`; ignored if *fname* is file-like."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.",
      "docstring": "Convert a path to an open file handle or pass-through a file-like object.\n\nConsider using `open_file_cm` instead, as it allows one to properly close\nnewly created file objects more easily.\n\nParameters\n----------\nfname : str or path-like or file-like\n    If `str` or `os.PathLike`, the file is opened using the flags specified\n    by *flag* and *encoding*.  If a file-like object, it is passed through.\nflag : str, default 'r'\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\nreturn_opened : bool, default False\n    If True, return both the file object and a boolean indicating whether\n    this was a new file (that the caller needs to close).  If False, return\n    only the new file.\nencoding : str or None, default None\n    Passed as the *mode* argument to `open` when *fname* is `str` or\n    `os.PathLike`; ignored if *fname* is file-like.\n\nReturns\n-------\nfh : file-like\nopened : bool\n    *opened* is only returned if *return_opened* is True.",
      "code": "def to_filehandle(fname, flag='r', return_opened=False, encoding=None):\n    \"\"\"\n    Convert a path to an open file handle or pass-through a file-like object.\n\n    Consider using `open_file_cm` instead, as it allows one to properly close\n    newly created file objects more easily.\n\n    Parameters\n    ----------\n    fname : str or path-like or file-like\n        If `str` or `os.PathLike`, the file is opened using the flags specified\n        by *flag* and *encoding*.  If a file-like object, it is passed through.\n    flag : str, default 'r'\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n    return_opened : bool, default False\n        If True, return both the file object and a boolean indicating whether\n        this was a new file (that the caller needs to close).  If False, return\n        only the new file.\n    encoding : str or None, default None\n        Passed as the *mode* argument to `open` when *fname* is `str` or\n        `os.PathLike`; ignored if *fname* is file-like.\n\n    Returns\n    -------\n    fh : file-like\n    opened : bool\n        *opened* is only returned if *return_opened* is True.\n    \"\"\"\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if \"U\" in flag:\n        warn_deprecated(\"3.3\", message=\"Passing a flag containing 'U' to \"\n                        \"to_filehandle() is deprecated since %(since)s and \"\n                        \"will be removed %(removal)s.\")\n        flag = flag.replace(\"U\", \"\")\n    if isinstance(fname, str):\n        if fname.endswith('.gz'):\n            fh = gzip.open(fname, flag)\n        elif fname.endswith('.bz2'):\n            # python may not be complied with bz2 support,\n            # bury import until we need it\n            import bz2\n            fh = bz2.BZ2File(fname, flag)\n        else:\n            fh = open(fname, flag, encoding=encoding)\n        opened = True\n    elif hasattr(fname, 'seek'):\n        fh = fname\n        opened = False\n    else:\n        raise ValueError('fname must be a PathLike or file handle')\n    if return_opened:\n        return fh, opened\n    return fh"
    },
    {
      "id": "matplotlib/lib.matplotlib.cbook/violin_stats",
      "name": "violin_stats",
      "qname": "lib.matplotlib.cbook.violin_stats",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/X",
          "name": "X",
          "qname": "lib.matplotlib.cbook.violin_stats.X",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "",
            "description": "Sample data that will be used to produce the gaussian kernel density\nestimates. Must have 2 or fewer dimensions."
          },
          "type": {
            "kind": "NamedType",
            "name": "array-like"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/method",
          "name": "method",
          "qname": "lib.matplotlib.cbook.violin_stats.method",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "callable",
            "default_value": "",
            "description": "The method used to calculate the kernel density estimate for each\ncolumn of data. When called via ``method(v, coords)``, it should\nreturn a vector of the values of the KDE evaluated at the values\nspecified in coords."
          },
          "type": {
            "kind": "NamedType",
            "name": "callable"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/points",
          "name": "points",
          "qname": "lib.matplotlib.cbook.violin_stats.points",
          "default_value": "100",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "int",
            "default_value": "100",
            "description": "Defines the number of points to evaluate each of the gaussian kernel\ndensity estimates at."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.cbook/violin_stats/quantiles",
          "name": "quantiles",
          "qname": "lib.matplotlib.cbook.violin_stats.quantiles",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "array-like",
            "default_value": "None",
            "description": "Defines (if not None) a list of floats in interval [0, 1] for each\ncolumn of data, which represents the quantiles that will be rendered\nfor that column of data. Must have 2 or fewer dimensions. 1D array will\nbe treated as a singleton list containing them."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "BoundaryType",
                "base_type": "float",
                "min": 0.0,
                "max": 1.0,
                "min_inclusive": true,
                "max_inclusive": true
              },
              {
                "kind": "NamedType",
                "name": "array-like"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.",
      "docstring": "Return a list of dictionaries of data which can be used to draw a series\nof violin plots.\n\nSee the ``Returns`` section below to view the required keys of the\ndictionary.\n\nUsers can skip this function and pass a user-defined set of dictionaries\nwith the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\nto do the calculations. See the *Returns* section below for the keys\nthat must be present in the dictionaries.\n\nParameters\n----------\nX : array-like\n    Sample data that will be used to produce the gaussian kernel density\n    estimates. Must have 2 or fewer dimensions.\n\nmethod : callable\n    The method used to calculate the kernel density estimate for each\n    column of data. When called via ``method(v, coords)``, it should\n    return a vector of the values of the KDE evaluated at the values\n    specified in coords.\n\npoints : int, default: 100\n    Defines the number of points to evaluate each of the gaussian kernel\n    density estimates at.\n\nquantiles : array-like, default: None\n    Defines (if not None) a list of floats in interval [0, 1] for each\n    column of data, which represents the quantiles that will be rendered\n    for that column of data. Must have 2 or fewer dimensions. 1D array will\n    be treated as a singleton list containing them.\n\nReturns\n-------\nlist of dict\n    A list of dictionaries containing the results for each column of data.\n    The dictionaries contain at least the following:\n\n    - coords: A list of scalars containing the coordinates this particular\n      kernel density estimate was evaluated at.\n    - vals: A list of scalars containing the values of the kernel density\n      estimate at each of the coordinates given in *coords*.\n    - mean: The mean value for this column of data.\n    - median: The median value for this column of data.\n    - min: The minimum value for this column of data.\n    - max: The maximum value for this column of data.\n    - quantiles: The quantile values for this column of data.",
      "code": "def violin_stats(X, method, points=100, quantiles=None):\n    \"\"\"\n    Return a list of dictionaries of data which can be used to draw a series\n    of violin plots.\n\n    See the ``Returns`` section below to view the required keys of the\n    dictionary.\n\n    Users can skip this function and pass a user-defined set of dictionaries\n    with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib\n    to do the calculations. See the *Returns* section below for the keys\n    that must be present in the dictionaries.\n\n    Parameters\n    ----------\n    X : array-like\n        Sample data that will be used to produce the gaussian kernel density\n        estimates. Must have 2 or fewer dimensions.\n\n    method : callable\n        The method used to calculate the kernel density estimate for each\n        column of data. When called via ``method(v, coords)``, it should\n        return a vector of the values of the KDE evaluated at the values\n        specified in coords.\n\n    points : int, default: 100\n        Defines the number of points to evaluate each of the gaussian kernel\n        density estimates at.\n\n    quantiles : array-like, default: None\n        Defines (if not None) a list of floats in interval [0, 1] for each\n        column of data, which represents the quantiles that will be rendered\n        for that column of data. Must have 2 or fewer dimensions. 1D array will\n        be treated as a singleton list containing them.\n\n    Returns\n    -------\n    list of dict\n        A list of dictionaries containing the results for each column of data.\n        The dictionaries contain at least the following:\n\n        - coords: A list of scalars containing the coordinates this particular\n          kernel density estimate was evaluated at.\n        - vals: A list of scalars containing the values of the kernel density\n          estimate at each of the coordinates given in *coords*.\n        - mean: The mean value for this column of data.\n        - median: The median value for this column of data.\n        - min: The minimum value for this column of data.\n        - max: The maximum value for this column of data.\n        - quantiles: The quantile values for this column of data.\n    \"\"\"\n\n    # List of dictionaries describing each of the violins.\n    vpstats = []\n\n    # Want X to be a list of data sequences\n    X = _reshape_2D(X, \"X\")\n\n    # Want quantiles to be as the same shape as data sequences\n    if quantiles is not None and len(quantiles) != 0:\n        quantiles = _reshape_2D(quantiles, \"quantiles\")\n    # Else, mock quantiles if is none or empty\n    else:\n        quantiles = [[]] * len(X)\n\n    # quantiles should has the same size as dataset\n    if len(X) != len(quantiles):\n        raise ValueError(\"List of violinplot statistics and quantiles values\"\n                         \" must have the same length\")\n\n    # Zip x and quantiles\n    for (x, q) in zip(X, quantiles):\n        # Dictionary of results for this distribution\n        stats = {}\n\n        # Calculate basic stats for the distribution\n        min_val = np.min(x)\n        max_val = np.max(x)\n        quantile_val = np.percentile(x, 100 * q)\n\n        # Evaluate the kernel density estimate\n        coords = np.linspace(min_val, max_val, points)\n        stats['vals'] = method(x, coords)\n        stats['coords'] = coords\n\n        # Store additional statistics for this distribution\n        stats['mean'] = np.mean(x)\n        stats['median'] = np.median(x)\n        stats['min'] = min_val\n        stats['max'] = max_val\n        stats['quantiles'] = np.atleast_1d(quantile_val)\n\n        # Append to output\n        vpstats.append(stats)\n\n    return vpstats"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.InvertedAitoffTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/AitoffTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.AitoffTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n\n            # Pre-compute some values\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n\n            alpha = np.arccos(cos_latitude * np.cos(half_long))\n            # Avoid divide-by-zero errors using same method as NumPy.\n            alpha[alpha == 0.0] = 1e-20\n            # We want unnormalized sinc.  numpy.sinc gives us normalized\n            sinc_alpha = np.sin(alpha) / alpha\n\n            x = (cos_latitude * np.sin(half_long)) / sinc_alpha\n            y = np.sin(latitude) / sinc_alpha\n            return np.column_stack([x, y])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return AitoffAxes.AitoffTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/InvertedAitoffTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.InvertedAitoffTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            # MGDTODO: Math is hard ;(\n            return xy"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/AitoffAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.AitoffAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.cla()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__call__/pos",
          "name": "pos",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__call__.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __call__(self, x, pos=None):\n            degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n            return f\"{degrees:0.0f}\\N{DEGREE SIGN}\""
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/ThetaFormatter/__init__/round_to",
          "name": "round_to",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.ThetaFormatter.__init__.round_to",
          "default_value": "1.0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to format the theta tick labels.  Converts the native\nunit of radians into degrees and adds a degree symbol.",
      "docstring": "",
      "code": "        def __init__(self, round_to=1.0):\n            self._round_to = round_to"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_pan",
      "name": "can_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.can_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.can_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return *True* if this axes supports the pan/zoom button functionality.\n\nThis axes object does not support interactive pan/zoom.",
      "docstring": "Return *True* if this axes supports the pan/zoom button functionality.\n\nThis axes object does not support interactive pan/zoom.",
      "code": "    def can_pan(self):\n        \"\"\"\n        Return *True* if this axes supports the pan/zoom button functionality.\n\n        This axes object does not support interactive pan/zoom.\n        \"\"\"\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_zoom",
      "name": "can_zoom",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.can_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/can_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.can_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return *True* if this axes supports the zoom box button functionality.\n\nThis axes object does not support interactive zoom box.",
      "docstring": "Return *True* if this axes supports the zoom box button functionality.\n\nThis axes object does not support interactive zoom box.",
      "code": "    def can_zoom(self):\n        \"\"\"\n        Return *True* if this axes supports the zoom box button functionality.\n\n        This axes object does not support interactive zoom box.\n        \"\"\"\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/cla",
      "name": "cla",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.cla",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/cla/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.cla.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def cla(self):\n        Axes.cla(self)\n\n        self.set_longitude_grid(30)\n        self.set_latitude_grid(15)\n        self.set_longitude_grid_ends(75)\n        self.xaxis.set_minor_locator(NullLocator())\n        self.yaxis.set_minor_locator(NullLocator())\n        self.xaxis.set_ticks_position('none')\n        self.yaxis.set_ticks_position('none')\n        self.yaxis.set_tick_params(label1On=True)\n        # Why do we need to turn on yaxis tick labels, but\n        # xaxis tick labels are already on?\n\n        self.grid(rcParams['axes.grid'])\n\n        Axes.set_xlim(self, -np.pi, np.pi)\n        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan",
      "name": "drag_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/key",
          "name": "key",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.key",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/drag_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.drag_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drag_pan(self, button, key, x, y):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/end_pan",
      "name": "end_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.end_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/end_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.end_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def end_pan(self):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord",
      "name": "format_coord",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord/lon",
          "name": "lon",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord.lon",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/format_coord/lat",
          "name": "lat",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.format_coord.lat",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return a format string formatting the coordinate.",
      "docstring": "Return a format string formatting the coordinate.",
      "code": "    def format_coord(self, lon, lat):\n        \"\"\"Return a format string formatting the coordinate.\"\"\"\n        lon, lat = np.rad2deg([lon, lat])\n        if lat >= 0.0:\n            ns = 'N'\n        else:\n            ns = 'S'\n        if lon >= 0.0:\n            ew = 'E'\n        else:\n            ew = 'W'\n        return ('%f\\N{DEGREE SIGN}%s, %f\\N{DEGREE SIGN}%s'\n                % (abs(lat), ns, abs(lon), ew))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_data_ratio",
      "name": "get_data_ratio",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_data_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_data_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_data_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the aspect ratio of the data itself.",
      "docstring": "Return the aspect ratio of the data itself.",
      "code": "    def get_data_ratio(self):\n        \"\"\"Return the aspect ratio of the data itself.\"\"\"\n        return 1.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform",
      "name": "get_xaxis_text1_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text1_transform, 'bottom', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform",
      "name": "get_xaxis_text2_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text2_transform, 'top', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform",
      "name": "get_xaxis_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_xaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_xaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform",
      "name": "get_yaxis_text1_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text1_transform(self, pad):\n        return self._yaxis_text1_transform, 'center', 'right'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform",
      "name": "get_yaxis_text2_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text2_transform(self, pad):\n        return self._yaxis_text2_transform, 'center', 'left'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform",
      "name": "get_yaxis_transform",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/get_yaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.get_yaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._yaxis_transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid",
      "name": "set_latitude_grid",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_latitude_grid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_latitude_grid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_latitude_grid/degrees",
          "name": "degrees",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_latitude_grid.degrees",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the number of degrees between each latitude grid.",
      "docstring": "Set the number of degrees between each latitude grid.",
      "code": "    def set_latitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each latitude grid.\n        \"\"\"\n        # Skip -90 and 90, which are the fixed limits.\n        grid = np.arange(-90 + degrees, 90, degrees)\n        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid",
      "name": "set_longitude_grid",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid/degrees",
          "name": "degrees",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid.degrees",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the number of degrees between each longitude grid.",
      "docstring": "Set the number of degrees between each longitude grid.",
      "code": "    def set_longitude_grid(self, degrees):\n        \"\"\"\n        Set the number of degrees between each longitude grid.\n        \"\"\"\n        # Skip -180 and 180, which are the fixed limits.\n        grid = np.arange(-180 + degrees, 180, degrees)\n        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends",
      "name": "set_longitude_grid_ends",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid_ends",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid_ends.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_longitude_grid_ends/degrees",
          "name": "degrees",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_longitude_grid_ends.degrees",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the latitude(s) at which to stop drawing the longitude grids.",
      "docstring": "Set the latitude(s) at which to stop drawing the longitude grids.",
      "code": "    def set_longitude_grid_ends(self, degrees):\n        \"\"\"\n        Set the latitude(s) at which to stop drawing the longitude grids.\n        \"\"\"\n        self._longitude_cap = np.deg2rad(degrees)\n        self._xaxis_pretransform \\\n            .clear() \\\n            .scale(1.0, self._longitude_cap * 2.0) \\\n            .translate(0.0, -self._longitude_cap)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim",
      "name": "set_xlim",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_xlim/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_xlim.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_xlim(self, *args, **kwargs):\n        raise TypeError(\"Changing axes limits of a geographic projection is \"\n                        \"not supported.  Please consider using Cartopy.\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale",
      "name": "set_yscale",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/set_yscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.set_yscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_yscale(self, *args, **kwargs):\n        if args[0] != 'linear':\n            raise NotImplementedError"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan",
      "name": "start_pan",
      "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/GeoAxes/start_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.geo.GeoAxes.start_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_pan(self, x, y, button):\n        pass"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return HammerAxes.InvertedHammerTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/HammerTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.HammerTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            half_long = longitude / 2.0\n            cos_latitude = np.cos(latitude)\n            sqrt2 = np.sqrt(2.0)\n            alpha = np.sqrt(1.0 + cos_latitude * np.cos(half_long))\n            x = (2.0 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha\n            y = (sqrt2 * np.sin(latitude)) / alpha\n            return np.column_stack([x, y])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return HammerAxes.HammerTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/InvertedHammerTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.InvertedHammerTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)\n            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))\n            latitude = np.arcsin(y*z)\n            return np.column_stack([longitude, latitude])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/HammerAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.HammerAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.cla()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/center_longitude",
          "name": "center_longitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.center_longitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/center_latitude",
          "name": "center_latitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.center_latitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/__init__/resolution",
          "name": "resolution",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.__init__.resolution",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def __init__(self, center_longitude, center_latitude, resolution):\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return LambertAxes.LambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/InvertedLambertTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.InvertedLambertTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            p = np.maximum(np.hypot(x, y), 1e-9)\n            c = 2 * np.arcsin(0.5 * p)\n            sin_c = np.sin(c)\n            cos_c = np.cos(c)\n\n            latitude = np.arcsin(cos_c*np.sin(clat) +\n                                 ((y*sin_c*np.cos(clat)) / p))\n            longitude = clong + np.arctan(\n                (x*sin_c) / (p*np.cos(clat)*cos_c - y*np.sin(clat)*sin_c))\n\n            return np.column_stack([longitude, latitude])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/center_longitude",
          "name": "center_longitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.center_longitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/center_latitude",
          "name": "center_latitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.center_latitude",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/__init__/resolution",
          "name": "resolution",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.__init__.resolution",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The base Lambert transform.",
      "docstring": "Create a new Lambert transform.  Resolution is the number of steps\nto interpolate between each input line segment to approximate its\npath in curved Lambert space.",
      "code": "        def __init__(self, center_longitude, center_latitude, resolution):\n            \"\"\"\n            Create a new Lambert transform.  Resolution is the number of steps\n            to interpolate between each input line segment to approximate its\n            path in curved Lambert space.\n            \"\"\"\n            _GeoTransform.__init__(self, resolution)\n            self._center_longitude = center_longitude\n            self._center_latitude = center_latitude"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return LambertAxes.InvertedLambertTransform(\n                self._center_longitude,\n                self._center_latitude,\n                self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/LambertTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.LambertTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            longitude, latitude = ll.T\n            clong = self._center_longitude\n            clat = self._center_latitude\n            cos_lat = np.cos(latitude)\n            sin_lat = np.sin(latitude)\n            diff_long = longitude - clong\n            cos_diff_long = np.cos(diff_long)\n\n            inner_k = np.maximum(  # Prevent divide-by-zero problems\n                1 + np.sin(clat)*sin_lat + np.cos(clat)*cos_lat*cos_diff_long,\n                1e-15)\n            k = np.sqrt(2 / inner_k)\n            x = k * cos_lat*np.sin(diff_long)\n            y = k * (np.cos(clat)*sin_lat - np.sin(clat)*cos_lat*cos_diff_long)\n\n            return np.column_stack([x, y])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/center_longitude",
          "name": "center_longitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.center_longitude",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/center_latitude",
          "name": "center_latitude",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.center_latitude",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, center_longitude=0, center_latitude=0, **kwargs):\n        self._longitude_cap = np.pi / 2\n        self._center_longitude = center_longitude\n        self._center_latitude = center_latitude\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.cla()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/cla",
      "name": "cla",
      "qname": "lib.matplotlib.projections.geo.LambertAxes.cla",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/LambertAxes/cla/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.LambertAxes.cla.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def cla(self):\n        GeoAxes.cla(self)\n        self.yaxis.set_major_formatter(NullFormatter())"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.MollweideTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/InvertedMollweideTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.InvertedMollweideTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, xy):\n            # docstring inherited\n            x, y = xy.T\n            # from Equations (7, 8) of\n            # https://mathworld.wolfram.com/MollweideProjection.html\n            theta = np.arcsin(y / np.sqrt(2))\n            longitude = (np.pi / (2 * np.sqrt(2))) * x / np.cos(theta)\n            latitude = np.arcsin((2 * theta + np.sin(2 * theta)) / np.pi)\n            return np.column_stack([longitude, latitude])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def inverted(self):\n            # docstring inherited\n            return MollweideAxes.InvertedMollweideTransform(self._resolution)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/MollweideTransform/transform_non_affine/ll",
          "name": "ll",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.MollweideTransform.transform_non_affine.ll",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "        def transform_non_affine(self, ll):\n            # docstring inherited\n            def d(theta):\n                delta = (-(theta + np.sin(theta) - pi_sin_l)\n                         / (1 + np.cos(theta)))\n                return delta, np.abs(delta) > 0.001\n\n            longitude, latitude = ll.T\n\n            clat = np.pi/2 - np.abs(latitude)\n            ihigh = clat < 0.087  # within 5 degrees of the poles\n            ilow = ~ihigh\n            aux = np.empty(latitude.shape, dtype=float)\n\n            if ilow.any():  # Newton-Raphson iteration\n                pi_sin_l = np.pi * np.sin(latitude[ilow])\n                theta = 2.0 * latitude[ilow]\n                delta, large_delta = d(theta)\n                while np.any(large_delta):\n                    theta[large_delta] += delta[large_delta]\n                    delta, large_delta = d(theta)\n                aux[ilow] = theta / 2\n\n            if ihigh.any():  # Taylor series-based approx. solution\n                e = clat[ihigh]\n                d = 0.5 * (3 * np.pi * e**2) ** (1.0/3)\n                aux[ihigh] = (np.pi/2 - d) * np.sign(latitude[ihigh])\n\n            xy = np.empty(ll.shape, dtype=float)\n            xy[:, 0] = (2.0 * np.sqrt(2.0) / np.pi) * longitude * np.cos(aux)\n            xy[:, 1] = np.sqrt(2.0) * np.sin(aux)\n\n            return xy"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.geo/MollweideAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.geo.MollweideAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        self._longitude_cap = np.pi / 2.0\n        GeoAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(0.5, adjustable='box', anchor='C')\n        self.cla()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__.axis",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/use_rmin",
          "name": "use_rmin",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__.use_rmin",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/__init__/_apply_theta_transforms",
          "name": "_apply_theta_transforms",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.__init__._apply_theta_transforms",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The inverse of the polar transform, mapping Cartesian\ncoordinate space *x* and *y* back to *theta* and *r*.",
      "docstring": "",
      "code": "    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        mtransforms.Transform.__init__(self)\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def inverted(self):\n        # docstring inherited\n        return PolarAxes.PolarTransform(self._axis, self._use_rmin,\n                                        self._apply_theta_transforms)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/InvertedPolarTransform/transform_non_affine/xy",
          "name": "xy",
          "qname": "lib.matplotlib.projections.polar.InvertedPolarTransform.transform_non_affine.xy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def transform_non_affine(self, xy):\n        # docstring inherited\n        x, y = xy.T\n        r = np.hypot(x, y)\n        theta = (np.arctan2(y, x) + 2 * np.pi) % (2 * np.pi)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            theta -= self._axis.get_theta_offset()\n            theta *= self._axis.get_theta_direction()\n            theta %= 2 * np.pi\n        if self._use_rmin and self._axis is not None:\n            r += self._axis.get_rorigin()\n            r *= self._axis.get_rsign()\n        return np.column_stack([theta, r])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__/scale_transform",
          "name": "scale_transform",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__.scale_transform",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/__init__/limits",
          "name": "limits",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.__init__.limits",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The affine part of the polar projection.  Scales the output so\nthat maximum radius rests on the edge of the axes circle.",
      "docstring": "*limits* is the view limit of the data.  The only part of\nits bounds that is used is the y limits (for the radius limits).\nThe theta range is handled by the non-affine transform.",
      "code": "    def __init__(self, scale_transform, limits):\n        \"\"\"\n        *limits* is the view limit of the data.  The only part of\n        its bounds that is used is the y limits (for the radius limits).\n        The theta range is handled by the non-affine transform.\n        \"\"\"\n        mtransforms.Affine2DBase.__init__(self)\n        self._scale_transform = scale_transform\n        self._limits = limits\n        self.set_children(scale_transform, limits)\n        self._mtx = None"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/get_matrix",
      "name": "get_matrix",
      "qname": "lib.matplotlib.projections.polar.PolarAffine.get_matrix",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAffine/get_matrix/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAffine.get_matrix.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_matrix(self):\n        # docstring inherited\n        if self._invalid:\n            limits_scaled = self._limits.transformed(self._scale_transform)\n            yscale = limits_scaled.ymax - limits_scaled.ymin\n            affine = mtransforms.Affine2D() \\\n                .scale(0.5 / yscale) \\\n                .translate(0.5, 0.5)\n            self._mtx = affine.get_matrix()\n            self._inverted = None\n            self._invalid = 0\n        return self._mtx"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/theta_offset",
          "name": "theta_offset",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.theta_offset",
          "default_value": "0",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/theta_direction",
          "name": "theta_direction",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.theta_direction",
          "default_value": "1",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/rlabel_position",
          "name": "rlabel_position",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.rlabel_position",
          "default_value": "22.5",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A polar graph projection, where the input dimensions are *theta*, *r*.\n\nTheta starts pointing east and goes anti-clockwise.",
      "docstring": "",
      "code": "    def __init__(self, *args,\n                 theta_offset=0, theta_direction=1, rlabel_position=22.5,\n                 **kwargs):\n        # docstring inherited\n        self._default_theta_offset = theta_offset\n        self._default_theta_direction = theta_direction\n        self._default_rlabel_position = np.deg2rad(rlabel_position)\n        super().__init__(*args, **kwargs)\n        self.use_sticky_edges = True\n        self.set_aspect('equal', adjustable='box', anchor='C')\n        self.cla()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_pan",
      "name": "can_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.can_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.can_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return *True* if this axes supports the pan/zoom button functionality.\n\nFor polar axes, this is slightly misleading. Both panning and\nzooming are performed by the same button. Panning is performed\nin azimuth while zooming is done along the radial.",
      "docstring": "Return *True* if this axes supports the pan/zoom button functionality.\n\nFor polar axes, this is slightly misleading. Both panning and\nzooming are performed by the same button. Panning is performed\nin azimuth while zooming is done along the radial.",
      "code": "    def can_pan(self):\n        \"\"\"\n        Return *True* if this axes supports the pan/zoom button functionality.\n\n        For polar axes, this is slightly misleading. Both panning and\n        zooming are performed by the same button. Panning is performed\n        in azimuth while zooming is done along the radial.\n        \"\"\"\n        return True"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_zoom",
      "name": "can_zoom",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.can_zoom",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/can_zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.can_zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return *True* if this axes supports the zoom box button functionality.\n\nPolar axes do not support zoom boxes.",
      "docstring": "Return *True* if this axes supports the zoom box button functionality.\n\nPolar axes do not support zoom boxes.",
      "code": "    def can_zoom(self):\n        \"\"\"\n        Return *True* if this axes supports the zoom box button functionality.\n\n        Polar axes do not support zoom boxes.\n        \"\"\"\n        return False"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/cla",
      "name": "cla",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.cla",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/cla/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.cla.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def cla(self):\n        Axes.cla(self)\n\n        self.title.set_y(1.05)\n\n        start = self.spines.get('start', None)\n        if start:\n            start.set_visible(False)\n        end = self.spines.get('end', None)\n        if end:\n            end.set_visible(False)\n        self.set_xlim(0.0, 2 * np.pi)\n\n        self.grid(rcParams['polaraxes.grid'])\n        inner = self.spines.get('inner', None)\n        if inner:\n            inner.set_visible(False)\n\n        self.set_rorigin(None)\n        self.set_theta_offset(self._default_theta_offset)\n        self.set_theta_direction(self._default_theta_direction)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan",
      "name": "drag_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/key",
          "name": "key",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.key",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/drag_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.drag_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def drag_pan(self, button, key, x, y):\n        p = self._pan_start\n\n        if p.mode == 'drag_r_labels':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with theta\n            dt = np.rad2deg(startt - t)\n            self.set_rlabel_position(p.r_label_angle - dt)\n\n            trans, vert1, horiz1 = self.get_yaxis_text1_transform(0.0)\n            trans, vert2, horiz2 = self.get_yaxis_text2_transform(0.0)\n            for t in self.yaxis.majorTicks + self.yaxis.minorTicks:\n                t.label1.set_va(vert1)\n                t.label1.set_ha(horiz1)\n                t.label2.set_va(vert2)\n                t.label2.set_ha(horiz2)\n\n        elif p.mode == 'zoom':\n            (startt, startr), (t, r) = p.trans_inverse.transform(\n                [(p.x, p.y), (x, y)])\n\n            # Deal with r\n            scale = r / startr\n            self.set_rmax(p.rmax / scale)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw",
      "name": "draw",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.draw",
      "decorators": [
        "cbook._delete_parameter('3.3', 'args')",
        "cbook._delete_parameter('3.3', 'kwargs')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.draw.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw/renderer",
          "name": "renderer",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.draw.renderer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.draw.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/draw/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.draw.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook._delete_parameter(\"3.3\", \"args\")\n    @cbook._delete_parameter(\"3.3\", \"kwargs\")\n    def draw(self, renderer, *args, **kwargs):\n        self._unstale_viewLim()\n        thetamin, thetamax = np.rad2deg(self._realViewLim.intervalx)\n        if thetamin > thetamax:\n            thetamin, thetamax = thetamax, thetamin\n        rmin, rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *\n                      self.get_rsign())\n        if isinstance(self.patch, mpatches.Wedge):\n            # Backwards-compatibility: Any subclassed Axes might override the\n            # patch to not be the Wedge that PolarAxes uses.\n            center = self.transWedge.transform((0.5, 0.5))\n            self.patch.set_center(center)\n            self.patch.set_theta1(thetamin)\n            self.patch.set_theta2(thetamax)\n\n            edge, _ = self.transWedge.transform((1, 0))\n            radius = edge - center[0]\n            width = min(radius * (rmax - rmin) / rmax, radius)\n            self.patch.set_radius(radius)\n            self.patch.set_width(width)\n\n            inner_width = radius - width\n            inner = self.spines.get('inner', None)\n            if inner:\n                inner.set_visible(inner_width != 0.0)\n\n        visible = not _is_full_circle_deg(thetamin, thetamax)\n        # For backwards compatibility, any subclassed Axes might override the\n        # spines to not include start/end that PolarAxes uses.\n        start = self.spines.get('start', None)\n        end = self.spines.get('end', None)\n        if start:\n            start.set_visible(visible)\n        if end:\n            end.set_visible(visible)\n        if visible:\n            yaxis_text_transform = self._yaxis_transform\n        else:\n            yaxis_text_transform = self._r_label_position + self.transData\n        if self._yaxis_text_transform != yaxis_text_transform:\n            self._yaxis_text_transform.set(yaxis_text_transform)\n            self.yaxis.reset_ticks()\n            self.yaxis.set_clip_path(self.patch)\n\n        Axes.draw(self, renderer, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/end_pan",
      "name": "end_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.end_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/end_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.end_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def end_pan(self):\n        del self._pan_start"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord",
      "name": "format_coord",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord/theta",
          "name": "theta",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord.theta",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/format_coord/r",
          "name": "r",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.format_coord.r",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def format_coord(self, theta, r):\n        # docstring inherited\n        if theta < 0:\n            theta += 2 * np.pi\n        theta /= np.pi\n        return ('\\N{GREEK SMALL LETTER THETA}=%0.3f\\N{GREEK SMALL LETTER PI} '\n                '(%0.3f\\N{DEGREE SIGN}), r=%0.3f') % (theta, theta * 180.0, r)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_data_ratio",
      "name": "get_data_ratio",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_data_ratio/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_data_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the aspect ratio of the data itself.  For a polar plot,\nthis should always be 1.0",
      "docstring": "Return the aspect ratio of the data itself.  For a polar plot,\nthis should always be 1.0",
      "code": "    def get_data_ratio(self):\n        \"\"\"\n        Return the aspect ratio of the data itself.  For a polar plot,\n        this should always be 1.0\n        \"\"\"\n        return 1.0"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rlabel_position",
      "name": "get_rlabel_position",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rlabel_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rlabel_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rlabel_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat\n    The theta position of the radius labels in degrees.",
      "code": "    def get_rlabel_position(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The theta position of the radius labels in degrees.\n        \"\"\"\n        return np.rad2deg(self._r_label_position.get_matrix()[0, 2])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmax",
      "name": "get_rmax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat\n    Outer radial limit.",
      "code": "    def get_rmax(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            Outer radial limit.\n        \"\"\"\n        return self.viewLim.ymax"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmin",
      "name": "get_rmin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rmin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rmin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat\n    The inner radial limit.",
      "code": "    def get_rmin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n            The inner radial limit.\n        \"\"\"\n        return self.viewLim.ymin"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rorigin",
      "name": "get_rorigin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rorigin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rorigin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rorigin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "Returns\n-------\nfloat",
      "code": "    def get_rorigin(self):\n        \"\"\"\n        Returns\n        -------\n        float\n        \"\"\"\n        return self._originViewLim.y0"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rsign",
      "name": "get_rsign",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rsign",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_rsign/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_rsign.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_rsign(self):\n        return np.sign(self._originViewLim.y1 - self._originViewLim.y0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_direction",
      "name": "get_theta_direction",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_direction",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_direction/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_direction.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the direction in which theta increases.\n\n-1:\n   Theta increases in the clockwise direction\n\n1:\n   Theta increases in the counterclockwise direction",
      "docstring": "Get the direction in which theta increases.\n\n-1:\n   Theta increases in the clockwise direction\n\n1:\n   Theta increases in the counterclockwise direction",
      "code": "    def get_theta_direction(self):\n        \"\"\"\n        Get the direction in which theta increases.\n\n        -1:\n           Theta increases in the clockwise direction\n\n        1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        return self._direction.get_matrix()[0, 0]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_offset",
      "name": "get_theta_offset",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_offset",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_theta_offset/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_theta_offset.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the offset for the location of 0 in radians.",
      "docstring": "Get the offset for the location of 0 in radians.",
      "code": "    def get_theta_offset(self):\n        \"\"\"\n        Get the offset for the location of 0 in radians.\n        \"\"\"\n        return self._theta_offset.get_matrix()[0, 2]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamax",
      "name": "get_thetamax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the maximum theta limit in degrees.",
      "docstring": "Return the maximum theta limit in degrees.",
      "code": "    def get_thetamax(self):\n        \"\"\"Return the maximum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamin",
      "name": "get_thetamin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_thetamin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_thetamin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get the minimum theta limit in degrees.",
      "docstring": "Get the minimum theta limit in degrees.",
      "code": "    def get_thetamin(self):\n        \"\"\"Get the minimum theta limit in degrees.\"\"\"\n        return np.rad2deg(self.viewLim.xmin)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform",
      "name": "get_xaxis_text1_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text1_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform",
      "name": "get_xaxis_text2_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_text2_transform(self, pad):\n        return self._xaxis_text_transform, 'center', 'center'"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform",
      "name": "get_xaxis_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_xaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_xaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_xaxis_transform(self, which='grid'):\n        cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)\n        return self._xaxis_transform"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform",
      "name": "get_yaxis_text1_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text1_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text1_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text1_transform(self, pad):\n        thetamin, thetamax = self._realViewLim.intervalx\n        if _is_full_circle_rad(thetamin, thetamax):\n            return self._yaxis_text_transform, 'bottom', 'left'\n        elif self.get_theta_direction() > 0:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        else:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        return self._yaxis_text_transform + pad_shift, 'center', halign"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform",
      "name": "get_yaxis_text2_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_text2_transform/pad",
          "name": "pad",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_text2_transform.pad",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_text2_transform(self, pad):\n        if self.get_theta_direction() > 0:\n            halign = 'right'\n            pad_shift = _ThetaShift(self, pad, 'max')\n        else:\n            halign = 'left'\n            pad_shift = _ThetaShift(self, pad, 'min')\n        return self._yaxis_text_transform + pad_shift, 'center', halign"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform",
      "name": "get_yaxis_transform",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/get_yaxis_transform/which",
          "name": "which",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.get_yaxis_transform.which",
          "default_value": "'grid'",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def get_yaxis_transform(self, which='grid'):\n        if which in ('tick1', 'tick2'):\n            return self._yaxis_text_transform\n        elif which == 'grid':\n            return self._yaxis_transform\n        else:\n            cbook._check_in_list(['tick1', 'tick2', 'grid'], which=which)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids",
      "name": "set_rgrids",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/radii",
          "name": "radii",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.radii",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with floats",
            "default_value": "",
            "description": "The radii for the radial gridlines"
          },
          "type": {
            "kind": "NamedType",
            "name": "tuple with floats"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/labels",
          "name": "labels",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with strings or None",
            "default_value": "",
            "description": "The labels to use at each radial gridline. The\n`matplotlib.ticker.ScalarFormatter` will be used if None."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple with strings"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/angle",
          "name": "angle",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.angle",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The angular position of the radius labels in degrees."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.fmt",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "",
            "description": "Format string used in `matplotlib.ticker.FormatStrFormatter`.\nFor example '%f'."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rgrids/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rgrids.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the radial gridlines on a polar plot.",
      "docstring": "Set the radial gridlines on a polar plot.\n\nParameters\n----------\nradii : tuple with floats\n    The radii for the radial gridlines\n\nlabels : tuple with strings or None\n    The labels to use at each radial gridline. The\n    `matplotlib.ticker.ScalarFormatter` will be used if None.\n\nangle : float\n    The angular position of the radius labels in degrees.\n\nfmt : str or None\n    Format string used in `matplotlib.ticker.FormatStrFormatter`.\n    For example '%f'.\n\nReturns\n-------\nlines : list of `.lines.Line2D`\n    The radial gridlines.\n\nlabels : list of `.text.Text`\n    The tick labels.\n\nOther Parameters\n----------------\n**kwargs\n    *kwargs* are optional `~.Text` properties for the labels.\n\nSee Also\n--------\n.PolarAxes.set_thetagrids\n.Axis.get_gridlines\n.Axis.get_ticklabels",
      "code": "    def set_rgrids(self, radii, labels=None, angle=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the radial gridlines on a polar plot.\n\n        Parameters\n        ----------\n        radii : tuple with floats\n            The radii for the radial gridlines\n\n        labels : tuple with strings or None\n            The labels to use at each radial gridline. The\n            `matplotlib.ticker.ScalarFormatter` will be used if None.\n\n        angle : float\n            The angular position of the radius labels in degrees.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The radial gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `~.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_thetagrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n        # Make sure we take into account unitized data\n        radii = self.convert_xunits(radii)\n        radii = np.asarray(radii)\n\n        self.set_yticks(radii)\n        if labels is not None:\n            self.set_yticklabels(labels)\n        elif fmt is not None:\n            self.yaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        if angle is None:\n            angle = self.get_rlabel_position()\n        self.set_rlabel_position(angle)\n        for t in self.yaxis.get_ticklabels():\n            t.update(kwargs)\n        return self.yaxis.get_gridlines(), self.yaxis.get_ticklabels()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position",
      "name": "set_rlabel_position",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlabel_position/value",
          "name": "value",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlabel_position.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "number",
            "default_value": "",
            "description": "The angular position of the radius labels in degrees."
          },
          "type": {
            "kind": "NamedType",
            "name": "number"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update the theta position of the radius labels.",
      "docstring": "Update the theta position of the radius labels.\n\nParameters\n----------\nvalue : number\n    The angular position of the radius labels in degrees.",
      "code": "    def set_rlabel_position(self, value):\n        \"\"\"\n        Update the theta position of the radius labels.\n\n        Parameters\n        ----------\n        value : number\n            The angular position of the radius labels in degrees.\n        \"\"\"\n        self._r_label_position.clear().translate(np.deg2rad(value), 0.0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim",
      "name": "set_rlim",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/bottom",
          "name": "bottom",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.bottom",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/top",
          "name": "top",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.top",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/emit",
          "name": "emit",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.emit",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/auto",
          "name": "auto",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.auto",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rlim/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rlim.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "See `~.polar.PolarAxes.set_ylim`.",
      "docstring": "See `~.polar.PolarAxes.set_ylim`.",
      "code": "    def set_rlim(self, bottom=None, top=None, emit=True, auto=False, **kwargs):\n        \"\"\"\n        See `~.polar.PolarAxes.set_ylim`.\n        \"\"\"\n        if 'rmin' in kwargs:\n            if bottom is None:\n                bottom = kwargs.pop('rmin')\n            else:\n                raise ValueError('Cannot supply both positional \"bottom\"'\n                                 'argument and kwarg \"rmin\"')\n        if 'rmax' in kwargs:\n            if top is None:\n                top = kwargs.pop('rmax')\n            else:\n                raise ValueError('Cannot supply both positional \"top\"'\n                                 'argument and kwarg \"rmax\"')\n        return self.set_ylim(bottom=bottom, top=top, emit=emit, auto=auto,\n                             **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax",
      "name": "set_rmax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmax/rmax",
          "name": "rmax",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmax.rmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the outer radial limit.",
      "docstring": "Set the outer radial limit.\n\nParameters\n----------\nrmax : float",
      "code": "    def set_rmax(self, rmax):\n        \"\"\"\n        Set the outer radial limit.\n\n        Parameters\n        ----------\n        rmax : float\n        \"\"\"\n        self.viewLim.y1 = rmax"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin",
      "name": "set_rmin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rmin/rmin",
          "name": "rmin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rmin.rmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the inner radial limit.",
      "docstring": "Set the inner radial limit.\n\nParameters\n----------\nrmin : float",
      "code": "    def set_rmin(self, rmin):\n        \"\"\"\n        Set the inner radial limit.\n\n        Parameters\n        ----------\n        rmin : float\n        \"\"\"\n        self.viewLim.y0 = rmin"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin",
      "name": "set_rorigin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rorigin/rorigin",
          "name": "rorigin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rorigin.rorigin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": ""
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Update the radial origin.",
      "docstring": "Update the radial origin.\n\nParameters\n----------\nrorigin : float",
      "code": "    def set_rorigin(self, rorigin):\n        \"\"\"\n        Update the radial origin.\n\n        Parameters\n        ----------\n        rorigin : float\n        \"\"\"\n        self._originViewLim.locked_y0 = rorigin"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale",
      "name": "set_rscale",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_rscale(self, *args, **kwargs):\n        return Axes.set_yscale(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks",
      "name": "set_rticks",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_rticks/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_rticks.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_rticks(self, *args, **kwargs):\n        return Axes.set_yticks(self, *args, **kwargs)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction",
      "name": "set_theta_direction",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_direction",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_direction.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_direction/direction",
          "name": "direction",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_direction.direction",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the direction in which theta increases.\n\nclockwise, -1:\n   Theta increases in the clockwise direction\n\ncounterclockwise, anticlockwise, 1:\n   Theta increases in the counterclockwise direction",
      "docstring": "Set the direction in which theta increases.\n\nclockwise, -1:\n   Theta increases in the clockwise direction\n\ncounterclockwise, anticlockwise, 1:\n   Theta increases in the counterclockwise direction",
      "code": "    def set_theta_direction(self, direction):\n        \"\"\"\n        Set the direction in which theta increases.\n\n        clockwise, -1:\n           Theta increases in the clockwise direction\n\n        counterclockwise, anticlockwise, 1:\n           Theta increases in the counterclockwise direction\n        \"\"\"\n        mtx = self._direction.get_matrix()\n        if direction in ('clockwise', -1):\n            mtx[0, 0] = -1\n        elif direction in ('counterclockwise', 'anticlockwise', 1):\n            mtx[0, 0] = 1\n        else:\n            cbook._check_in_list(\n                [-1, 1, 'clockwise', 'counterclockwise', 'anticlockwise'],\n                direction=direction)\n        self._direction.invalidate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset",
      "name": "set_theta_offset",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_offset/offset",
          "name": "offset",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_offset.offset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the offset for the location of 0 in radians.",
      "docstring": "Set the offset for the location of 0 in radians.",
      "code": "    def set_theta_offset(self, offset):\n        \"\"\"\n        Set the offset for the location of 0 in radians.\n        \"\"\"\n        mtx = self._theta_offset.get_matrix()\n        mtx[0, 2] = offset\n        self._theta_offset.invalidate()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location",
      "name": "set_theta_zero_location",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location/loc",
          "name": "loc",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\"."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_theta_zero_location/offset",
          "name": "offset",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_theta_zero_location.offset",
          "default_value": "0.0",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "0",
            "description": "An offset in degrees to apply from the specified *loc*. **Note:**\nthis offset is *always* applied counter-clockwise regardless of\nthe direction setting."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the location of theta's zero.\n\nThis simply calls `set_theta_offset` with the correct value in radians.",
      "docstring": "Set the location of theta's zero.\n\nThis simply calls `set_theta_offset` with the correct value in radians.\n\nParameters\n----------\nloc : str\n    May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\".\noffset : float, default: 0\n    An offset in degrees to apply from the specified *loc*. **Note:**\n    this offset is *always* applied counter-clockwise regardless of\n    the direction setting.",
      "code": "    def set_theta_zero_location(self, loc, offset=0.0):\n        \"\"\"\n        Set the location of theta's zero.\n\n        This simply calls `set_theta_offset` with the correct value in radians.\n\n        Parameters\n        ----------\n        loc : str\n            May be one of \"N\", \"NW\", \"W\", \"SW\", \"S\", \"SE\", \"E\", or \"NE\".\n        offset : float, default: 0\n            An offset in degrees to apply from the specified *loc*. **Note:**\n            this offset is *always* applied counter-clockwise regardless of\n            the direction setting.\n        \"\"\"\n        mapping = {\n            'N': np.pi * 0.5,\n            'NW': np.pi * 0.75,\n            'W': np.pi,\n            'SW': np.pi * 1.25,\n            'S': np.pi * 1.5,\n            'SE': np.pi * 1.75,\n            'E': 0,\n            'NE': np.pi * 0.25}\n        return self.set_theta_offset(mapping[loc] + np.deg2rad(offset))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids",
      "name": "set_thetagrids",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/angles",
          "name": "angles",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.angles",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with floats, degrees",
            "default_value": "",
            "description": "The angles of the theta gridlines."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple with floats"
              },
              {
                "kind": "NamedType",
                "name": "degrees"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/labels",
          "name": "labels",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.labels",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "tuple with strings or None",
            "default_value": "",
            "description": "The labels to use at each theta gridline. The\n`.projections.polar.ThetaFormatter` will be used if None."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "tuple with strings"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/fmt",
          "name": "fmt",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.fmt",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "str or None",
            "default_value": "",
            "description": "Format string used in `matplotlib.ticker.FormatStrFormatter`.\nFor example '%f'. Note that the angle that is used is in\nradians."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "str"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetagrids/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetagrids.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the theta gridlines in a polar plot.",
      "docstring": "Set the theta gridlines in a polar plot.\n\nParameters\n----------\nangles : tuple with floats, degrees\n    The angles of the theta gridlines.\n\nlabels : tuple with strings or None\n    The labels to use at each theta gridline. The\n    `.projections.polar.ThetaFormatter` will be used if None.\n\nfmt : str or None\n    Format string used in `matplotlib.ticker.FormatStrFormatter`.\n    For example '%f'. Note that the angle that is used is in\n    radians.\n\nReturns\n-------\nlines : list of `.lines.Line2D`\n    The theta gridlines.\n\nlabels : list of `.text.Text`\n    The tick labels.\n\nOther Parameters\n----------------\n**kwargs\n    *kwargs* are optional `~.Text` properties for the labels.\n\nSee Also\n--------\n.PolarAxes.set_rgrids\n.Axis.get_gridlines\n.Axis.get_ticklabels",
      "code": "    def set_thetagrids(self, angles, labels=None, fmt=None, **kwargs):\n        \"\"\"\n        Set the theta gridlines in a polar plot.\n\n        Parameters\n        ----------\n        angles : tuple with floats, degrees\n            The angles of the theta gridlines.\n\n        labels : tuple with strings or None\n            The labels to use at each theta gridline. The\n            `.projections.polar.ThetaFormatter` will be used if None.\n\n        fmt : str or None\n            Format string used in `matplotlib.ticker.FormatStrFormatter`.\n            For example '%f'. Note that the angle that is used is in\n            radians.\n\n        Returns\n        -------\n        lines : list of `.lines.Line2D`\n            The theta gridlines.\n\n        labels : list of `.text.Text`\n            The tick labels.\n\n        Other Parameters\n        ----------------\n        **kwargs\n            *kwargs* are optional `~.Text` properties for the labels.\n\n        See Also\n        --------\n        .PolarAxes.set_rgrids\n        .Axis.get_gridlines\n        .Axis.get_ticklabels\n        \"\"\"\n\n        # Make sure we take into account unitized data\n        angles = self.convert_yunits(angles)\n        angles = np.deg2rad(angles)\n        self.set_xticks(angles)\n        if labels is not None:\n            self.set_xticklabels(labels)\n        elif fmt is not None:\n            self.xaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))\n        for t in self.xaxis.get_ticklabels():\n            t.update(kwargs)\n        return self.xaxis.get_ticklines(), self.xaxis.get_ticklabels()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim",
      "name": "set_thetalim",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetalim/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetalim.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the minimum and maximum theta values.\n\nCan take the following signatures:\n\n- ``set_thetalim(minval, maxval)``: Set the limits in radians.\n- ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n  in degrees.\n\nwhere minval and maxval are the minimum and maximum limits. Values are\nwrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\nit is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\nan axes symmetric around 0. A ValueError is raised if the absolute\nangle difference is larger than :math:`2\\pi`.",
      "docstring": "Set the minimum and maximum theta values.\n\nCan take the following signatures:\n\n- ``set_thetalim(minval, maxval)``: Set the limits in radians.\n- ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n  in degrees.\n\nwhere minval and maxval are the minimum and maximum limits. Values are\nwrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\nit is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\nan axes symmetric around 0. A ValueError is raised if the absolute\nangle difference is larger than :math:`2\\pi`.",
      "code": "    def set_thetalim(self, *args, **kwargs):\n        r\"\"\"\n        Set the minimum and maximum theta values.\n\n        Can take the following signatures:\n\n        - ``set_thetalim(minval, maxval)``: Set the limits in radians.\n        - ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits\n          in degrees.\n\n        where minval and maxval are the minimum and maximum limits. Values are\n        wrapped in to the range :math:`[0, 2\\pi]` (in radians), so for example\n        it is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have\n        an axes symmetric around 0. A ValueError is raised if the absolute\n        angle difference is larger than :math:`2\\pi`.\n        \"\"\"\n        thetamin = None\n        thetamax = None\n        left = None\n        right = None\n\n        if len(args) == 2:\n            if args[0] is not None and args[1] is not None:\n                left, right = args\n                if abs(right - left) > 2 * np.pi:\n                    raise ValueError('The angle range must be <= 2 pi')\n\n        if 'thetamin' in kwargs:\n            thetamin = np.deg2rad(kwargs.pop('thetamin'))\n        if 'thetamax' in kwargs:\n            thetamax = np.deg2rad(kwargs.pop('thetamax'))\n\n        if thetamin is not None and thetamax is not None:\n            if abs(thetamax - thetamin) > 2 * np.pi:\n                raise ValueError('The angle range must be <= 360 degrees')\n        return tuple(np.rad2deg(self.set_xlim(left=left, right=right,\n                                              xmin=thetamin, xmax=thetamax)))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax",
      "name": "set_thetamax",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamax",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamax.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamax/thetamax",
          "name": "thetamax",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamax.thetamax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the maximum theta limit in degrees.",
      "docstring": "Set the maximum theta limit in degrees.",
      "code": "    def set_thetamax(self, thetamax):\n        \"\"\"Set the maximum theta limit in degrees.\"\"\"\n        self.viewLim.x1 = np.deg2rad(thetamax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin",
      "name": "set_thetamin",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamin",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamin.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_thetamin/thetamin",
          "name": "thetamin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_thetamin.thetamin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the minimum theta limit in degrees.",
      "docstring": "Set the minimum theta limit in degrees.",
      "code": "    def set_thetamin(self, thetamin):\n        \"\"\"Set the minimum theta limit in degrees.\"\"\"\n        self.viewLim.x0 = np.deg2rad(thetamin)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_xscale",
      "name": "set_xscale",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_xscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_xscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_xscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_xscale/scale",
          "name": "scale",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_xscale.scale",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_xscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_xscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_xscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_xscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_xscale(self, scale, *args, **kwargs):\n        if scale != 'linear':\n            raise NotImplementedError(\n                \"You can not set the xscale on a polar plot.\")"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim",
      "name": "set_ylim",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/bottom",
          "name": "bottom",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.bottom",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The bottom limit (default: None, which leaves the bottom\nlimit unchanged).\nThe bottom and top ylims may be passed as the tuple\n(*bottom*, *top*) as the first positional argument (or as\nthe *bottom* keyword argument)."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/top",
          "name": "top",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.top",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The top limit (default: None, which leaves the top limit\nunchanged)."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/emit",
          "name": "emit",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.emit",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool",
            "default_value": "True",
            "description": "Whether to notify observers of limit change."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/auto",
          "name": "auto",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.auto",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "bool or None",
            "default_value": "False",
            "description": "Whether to turn on autoscaling of the y-axis. True turns on,\nFalse turns off, None leaves unchanged."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "bool"
              },
              {
                "kind": "NamedType",
                "name": "None"
              }
            ]
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/ymin",
          "name": "ymin",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.ymin",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "These arguments are deprecated and will be removed in a future\nversion.  They are equivalent to *bottom* and *top* respectively,\nand it is an error to pass both *ymin* and *bottom* or\n*ymax* and *top*."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_ylim/ymax",
          "name": "ymax",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_ylim.ymax",
          "default_value": "None",
          "assigned_by": "NAME_ONLY",
          "is_public": true,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "These arguments are deprecated and will be removed in a future\nversion.  They are equivalent to *bottom* and *top* respectively,\nand it is an error to pass both *ymin* and *bottom* or\n*ymax* and *top*."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Set the data limits for the radial axis.",
      "docstring": "Set the data limits for the radial axis.\n\nParameters\n----------\nbottom : float, optional\n    The bottom limit (default: None, which leaves the bottom\n    limit unchanged).\n    The bottom and top ylims may be passed as the tuple\n    (*bottom*, *top*) as the first positional argument (or as\n    the *bottom* keyword argument).\n\ntop : float, optional\n    The top limit (default: None, which leaves the top limit\n    unchanged).\n\nemit : bool, default: True\n    Whether to notify observers of limit change.\n\nauto : bool or None, default: False\n    Whether to turn on autoscaling of the y-axis. True turns on,\n    False turns off, None leaves unchanged.\n\nymin, ymax : float, optional\n    These arguments are deprecated and will be removed in a future\n    version.  They are equivalent to *bottom* and *top* respectively,\n    and it is an error to pass both *ymin* and *bottom* or\n    *ymax* and *top*.\n\nReturns\n-------\nbottom, top : (float, float)\n    The new y-axis limits in data coordinates.",
      "code": "    def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 *, ymin=None, ymax=None):\n        \"\"\"\n        Set the data limits for the radial axis.\n\n        Parameters\n        ----------\n        bottom : float, optional\n            The bottom limit (default: None, which leaves the bottom\n            limit unchanged).\n            The bottom and top ylims may be passed as the tuple\n            (*bottom*, *top*) as the first positional argument (or as\n            the *bottom* keyword argument).\n\n        top : float, optional\n            The top limit (default: None, which leaves the top limit\n            unchanged).\n\n        emit : bool, default: True\n            Whether to notify observers of limit change.\n\n        auto : bool or None, default: False\n            Whether to turn on autoscaling of the y-axis. True turns on,\n            False turns off, None leaves unchanged.\n\n        ymin, ymax : float, optional\n            These arguments are deprecated and will be removed in a future\n            version.  They are equivalent to *bottom* and *top* respectively,\n            and it is an error to pass both *ymin* and *bottom* or\n            *ymax* and *top*.\n\n        Returns\n        -------\n        bottom, top : (float, float)\n            The new y-axis limits in data coordinates.\n        \"\"\"\n        if ymin is not None:\n            if bottom is not None:\n                raise ValueError('Cannot supply both positional \"bottom\" '\n                                 'argument and kwarg \"ymin\"')\n            else:\n                bottom = ymin\n        if ymax is not None:\n            if top is not None:\n                raise ValueError('Cannot supply both positional \"top\" '\n                                 'argument and kwarg \"ymax\"')\n            else:\n                top = ymax\n        if top is None and np.iterable(bottom):\n            bottom, top = bottom[0], bottom[1]\n        return super().set_ylim(bottom=bottom, top=top, emit=emit, auto=auto)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale",
      "name": "set_yscale",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/set_yscale/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.set_yscale.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_yscale(self, *args, **kwargs):\n        Axes.set_yscale(self, *args, **kwargs)\n        self.yaxis.set_major_locator(\n            self.RadialLocator(self.yaxis.get_major_locator(), self))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan",
      "name": "start_pan",
      "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/y",
          "name": "y",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarAxes/start_pan/button",
          "name": "button",
          "qname": "lib.matplotlib.projections.polar.PolarAxes.start_pan.button",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def start_pan(self, x, y, button):\n        angle = np.deg2rad(self.get_rlabel_position())\n        mode = ''\n        if button == 1:\n            epsilon = np.pi / 45.0\n            t, r = self.transData.inverted().transform((x, y))\n            if angle - epsilon <= t <= angle + epsilon:\n                mode = 'drag_r_labels'\n        elif button == 3:\n            mode = 'zoom'\n\n        self._pan_start = types.SimpleNamespace(\n            rmax=self.get_rmax(),\n            trans=self.transData.frozen(),\n            trans_inverse=self.transData.inverted().frozen(),\n            r_label_angle=self.get_rlabel_position(),\n            x=x,\n            y=y,\n            mode=mode)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__.axis",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/use_rmin",
          "name": "use_rmin",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__.use_rmin",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/__init__/_apply_theta_transforms",
          "name": "_apply_theta_transforms",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.__init__._apply_theta_transforms",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "The base polar transform.  This handles projection *theta* and\n*r* into Cartesian coordinate space *x* and *y*, but does not\nperform the ultimate affine transformation into the correct\nposition.",
      "docstring": "",
      "code": "    def __init__(self, axis=None, use_rmin=True,\n                 _apply_theta_transforms=True):\n        mtransforms.Transform.__init__(self)\n        self._axis = axis\n        self._use_rmin = use_rmin\n        self._apply_theta_transforms = _apply_theta_transforms"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/inverted",
      "name": "inverted",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.inverted",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/inverted/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.inverted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def inverted(self):\n        # docstring inherited\n        return PolarAxes.InvertedPolarTransform(self._axis, self._use_rmin,\n                                                self._apply_theta_transforms)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine",
      "name": "transform_non_affine",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_non_affine/tr",
          "name": "tr",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_non_affine.tr",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def transform_non_affine(self, tr):\n        # docstring inherited\n        t, r = np.transpose(tr)\n        # PolarAxes does not use the theta transforms here, but apply them for\n        # backwards-compatibility if not being used by it.\n        if self._apply_theta_transforms and self._axis is not None:\n            t *= self._axis.get_theta_direction()\n            t += self._axis.get_theta_offset()\n        if self._use_rmin and self._axis is not None:\n            r = (r - self._axis.get_rorigin()) * self._axis.get_rsign()\n        r = np.where(r >= 0, r, np.nan)\n        return np.column_stack([r * np.cos(t), r * np.sin(t)])"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine",
      "name": "transform_path_non_affine",
      "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_path_non_affine",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_path_non_affine.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/PolarTransform/transform_path_non_affine/path",
          "name": "path",
          "qname": "lib.matplotlib.projections.polar.PolarTransform.transform_path_non_affine.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def transform_path_non_affine(self, path):\n        # docstring inherited\n        if not len(path) or path._interpolation_steps == 1:\n            return Path(self.transform_non_affine(path.vertices), path.codes)\n        xys = []\n        codes = []\n        last_t = last_r = None\n        for trs, c in path.iter_segments():\n            trs = trs.reshape((-1, 2))\n            if c == Path.LINETO:\n                (t, r), = trs\n                if t == last_t:  # Same angle: draw a straight line.\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.append(Path.LINETO)\n                elif r == last_r:  # Same radius: draw an arc.\n                    # The following is complicated by Path.arc() being\n                    # \"helpful\" and unwrapping the angles, but we don't want\n                    # that behavior here.\n                    last_td, td = np.rad2deg([last_t, t])\n                    if self._use_rmin and self._axis is not None:\n                        r = ((r - self._axis.get_rorigin())\n                             * self._axis.get_rsign())\n                    if last_td <= td:\n                        while td - last_td > 360:\n                            arc = Path.arc(last_td, last_td + 360)\n                            xys.extend(arc.vertices[1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td += 360\n                        arc = Path.arc(last_td, td)\n                        xys.extend(arc.vertices[1:] * r)\n                        codes.extend(arc.codes[1:])\n                    else:\n                        # The reverse version also relies on the fact that all\n                        # codes but the first one are the same.\n                        while last_td - td > 360:\n                            arc = Path.arc(last_td - 360, last_td)\n                            xys.extend(arc.vertices[::-1][1:] * r)\n                            codes.extend(arc.codes[1:])\n                            last_td -= 360\n                        arc = Path.arc(td, last_td)\n                        xys.extend(arc.vertices[::-1][1:] * r)\n                        codes.extend(arc.codes[1:])\n                else:  # Interpolate.\n                    trs = cbook.simple_linear_interpolation(\n                        np.row_stack([(last_t, last_r), trs]),\n                        path._interpolation_steps)[1:]\n                    xys.extend(self.transform_non_affine(trs))\n                    codes.extend([Path.LINETO] * len(trs))\n            else:  # Not a straight line.\n                xys.extend(self.transform_non_affine(trs))\n                codes.extend([c] * len(trs))\n            last_t, last_r = trs[-1]\n        return Path(xys, codes)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial Axis.\n\nThis overrides certain properties of a `.YAxis` to provide special-casing\nfor a radial axis.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.sticky_edges.y.append(0)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/cla",
      "name": "cla",
      "qname": "lib.matplotlib.projections.polar.RadialAxis.cla",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialAxis/cla/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialAxis.cla.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def cla(self):\n        super().cla()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self):\n        show_all = True\n        # Ensure previous behaviour with full circle non-annular views.\n        if self._axes:\n            if _is_full_circle_rad(*self._axes.viewLim.intervalx):\n                rorigin = self._axes.get_rorigin() * self._axes.get_rsign()\n                if self._axes.get_rmin() <= rorigin:\n                    show_all = False\n        if show_all:\n            return self.base()\n        else:\n            return [tick for tick in self.base() if tick > rorigin]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__/base",
          "name": "base",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__.base",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/__init__/axes",
          "name": "axes",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.__init__.axes",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate radius ticks.\n\nEnsures that all ticks are strictly positive.  For all other\ntasks, it delegates to the base\n:class:`~matplotlib.ticker.Locator` (which may be different\ndepending on the scale of the *r*-axis.",
      "docstring": "",
      "code": "    def __init__(self, base, axes=None):\n        self.base = base\n        self._axes = axes"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/autoscale",
      "name": "autoscale",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.autoscale",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/autoscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.autoscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        return self.base.autoscale()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular",
      "name": "nonsingular",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/nonsingular/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.nonsingular.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def nonsingular(self, vmin, vmax):\n        # docstring inherited\n        return ((0, 1) if (vmin, vmax) == (-np.inf, np.inf)  # Init. limits.\n                else self.base.nonsingular(vmin, vmax))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/pan",
      "name": "pan",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.pan",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/pan/numsteps",
          "name": "numsteps",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.pan.numsteps",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def pan(self, numsteps):\n        return self.base.pan(numsteps)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/refresh",
      "name": "refresh",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.refresh",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/refresh/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.refresh.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def refresh(self):\n        # docstring inherited\n        return self.base.refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits",
      "name": "view_limits",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/view_limits/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.view_limits.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def view_limits(self, vmin, vmax):\n        vmin, vmax = self.base.view_limits(vmin, vmax)\n        if vmax > vmin:\n            # this allows inverted r/y-lims\n            vmin = min(0, vmin)\n        return mtransforms.nonsingular(vmin, vmax)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.projections.polar.RadialLocator.zoom",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialLocator/zoom/direction",
          "name": "direction",
          "qname": "lib.matplotlib.projections.polar.RadialLocator.zoom.direction",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def zoom(self, direction):\n        return self.base.zoom(direction)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.RadialTick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialTick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.RadialTick.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.RadialTick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A radial-axis tick.\n\nThis subclass of `.YTick` provides radial ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\naxes limits.  This results in ticks that are correctly perpendicular to\nthe spine. Labels are also rotated to be perpendicular to the spine, when\n'auto' rotation is enabled.",
      "docstring": "",
      "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.label1.set_rotation_mode('anchor')\n        self.label2.set_rotation_mode('anchor')"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.projections.polar.RadialTick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.RadialTick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/RadialTick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.projections.polar.RadialTick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        thetamin = axes.get_thetamin()\n        thetamax = axes.get_thetamax()\n        direction = axes.get_theta_direction()\n        offset_rad = axes.get_theta_offset()\n        offset = np.rad2deg(offset_rad)\n        full = _is_full_circle_deg(thetamin, thetamax)\n\n        if full:\n            angle = (axes.get_rlabel_position() * direction +\n                     offset) % 360 - 90\n            tick_angle = 0\n        else:\n            angle = (thetamin * direction + offset) % 360 - 90\n            if direction > 0:\n                tick_angle = np.deg2rad(angle)\n            else:\n                tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        if full:\n            ha = self.label1.get_horizontalalignment()\n            va = self.label1.get_verticalalignment()\n        else:\n            ha, va = self._determine_anchor(mode, angle, direction > 0)\n        self.label1.set_horizontalalignment(ha)\n        self.label1.set_verticalalignment(va)\n        self.label1.set_rotation(text_angle)\n\n        marker = self.tick1line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        if full:\n            self.label2.set_visible(False)\n            self.tick2line.set_visible(False)\n        angle = (thetamax * direction + offset) % 360 - 90\n        if direction > 0:\n            tick_angle = np.deg2rad(angle)\n        else:\n            tick_angle = np.deg2rad(angle + 180)\n        text_angle = (angle + 90) % 180 - 90  # between -90 and +90.\n        mode, user_angle = self._labelrotation\n        if mode == 'auto':\n            text_angle += user_angle\n        else:\n            text_angle = user_angle\n\n        ha, va = self._determine_anchor(mode, angle, direction < 0)\n        self.label2.set_ha(ha)\n        self.label2.set_va(va)\n        self.label2.set_rotation(text_angle)\n\n        marker = self.tick2line.get_marker()\n        if marker == mmarkers.TICKLEFT:\n            trans = mtransforms.Affine2D().rotate(tick_angle)\n        elif marker == '_':\n            trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / 2)\n        elif marker == mmarkers.TICKRIGHT:\n            trans = mtransforms.Affine2D().scale(-1, 1).rotate(tick_angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/cla",
      "name": "cla",
      "qname": "lib.matplotlib.projections.polar.ThetaAxis.cla",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaAxis/cla/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaAxis.cla.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def cla(self):\n        super().cla()\n        self.set_ticks_position('none')\n        self._wrap_locator_formatter()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__/x",
          "name": "x",
          "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaFormatter/__call__/pos",
          "name": "pos",
          "qname": "lib.matplotlib.projections.polar.ThetaFormatter.__call__.pos",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self, x, pos=None):\n        vmin, vmax = self.axis.get_view_interval()\n        d = np.rad2deg(abs(vmax - vmin))\n        digits = max(-int(np.log10(d) - 1.5), 0)\n        # Use unicode rather than mathtext with \\circ, so that it will work\n        # correctly with any arbitrary font (assuming it has a degree sign),\n        # whereas $5\\circ$ will only work correctly with one of the supported\n        # math fonts (Computer Modern and STIX).\n        return (\"{value:0.{digits:d}f}\\N{DEGREE SIGN}\"\n                .format(value=np.rad2deg(x), digits=digits))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__call__",
      "name": "__call__",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.__call__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__call__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.__call__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __call__(self):\n        lim = self.axis.get_view_interval()\n        if _is_full_circle_deg(lim[0], lim[1]):\n            return np.arange(8) * 2 * np.pi / 8\n        else:\n            return np.deg2rad(self.base())"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/__init__/base",
          "name": "base",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.__init__.base",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Used to locate theta ticks.\n\nThis will work the same as the base locator except in the case that the\nview spans the entire circle. In such cases, the previously used default\nlocations of every 45 degrees are returned.",
      "docstring": "",
      "code": "    def __init__(self, base):\n        self.base = base\n        self.axis = self.base.axis = _AxisWrapper(self.base.axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/autoscale",
      "name": "autoscale",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.autoscale",
      "decorators": [
        "cbook.deprecated('3.2')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/autoscale/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.autoscale.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.2\")\n    def autoscale(self):\n        return self.base.autoscale()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/pan",
      "name": "pan",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.pan",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/pan/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.pan.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/pan/numsteps",
          "name": "numsteps",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.pan.numsteps",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def pan(self, numsteps):\n        return self.base.pan(numsteps)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/refresh",
      "name": "refresh",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.refresh",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/refresh/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.refresh.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def refresh(self):\n        # docstring inherited\n        return self.base.refresh()"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis",
      "name": "set_axis",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.set_axis",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.set_axis.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/set_axis/axis",
          "name": "axis",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.set_axis.axis",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def set_axis(self, axis):\n        self.axis = _AxisWrapper(axis)\n        self.base.set_axis(self.axis)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits",
      "name": "view_limits",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits/vmin",
          "name": "vmin",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits.vmin",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/view_limits/vmax",
          "name": "vmax",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.view_limits.vmax",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def view_limits(self, vmin, vmax):\n        vmin, vmax = np.rad2deg((vmin, vmax))\n        return np.deg2rad(self.base.view_limits(vmin, vmax))"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/zoom",
      "name": "zoom",
      "qname": "lib.matplotlib.projections.polar.ThetaLocator.zoom",
      "decorators": [
        "cbook.deprecated('3.3')"
      ],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/zoom/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.zoom.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaLocator/zoom/direction",
          "name": "direction",
          "qname": "lib.matplotlib.projections.polar.ThetaLocator.zoom.direction",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @cbook.deprecated(\"3.3\")\n    def zoom(self, direction):\n        return self.base.zoom(direction)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/axes",
          "name": "axes",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.axes",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/args",
          "name": "args",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.args",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/__init__/kwargs",
          "name": "kwargs",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.__init__.kwargs",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A theta-axis tick.\n\nThis subclass of `.XTick` provides angular ticks with some small\nmodification to their re-positioning such that ticks are rotated based on\ntick location. This results in ticks that are correctly perpendicular to\nthe arc spine.\n\nWhen 'auto' rotation is enabled, labels are also rotated to be parallel to\nthe spine. The label padding is also applied here since it's not possible\nto use a generic axes transform to produce tick-specific padding.",
      "docstring": "",
      "code": "    def __init__(self, axes, *args, **kwargs):\n        self._text1_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        self._text2_translate = mtransforms.ScaledTranslation(\n            0, 0, axes.figure.dpi_scale_trans)\n        super().__init__(axes, *args, **kwargs)\n        self.label1.set(\n            rotation_mode='anchor',\n            transform=self.label1.get_transform() + self._text1_translate)\n        self.label2.set(\n            rotation_mode='anchor',\n            transform=self.label2.get_transform() + self._text2_translate)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position",
      "name": "update_position",
      "qname": "lib.matplotlib.projections.polar.ThetaTick.update_position",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.update_position.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections.polar/ThetaTick/update_position/loc",
          "name": "loc",
          "qname": "lib.matplotlib.projections.polar.ThetaTick.update_position.loc",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def update_position(self, loc):\n        super().update_position(loc)\n        axes = self.axes\n        angle = loc * axes.get_theta_direction() + axes.get_theta_offset()\n        text_angle = np.rad2deg(angle) % 360 - 90\n        angle -= np.pi / 2\n\n        marker = self.tick1line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick1line._marker._transform\n        self.tick1line._marker._transform = trans\n\n        marker = self.tick2line.get_marker()\n        if marker in (mmarkers.TICKUP, '|'):\n            trans = mtransforms.Affine2D().scale(1, 1).rotate(angle)\n        elif marker == mmarkers.TICKDOWN:\n            trans = mtransforms.Affine2D().scale(1, -1).rotate(angle)\n        else:\n            # Don't modify custom tick line markers.\n            trans = self.tick2line._marker._transform\n        self.tick2line._marker._transform = trans\n\n        mode, user_angle = self._labelrotation\n        if mode == 'default':\n            text_angle = user_angle\n        else:\n            if text_angle > 90:\n                text_angle -= 180\n            elif text_angle < -90:\n                text_angle += 180\n            text_angle += user_angle\n        self.label1.set_rotation(text_angle)\n        self.label2.set_rotation(text_angle)\n\n        # This extra padding helps preserve the look from previous releases but\n        # is also needed because labels are anchored to their center.\n        pad = self._pad + 7\n        self._update_padding(pad,\n                             self._loc * axes.get_theta_direction() +\n                             axes.get_theta_offset())"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/__init__",
      "name": "__init__",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/__init__/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "A mapping of registered projection names to projection classes.",
      "docstring": "",
      "code": "    def __init__(self):\n        self._all_projection_types = {}"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class",
      "name": "get_projection_class",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_class",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_class.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_class/name",
          "name": "name",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_class.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get a projection class from its *name*.",
      "docstring": "Get a projection class from its *name*.",
      "code": "    def get_projection_class(self, name):\n        \"\"\"Get a projection class from its *name*.\"\"\"\n        return self._all_projection_types[name]"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_names",
      "name": "get_projection_names",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_names",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/get_projection_names/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.get_projection_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Return the names of all projections currently registered.",
      "docstring": "Return the names of all projections currently registered.",
      "code": "    def get_projection_names(self):\n        \"\"\"Return the names of all projections currently registered.\"\"\"\n        return sorted(self._all_projection_types)"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register",
      "name": "register",
      "qname": "lib.matplotlib.projections.ProjectionRegistry.register",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register/self",
          "name": "self",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.register.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "matplotlib/lib.matplotlib.projections/ProjectionRegistry/register/projections",
          "name": "projections",
          "qname": "lib.matplotlib.projections.ProjectionRegistry.register.projections",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Register a new set of projections.",
      "docstring": "Register a new set of projections.",
      "code": "    def register(self, *projections):\n        \"\"\"Register a new set of projections.\"\"\"\n        for projection in projections:\n            name = projection.name\n            self._all_projection_types[name] = projection"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/get_projection_class",
      "name": "get_projection_class",
      "qname": "lib.matplotlib.projections.get_projection_class",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/get_projection_class/projection",
          "name": "projection",
          "qname": "lib.matplotlib.projections.get_projection_class.projection",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "Get a projection class from its name.\n\nIf *projection* is None, a standard rectilinear projection is returned.",
      "docstring": "Get a projection class from its name.\n\nIf *projection* is None, a standard rectilinear projection is returned.",
      "code": "def get_projection_class(projection=None):\n    \"\"\"\n    Get a projection class from its name.\n\n    If *projection* is None, a standard rectilinear projection is returned.\n    \"\"\"\n    if projection is None:\n        projection = 'rectilinear'\n\n    try:\n        return projection_registry.get_projection_class(projection)\n    except KeyError as err:\n        raise ValueError(\"Unknown projection %r\" % projection) from err"
    },
    {
      "id": "matplotlib/lib.matplotlib.projections/register_projection",
      "name": "register_projection",
      "qname": "lib.matplotlib.projections.register_projection",
      "decorators": [],
      "parameters": [
        {
          "id": "matplotlib/lib.matplotlib.projections/register_projection/cls",
          "name": "cls",
          "qname": "lib.matplotlib.projections.register_projection.cls",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": true,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": true,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def register_projection(cls):\n    projection_registry.register(cls)"
    }
  ]
}