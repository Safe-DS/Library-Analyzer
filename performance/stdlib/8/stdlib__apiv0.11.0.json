{
  "schemaVersion": 1,
  "distribution": "",
  "package": "stdlib",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column",
      "name": "Column",
      "qname": "safeds.data.tabular.containers._column.Column",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._column/Column/__init__",
        "stdlib/safeds.data.tabular.containers._column/Column/__eq__",
        "stdlib/safeds.data.tabular.containers._column/Column/__getitem__",
        "stdlib/safeds.data.tabular.containers._column/Column/__hash__",
        "stdlib/safeds.data.tabular.containers._column/Column/__iter__",
        "stdlib/safeds.data.tabular.containers._column/Column/__len__",
        "stdlib/safeds.data.tabular.containers._column/Column/__repr__",
        "stdlib/safeds.data.tabular.containers._column/Column/__str__",
        "stdlib/safeds.data.tabular.containers._column/Column/name@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/n_rows@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/type@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values",
        "stdlib/safeds.data.tabular.containers._column/Column/get_value",
        "stdlib/safeds.data.tabular.containers._column/Column/all",
        "stdlib/safeds.data.tabular.containers._column/Column/any",
        "stdlib/safeds.data.tabular.containers._column/Column/none",
        "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values",
        "stdlib/safeds.data.tabular.containers._column/Column/rename",
        "stdlib/safeds.data.tabular.containers._column/Column/correlation_with",
        "stdlib/safeds.data.tabular.containers._column/Column/idness",
        "stdlib/safeds.data.tabular.containers._column/Column/maximum",
        "stdlib/safeds.data.tabular.containers._column/Column/mean",
        "stdlib/safeds.data.tabular.containers._column/Column/median",
        "stdlib/safeds.data.tabular.containers._column/Column/minimum",
        "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio",
        "stdlib/safeds.data.tabular.containers._column/Column/mode",
        "stdlib/safeds.data.tabular.containers._column/Column/stability",
        "stdlib/safeds.data.tabular.containers._column/Column/standard_deviation",
        "stdlib/safeds.data.tabular.containers._column/Column/sum",
        "stdlib/safeds.data.tabular.containers._column/Column/variance",
        "stdlib/safeds.data.tabular.containers._column/Column/plot_boxplot",
        "stdlib/safeds.data.tabular.containers._column/Column/plot_histogram",
        "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_",
        "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A column is a named collection of values.",
      "docstring": "A column is a named collection of values.\n\nParameters\n----------\nname : str\n    The name of the column.\ndata : Iterable\n    The data.\ntype_ : Optional[ColumnType]\n    The type of the column. If not specified, the type will be inferred from the data.",
      "code": "class Column:\n    \"\"\"\n    A column is a named collection of values.\n\n    Parameters\n    ----------\n    name : str\n        The name of the column.\n    data : Iterable\n        The data.\n    type_ : Optional[ColumnType]\n        The type of the column. If not specified, the type will be inferred from the data.\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(self, name: str, data: Iterable, type_: ColumnType | None = None) -> None:\n        self._name: str = name\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        # noinspection PyProtectedMember\n        self._type: ColumnType = type_ if type_ is not None else ColumnType._from_numpy_data_type(self._data.dtype)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Column):\n            return NotImplemented\n        if self is other:\n            return True\n        return self.name == other.name and self._data.equals(other._data)\n\n    def __getitem__(self, index: int) -> Any:\n        return self.get_value(index)\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)\n\n    def __len__(self) -> int:\n        return len(self._data)\n\n    def __repr__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__str__()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of the column.\n\n        Returns\n        -------\n        name : str\n            The name of the column.\n        \"\"\"\n        return self._name\n\n    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of elements in the column.\n\n        Returns\n        -------\n        n_rows : int\n            The number of elements.\n        \"\"\"\n        return len(self._data)\n\n    @property\n    def type(self) -> ColumnType:\n        \"\"\"\n        Return the type of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n        \"\"\"\n        return self._type\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Getters\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def get_unique_values(self) -> list[Any]:\n        \"\"\"\n        Return a list of all unique values in the column.\n\n        Returns\n        -------\n        unique_values : list[any]\n            List of unique values in the column.\n        \"\"\"\n        return list(self._data.unique())\n\n    def get_value(self, index: int) -> Any:\n        \"\"\"\n        Return column value at specified index, starting at 0.\n\n        Parameters\n        ----------\n        index : int\n            Index of requested element.\n\n        Returns\n        -------\n        value\n            Value at index in column.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If the given index does not exist in the column.\n        \"\"\"\n        if index < 0 or index >= self._data.size:\n            raise IndexOutOfBoundsError(index)\n\n        return self._data[index]\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Information\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def all(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if all values have a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if all match.\n\n        \"\"\"\n        return all(predicate(value) for value in self._data)\n\n    def any(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if any value has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if any match.\n\n        \"\"\"\n        return any(predicate(value) for value in self._data)\n\n    def none(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if no values has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if none match.\n\n        \"\"\"\n        return all(not predicate(value) for value in self._data)\n\n    def has_missing_values(self) -> bool:\n        \"\"\"\n        Return whether the column has missing values.\n\n        Returns\n        -------\n        missing_values_exist : bool\n            True if missing values exist.\n        \"\"\"\n        return self.any(lambda value: value is None or (isinstance(value, Number) and np.isnan(value)))\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Transformations\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def rename(self, new_name: str) -> Column:\n        \"\"\"\n        Return a new column with a new name.\n\n        Parameters\n        ----------\n        new_name : str\n            The new name of the column.\n\n        Returns\n        -------\n        column : Column\n            A new column with the new name.\n        \"\"\"\n        return Column(new_name, self._data, self._type)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Statistics\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def correlation_with(self, other_column: Column) -> float:\n        \"\"\"\n        Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\n        Returns\n        -------\n        correlation : float\n            Correlation between the two columns.\n\n        Raises\n        ------\n        TypeError\n            If one of the columns is not numerical.\n        \"\"\"\n        if not self._type.is_numeric() or not other_column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"Columns must be numerical. {self.name} is {self._type}, \"\n                f\"{other_column.name} is {other_column._type}.\",\n            )\n        if self._data.size != other_column._data.size:\n            raise ColumnLengthMismatchError(\n                f\"{self.name} is of size {self._data.size}, \"\n                f\"{other_column.name} is of size {other_column._data.size}.\",\n            )\n        return self._data.corr(other_column._data)\n\n    def idness(self) -> float:\n        r\"\"\"\n        Calculate the idness of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of different values}}{\\text{number of rows}}\n        $$\n\n        Returns\n        -------\n        idness : float\n            The idness of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If this column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.nunique() / self._data.size\n\n    def maximum(self) -> float:\n        \"\"\"\n        Return the maximum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        max : float\n            The maximum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.max()\n\n    def mean(self) -> float:\n        \"\"\"\n        Return the mean value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        mean : float\n            The mean value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.mean()\n\n    def median(self) -> float:\n        \"\"\"\n        Return the median value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        median : float\n            The median value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.median()\n\n    def minimum(self) -> float:\n        \"\"\"\n        Return the minimum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        min : float\n            The minimum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.min()\n\n    def missing_value_ratio(self) -> float:\n        \"\"\"\n        Return the ratio of null values to the total number of elements in the column.\n\n        Returns\n        -------\n        ratio : float\n            The ratio of null values to the total number of elements in the column.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._count_missing_values() / self._data.size\n\n    def mode(self) -> Any:\n        \"\"\"\n        Return the mode of the column.\n\n        Returns\n        -------\n        List :\n            Returns a list with the most common values.\n        \"\"\"\n        return self._data.mode().tolist()\n\n    def stability(self) -> float:\n        r\"\"\"\n        Calculate the stability of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n        $$\n\n        Returns\n        -------\n        stability : float\n            The stability of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If the column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.value_counts()[self.mode()[0]] / self._data.count()\n\n    def standard_deviation(self) -> float:\n        \"\"\"\n        Return the standard deviation of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The standard deviation of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.std()\n\n    def sum(self) -> float:\n        \"\"\"\n        Return the sum of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The sum of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.sum()\n\n    def variance(self) -> float:\n        \"\"\"\n        Return the variance of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The variance of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n\n        return self._data.var()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Plotting\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def plot_boxplot(self) -> Image:\n        \"\"\"\n        Plot this column in a boxplot. This function can only plot real numerical data.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        TypeError\n            If the column contains non-numerical data or complex data.\n        \"\"\"\n        for data in self._data:\n            if not isinstance(data, int) and not isinstance(data, float) and not isinstance(data, complex):\n                raise NonNumericColumnError(self.name)\n            if isinstance(data, complex):\n                raise TypeError(\n                    \"The column contains complex data. Boxplots cannot plot the imaginary part of complex \"\n                    \"data. Please provide a Column with only real numbers\",\n                )\n\n        fig = plt.figure()\n        ax = sns.boxplot(data=self._data)\n        ax.set(xlabel=self.name)\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)\n\n    def plot_histogram(self) -> Image:\n        \"\"\"\n        Plot a column in a histogram.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        fig = plt.figure()\n        ax = sns.histplot(data=self._data)\n        ax.set_xticks(ax.get_xticks())\n        ax.set(xlabel=self.name)\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Other\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _count_missing_values(self) -> int:\n        \"\"\"\n        Return the number of null values in the column.\n\n        Returns\n        -------\n        count : int\n            The number of null values.\n        \"\"\"\n        return self._data.isna().sum()",
      "instance_attributes": [
        {
          "name": "_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_type",
          "types": {
            "kind": "NamedType",
            "name": "ColumnType"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row",
      "name": "Row",
      "qname": "safeds.data.tabular.containers._row.Row",
      "decorators": [],
      "superclasses": [
        "Mapping[str, Any]"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.containers._row/Row/from_dict",
        "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe",
        "stdlib/safeds.data.tabular.containers._row/Row/__init__",
        "stdlib/safeds.data.tabular.containers._row/Row/__contains__",
        "stdlib/safeds.data.tabular.containers._row/Row/__eq__",
        "stdlib/safeds.data.tabular.containers._row/Row/__getitem__",
        "stdlib/safeds.data.tabular.containers._row/Row/__iter__",
        "stdlib/safeds.data.tabular.containers._row/Row/__len__",
        "stdlib/safeds.data.tabular.containers._row/Row/__repr__",
        "stdlib/safeds.data.tabular.containers._row/Row/__str__",
        "stdlib/safeds.data.tabular.containers._row/Row/column_names@getter",
        "stdlib/safeds.data.tabular.containers._row/Row/n_columns@getter",
        "stdlib/safeds.data.tabular.containers._row/Row/schema@getter",
        "stdlib/safeds.data.tabular.containers._row/Row/get_value",
        "stdlib/safeds.data.tabular.containers._row/Row/has_column",
        "stdlib/safeds.data.tabular.containers._row/Row/get_column_type",
        "stdlib/safeds.data.tabular.containers._row/Row/to_dict",
        "stdlib/safeds.data.tabular.containers._row/Row/_repr_html_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A row is a collection of named values.",
      "docstring": "A row is a collection of named values.\n\nParameters\n----------\ndata : Mapping[str, Any] | None\n    The data. If None, an empty row is created.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})",
      "code": "class Row(Mapping[str, Any]):\n    \"\"\"\n    A row is a collection of named values.\n\n    Parameters\n    ----------\n    data : Mapping[str, Any] | None\n        The data. If None, an empty row is created.\n\n    Examples\n    --------\n    >>> from safeds.data.tabular.containers import Row\n    >>> row = Row({\"a\": 1, \"b\": 2})\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Creation\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def from_dict(data: dict[str, Any]) -> Row:\n        \"\"\"\n        Create a row from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, Any]\n            The data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row.from_dict({\"a\": 1, \"b\": 2})\n        \"\"\"\n        return Row(data)\n\n    @staticmethod\n    def _from_polars_dataframe(data: pl.DataFrame, schema: Schema | None = None) -> Row:\n        \"\"\"\n        Create a row from a `polars.DataFrame`.\n\n        Parameters\n        ----------\n        data : polars.DataFrame\n            The data.\n        schema : Schema | None\n            The schema. If None, the schema is inferred from the data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> import polars as pl\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row._from_polars_dataframe(pl.DataFrame({\"a\": [1], \"b\": [2]}))\n        \"\"\"\n        result = object.__new__(Row)\n        result._data = data\n\n        if schema is None:\n            # noinspection PyProtectedMember\n            result._schema = Schema._from_polars_dataframe(data)\n        else:\n            result._schema = schema\n\n        return result\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(self, data: Mapping[str, Any] | None = None):\n        \"\"\"\n        Create a row from a mapping of column names to column values.\n\n        Parameters\n        ----------\n        data : Mapping[str, Any] | None\n            The data. If None, an empty row is created.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        \"\"\"\n        if data is None:\n            data = {}\n\n        self._data: pl.DataFrame = pl.DataFrame(data)\n        # noinspection PyProtectedMember\n        self._schema: Schema = Schema._from_polars_dataframe(self._data)\n\n    def __contains__(self, obj: Any) -> bool:\n        \"\"\"\n        Check whether the row contains an object as key.\n\n        Parameters\n        ----------\n        obj : Any\n            The object.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the object as key, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> \"a\" in row\n        True\n\n        >>> \"c\" in row\n        False\n        \"\"\"\n        return isinstance(obj, str) and self.has_column(obj)\n\n    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Check whether this row is equal to another object.\n\n        Parameters\n        ----------\n        other : Any\n            The other object.\n\n        Returns\n        -------\n        equal : bool\n            True if the other object is an identical row. False if the other object is a different row. NotImplemented\n            if the other object is not a row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row1 = Row({\"a\": 1, \"b\": 2})\n        >>> row2 = Row({\"a\": 1, \"b\": 2})\n        >>> row1 == row2\n        True\n\n        >>> row3 = Row({\"a\": 1, \"b\": 3})\n        >>> row1 == row3\n        False\n        \"\"\"\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._schema == other._schema and self._data.frame_equal(other._data)\n\n    def __getitem__(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row[\"a\"]\n        1\n        \"\"\"\n        return self.get_value(column_name)\n\n    def __iter__(self) -> Iterator[Any]:\n        \"\"\"\n        Create an iterator for the column names of this row.\n\n        Returns\n        -------\n        iterator : Iterator[Any]\n            The iterator.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> list(row)\n        ['a', 'b']\n        \"\"\"\n        return iter(self.column_names)\n\n    def __len__(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> len(row)\n        2\n        \"\"\"\n        return self._data.width\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return an unambiguous string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> repr(row)\n        \"Row({'a': 1})\"\n        \"\"\"\n        return f\"Row({str(self)})\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Return a user-friendly string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> str(row)\n        \"{'a': 1}\"\n        \"\"\"\n        match len(self):\n            case 0:\n                return \"{}\"\n            case 1:\n                return str(self.to_dict())\n            case _:\n                lines = (f\"    {name!r}: {value!r}\" for name, value in self.to_dict().items())\n                joined = \",\\n\".join(lines)\n                return f\"{{\\n{joined}\\n}}\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in the row.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.column_names\n        ['a', 'b']\n        \"\"\"\n        return self._schema.column_names\n\n    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.n_columns\n        2\n        \"\"\"\n        return self._data.width\n\n    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the row.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> schema = row.schema\n        \"\"\"\n        return self._schema\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Getters\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def get_value(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_value(\"a\")\n        1\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n\n        return self._data[0, column_name]\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Check whether the row contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the column, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.has_column(\"a\")\n        True\n\n        >>> row.has_column(\"c\")\n        False\n        \"\"\"\n        return self._schema.has_column(column_name)\n\n    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_column_type(\"a\")\n        Integer\n        \"\"\"\n        return self._schema.get_column_type(column_name)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Conversion\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, Any]\n            Dictionary representation of the row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.to_dict()\n        {'a': 1, 'b': 2}\n        \"\"\"\n        return {column_name: self.get_value(column_name) for column_name in self.column_names}\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _repr_html_(self) -> str:\n        \"\"\"\n        Return an HTML representation of the row.\n\n        Returns\n        -------\n        output : str\n            The generated HTML.\n        \"\"\"\n        # noinspection PyProtectedMember\n        return self._data._repr_html_()",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_schema",
          "types": {
            "kind": "NamedType",
            "name": "Schema"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table",
      "name": "Table",
      "qname": "safeds.data.tabular.containers._table.Table",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._table/Table/from_csv_file",
        "stdlib/safeds.data.tabular.containers._table/Table/from_json_file",
        "stdlib/safeds.data.tabular.containers._table/Table/from_dict",
        "stdlib/safeds.data.tabular.containers._table/Table/from_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/from_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/__init__",
        "stdlib/safeds.data.tabular.containers._table/Table/__eq__",
        "stdlib/safeds.data.tabular.containers._table/Table/__hash__",
        "stdlib/safeds.data.tabular.containers._table/Table/__repr__",
        "stdlib/safeds.data.tabular.containers._table/Table/__str__",
        "stdlib/safeds.data.tabular.containers._table/Table/column_names@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/n_columns@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/n_rows@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/schema@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/get_column",
        "stdlib/safeds.data.tabular.containers._table/Table/has_column",
        "stdlib/safeds.data.tabular.containers._table/Table/get_column_type",
        "stdlib/safeds.data.tabular.containers._table/Table/get_row",
        "stdlib/safeds.data.tabular.containers._table/Table/summary",
        "stdlib/safeds.data.tabular.containers._table/Table/add_column",
        "stdlib/safeds.data.tabular.containers._table/Table/add_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/add_row",
        "stdlib/safeds.data.tabular.containers._table/Table/add_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/filter_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_missing_values",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_non_numerical_values",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_duplicate_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_missing_values",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_outliers",
        "stdlib/safeds.data.tabular.containers._table/Table/rename_column",
        "stdlib/safeds.data.tabular.containers._table/Table/replace_column",
        "stdlib/safeds.data.tabular.containers._table/Table/shuffle_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/slice_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/sort_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/sort_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/split",
        "stdlib/safeds.data.tabular.containers._table/Table/tag_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/transform_column",
        "stdlib/safeds.data.tabular.containers._table/Table/plot_correlation_heatmap",
        "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot",
        "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot",
        "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file",
        "stdlib/safeds.data.tabular.containers._table/Table/to_json_file",
        "stdlib/safeds.data.tabular.containers._table/Table/to_dict",
        "stdlib/safeds.data.tabular.containers._table/Table/to_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/to_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_",
        "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\nTo create a `Table`, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "docstring": "A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\nTo create a `Table`, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "code": "class Table:\n    \"\"\"\n    A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\n    To create a `Table`, use one of the following static methods:\n\n    | Method                                                                       | Description                            |\n    | ---------------------------------------------------------------------------- | -------------------------------------- |\n    | [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n    | [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n    | [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n    | [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n    | [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Creation\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def from_csv_file(path: str) -> Table:\n        \"\"\"\n        Read data from a CSV file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the CSV file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the CSV file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_csv(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n\n    @staticmethod\n    def from_json_file(path: str) -> Table:\n        \"\"\"\n        Read data from a JSON file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the JSON file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the JSON file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_json(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n\n    @staticmethod\n    def from_dict(data: dict[str, list[Any]]) -> Table:\n        \"\"\"\n        Create a table from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, list[Any]]\n            The data.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If columns have different lengths.\n        \"\"\"\n        # Validation\n        expected_length: int | None = None\n        for column_values in data.values():\n            if expected_length is None:\n                expected_length = len(column_values)\n            elif len(column_values) != expected_length:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column_name}: {len(column_values)}\" for column_name, column_values in data.items()),\n                )\n\n        # Implementation\n        dataframe: DataFrame = pd.DataFrame()\n        for column_name, column_values in data.items():\n            dataframe[column_name] = column_values\n        return Table(dataframe)\n\n    @staticmethod\n    def from_columns(columns: list[Column]) -> Table:\n        \"\"\"\n        Return a table created from a list of columns.\n\n        Parameters\n        ----------\n        columns : list[Column]\n            The columns to be combined. They need to have the same size.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If any of the column sizes does not match with the others.\n        \"\"\"\n        dataframe: DataFrame = pd.DataFrame()\n\n        for column in columns:\n            if column._data.size != columns[0]._data.size:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column.name}: {column._data.size}\" for column in columns),\n                )\n            dataframe[column.name] = column._data\n\n        return Table(dataframe)\n\n    @staticmethod\n    def from_rows(rows: list[Row]) -> Table:\n        \"\"\"\n        Return a table created from a list of rows.\n\n        Parameters\n        ----------\n        rows : list[Row]\n            The rows to be combined. They need to have a matching schema.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        SchemaMismatchError\n            If any of the row schemas does not match with the others.\n        \"\"\"\n        if len(rows) == 0:\n            raise MissingDataError(\"This function requires at least one row.\")\n\n        schema_compare: Schema = rows[0]._schema\n        row_array: list[pd.DataFrame] = []\n\n        for row in rows:\n            if schema_compare != row._schema:\n                raise SchemaMismatchError\n            row_array.append(row._data.to_pandas())\n\n        dataframe: DataFrame = pd.concat(row_array, ignore_index=True)\n        dataframe.columns = schema_compare.column_names\n        return Table(dataframe)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(self, data: Iterable, schema: Schema | None = None):\n        \"\"\"\n        Create a table from a `DataFrame`.\n\n        You should not use this constructor directly. Instead, use one of the following static methods:\n\n        | Method                                                                       | Description                            |\n        | ---------------------------------------------------------------------------- | -------------------------------------- |\n        | [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n        | [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n        | [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n        | [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n        | [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |\n        \"\"\"\n        self._data: pd.DataFrame = data if isinstance(data, pd.DataFrame) else pd.DataFrame(data)\n        self._schema: Schema = Schema._from_pandas_dataframe(self._data) if schema is None else schema\n\n        if self._data.empty:\n            self._data = pd.DataFrame(columns=self._schema.column_names)\n\n        self._data = self._data.reset_index(drop=True)\n        self._data.columns = self._schema.column_names\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Table):\n            return NotImplemented\n        if self is other:\n            return True\n        table1 = self.sort_columns()\n        table2 = other.sort_columns()\n        return table1._data.equals(table2._data) and table1._schema == table2._schema\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def __repr__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__str__()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in this table.\n\n        Alias for self.schema.column_names -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The list of the column names.\n        \"\"\"\n        return self._schema.column_names\n\n    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n        \"\"\"\n        return self._data.shape[1]\n\n    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of rows.\n\n        Returns\n        -------\n        n_rows : int\n            The number of rows.\n        \"\"\"\n        return self._data.shape[0]\n\n    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the table.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        return self._schema\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Getters\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def get_column(self, column_name: str) -> Column:\n        \"\"\"\n        Return a column with the data of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        column : Column\n            The column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if self._schema.has_column(column_name):\n            output_column = Column(\n                column_name,\n                self._data.iloc[:, [self._schema._get_column_index(column_name)]].squeeze(),\n                self._schema.get_column_type(column_name),\n            )\n            return output_column\n\n        raise UnknownColumnNameError([column_name])\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the table contains a given column.\n\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the column exists.\n        \"\"\"\n        return self._schema.has_column(column_name)\n\n    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column to be queried.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self._schema.get_column_type(column_name)\n\n    def get_row(self, index: int) -> Row:\n        \"\"\"\n        Return the row at a specified index.\n\n        Parameters\n        ----------\n        index : int\n            The index.\n\n        Returns\n        -------\n        row : Row\n            The row of the table at the index.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If no row at the specified index exists in this table.\n        \"\"\"\n        if len(self._data.index) - 1 < index or index < 0:\n            raise IndexOutOfBoundsError(index)\n\n        return Row._from_polars_dataframe(pl.DataFrame(self._data.iloc[[index]]), self._schema)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Information\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def summary(self) -> Table:\n        \"\"\"\n        Return a table with a number of statistical key values.\n\n        Returns\n        -------\n        result : Table\n            The table with statistics.\n        \"\"\"\n        columns = self.to_columns()\n        result = pd.DataFrame()\n        statistics = {}\n\n        for column in columns:\n            statistics = {\n                \"maximum\": column.maximum,\n                \"minimum\": column.minimum,\n                \"mean\": column.mean,\n                \"mode\": column.mode,\n                \"median\": column.median,\n                \"sum\": column.sum,\n                \"variance\": column.variance,\n                \"standard deviation\": column.standard_deviation,\n                \"idness\": column.idness,\n                \"stability\": column.stability,\n            }\n            values = []\n\n            for function in statistics.values():\n                try:\n                    values.append(str(function()))\n                except NonNumericColumnError:\n                    values.append(\"-\")\n\n            result = pd.concat([result, pd.DataFrame(values)], axis=1)\n\n        result = pd.concat([pd.DataFrame(list(statistics.keys())), result], axis=1)\n        result.columns = [\"metrics\", *self.column_names]\n\n        return Table(result)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Transformations\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def add_column(self, column: Column) -> Table:\n        \"\"\"\n        Return the original table with the provided column attached at the end.\n\n        Returns\n        -------\n        result : Table\n            The table with the column attached.\n\n        Raises\n        ------\n        DuplicateColumnNameError\n            If the new column already exists.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n\n        \"\"\"\n        if self.has_column(column.name):\n            raise DuplicateColumnNameError(column.name)\n\n        if column._data.size != self.n_rows:\n            raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        result[column.name] = column._data\n        return Table(result)\n\n    def add_columns(self, columns: list[Column] | Table) -> Table:\n        \"\"\"\n        Add multiple columns to the table.\n\n        Parameters\n        ----------\n        columns : list[Column] or Table\n            The columns to be added.\n\n        Returns\n        -------\n        result: Table\n            A new table combining the original table and the given columns.\n\n        Raises\n        ------\n        ColumnSizeError\n            If at least one of the column sizes from the provided column list does not match the table.\n        DuplicateColumnNameError\n            If at least one column name from the provided column list already exists in the table.\n        \"\"\"\n        if isinstance(columns, Table):\n            columns = columns.to_columns()\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        for column in columns:\n            if column.name in result.columns:\n                raise DuplicateColumnNameError(column.name)\n\n            if column._data.size != self.n_rows:\n                raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n            result[column.name] = column._data\n        return Table(result)\n\n    def add_row(self, row: Row) -> Table:\n        \"\"\"\n        Add a row to the table.\n\n        Parameters\n        ----------\n        row : Row\n            The row to be added.\n\n        Returns\n        -------\n        table : Table\n            A new table with the added row at the end.\n\n        \"\"\"\n        if self._schema != row.schema:\n            raise SchemaMismatchError\n\n        row_frame = row._data.to_pandas()\n\n        new_df = pd.concat([self._data, row_frame]).infer_objects()\n        new_df.columns = self.column_names\n        return Table(new_df)\n\n    def add_rows(self, rows: list[Row] | Table) -> Table:\n        \"\"\"\n        Add multiple rows to a table.\n\n        Parameters\n        ----------\n        rows : list[Row] or Table\n            The rows to be added.\n\n        Returns\n        -------\n        result : Table\n            A new table which combines the original table and the given rows.\n        \"\"\"\n        if isinstance(rows, Table):\n            rows = rows.to_rows()\n        result = self._data\n        for row in rows:\n            if self._schema != row.schema:\n                raise SchemaMismatchError\n\n        row_frames = [row._data.to_pandas() for row in rows]\n        for row_frame in row_frames:\n            row_frame.columns = self.column_names\n\n        result = pd.concat([result, *row_frames]).infer_objects()\n        result.columns = self.column_names\n        return Table(result)\n\n    def filter_rows(self, query: Callable[[Row], bool]) -> Table:\n        \"\"\"\n        Return a table with rows filtered by Callable (e.g. lambda function).\n\n        Parameters\n        ----------\n        query : lambda function\n            A Callable that is applied to all rows.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the rows filtered by the query.\n        \"\"\"\n        rows: list[Row] = [row for row in self.to_rows() if query(row)]\n        if len(rows) == 0:\n            result_table = Table([], self._schema)\n        else:\n            result_table = self.from_rows(rows)\n        return result_table\n\n    def keep_only_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table with only the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing only the columns to be kept.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the given column(s).\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data[column_names]\n        transformed_data.columns = column_names\n        return Table(transformed_data)\n\n    def remove_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table without the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing all columns to be dropped.\n\n        Returns\n        -------\n        table : Table\n            A table without the given columns.\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data.drop(labels=column_names, axis=\"columns\")\n        transformed_data.columns = [name for name in self._schema.column_names if name not in column_names]\n        return Table(transformed_data)\n\n    def remove_columns_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain missing values.\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if not column.has_missing_values()])\n\n    def remove_columns_with_non_numerical_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain non-numerical values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain non-numerical values.\n\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if column.type.is_numeric()])\n\n    def remove_duplicate_rows(self) -> Table:\n        \"\"\"\n        Return a copy of the table with every duplicate row removed.\n\n        Returns\n        -------\n        result : Table\n            The table with the duplicate rows removed.\n        \"\"\"\n        result = self._data.drop_duplicates(ignore_index=True)\n        result.columns = self._schema.column_names\n        return Table(result)\n\n    def remove_rows_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the rows that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the rows that contain missing values.\n        \"\"\"\n        result = self._data.copy(deep=True)\n        result = result.dropna(axis=\"index\")\n        return Table(result, self._schema)\n\n    def remove_rows_with_outliers(self) -> Table:\n        \"\"\"\n        Remove all rows from the table that contain at least one outlier.\n\n        We define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\n        Missing values are not considered outliers. They are also ignored during the calculation of the standard\n        deviation.\n\n        Returns\n        -------\n        new_table : Table\n            A new table without rows containing outliers.\n        \"\"\"\n        copy = self._data.copy(deep=True)\n\n        table_without_nonnumericals = self.remove_columns_with_non_numerical_values()\n        z_scores = np.absolute(stats.zscore(table_without_nonnumericals._data, nan_policy=\"omit\"))\n        filter_ = ((z_scores < 3) | np.isnan(z_scores)).all(axis=1)\n\n        return Table(copy[filter_], self._schema)\n\n    def rename_column(self, old_name: str, new_name: str) -> Table:\n        \"\"\"\n        Rename a single column.\n\n        Parameters\n        ----------\n        old_name : str\n            The old name of the target column\n        new_name : str\n            The new name of the target column\n\n        Returns\n        -------\n        table : Table\n            The Table with the renamed column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified old target column name does not exist.\n        DuplicateColumnNameError\n            If the specified new target column name already exists.\n        \"\"\"\n        if old_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_name])\n        if old_name == new_name:\n            return self\n        if new_name in self._schema.column_names:\n            raise DuplicateColumnNameError(new_name)\n\n        new_df = self._data.copy()\n        new_df.columns = self._schema.column_names\n        return Table(new_df.rename(columns={old_name: new_name}))\n\n    def replace_column(self, old_column_name: str, new_column: Column) -> Table:\n        \"\"\"\n        Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\n        Parameters\n        ----------\n        old_column_name : str\n            The name of the column to be replaced.\n\n        new_column : Column\n            The new column replacing the old column.\n\n        Returns\n        -------\n        result : Table\n            A table with the old column replaced by the new column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the old column does not exist.\n\n        DuplicateColumnNameError\n            If the new column already exists and the existing column is not affected by the replacement.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n        \"\"\"\n        if old_column_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_column_name])\n\n        if new_column.name in self._schema.column_names and new_column.name != old_column_name:\n            raise DuplicateColumnNameError(new_column.name)\n\n        if self.n_rows != new_column._data.size:\n            raise ColumnSizeError(str(self.n_rows), str(new_column._data.size))\n\n        if old_column_name != new_column.name:\n            renamed_table = self.rename_column(old_column_name, new_column.name)\n            result = renamed_table._data\n            result.columns = renamed_table._schema.column_names\n        else:\n            result = self._data.copy()\n            result.columns = self._schema.column_names\n\n        result[new_column.name] = new_column._data\n        return Table(result)\n\n    def shuffle_rows(self) -> Table:\n        \"\"\"\n        Shuffle the table randomly.\n\n        Returns\n        -------\n        result : Table\n            The shuffled Table.\n\n        \"\"\"\n        new_df = self._data.sample(frac=1.0)\n        new_df.columns = self._schema.column_names\n        return Table(new_df)\n\n    def slice_rows(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n        step: int = 1,\n    ) -> Table:\n        \"\"\"\n        Slice a part of the table into a new table.\n\n        Parameters\n        ----------\n        start : int\n            The first index of the range to be copied into a new table, None by default.\n        end : int\n            The last index of the range to be copied into a new table, None by default.\n        step : int\n            The step size used to iterate through the table, 1 by default.\n\n        Returns\n        -------\n        result : Table\n            The resulting table.\n\n        Raises\n        ------\n        ValueError\n            If the index is out of bounds.\n        \"\"\"\n        if start is None:\n            start = 0\n\n        if end is None:\n            end = self.n_rows\n\n        if start < 0 or end < 0 or start >= self.n_rows or end > self.n_rows or end < start:\n            raise ValueError(\"The given index is out of bounds\")\n\n        new_df = self._data.iloc[start:end:step]\n        new_df.columns = self._schema.column_names\n        return Table(new_df)\n\n    def sort_columns(\n        self,\n        comparator: Callable[[Column, Column], int] = lambda col1, col2: (col1.name > col2.name)\n        - (col1.name < col2.name),\n    ) -> Table:\n        \"\"\"\n        Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\n        returns an integer:\n\n        * If `col1` should be ordered before `col2`, the function should return a negative number.\n        * If `col1` should be ordered after `col2`, the function should return a positive number.\n        * If the original order of `col1` and `col2` should be kept, the function should return 0.\n\n        If no comparator is given, the columns will be sorted alphabetically by their name.\n\n        Parameters\n        ----------\n        comparator : Callable[[Column, Column], int]\n            The function used to compare two columns.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted columns.\n        \"\"\"\n        columns = self.to_columns()\n        columns.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_columns(columns)\n\n    def sort_rows(self, comparator: Callable[[Row, Row], int]) -> Table:\n        \"\"\"\n        Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\n        returns an integer:\n\n        * If `row1` should be ordered before `row2`, the function should return a negative number.\n        * If `row1` should be ordered after `row2`, the function should return a positive number.\n        * If the original order of `row1` and `row2` should be kept, the function should return 0.\n\n        Parameters\n        ----------\n        comparator : Callable[[Row, Row], int]\n            The function used to compare two rows.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted rows.\n        \"\"\"\n        rows = self.to_rows()\n        rows.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_rows(rows)\n\n    def split(self, percentage_in_first: float) -> tuple[Table, Table]:\n        \"\"\"\n        Split the table into two new tables.\n\n        Parameters\n        ----------\n        percentage_in_first : float\n            The desired size of the first table in percentage to the given table.\n\n        Returns\n        -------\n        result : (Table, Table)\n            A tuple containing the two resulting tables. The first table has the specified size, the second table\n            contains the rest of the data.\n\n\n        \"\"\"\n        if percentage_in_first <= 0 or percentage_in_first >= 1:\n            raise ValueError(\"the given percentage is not in range\")\n        return (\n            self.slice_rows(0, round(percentage_in_first * self.n_rows)),\n            self.slice_rows(round(percentage_in_first * self.n_rows)),\n        )\n\n    def tag_columns(self, target_name: str, feature_names: list[str] | None = None) -> TaggedTable:\n        \"\"\"\n        Mark the columns of the table as target column or feature columns. The original table is not modified.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target column.\n        feature_names : Optional[list[str]]\n            Names of the feature columns. If None, all columns except the target column are used.\n\n        Returns\n        -------\n        tagged_table : TaggedTable\n            A new tagged table with the given target and feature names.\n        \"\"\"\n        from ._tagged_table import TaggedTable\n\n        return TaggedTable(self._data, target_name, feature_names, self._schema)\n\n    def transform_column(self, name: str, transformer: Callable[[Row], Any]) -> Table:\n        \"\"\"\n        Transform provided column by calling provided transformer.\n\n        Returns\n        -------\n        result : Table\n            The table with the transformed column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the column does not exist.\n\n        \"\"\"\n        if self.has_column(name):\n            items: list = [transformer(item) for item in self.to_rows()]\n            result: Column = Column(name, pd.Series(items))\n            return self.replace_column(name, result)\n        raise UnknownColumnNameError([name])\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Plotting\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def plot_correlation_heatmap(self) -> Image:\n        \"\"\"\n        Plot a correlation heatmap for all numerical columns of this `Table`.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        only_numerical = self.remove_columns_with_non_numerical_values()\n\n        fig = plt.figure()\n        sns.heatmap(\n            data=only_numerical._data.corr(),\n            vmin=-1,\n            vmax=1,\n            xticklabels=only_numerical.column_names,\n            yticklabels=only_numerical.column_names,\n            cmap=\"vlag\",\n        )\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)\n\n    def plot_lineplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a lineplot.\n\n        If there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\n        and the lower-transparency area around the line representing the 95% confidence interval.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.lineplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)\n\n    def plot_scatterplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a scatterplot.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.scatterplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Conversion\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def to_csv_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a CSV file.\n\n        If the file and/or the directories do not exist they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_csv = self._data.copy()\n        data_to_csv.columns = self._schema.column_names\n        data_to_csv.to_csv(path, index=False)\n\n    def to_json_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a JSON file.\n\n        If the file and/or the directories do not exist, they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_json = self._data.copy()\n        data_to_json.columns = self._schema.column_names\n        data_to_json.to_json(path)\n\n    def to_dict(self) -> dict[str, list[Any]]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, list[Any]]\n            Dictionary representation of the table.\n        \"\"\"\n        return {column_name: list(self.get_column(column_name)) for column_name in self.column_names}\n\n    def to_columns(self) -> list[Column]:\n        \"\"\"\n        Return a list of the columns.\n\n        Returns\n        -------\n        columns : list[Columns]\n            List of columns.\n        \"\"\"\n        return [self.get_column(name) for name in self._schema.column_names]\n\n    def to_rows(self) -> list[Row]:\n        \"\"\"\n        Return a list of the rows.\n\n        Returns\n        -------\n        rows : list[Row]\n            List of rows.\n        \"\"\"\n        return [\n            Row._from_polars_dataframe(\n                pl.DataFrame([list(series_row)], schema=self._schema.column_names),\n                self._schema,\n            )\n            for (_, series_row) in self._data.iterrows()\n        ]\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dataframe interchange protocol\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True):  # type: ignore[no-untyped-def]\n        \"\"\"\n        Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\n        Generally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\n        allow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\n        decide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\n        interchange protocol.\n\n        The specification of the dataframe interchange protocol can be found on\n        [GitHub](https://github.com/data-apis/dataframe-api).\n\n        Parameters\n        ----------\n        nan_as_null : bool\n            Whether to replace missing values in the data with `NaN`.\n        allow_copy : bool\n            Whether memory may be copied to create the DataFrame exchange object.\n\n        Returns\n        -------\n        dataframe\n            A DataFrame object that conforms to the dataframe interchange protocol.\n        \"\"\"\n        if not allow_copy:\n            raise NotImplementedError(\"For the moment we need to copy the data, so `allow_copy` must be True.\")\n\n        data_copy = self._data.copy()\n        data_copy.columns = self.column_names\n        return data_copy.__dataframe__(nan_as_null, allow_copy)",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_schema",
          "types": {
            "kind": "NamedType",
            "name": "Schema"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable",
      "name": "TaggedTable",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable",
      "decorators": [],
      "superclasses": [
        "Table"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/features@getter",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target@getter",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.",
      "docstring": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.\n\nParameters\n----------\ndata : Iterable\n    The data.\ntarget_name : str\n    Name of the target column.\nfeature_names : Optional[list[str]]\n    Names of the feature columns. If None, all columns except the target column are used.\nschema : Optional[Schema]\n    The schema of the table. If not specified, the schema will be inferred from the data.",
      "code": "class TaggedTable(Table):\n    \"\"\"\n    A tagged table is a table that additionally knows which columns are features and which are the target to predict.\n\n    Parameters\n    ----------\n    data : Iterable\n        The data.\n    target_name : str\n        Name of the target column.\n    feature_names : Optional[list[str]]\n        Names of the feature columns. If None, all columns except the target column are used.\n    schema : Optional[Schema]\n        The schema of the table. If not specified, the schema will be inferred from the data.\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(\n        self,\n        data: Iterable,\n        target_name: str,\n        feature_names: list[str] | None = None,\n        schema: Schema | None = None,\n    ):\n        super().__init__(data, schema)\n\n        # If no feature names are specified, use all columns except the target column\n        if feature_names is None:\n            feature_names = self.column_names\n            if target_name in feature_names:\n                feature_names.remove(target_name)\n\n        # Validate inputs\n        if target_name in feature_names:\n            raise ValueError(f\"Column '{target_name}' cannot be both feature and target.\")\n        if len(feature_names) == 0:\n            raise ValueError(\"At least one feature column must be specified.\")\n\n        self._features: Table = self.keep_only_columns(feature_names)\n        self._target: Column = self.get_column(target_name)\n\n    def __repr__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__str__()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def features(self) -> Table:\n        return self._features\n\n    @property\n    def target(self) -> Column:\n        return self._target\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        print(header_info)  # noqa: T201\n        return tmp._ipython_display_()",
      "instance_attributes": [
        {
          "name": "_features",
          "types": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "name": "_target",
          "types": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError",
      "name": "ColumnLengthMismatchError",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when the lengths of two or more columns do not match.",
      "docstring": "Exception raised when the lengths of two or more columns do not match.",
      "code": "class ColumnLengthMismatchError(Exception):\n    \"\"\"Exception raised when the lengths of two or more columns do not match.\"\"\"\n\n    def __init__(self, column_info: str):\n        super().__init__(f\"The length of at least one column differs: \\n{column_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError",
      "name": "ColumnSizeError",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to use a column of unsupported size.",
      "docstring": "Exception raised for trying to use a column of unsupported size.\n\nParameters\n----------\nexpected_size : str\n    The expected size of the column as an expression (e.g. 2, >0, !=0).\nactual_size : str\n    The actual size of the column as an expression (e.g. 2, >0, !=0).",
      "code": "class ColumnSizeError(Exception):\n    \"\"\"\n    Exception raised for trying to use a column of unsupported size.\n\n    Parameters\n    ----------\n    expected_size : str\n        The expected size of the column as an expression (e.g. 2, >0, !=0).\n    actual_size : str\n        The actual size of the column as an expression (e.g. 2, >0, !=0).\n    \"\"\"\n\n    def __init__(self, expected_size: str, actual_size: str):\n        super().__init__(f\"Expected a column of size {expected_size} but got column of size {actual_size}.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError",
      "name": "DuplicateColumnNameError",
      "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to modify a table resulting in a duplicate column name.",
      "docstring": "Exception raised for trying to modify a table resulting in a duplicate column name.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column that resulted in a duplicate.",
      "code": "class DuplicateColumnNameError(Exception):\n    \"\"\"\n    Exception raised for trying to modify a table resulting in a duplicate column name.\n\n    Parameters\n    ----------\n    column_name : str\n        The name of the column that resulted in a duplicate.\n    \"\"\"\n\n    def __init__(self, column_name: str):\n        super().__init__(f\"Column '{column_name}' already exists.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError",
      "name": "IndexOutOfBoundsError",
      "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError",
      "decorators": [],
      "superclasses": [
        "IndexError"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an element by an index that does not exist in the underlying data.",
      "docstring": "Exception raised for trying to access an element by an index that does not exist in the underlying data.\n\nParameters\n----------\nindex : int\n    The wrongly used index.",
      "code": "class IndexOutOfBoundsError(IndexError):\n    \"\"\"\n    Exception raised for trying to access an element by an index that does not exist in the underlying data.\n\n    Parameters\n    ----------\n    index : int\n        The wrongly used index.\n    \"\"\"\n\n    def __init__(self, index: int):\n        super().__init__(f\"There is no element at index '{index}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError",
      "name": "MissingDataError",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised if a function is not given enough data to succeed.",
      "docstring": "Exception raised if a function is not given enough data to succeed.",
      "code": "class MissingDataError(Exception):\n    \"\"\"Exception raised if a function is not given enough data to succeed.\"\"\"\n\n    def __init__(self, missing_data_info: str):\n        super().__init__(f\"The function is missing data: \\n{missing_data_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError",
      "name": "MissingSchemaError",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingSchemaError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a required schema is missing.",
      "docstring": "Exception raised when a required schema is missing.",
      "code": "class MissingSchemaError(Exception):\n    \"\"\"Exception raised when a required schema is missing.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Failed because a required schema is missing.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError",
      "name": "NonNumericColumnError",
      "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "docstring": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "code": "class NonNumericColumnError(Exception):\n    \"\"\"Exception raised for trying to do numerical operations on a non-numerical column.\"\"\"\n\n    def __init__(self, column_info: str) -> None:\n        super().__init__(f\"Tried to do a numerical operation on one or multiple non numerical Columns: \\n{column_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError",
      "name": "SchemaMismatchError",
      "qname": "safeds.data.tabular.exceptions._exceptions.SchemaMismatchError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when schemas are unequal.",
      "docstring": "Exception raised when schemas are unequal.",
      "code": "class SchemaMismatchError(Exception):\n    \"\"\"Exception raised when schemas are unequal.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Failed because at least two schemas didn't match.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError",
      "name": "TransformerNotFittedError",
      "qname": "safeds.data.tabular.exceptions._exceptions.TransformerNotFittedError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a transformer is used before fitting it.",
      "docstring": "Raised when a transformer is used before fitting it.",
      "code": "class TransformerNotFittedError(Exception):\n    \"\"\"Raised when a transformer is used before fitting it.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"The transformer has not been fitted yet.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError",
      "name": "UnknownColumnNameError",
      "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError",
      "decorators": [],
      "superclasses": [
        "KeyError"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an invalid column name.",
      "docstring": "Exception raised for trying to access an invalid column name.\n\nParameters\n----------\ncolumn_names : list[str]\n    The name of the column that was tried to be accessed.",
      "code": "class UnknownColumnNameError(KeyError):\n    \"\"\"\n    Exception raised for trying to access an invalid column name.\n\n    Parameters\n    ----------\n    column_names : list[str]\n        The name of the column that was tried to be accessed.\n    \"\"\"\n\n    def __init__(self, column_names: list[str]):\n        super().__init__(f\"Could not find column(s) '{', '.join(column_names)}'\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer",
      "name": "Imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer",
      "decorators": [],
      "superclasses": [
        "TableTransformer"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__",
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit",
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform",
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Replace missing values with the given strategy.",
      "docstring": "Replace missing values with the given strategy.\n\nParameters\n----------\nstrategy : ImputerStrategy\n    The strategy used to impute missing values. Use the classes nested inside `Imputer.Strategy` to specify it.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Column, Table\n>>> from safeds.data.tabular.transformation import Imputer\n>>>\n>>> table = Table.from_columns(\n...     [\n...         Column(\"a\", [1, 3, None]),\n...         Column(\"b\", [None, 2, 3]),\n...     ],\n... )\n>>> transformer = Imputer(Imputer.Strategy.Constant(0))\n>>> transformed_table = transformer.fit_and_transform(table)",
      "code": "class Imputer(TableTransformer):\n    \"\"\"\n    Replace missing values with the given strategy.\n\n    Parameters\n    ----------\n    strategy : ImputerStrategy\n        The strategy used to impute missing values. Use the classes nested inside `Imputer.Strategy` to specify it.\n\n    Examples\n    --------\n    >>> from safeds.data.tabular.containers import Column, Table\n    >>> from safeds.data.tabular.transformation import Imputer\n    >>>\n    >>> table = Table.from_columns(\n    ...     [\n    ...         Column(\"a\", [1, 3, None]),\n    ...         Column(\"b\", [None, 2, 3]),\n    ...     ],\n    ... )\n    >>> transformer = Imputer(Imputer.Strategy.Constant(0))\n    >>> transformed_table = transformer.fit_and_transform(table)\n    \"\"\"\n\n    class Strategy:\n        class Constant(ImputerStrategy):\n            \"\"\"\n            An imputation strategy for imputing missing data with given constant values.\n\n            Parameters\n            ----------\n            value :\n                The given value to impute missing values.\n            \"\"\"\n\n            def __init__(self, value: Any):\n                self._value = value\n\n            def __str__(self) -> str:\n                return f\"Constant({self._value})\"\n\n            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"constant\"\n                imputer.fill_value = self._value\n\n        class Mean(ImputerStrategy):\n            \"\"\"An imputation strategy for imputing missing data with mean values.\"\"\"\n\n            def __str__(self) -> str:\n                return \"Mean\"\n\n            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"mean\"\n\n        class Median(ImputerStrategy):\n            \"\"\"An imputation strategy for imputing missing data with median values.\"\"\"\n\n            def __str__(self) -> str:\n                return \"Median\"\n\n            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"median\"\n\n        class Mode(ImputerStrategy):\n            \"\"\"An imputation strategy for imputing missing data with mode values.\"\"\"\n\n            def __str__(self) -> str:\n                return \"Mode\"\n\n            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"most_frequent\"\n\n    def __init__(self, strategy: ImputerStrategy):\n        self._strategy = strategy\n\n        self._wrapped_transformer: sk_SimpleImputer | None = None\n        self._column_names: list[str] | None = None\n\n    # noinspection PyProtectedMember\n    def fit(self, table: Table, column_names: list[str] | None = None) -> Imputer:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n        if column_names is None:\n            column_names = table.column_names\n        else:\n            missing_columns = set(column_names) - set(table.column_names)\n            if len(missing_columns) > 0:\n                raise UnknownColumnNameError(list(missing_columns))\n\n        if isinstance(self._strategy, Imputer.Strategy.Mode):\n            for name in column_names:\n                if len(table.get_column(name).mode()) > 1:\n                    raise IndexError(\"There are multiple most frequent values in a column given for the Imputer\")\n\n        wrapped_transformer = sk_SimpleImputer()\n        self._strategy._augment_imputer(wrapped_transformer)\n        wrapped_transformer.fit(table._data[column_names])\n\n        result = Imputer(self._strategy)\n        result._wrapped_transformer = wrapped_transformer\n        result._column_names = column_names\n\n        return result\n\n    # noinspection PyProtectedMember\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        # Input table does not contain all columns used to fit the transformer\n        missing_columns = set(self._column_names) - set(table.column_names)\n        if len(missing_columns) > 0:\n            raise UnknownColumnNameError(list(missing_columns))\n\n        data = table._data.copy()\n        data[self._column_names] = pd.DataFrame(\n            self._wrapped_transformer.transform(data[self._column_names]),\n            columns=self._column_names,\n        )\n        return Table(data, table.schema)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n        return self._wrapped_transformer is not None",
      "instance_attributes": [
        {
          "name": "_strategy",
          "types": {
            "kind": "NamedType",
            "name": "ImputerStrategy"
          }
        },
        {
          "name": "_wrapped_transformer",
          "types": {
            "kind": "NamedType",
            "name": "SimpleImputer"
          }
        },
        {
          "name": "_column_names",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder",
      "name": "LabelEncoder",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder",
      "decorators": [],
      "superclasses": [
        "InvertibleTableTransformer"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/__init__",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "The LabelEncoder encodes one or more given columns into labels.",
      "docstring": "The LabelEncoder encodes one or more given columns into labels.",
      "code": "class LabelEncoder(InvertibleTableTransformer):\n    \"\"\"The LabelEncoder encodes one or more given columns into labels.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_transformer: sk_OrdinalEncoder | None = None\n        self._column_names: list[str] | None = None\n\n    def fit(self, table: Table, column_names: list[str] | None = None) -> LabelEncoder:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n        if column_names is None:\n            column_names = table.column_names\n        else:\n            missing_columns = set(column_names) - set(table.column_names)\n            if len(missing_columns) > 0:\n                raise UnknownColumnNameError(list(missing_columns))\n\n        wrapped_transformer = sk_OrdinalEncoder()\n        wrapped_transformer.fit(table._data[column_names])\n\n        result = LabelEncoder()\n        result._wrapped_transformer = wrapped_transformer\n        result._column_names = column_names\n\n        return result\n\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        # Input table does not contain all columns used to fit the transformer\n        missing_columns = set(self._column_names) - set(table.column_names)\n        if len(missing_columns) > 0:\n            raise UnknownColumnNameError(list(missing_columns))\n\n        data = table._data.copy()\n        data.columns = table.column_names\n        data[self._column_names] = self._wrapped_transformer.transform(data[self._column_names])\n        return Table(data)\n\n    def inverse_transform(self, transformed_table: Table) -> Table:\n        \"\"\"\n        Undo the learned transformation.\n\n        Parameters\n        ----------\n        transformed_table : Table\n            The table to be transformed back to the original version.\n\n        Returns\n        -------\n        table : Table\n            The original table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        data = transformed_table._data.copy()\n        data.columns = transformed_table.column_names\n        data[self._column_names] = self._wrapped_transformer.inverse_transform(data[self._column_names])\n        return Table(data)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n        return self._wrapped_transformer is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_transformer",
          "types": {
            "kind": "NamedType",
            "name": "OrdinalEncoder"
          }
        },
        {
          "name": "_column_names",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder",
      "name": "OneHotEncoder",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder",
      "decorators": [],
      "superclasses": [
        "InvertibleTableTransformer"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/__init__",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Encodes categorical columns to numerical features [0,1] that represent the existence for each value.",
      "docstring": "Encodes categorical columns to numerical features [0,1] that represent the existence for each value.",
      "code": "class OneHotEncoder(InvertibleTableTransformer):\n    \"\"\"Encodes categorical columns to numerical features [0,1] that represent the existence for each value.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_transformer: sk_OneHotEncoder | None = None\n        self._column_names: dict[str, list[str]] | None = None\n\n    # noinspection PyProtectedMember\n    def fit(self, table: Table, column_names: list[str] | None = None) -> OneHotEncoder:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n        if column_names is None:\n            column_names = table.column_names\n        else:\n            missing_columns = set(column_names) - set(table.column_names)\n            if len(missing_columns) > 0:\n                raise UnknownColumnNameError(list(missing_columns))\n\n        data = table._data.copy()\n        data.columns = table.column_names\n\n        wrapped_transformer = sk_OneHotEncoder()\n        wrapped_transformer.fit(data[column_names])\n\n        result = OneHotEncoder()\n        result._wrapped_transformer = wrapped_transformer\n        result._column_names = {\n            column: [f\"{column}_{element}\" for element in table.get_column(column).get_unique_values()]\n            for column in column_names\n        }\n\n        return result\n\n    # noinspection PyProtectedMember\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        # Input table does not contain all columns used to fit the transformer\n        missing_columns = set(self._column_names.keys()) - set(table.column_names)\n        if len(missing_columns) > 0:\n            raise UnknownColumnNameError(list(missing_columns))\n\n        original = table._data.copy()\n        original.columns = table.schema.column_names\n\n        one_hot_encoded = pd.DataFrame(\n            self._wrapped_transformer.transform(original[self._column_names.keys()]).toarray(),\n        )\n        one_hot_encoded.columns = self._wrapped_transformer.get_feature_names_out()\n\n        unchanged = original.drop(self._column_names.keys(), axis=1)\n\n        res = Table(pd.concat([unchanged, one_hot_encoded], axis=1))\n        column_names = []\n\n        for name in table.column_names:\n            if name not in self._column_names.keys():\n                column_names.append(name)\n            else:\n                column_names.extend(\n                    [f_name for f_name in self._wrapped_transformer.get_feature_names_out() if f_name.startswith(name)],\n                )\n        res = res.sort_columns(lambda col1, col2: column_names.index(col1.name) - column_names.index(col2.name))\n\n        return res\n\n    # noinspection PyProtectedMember\n    def inverse_transform(self, transformed_table: Table) -> Table:\n        \"\"\"\n        Undo the learned transformation.\n\n        Parameters\n        ----------\n        transformed_table : Table\n            The table to be transformed back to the original version.\n\n        Returns\n        -------\n        table : Table\n            The original table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        data = transformed_table._data.copy()\n        data.columns = transformed_table.column_names\n\n        decoded = pd.DataFrame(\n            self._wrapped_transformer.inverse_transform(\n                transformed_table.keep_only_columns(self._wrapped_transformer.get_feature_names_out())._data,\n            ),\n            columns=list(self._column_names.keys()),\n        )\n        unchanged = data.drop(self._wrapped_transformer.get_feature_names_out(), axis=1)\n\n        res = Table(pd.concat([unchanged, decoded], axis=1))\n        column_names = [\n            name\n            if name not in [value for value_list in list(self._column_names.values()) for value in value_list]\n            else list(self._column_names.keys())[\n                [\n                    list(self._column_names.values()).index(value)\n                    for value in list(self._column_names.values())\n                    if name in value\n                ][0]\n            ]\n            for name in transformed_table.column_names\n        ]\n        res = res.sort_columns(lambda col1, col2: column_names.index(col1.name) - column_names.index(col2.name))\n\n        return res\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n        return self._wrapped_transformer is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_transformer",
          "types": {
            "kind": "NamedType",
            "name": "OneHotEncoder"
          }
        },
        {
          "name": "_column_names",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/InvertibleTableTransformer",
      "name": "InvertibleTableTransformer",
      "qname": "safeds.data.tabular.transformation._table_transformer.InvertibleTableTransformer",
      "decorators": [],
      "superclasses": [
        "TableTransformer"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._table_transformer/InvertibleTableTransformer/inverse_transform"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A `TableTransformer` that can also undo the learned transformation after it has been applied.",
      "docstring": "A `TableTransformer` that can also undo the learned transformation after it has been applied.",
      "code": "class InvertibleTableTransformer(TableTransformer):\n    \"\"\"A `TableTransformer` that can also undo the learned transformation after it has been applied.\"\"\"\n\n    @abstractmethod\n    def inverse_transform(self, transformed_table: Table) -> Table:\n        \"\"\"\n        Undo the learned transformation.\n\n        Parameters\n        ----------\n        transformed_table : Table\n            The table to be transformed back to the original version.\n\n        Returns\n        -------\n        table : Table\n            The original table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer",
      "name": "TableTransformer",
      "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit",
        "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/transform",
        "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/is_fitted",
        "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit_and_transform"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Learn a transformation for a set of columns in a `Table` and transform another `Table` with the same columns.",
      "docstring": "Learn a transformation for a set of columns in a `Table` and transform another `Table` with the same columns.",
      "code": "class TableTransformer(ABC):\n    \"\"\"Learn a transformation for a set of columns in a `Table` and transform another `Table` with the same columns.\"\"\"\n\n    @abstractmethod\n    def fit(self, table: Table, column_names: list[str] | None = None) -> TableTransformer:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n\n    @abstractmethod\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n\n    @abstractmethod\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n\n    def fit_and_transform(self, table: Table, column_names: list[str] | None = None) -> Table:\n        \"\"\"\n        Learn a transformation for a set of columns in a table and apply the learned transformation to the same table.\n\n        If you also need the fitted transformer, use `fit` and `transform` separately.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer. The transformer is then applied to this table.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n        \"\"\"\n        return self.fit(table, column_names).transform(table)",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Anything",
      "name": "Anything",
      "qname": "safeds.data.tabular.typing._column_type.Anything",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/Anything/__init__",
        "stdlib/safeds.data.tabular.typing._column_type/Anything/__repr__",
        "stdlib/safeds.data.tabular.typing._column_type/Anything/is_nullable",
        "stdlib/safeds.data.tabular.typing._column_type/Anything/is_numeric"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that contains anything.",
      "docstring": "Type for a column that contains anything.\n\nParameters\n----------\nis_nullable : bool\n    Whether the type also allows null values.",
      "code": "class Anything(ColumnType):\n    \"\"\"\n    Type for a column that contains anything.\n\n    Parameters\n    ----------\n    is_nullable : bool\n        Whether the type also allows null values.\n    \"\"\"\n\n    _is_nullable: bool\n\n    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable\n\n    def __repr__(self) -> str:\n        result = \"Anything\"\n        if self._is_nullable:\n            result += \"?\"\n        return result\n\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable\n\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False",
      "instance_attributes": [
        {
          "name": "_is_nullable",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean",
      "name": "Boolean",
      "qname": "safeds.data.tabular.typing._column_type.Boolean",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/Boolean/__init__",
        "stdlib/safeds.data.tabular.typing._column_type/Boolean/__repr__",
        "stdlib/safeds.data.tabular.typing._column_type/Boolean/is_nullable",
        "stdlib/safeds.data.tabular.typing._column_type/Boolean/is_numeric"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains booleans.",
      "docstring": "Type for a column that only contains booleans.\n\nParameters\n----------\nis_nullable : bool\n    Whether the type also allows null values.",
      "code": "class Boolean(ColumnType):\n    \"\"\"\n    Type for a column that only contains booleans.\n\n    Parameters\n    ----------\n    is_nullable : bool\n        Whether the type also allows null values.\n    \"\"\"\n\n    _is_nullable: bool\n\n    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable\n\n    def __repr__(self) -> str:\n        result = \"Boolean\"\n        if self._is_nullable:\n            result += \"?\"\n        return result\n\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable\n\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False",
      "instance_attributes": [
        {
          "name": "_is_nullable",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType",
      "name": "ColumnType",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/ColumnType/_from_numpy_data_type",
        "stdlib/safeds.data.tabular.typing._column_type/ColumnType/_from_polars_data_type",
        "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_nullable",
        "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_numeric"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Abstract base class for column types.",
      "docstring": "Abstract base class for column types.",
      "code": "class ColumnType(ABC):\n    \"\"\"Abstract base class for column types.\"\"\"\n\n    @staticmethod\n    def _from_numpy_data_type(data_type: np.dtype) -> ColumnType:\n        \"\"\"\n        Return the column type for a given `numpy` data type.\n\n        Parameters\n        ----------\n        data_type : numpy.dtype\n            The `numpy` data type.\n\n        Returns\n        -------\n        column_type : ColumnType\n            The ColumnType.\n\n        Raises\n        ------\n        NotImplementedError\n            If the given data type is not supported.\n        \"\"\"\n        if data_type.kind in (\"u\", \"i\"):\n            return Integer()\n        if data_type.kind == \"b\":\n            return Boolean()\n        if data_type.kind == \"f\":\n            return RealNumber()\n        if data_type.kind in (\"S\", \"U\", \"O\", \"M\", \"m\"):\n            return String()\n\n        message = f\"Unsupported numpy data type '{data_type}'.\"\n        raise NotImplementedError(message)\n\n    @staticmethod\n    def _from_polars_data_type(data_type: PolarsDataType) -> ColumnType:\n        \"\"\"\n        Return the column type for a given `polars` data type.\n\n        Parameters\n        ----------\n        data_type : PolarsDataType\n            The `polars` data type.\n\n        Returns\n        -------\n        column_type : ColumnType\n            The ColumnType.\n\n        Raises\n        ------\n        NotImplementedError\n            If the given data type is not supported.\n        \"\"\"\n        if data_type in POLARS_INTEGER_DTYPES:\n            return Integer()\n        if data_type is PolarsBoolean:\n            return Boolean()\n        if data_type in POLARS_FLOAT_DTYPES or data_type is PolarsDecimal:\n            return RealNumber()\n        if data_type is PolarsUtf8 or data_type is PolarsObject or data_type in POLARS_TEMPORAL_DTYPES:\n            return String()\n\n        message = f\"Unsupported polars data type '{data_type}'.\"\n        raise NotImplementedError(message)\n\n    @abstractmethod\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n\n    @abstractmethod\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Integer",
      "name": "Integer",
      "qname": "safeds.data.tabular.typing._column_type.Integer",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/Integer/__init__",
        "stdlib/safeds.data.tabular.typing._column_type/Integer/__repr__",
        "stdlib/safeds.data.tabular.typing._column_type/Integer/is_nullable",
        "stdlib/safeds.data.tabular.typing._column_type/Integer/is_numeric"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains integers.",
      "docstring": "Type for a column that only contains integers.\n\nParameters\n----------\nis_nullable : bool\n    Whether the type also allows null values.",
      "code": "class Integer(ColumnType):\n    \"\"\"\n    Type for a column that only contains integers.\n\n    Parameters\n    ----------\n    is_nullable : bool\n        Whether the type also allows null values.\n    \"\"\"\n\n    _is_nullable: bool\n\n    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable\n\n    def __repr__(self) -> str:\n        result = \"Integer\"\n        if self._is_nullable:\n            result += \"?\"\n        return result\n\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable\n\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return True",
      "instance_attributes": [
        {
          "name": "_is_nullable",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber",
      "name": "RealNumber",
      "qname": "safeds.data.tabular.typing._column_type.RealNumber",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__init__",
        "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__repr__",
        "stdlib/safeds.data.tabular.typing._column_type/RealNumber/is_nullable",
        "stdlib/safeds.data.tabular.typing._column_type/RealNumber/is_numeric"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains real numbers.",
      "docstring": "Type for a column that only contains real numbers.\n\nParameters\n----------\nis_nullable : bool\n    Whether the type also allows null values.",
      "code": "class RealNumber(ColumnType):\n    \"\"\"\n    Type for a column that only contains real numbers.\n\n    Parameters\n    ----------\n    is_nullable : bool\n        Whether the type also allows null values.\n    \"\"\"\n\n    _is_nullable: bool\n\n    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable\n\n    def __repr__(self) -> str:\n        result = \"RealNumber\"\n        if self._is_nullable:\n            result += \"?\"\n        return result\n\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable\n\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return True",
      "instance_attributes": [
        {
          "name": "_is_nullable",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/String",
      "name": "String",
      "qname": "safeds.data.tabular.typing._column_type.String",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/String/__init__",
        "stdlib/safeds.data.tabular.typing._column_type/String/__repr__",
        "stdlib/safeds.data.tabular.typing._column_type/String/is_nullable",
        "stdlib/safeds.data.tabular.typing._column_type/String/is_numeric"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains strings.",
      "docstring": "Type for a column that only contains strings.\n\nParameters\n----------\nis_nullable : bool\n    Whether the type also allows null values.",
      "code": "class String(ColumnType):\n    \"\"\"\n    Type for a column that only contains strings.\n\n    Parameters\n    ----------\n    is_nullable : bool\n        Whether the type also allows null values.\n    \"\"\"\n\n    _is_nullable: bool\n\n    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable\n\n    def __repr__(self) -> str:\n        result = \"String\"\n        if self._is_nullable:\n            result += \"?\"\n        return result\n\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable\n\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False",
      "instance_attributes": [
        {
          "name": "_is_nullable",
          "types": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._imputer_strategy/ImputerStrategy",
      "name": "ImputerStrategy",
      "qname": "safeds.data.tabular.typing._imputer_strategy.ImputerStrategy",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._imputer_strategy/ImputerStrategy/_augment_imputer"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "The abstract base class of the different imputation strategies supported by the `Imputer`.\n\nThis class is only needed for type annotations. Use the subclasses nested inside `Imputer.Strategy` instead.",
      "docstring": "The abstract base class of the different imputation strategies supported by the `Imputer`.\n\nThis class is only needed for type annotations. Use the subclasses nested inside `Imputer.Strategy` instead.",
      "code": "class ImputerStrategy(ABC):\n    \"\"\"\n    The abstract base class of the different imputation strategies supported by the `Imputer`.\n\n    This class is only needed for type annotations. Use the subclasses nested inside `Imputer.Strategy` instead.\n    \"\"\"\n\n    @abstractmethod\n    def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n        pass",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema",
      "name": "Schema",
      "qname": "safeds.data.tabular.typing._schema.Schema",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.typing._schema/Schema/_from_pandas_dataframe",
        "stdlib/safeds.data.tabular.typing._schema/Schema/_from_polars_dataframe",
        "stdlib/safeds.data.tabular.typing._schema/Schema/__init__",
        "stdlib/safeds.data.tabular.typing._schema/Schema/__hash__",
        "stdlib/safeds.data.tabular.typing._schema/Schema/__str__",
        "stdlib/safeds.data.tabular.typing._schema/Schema/column_names@getter",
        "stdlib/safeds.data.tabular.typing._schema/Schema/has_column",
        "stdlib/safeds.data.tabular.typing._schema/Schema/get_column_type",
        "stdlib/safeds.data.tabular.typing._schema/Schema/_get_column_index"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Store column names and corresponding data types for a `Table` or `Row`.",
      "docstring": "Store column names and corresponding data types for a `Table` or `Row`.\n\nParameters\n----------\nschema : dict[str, ColumnType]\n    Map from column names to data types.",
      "code": "class Schema:\n    \"\"\"\n    Store column names and corresponding data types for a `Table` or `Row`.\n\n    Parameters\n    ----------\n    schema : dict[str, ColumnType]\n        Map from column names to data types.\n    \"\"\"\n\n    _schema: dict[str, ColumnType]\n\n    @staticmethod\n    def _from_pandas_dataframe(dataframe: pd.DataFrame) -> Schema:\n        \"\"\"\n        Create a schema from a `pandas.DataFrame`.\n\n        Parameters\n        ----------\n        dataframe : pd.DataFrame\n            The dataframe.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        names = dataframe.columns\n        # noinspection PyProtectedMember\n        types = (ColumnType._from_numpy_data_type(data_type) for data_type in dataframe.dtypes)\n\n        return Schema(dict(zip(names, types, strict=True)))\n\n    @staticmethod\n    def _from_polars_dataframe(dataframe: pl.DataFrame) -> Schema:\n        \"\"\"\n        Create a schema from a `polars.Dataframe`.\n\n        Parameters\n        ----------\n        dataframe : pl.DataFrame\n            The dataframe.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        names = dataframe.columns\n        # noinspection PyProtectedMember\n        types = (ColumnType._from_polars_data_type(data_type) for data_type in dataframe.dtypes)\n\n        return Schema(dict(zip(names, types, strict=True)))\n\n    def __init__(self, schema: dict[str, ColumnType]):\n        self._schema = dict(schema)  # Defensive copy\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Return a hash value for the schema.\n\n        Returns\n        -------\n        hash : int\n            The hash value.\n        \"\"\"\n        column_names = self._schema.keys()\n        column_types = map(repr, self._schema.values())\n        return hash(tuple(zip(column_names, column_types, strict=True)))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Return a user-friendly string representation of the schema.\n\n        Returns\n        -------\n        string : str\n            The string representation.\n        \"\"\"\n        match len(self._schema):\n            case 0:\n                return \"{}\"\n            case 1:\n                return str(self._schema)\n            case _:\n                lines = (f\"    {name!r}: {type_}\" for name, type_ in self._schema.items())\n                joined = \",\\n\".join(lines)\n                return f\"{{\\n{joined}\\n}}\"\n\n    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names saved in this schema.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n        \"\"\"\n        return list(self._schema.keys())\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the schema contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the schema contains the column.\n        \"\"\"\n        return column_name in self._schema\n\n    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified column name does not exist.\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n        return self._schema[column_name]\n\n    def _get_column_index(self, column_name: str) -> int:\n        \"\"\"\n         Return the index of the column with specified column name.\n\n        Parameters\n        ----------\n         column_name : str\n             The name of the column.\n\n        Returns\n        -------\n        index : int\n             The index of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified column name does not exist.\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n\n        return list(self._schema.keys()).index(column_name)",
      "instance_attributes": [
        {
          "name": "_schema",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost",
      "name": "AdaBoost",
      "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/__init__",
        "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/fit",
        "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/predict",
        "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Ada Boost classification.",
      "docstring": "Ada Boost classification.",
      "code": "class AdaBoost(Classifier):\n    \"\"\"Ada Boost classification.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_classifier: sk_AdaBoostClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None\n\n    def fit(self, training_set: TaggedTable) -> AdaBoost:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : AdaBoost\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_AdaBoostClassifier()\n        fit(wrapped_classifier, training_set)\n\n        result = AdaBoost()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result\n\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_classifier",
          "types": {
            "kind": "NamedType",
            "name": "AdaBoostClassifier"
          }
        },
        {
          "name": "_feature_names",
          "types": null
        },
        {
          "name": "_target_name",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier",
      "name": "Classifier",
      "qname": "safeds.ml.classical.classification._classifier.Classifier",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._classifier/Classifier/fit",
        "stdlib/safeds.ml.classical.classification._classifier/Classifier/predict",
        "stdlib/safeds.ml.classical.classification._classifier/Classifier/is_fitted",
        "stdlib/safeds.ml.classical.classification._classifier/Classifier/accuracy"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Abstract base class for all classifiers.",
      "docstring": "Abstract base class for all classifiers.",
      "code": "class Classifier(ABC):\n    \"\"\"Abstract base class for all classifiers.\"\"\"\n\n    @abstractmethod\n    def fit(self, training_set: TaggedTable) -> Classifier:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : Classifier\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n\n    @abstractmethod\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n\n    @abstractmethod\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n\n    # noinspection PyProtectedMember\n    def accuracy(self, validation_or_test_set: TaggedTable) -> float:\n        \"\"\"\n        Compute the accuracy of the classifier on the given data.\n\n        Parameters\n        ----------\n        validation_or_test_set : TaggedTable\n            The validation or test set.\n\n        Returns\n        -------\n        accuracy : float\n            The calculated accuracy score, i.e. the percentage of equal data.\n        \"\"\"\n        expected = validation_or_test_set.target\n        predicted = self.predict(validation_or_test_set.features).target\n\n        return sk_accuracy_score(expected._data, predicted._data)",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree",
      "name": "DecisionTree",
      "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/__init__",
        "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/fit",
        "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/predict",
        "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Decision tree classification.",
      "docstring": "Decision tree classification.",
      "code": "class DecisionTree(Classifier):\n    \"\"\"Decision tree classification.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_classifier: sk_DecisionTreeClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None\n\n    def fit(self, training_set: TaggedTable) -> DecisionTree:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : DecisionTree\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_DecisionTreeClassifier()\n        fit(wrapped_classifier, training_set)\n\n        result = DecisionTree()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result\n\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_classifier",
          "types": {
            "kind": "NamedType",
            "name": "DecisionTreeClassifier"
          }
        },
        {
          "name": "_feature_names",
          "types": null
        },
        {
          "name": "_target_name",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting",
      "name": "GradientBoosting",
      "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/__init__",
        "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/fit",
        "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/predict",
        "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Gradient boosting classification.",
      "docstring": "Gradient boosting classification.",
      "code": "class GradientBoosting(Classifier):\n    \"\"\"Gradient boosting classification.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_classifier: sk_GradientBoostingClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None\n\n    def fit(self, training_set: TaggedTable) -> GradientBoosting:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : GradientBoosting\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_GradientBoostingClassifier()\n        fit(wrapped_classifier, training_set)\n\n        result = GradientBoosting()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result\n\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_classifier",
          "types": {
            "kind": "NamedType",
            "name": "GradientBoostingClassifier"
          }
        },
        {
          "name": "_feature_names",
          "types": null
        },
        {
          "name": "_target_name",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors",
      "name": "KNearestNeighbors",
      "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/__init__",
        "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/fit",
        "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/predict",
        "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "K-nearest-neighbors classification.",
      "docstring": "K-nearest-neighbors classification.\n\nParameters\n----------\nnumber_of_neighbors : int\n    The number of neighbors to be interpolated with. Has to be less than or equal to the sample size.",
      "code": "class KNearestNeighbors(Classifier):\n    \"\"\"\n    K-nearest-neighbors classification.\n\n    Parameters\n    ----------\n    number_of_neighbors : int\n        The number of neighbors to be interpolated with. Has to be less than or equal to the sample size.\n    \"\"\"\n\n    def __init__(self, number_of_neighbors: int) -> None:\n        self._number_of_neighbors = number_of_neighbors\n\n        self._wrapped_classifier: sk_KNeighborsClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None\n\n    def fit(self, training_set: TaggedTable) -> KNearestNeighbors:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : KNearestNeighbors\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_KNeighborsClassifier(self._number_of_neighbors, n_jobs=-1)\n        fit(wrapped_classifier, training_set)\n\n        result = KNearestNeighbors(self._number_of_neighbors)\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result\n\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None",
      "instance_attributes": [
        {
          "name": "_number_of_neighbors",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_wrapped_classifier",
          "types": {
            "kind": "NamedType",
            "name": "KNeighborsClassifier"
          }
        },
        {
          "name": "_feature_names",
          "types": null
        },
        {
          "name": "_target_name",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression",
      "name": "LogisticRegression",
      "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/__init__",
        "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/fit",
        "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/predict",
        "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Regularized logistic regression.",
      "docstring": "Regularized logistic regression.",
      "code": "class LogisticRegression(Classifier):\n    \"\"\"Regularized logistic regression.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_classifier: sk_LogisticRegression | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None\n\n    def fit(self, training_set: TaggedTable) -> LogisticRegression:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : LogisticRegression\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_LogisticRegression(n_jobs=-1)\n        fit(wrapped_classifier, training_set)\n\n        result = LogisticRegression()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result\n\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_classifier",
          "types": {
            "kind": "NamedType",
            "name": "LogisticRegression"
          }
        },
        {
          "name": "_feature_names",
          "types": null
        },
        {
          "name": "_target_name",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest",
      "name": "RandomForest",
      "qname": "safeds.ml.classical.classification._random_forest.RandomForest",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/__init__",
        "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/fit",
        "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/predict",
        "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/is_fitted"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Random forest classification.",
      "docstring": "Random forest classification.",
      "code": "class RandomForest(Classifier):\n    \"\"\"Random forest classification.\"\"\"\n\n    def __init__(self) -> None:\n        self._wrapped_classifier: sk_RandomForestClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None\n\n    def fit(self, training_set: TaggedTable) -> RandomForest:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : RandomForest\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_RandomForestClassifier(n_jobs=-1)\n        fit(wrapped_classifier, training_set)\n\n        result = RandomForest()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result\n\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)\n\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None",
      "instance_attributes": [
        {
          "name": "_wrapped_classifier",
          "types": {
            "kind": "NamedType",
            "name": "RandomForestClassifier"
          }
        },
        {
          "name": "_feature_names",
          "types": null
        },
        {
          "name": "_target_name",
          "types": null
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError",
      "name": "DatasetContainsTargetError",
      "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError",
      "decorators": [],
      "superclasses": [
        "ValueError"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset contains the target column already.",
      "docstring": "Raised when a dataset contains the target column already.\n\nParameters\n----------\ntarget_name: str\n    The name of the target column.",
      "code": "class DatasetContainsTargetError(ValueError):\n    \"\"\"\n    Raised when a dataset contains the target column already.\n\n    Parameters\n    ----------\n    target_name: str\n        The name of the target column.\n    \"\"\"\n\n    def __init__(self, target_name: str):\n        super().__init__(f\"Dataset already contains the target column '{target_name}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError",
      "name": "DatasetMissesFeaturesError",
      "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError",
      "decorators": [],
      "superclasses": [
        "ValueError"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset misses feature columns.",
      "docstring": "Raised when a dataset misses feature columns.\n\nParameters\n----------\nmissing_feature_names: list[str]\n    The names of the missing feature columns.",
      "code": "class DatasetMissesFeaturesError(ValueError):\n    \"\"\"\n    Raised when a dataset misses feature columns.\n\n    Parameters\n    ----------\n    missing_feature_names: list[str]\n        The names of the missing feature columns.\n    \"\"\"\n\n    def __init__(self, missing_feature_names: list[str]):\n        super().__init__(f\"Dataset misses the feature columns '{missing_feature_names}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError",
      "name": "LearningError",
      "qname": "safeds.ml.exceptions._exceptions.LearningError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while training a model.",
      "docstring": "Raised when an error occurred while training a model.\n\nParameters\n----------\nreason: str | None\n    The reason for the error.",
      "code": "class LearningError(Exception):\n    \"\"\"\n    Raised when an error occurred while training a model.\n\n    Parameters\n    ----------\n    reason: str | None\n        The reason for the error.\n    \"\"\"\n\n    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while learning\")\n        else:\n            super().__init__(f\"Error occurred while learning: {reason}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError",
      "name": "ModelNotFittedError",
      "qname": "safeds.ml.exceptions._exceptions.ModelNotFittedError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a model is used before fitting it.",
      "docstring": "Raised when a model is used before fitting it.",
      "code": "class ModelNotFittedError(Exception):\n    \"\"\"Raised when a model is used before fitting it.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"The model has not been fitted yet.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError",
      "name": "PredictionError",
      "qname": "safeds.ml.exceptions._exceptions.PredictionError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while prediction a target vector using a model.",
      "docstring": "Raised when an error occurred while prediction a target vector using a model.\n\nParameters\n----------\nreason: str | None\n    The reason for the error.",
      "code": "class PredictionError(Exception):\n    \"\"\"\n    Raised when an error occurred while prediction a target vector using a model.\n\n    Parameters\n    ----------\n    reason: str | None\n        The reason for the error.\n    \"\"\"\n\n    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while predicting\")\n        else:\n            super().__init__(f\"Error occurred while predicting: {reason}\")",
      "instance_attributes": []
    }
  ],
  "functions": [
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._column.Column.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._column.Column.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Column):\n            return NotImplemented\n        if self is other:\n            return True\n        return self.name == other.name and self._data.equals(other._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__",
      "name": "__getitem__",
      "qname": "safeds.data.tabular.containers._column.Column.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._column.Column.__getitem__.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, index: int) -> Any:\n        return self.get_value(index)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._column.Column.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._column.Column.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/name",
          "name": "name",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Iterable",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Iterable"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/type_",
          "name": "type_",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.type_",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[ColumnType]",
            "default_value": "",
            "description": "The type of the column. If not specified, the type will be inferred from the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[ColumnType]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A column is a named collection of values.",
      "docstring": "",
      "code": "    def __init__(self, name: str, data: Iterable, type_: ColumnType | None = None) -> None:\n        self._name: str = name\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        # noinspection PyProtectedMember\n        self._type: ColumnType = type_ if type_ is not None else ColumnType._from_numpy_data_type(self._data.dtype)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__iter__",
      "name": "__iter__",
      "qname": "safeds.data.tabular.containers._column.Column.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__iter__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__len__",
      "name": "__len__",
      "qname": "safeds.data.tabular.containers._column.Column.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__len__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self) -> int:\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._column.Column.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._column.Column.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values",
      "name": "_count_missing_values",
      "qname": "safeds.data.tabular.containers._column.Column._count_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column._count_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of null values in the column.",
      "docstring": "Return the number of null values in the column.\n\nReturns\n-------\ncount : int\n    The number of null values.",
      "code": "    def _count_missing_values(self) -> int:\n        \"\"\"\n        Return the number of null values in the column.\n\n        Returns\n        -------\n        count : int\n            The number of null values.\n        \"\"\"\n        return self._data.isna().sum()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._column.Column._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/all",
      "name": "all",
      "qname": "safeds.data.tabular.containers._column.Column.all",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/all/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.all.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/all/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.all.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if all values have a given property.",
      "docstring": "Check if all values have a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if all match.",
      "code": "    def all(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if all values have a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if all match.\n\n        \"\"\"\n        return all(predicate(value) for value in self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/any",
      "name": "any",
      "qname": "safeds.data.tabular.containers._column.Column.any",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/any/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.any.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/any/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.any.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if any value has a given property.",
      "docstring": "Check if any value has a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if any match.",
      "code": "    def any(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if any value has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if any match.\n\n        \"\"\"\n        return any(predicate(value) for value in self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with",
      "name": "correlation_with",
      "qname": "safeds.data.tabular.containers._column.Column.correlation_with",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.correlation_with.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with/other_column",
          "name": "other_column",
          "qname": "safeds.data.tabular.containers._column.Column.correlation_with.other_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate Pearson correlation between this and another column. Both columns have to be numerical.",
      "docstring": "Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\nReturns\n-------\ncorrelation : float\n    Correlation between the two columns.\n\nRaises\n------\nTypeError\n    If one of the columns is not numerical.",
      "code": "    def correlation_with(self, other_column: Column) -> float:\n        \"\"\"\n        Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\n        Returns\n        -------\n        correlation : float\n            Correlation between the two columns.\n\n        Raises\n        ------\n        TypeError\n            If one of the columns is not numerical.\n        \"\"\"\n        if not self._type.is_numeric() or not other_column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"Columns must be numerical. {self.name} is {self._type}, \"\n                f\"{other_column.name} is {other_column._type}.\",\n            )\n        if self._data.size != other_column._data.size:\n            raise ColumnLengthMismatchError(\n                f\"{self.name} is of size {self._data.size}, \"\n                f\"{other_column.name} is of size {other_column._data.size}.\",\n            )\n        return self._data.corr(other_column._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values",
      "name": "get_unique_values",
      "qname": "safeds.data.tabular.containers._column.Column.get_unique_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.get_unique_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all unique values in the column.",
      "docstring": "Return a list of all unique values in the column.\n\nReturns\n-------\nunique_values : list[any]\n    List of unique values in the column.",
      "code": "    def get_unique_values(self) -> list[Any]:\n        \"\"\"\n        Return a list of all unique values in the column.\n\n        Returns\n        -------\n        unique_values : list[any]\n            List of unique values in the column.\n        \"\"\"\n        return list(self._data.unique())"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value",
      "name": "get_value",
      "qname": "safeds.data.tabular.containers._column.Column.get_value",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.get_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._column.Column.get_value.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Index of requested element."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return column value at specified index, starting at 0.",
      "docstring": "Return column value at specified index, starting at 0.\n\nParameters\n----------\nindex : int\n    Index of requested element.\n\nReturns\n-------\nvalue\n    Value at index in column.\n\nRaises\n------\nIndexOutOfBoundsError\n    If the given index does not exist in the column.",
      "code": "    def get_value(self, index: int) -> Any:\n        \"\"\"\n        Return column value at specified index, starting at 0.\n\n        Parameters\n        ----------\n        index : int\n            Index of requested element.\n\n        Returns\n        -------\n        value\n            Value at index in column.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If the given index does not exist in the column.\n        \"\"\"\n        if index < 0 or index >= self._data.size:\n            raise IndexOutOfBoundsError(index)\n\n        return self._data[index]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values",
      "name": "has_missing_values",
      "qname": "safeds.data.tabular.containers._column.Column.has_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.has_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the column has missing values.",
      "docstring": "Return whether the column has missing values.\n\nReturns\n-------\nmissing_values_exist : bool\n    True if missing values exist.",
      "code": "    def has_missing_values(self) -> bool:\n        \"\"\"\n        Return whether the column has missing values.\n\n        Returns\n        -------\n        missing_values_exist : bool\n            True if missing values exist.\n        \"\"\"\n        return self.any(lambda value: value is None or (isinstance(value, Number) and np.isnan(value)))"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/idness",
      "name": "idness",
      "qname": "safeds.data.tabular.containers._column.Column.idness",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/idness/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.idness.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate the idness of this column, which we define as.\n\n$$\n\\frac{\\text{number of different values}}{\\text{number of rows}}\n$$",
      "docstring": "Calculate the idness of this column, which we define as.\n\n$$\n\\frac{\\text{number of different values}}{\\text{number of rows}}\n$$\n\nReturns\n-------\nidness : float\n    The idness of the column.\n\nRaises\n------\nColumnSizeError\n    If this column is empty.",
      "code": "    def idness(self) -> float:\n        r\"\"\"\n        Calculate the idness of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of different values}}{\\text{number of rows}}\n        $$\n\n        Returns\n        -------\n        idness : float\n            The idness of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If this column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.nunique() / self._data.size"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/maximum",
      "name": "maximum",
      "qname": "safeds.data.tabular.containers._column.Column.maximum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/maximum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.maximum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the maximum value of the column. The column has to be numerical.",
      "docstring": "Return the maximum value of the column. The column has to be numerical.\n\nReturns\n-------\nmax : float\n    The maximum value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def maximum(self) -> float:\n        \"\"\"\n        Return the maximum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        max : float\n            The maximum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.max()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/mean",
      "name": "mean",
      "qname": "safeds.data.tabular.containers._column.Column.mean",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/mean/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.mean.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mean value of the column. The column has to be numerical.",
      "docstring": "Return the mean value of the column. The column has to be numerical.\n\nReturns\n-------\nmean : float\n    The mean value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def mean(self) -> float:\n        \"\"\"\n        Return the mean value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        mean : float\n            The mean value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.mean()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/median",
      "name": "median",
      "qname": "safeds.data.tabular.containers._column.Column.median",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/median/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.median.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the median value of the column. The column has to be numerical.",
      "docstring": "Return the median value of the column. The column has to be numerical.\n\nReturns\n-------\nmedian : float\n    The median value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def median(self) -> float:\n        \"\"\"\n        Return the median value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        median : float\n            The median value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.median()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/minimum",
      "name": "minimum",
      "qname": "safeds.data.tabular.containers._column.Column.minimum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/minimum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.minimum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the minimum value of the column. The column has to be numerical.",
      "docstring": "Return the minimum value of the column. The column has to be numerical.\n\nReturns\n-------\nmin : float\n    The minimum value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def minimum(self) -> float:\n        \"\"\"\n        Return the minimum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        min : float\n            The minimum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.min()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio",
      "name": "missing_value_ratio",
      "qname": "safeds.data.tabular.containers._column.Column.missing_value_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.missing_value_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the ratio of null values to the total number of elements in the column.",
      "docstring": "Return the ratio of null values to the total number of elements in the column.\n\nReturns\n-------\nratio : float\n    The ratio of null values to the total number of elements in the column.",
      "code": "    def missing_value_ratio(self) -> float:\n        \"\"\"\n        Return the ratio of null values to the total number of elements in the column.\n\n        Returns\n        -------\n        ratio : float\n            The ratio of null values to the total number of elements in the column.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._count_missing_values() / self._data.size"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/mode",
      "name": "mode",
      "qname": "safeds.data.tabular.containers._column.Column.mode",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/mode/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mode of the column.",
      "docstring": "Return the mode of the column.\n\nReturns\n-------\nList :\n    Returns a list with the most common values.",
      "code": "    def mode(self) -> Any:\n        \"\"\"\n        Return the mode of the column.\n\n        Returns\n        -------\n        List :\n            Returns a list with the most common values.\n        \"\"\"\n        return self._data.mode().tolist()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/n_rows@getter",
      "name": "n_rows",
      "qname": "safeds.data.tabular.containers._column.Column.n_rows",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/n_rows@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.n_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of elements in the column.",
      "docstring": "Return the number of elements in the column.\n\nReturns\n-------\nn_rows : int\n    The number of elements.",
      "code": "    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of elements in the column.\n\n        Returns\n        -------\n        n_rows : int\n            The number of elements.\n        \"\"\"\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/name@getter",
      "name": "name",
      "qname": "safeds.data.tabular.containers._column.Column.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/name@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the name of the column.",
      "docstring": "Return the name of the column.\n\nReturns\n-------\nname : str\n    The name of the column.",
      "code": "    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of the column.\n\n        Returns\n        -------\n        name : str\n            The name of the column.\n        \"\"\"\n        return self._name"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/none",
      "name": "none",
      "qname": "safeds.data.tabular.containers._column.Column.none",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/none/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.none.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/none/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.none.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if no values has a given property.",
      "docstring": "Check if no values has a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if none match.",
      "code": "    def none(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if no values has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if none match.\n\n        \"\"\"\n        return all(not predicate(value) for value in self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_boxplot",
      "name": "plot_boxplot",
      "qname": "safeds.data.tabular.containers._column.Column.plot_boxplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_boxplot/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.plot_boxplot.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot this column in a boxplot. This function can only plot real numerical data.",
      "docstring": "Plot this column in a boxplot. This function can only plot real numerical data.\n\nReturns\n-------\nplot: Image\n    The plot as an image.\n\nRaises\n------\nTypeError\n    If the column contains non-numerical data or complex data.",
      "code": "    def plot_boxplot(self) -> Image:\n        \"\"\"\n        Plot this column in a boxplot. This function can only plot real numerical data.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        TypeError\n            If the column contains non-numerical data or complex data.\n        \"\"\"\n        for data in self._data:\n            if not isinstance(data, int) and not isinstance(data, float) and not isinstance(data, complex):\n                raise NonNumericColumnError(self.name)\n            if isinstance(data, complex):\n                raise TypeError(\n                    \"The column contains complex data. Boxplots cannot plot the imaginary part of complex \"\n                    \"data. Please provide a Column with only real numbers\",\n                )\n\n        fig = plt.figure()\n        ax = sns.boxplot(data=self._data)\n        ax.set(xlabel=self.name)\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_histogram",
      "name": "plot_histogram",
      "qname": "safeds.data.tabular.containers._column.Column.plot_histogram",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_histogram/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.plot_histogram.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a column in a histogram.",
      "docstring": "Plot a column in a histogram.\n\nReturns\n-------\nplot: Image\n    The plot as an image.",
      "code": "    def plot_histogram(self) -> Image:\n        \"\"\"\n        Plot a column in a histogram.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        fig = plt.figure()\n        ax = sns.histplot(data=self._data)\n        ax.set_xticks(ax.get_xticks())\n        ax.set(xlabel=self.name)\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/rename",
      "name": "rename",
      "qname": "safeds.data.tabular.containers._column.Column.rename",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/rename/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.rename.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/rename/new_name",
          "name": "new_name",
          "qname": "safeds.data.tabular.containers._column.Column.rename.new_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The new name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a new column with a new name.",
      "docstring": "Return a new column with a new name.\n\nParameters\n----------\nnew_name : str\n    The new name of the column.\n\nReturns\n-------\ncolumn : Column\n    A new column with the new name.",
      "code": "    def rename(self, new_name: str) -> Column:\n        \"\"\"\n        Return a new column with a new name.\n\n        Parameters\n        ----------\n        new_name : str\n            The new name of the column.\n\n        Returns\n        -------\n        column : Column\n            A new column with the new name.\n        \"\"\"\n        return Column(new_name, self._data, self._type)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/stability",
      "name": "stability",
      "qname": "safeds.data.tabular.containers._column.Column.stability",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/stability/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.stability.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate the stability of this column, which we define as.\n\n$$\n\\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n$$",
      "docstring": "Calculate the stability of this column, which we define as.\n\n$$\n\\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n$$\n\nReturns\n-------\nstability : float\n    The stability of the column.\n\nRaises\n------\nColumnSizeError\n    If the column is empty.",
      "code": "    def stability(self) -> float:\n        r\"\"\"\n        Calculate the stability of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n        $$\n\n        Returns\n        -------\n        stability : float\n            The stability of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If the column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.value_counts()[self.mode()[0]] / self._data.count()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/standard_deviation",
      "name": "standard_deviation",
      "qname": "safeds.data.tabular.containers._column.Column.standard_deviation",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/standard_deviation/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.standard_deviation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the standard deviation of the column. The column has to be numerical.",
      "docstring": "Return the standard deviation of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The standard deviation of all values.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def standard_deviation(self) -> float:\n        \"\"\"\n        Return the standard deviation of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The standard deviation of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.std()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/sum",
      "name": "sum",
      "qname": "safeds.data.tabular.containers._column.Column.sum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/sum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.sum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the sum of the column. The column has to be numerical.",
      "docstring": "Return the sum of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The sum of all values.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def sum(self) -> float:\n        \"\"\"\n        Return the sum of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The sum of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.sum()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/type@getter",
      "name": "type",
      "qname": "safeds.data.tabular.containers._column.Column.type",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/type@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the column.",
      "docstring": "Return the type of the column.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.",
      "code": "    @property\n    def type(self) -> ColumnType:\n        \"\"\"\n        Return the type of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n        \"\"\"\n        return self._type"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/variance",
      "name": "variance",
      "qname": "safeds.data.tabular.containers._column.Column.variance",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/variance/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.variance.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the variance of the column. The column has to be numerical.",
      "docstring": "Return the variance of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The variance of all values.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def variance(self) -> float:\n        \"\"\"\n        Return the variance of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The variance of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n\n        return self._data.var()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__contains__",
      "name": "__contains__",
      "qname": "safeds.data.tabular.containers._row.Row.__contains__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__contains__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__contains__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__contains__/obj",
          "name": "obj",
          "qname": "safeds.data.tabular.containers._row.Row.__contains__.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Any",
            "default_value": "",
            "description": "The object."
          },
          "type": {
            "kind": "NamedType",
            "name": "Any"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check whether the row contains an object as key.",
      "docstring": "Check whether the row contains an object as key.\n\nParameters\n----------\nobj : Any\n    The object.\n\nReturns\n-------\nhas_column : bool\n    True, if the row contains the object as key, False otherwise.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> \"a\" in row\nTrue\n\n>>> \"c\" in row\nFalse",
      "code": "    def __contains__(self, obj: Any) -> bool:\n        \"\"\"\n        Check whether the row contains an object as key.\n\n        Parameters\n        ----------\n        obj : Any\n            The object.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the object as key, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> \"a\" in row\n        True\n\n        >>> \"c\" in row\n        False\n        \"\"\"\n        return isinstance(obj, str) and self.has_column(obj)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._row.Row.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._row.Row.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Any",
            "default_value": "",
            "description": "The other object."
          },
          "type": {
            "kind": "NamedType",
            "name": "Any"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check whether this row is equal to another object.",
      "docstring": "Check whether this row is equal to another object.\n\nParameters\n----------\nother : Any\n    The other object.\n\nReturns\n-------\nequal : bool\n    True if the other object is an identical row. False if the other object is a different row. NotImplemented\n    if the other object is not a row.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row1 = Row({\"a\": 1, \"b\": 2})\n>>> row2 = Row({\"a\": 1, \"b\": 2})\n>>> row1 == row2\nTrue\n\n>>> row3 = Row({\"a\": 1, \"b\": 3})\n>>> row1 == row3\nFalse",
      "code": "    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Check whether this row is equal to another object.\n\n        Parameters\n        ----------\n        other : Any\n            The other object.\n\n        Returns\n        -------\n        equal : bool\n            True if the other object is an identical row. False if the other object is a different row. NotImplemented\n            if the other object is not a row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row1 = Row({\"a\": 1, \"b\": 2})\n        >>> row2 = Row({\"a\": 1, \"b\": 2})\n        >>> row1 == row2\n        True\n\n        >>> row3 = Row({\"a\": 1, \"b\": 3})\n        >>> row1 == row3\n        False\n        \"\"\"\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._schema == other._schema and self._data.frame_equal(other._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__",
      "name": "__getitem__",
      "qname": "safeds.data.tabular.containers._row.Row.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.__getitem__.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the value of a specified column.",
      "docstring": "Return the value of a specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nvalue : Any\n    The column value.\n\nRaises\n------\nUnknownColumnNameError\n    If the row does not contain the specified column.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row[\"a\"]\n1",
      "code": "    def __getitem__(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row[\"a\"]\n        1\n        \"\"\"\n        return self.get_value(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._row.Row.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.data",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Mapping[str, Any] | None",
            "default_value": "",
            "description": "The data. If None, an empty row is created."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Mapping[str"
              },
              {
                "kind": "NamedType",
                "name": "Any] | None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A row is a collection of named values.",
      "docstring": "Create a row from a mapping of column names to column values.\n\nParameters\n----------\ndata : Mapping[str, Any] | None\n    The data. If None, an empty row is created.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})",
      "code": "    def __init__(self, data: Mapping[str, Any] | None = None):\n        \"\"\"\n        Create a row from a mapping of column names to column values.\n\n        Parameters\n        ----------\n        data : Mapping[str, Any] | None\n            The data. If None, an empty row is created.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        \"\"\"\n        if data is None:\n            data = {}\n\n        self._data: pl.DataFrame = pl.DataFrame(data)\n        # noinspection PyProtectedMember\n        self._schema: Schema = Schema._from_polars_dataframe(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__iter__",
      "name": "__iter__",
      "qname": "safeds.data.tabular.containers._row.Row.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__iter__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create an iterator for the column names of this row.",
      "docstring": "Create an iterator for the column names of this row.\n\nReturns\n-------\niterator : Iterator[Any]\n    The iterator.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> list(row)\n['a', 'b']",
      "code": "    def __iter__(self) -> Iterator[Any]:\n        \"\"\"\n        Create an iterator for the column names of this row.\n\n        Returns\n        -------\n        iterator : Iterator[Any]\n            The iterator.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> list(row)\n        ['a', 'b']\n        \"\"\"\n        return iter(self.column_names)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__len__",
      "name": "__len__",
      "qname": "safeds.data.tabular.containers._row.Row.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__len__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns in this row.",
      "docstring": "Return the number of columns in this row.\n\nReturns\n-------\nn_columns : int\n    The number of columns.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> len(row)\n2",
      "code": "    def __len__(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> len(row)\n        2\n        \"\"\"\n        return self._data.width"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._row.Row.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return an unambiguous string representation of this row.",
      "docstring": "Return an unambiguous string representation of this row.\n\nReturns\n-------\nrepresentation : str\n    The string representation.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1})\n>>> repr(row)\n\"Row({'a': 1})\"",
      "code": "    def __repr__(self) -> str:\n        \"\"\"\n        Return an unambiguous string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> repr(row)\n        \"Row({'a': 1})\"\n        \"\"\"\n        return f\"Row({str(self)})\""
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._row.Row.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a user-friendly string representation of this row.",
      "docstring": "Return a user-friendly string representation of this row.\n\nReturns\n-------\nrepresentation : str\n    The string representation.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1})\n>>> str(row)\n\"{'a': 1}\"",
      "code": "    def __str__(self) -> str:\n        \"\"\"\n        Return a user-friendly string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> str(row)\n        \"{'a': 1}\"\n        \"\"\"\n        match len(self):\n            case 0:\n                return \"{}\"\n            case 1:\n                return str(self.to_dict())\n            case _:\n                lines = (f\"    {name!r}: {value!r}\" for name, value in self.to_dict().items())\n                joined = \",\\n\".join(lines)\n                return f\"{{\\n{joined}\\n}}\""
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe",
      "name": "_from_polars_dataframe",
      "qname": "safeds.data.tabular.containers._row.Row._from_polars_dataframe",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row._from_polars_dataframe.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "polars.DataFrame",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "NamedType",
            "name": "polars.DataFrame"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._row.Row._from_polars_dataframe.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Schema | None",
            "default_value": "",
            "description": "The schema. If None, the schema is inferred from the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Schema | None"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a row from a `polars.DataFrame`.",
      "docstring": "Create a row from a `polars.DataFrame`.\n\nParameters\n----------\ndata : polars.DataFrame\n    The data.\nschema : Schema | None\n    The schema. If None, the schema is inferred from the data.\n\nReturns\n-------\nrow : Row\n    The created row.\n\nExamples\n--------\n>>> import polars as pl\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row._from_polars_dataframe(pl.DataFrame({\"a\": [1], \"b\": [2]}))",
      "code": "    @staticmethod\n    def _from_polars_dataframe(data: pl.DataFrame, schema: Schema | None = None) -> Row:\n        \"\"\"\n        Create a row from a `polars.DataFrame`.\n\n        Parameters\n        ----------\n        data : polars.DataFrame\n            The data.\n        schema : Schema | None\n            The schema. If None, the schema is inferred from the data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> import polars as pl\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row._from_polars_dataframe(pl.DataFrame({\"a\": [1], \"b\": [2]}))\n        \"\"\"\n        result = object.__new__(Row)\n        result._data = data\n\n        if schema is None:\n            # noinspection PyProtectedMember\n            result._schema = Schema._from_polars_dataframe(data)\n        else:\n            result._schema = schema\n\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/_repr_html_",
      "name": "_repr_html_",
      "qname": "safeds.data.tabular.containers._row.Row._repr_html_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_repr_html_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row._repr_html_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return an HTML representation of the row.",
      "docstring": "Return an HTML representation of the row.\n\nReturns\n-------\noutput : str\n    The generated HTML.",
      "code": "    def _repr_html_(self) -> str:\n        \"\"\"\n        Return an HTML representation of the row.\n\n        Returns\n        -------\n        output : str\n            The generated HTML.\n        \"\"\"\n        # noinspection PyProtectedMember\n        return self._data._repr_html_()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/column_names@getter",
      "name": "column_names",
      "qname": "safeds.data.tabular.containers._row.Row.column_names",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/column_names@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names in the row.",
      "docstring": "Return a list of all column names in the row.\n\nReturns\n-------\ncolumn_names : list[str]\n    The column names.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.column_names\n['a', 'b']",
      "code": "    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in the row.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.column_names\n        ['a', 'b']\n        \"\"\"\n        return self._schema.column_names"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/from_dict",
      "name": "from_dict",
      "qname": "safeds.data.tabular.containers._row.Row.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/from_dict/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row.from_dict.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict[str, Any]",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "Any]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a row from a dictionary that maps column names to column values.",
      "docstring": "Create a row from a dictionary that maps column names to column values.\n\nParameters\n----------\ndata : dict[str, Any]\n    The data.\n\nReturns\n-------\nrow : Row\n    The created row.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row.from_dict({\"a\": 1, \"b\": 2})",
      "code": "    @staticmethod\n    def from_dict(data: dict[str, Any]) -> Row:\n        \"\"\"\n        Create a row from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, Any]\n            The data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row.from_dict({\"a\": 1, \"b\": 2})\n        \"\"\"\n        return Row(data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_type",
      "name": "get_column_type",
      "qname": "safeds.data.tabular.containers._row.Row.get_column_type",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_type/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_column_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_type/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.get_column_type.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the specified column.",
      "docstring": "Return the type of the specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nUnknownColumnNameError\n    If the row does not contain the specified column.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.get_column_type(\"a\")\nInteger",
      "code": "    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_column_type(\"a\")\n        Integer\n        \"\"\"\n        return self._schema.get_column_type(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value",
      "name": "get_value",
      "qname": "safeds.data.tabular.containers._row.Row.get_value",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.get_value.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the value of a specified column.",
      "docstring": "Return the value of a specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nvalue : Any\n    The column value.\n\nRaises\n------\nUnknownColumnNameError\n    If the row does not contain the specified column.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.get_value(\"a\")\n1",
      "code": "    def get_value(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_value(\"a\")\n        1\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n\n        return self._data[0, column_name]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.containers._row.Row.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check whether the row contains a given column.",
      "docstring": "Check whether the row contains a given column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nhas_column : bool\n    True, if the row contains the column, False otherwise.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.has_column(\"a\")\nTrue\n\n>>> row.has_column(\"c\")\nFalse",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Check whether the row contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the column, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.has_column(\"a\")\n        True\n\n        >>> row.has_column(\"c\")\n        False\n        \"\"\"\n        return self._schema.has_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/n_columns@getter",
      "name": "n_columns",
      "qname": "safeds.data.tabular.containers._row.Row.n_columns",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/n_columns@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.n_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns in this row.",
      "docstring": "Return the number of columns in this row.\n\nReturns\n-------\nn_columns : int\n    The number of columns.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.n_columns\n2",
      "code": "    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.n_columns\n        2\n        \"\"\"\n        return self._data.width"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/schema@getter",
      "name": "schema",
      "qname": "safeds.data.tabular.containers._row.Row.schema",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/schema@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.schema.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the schema of the row.",
      "docstring": "Return the schema of the row.\n\nReturns\n-------\nschema : Schema\n    The schema.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> schema = row.schema",
      "code": "    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the row.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> schema = row.schema\n        \"\"\"\n        return self._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/to_dict",
      "name": "to_dict",
      "qname": "safeds.data.tabular.containers._row.Row.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/to_dict/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a dictionary that maps column names to column values.",
      "docstring": "Return a dictionary that maps column names to column values.\n\nReturns\n-------\ndata : dict[str, Any]\n    Dictionary representation of the row.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.to_dict()\n{'a': 1, 'b': 2}",
      "code": "    def to_dict(self) -> dict[str, Any]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, Any]\n            Dictionary representation of the row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.to_dict()\n        {'a': 1, 'b': 2}\n        \"\"\"\n        return {column_name: self.get_value(column_name) for column_name in self.column_names}"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__",
      "name": "__dataframe__",
      "qname": "safeds.data.tabular.containers._table.Table.__dataframe__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__dataframe__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__/nan_as_null",
          "name": "nan_as_null",
          "qname": "safeds.data.tabular.containers._table.Table.__dataframe__.nan_as_null",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether to replace missing values in the data with `NaN`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__/allow_copy",
          "name": "allow_copy",
          "qname": "safeds.data.tabular.containers._table.Table.__dataframe__.allow_copy",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether memory may be copied to create the DataFrame exchange object."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\nGenerally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\nallow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\ndecide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\ninterchange protocol.\n\nThe specification of the dataframe interchange protocol can be found on\n[GitHub](https://github.com/data-apis/dataframe-api).",
      "docstring": "Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\nGenerally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\nallow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\ndecide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\ninterchange protocol.\n\nThe specification of the dataframe interchange protocol can be found on\n[GitHub](https://github.com/data-apis/dataframe-api).\n\nParameters\n----------\nnan_as_null : bool\n    Whether to replace missing values in the data with `NaN`.\nallow_copy : bool\n    Whether memory may be copied to create the DataFrame exchange object.\n\nReturns\n-------\ndataframe\n    A DataFrame object that conforms to the dataframe interchange protocol.",
      "code": "    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True):  # type: ignore[no-untyped-def]\n        \"\"\"\n        Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\n        Generally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\n        allow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\n        decide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\n        interchange protocol.\n\n        The specification of the dataframe interchange protocol can be found on\n        [GitHub](https://github.com/data-apis/dataframe-api).\n\n        Parameters\n        ----------\n        nan_as_null : bool\n            Whether to replace missing values in the data with `NaN`.\n        allow_copy : bool\n            Whether memory may be copied to create the DataFrame exchange object.\n\n        Returns\n        -------\n        dataframe\n            A DataFrame object that conforms to the dataframe interchange protocol.\n        \"\"\"\n        if not allow_copy:\n            raise NotImplementedError(\"For the moment we need to copy the data, so `allow_copy` must be True.\")\n\n        data_copy = self._data.copy()\n        data_copy.columns = self.column_names\n        return data_copy.__dataframe__(nan_as_null, allow_copy)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._table.Table.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._table.Table.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Table):\n            return NotImplemented\n        if self is other:\n            return True\n        table1 = self.sort_columns()\n        table2 = other.sort_columns()\n        return table1._data.equals(table2._data) and table1._schema == table2._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._table.Table.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._table.Table.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\nTo create a `Table`, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "docstring": "Create a table from a `DataFrame`.\n\nYou should not use this constructor directly. Instead, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "code": "    def __init__(self, data: Iterable, schema: Schema | None = None):\n        \"\"\"\n        Create a table from a `DataFrame`.\n\n        You should not use this constructor directly. Instead, use one of the following static methods:\n\n        | Method                                                                       | Description                            |\n        | ---------------------------------------------------------------------------- | -------------------------------------- |\n        | [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n        | [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n        | [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n        | [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n        | [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |\n        \"\"\"\n        self._data: pd.DataFrame = data if isinstance(data, pd.DataFrame) else pd.DataFrame(data)\n        self._schema: Schema = Schema._from_pandas_dataframe(self._data) if schema is None else schema\n\n        if self._data.empty:\n            self._data = pd.DataFrame(columns=self._schema.column_names)\n\n        self._data = self._data.reset_index(drop=True)\n        self._data.columns = self._schema.column_names"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._table.Table.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._table.Table.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._table.Table._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column",
      "name": "add_column",
      "qname": "safeds.data.tabular.containers._table.Table.add_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column/column",
          "name": "column",
          "qname": "safeds.data.tabular.containers._table.Table.add_column.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the original table with the provided column attached at the end.",
      "docstring": "Return the original table with the provided column attached at the end.\n\nReturns\n-------\nresult : Table\n    The table with the column attached.\n\nRaises\n------\nDuplicateColumnNameError\n    If the new column already exists.\n\nColumnSizeError\n    If the size of the column does not match the amount of rows.",
      "code": "    def add_column(self, column: Column) -> Table:\n        \"\"\"\n        Return the original table with the provided column attached at the end.\n\n        Returns\n        -------\n        result : Table\n            The table with the column attached.\n\n        Raises\n        ------\n        DuplicateColumnNameError\n            If the new column already exists.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n\n        \"\"\"\n        if self.has_column(column.name):\n            raise DuplicateColumnNameError(column.name)\n\n        if column._data.size != self.n_rows:\n            raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        result[column.name] = column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns",
      "name": "add_columns",
      "qname": "safeds.data.tabular.containers._table.Table.add_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.containers._table.Table.add_columns.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Column] or Table",
            "default_value": "",
            "description": "The columns to be added."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list[Column]"
              },
              {
                "kind": "NamedType",
                "name": "Table"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add multiple columns to the table.",
      "docstring": "Add multiple columns to the table.\n\nParameters\n----------\ncolumns : list[Column] or Table\n    The columns to be added.\n\nReturns\n-------\nresult: Table\n    A new table combining the original table and the given columns.\n\nRaises\n------\nColumnSizeError\n    If at least one of the column sizes from the provided column list does not match the table.\nDuplicateColumnNameError\n    If at least one column name from the provided column list already exists in the table.",
      "code": "    def add_columns(self, columns: list[Column] | Table) -> Table:\n        \"\"\"\n        Add multiple columns to the table.\n\n        Parameters\n        ----------\n        columns : list[Column] or Table\n            The columns to be added.\n\n        Returns\n        -------\n        result: Table\n            A new table combining the original table and the given columns.\n\n        Raises\n        ------\n        ColumnSizeError\n            If at least one of the column sizes from the provided column list does not match the table.\n        DuplicateColumnNameError\n            If at least one column name from the provided column list already exists in the table.\n        \"\"\"\n        if isinstance(columns, Table):\n            columns = columns.to_columns()\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        for column in columns:\n            if column.name in result.columns:\n                raise DuplicateColumnNameError(column.name)\n\n            if column._data.size != self.n_rows:\n                raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n            result[column.name] = column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row",
      "name": "add_row",
      "qname": "safeds.data.tabular.containers._table.Table.add_row",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_row.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row/row",
          "name": "row",
          "qname": "safeds.data.tabular.containers._table.Table.add_row.row",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Row",
            "default_value": "",
            "description": "The row to be added."
          },
          "type": {
            "kind": "NamedType",
            "name": "Row"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add a row to the table.",
      "docstring": "Add a row to the table.\n\nParameters\n----------\nrow : Row\n    The row to be added.\n\nReturns\n-------\ntable : Table\n    A new table with the added row at the end.",
      "code": "    def add_row(self, row: Row) -> Table:\n        \"\"\"\n        Add a row to the table.\n\n        Parameters\n        ----------\n        row : Row\n            The row to be added.\n\n        Returns\n        -------\n        table : Table\n            A new table with the added row at the end.\n\n        \"\"\"\n        if self._schema != row.schema:\n            raise SchemaMismatchError\n\n        row_frame = row._data.to_pandas()\n\n        new_df = pd.concat([self._data, row_frame]).infer_objects()\n        new_df.columns = self.column_names\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows",
      "name": "add_rows",
      "qname": "safeds.data.tabular.containers._table.Table.add_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows/rows",
          "name": "rows",
          "qname": "safeds.data.tabular.containers._table.Table.add_rows.rows",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Row] or Table",
            "default_value": "",
            "description": "The rows to be added."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list[Row]"
              },
              {
                "kind": "NamedType",
                "name": "Table"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add multiple rows to a table.",
      "docstring": "Add multiple rows to a table.\n\nParameters\n----------\nrows : list[Row] or Table\n    The rows to be added.\n\nReturns\n-------\nresult : Table\n    A new table which combines the original table and the given rows.",
      "code": "    def add_rows(self, rows: list[Row] | Table) -> Table:\n        \"\"\"\n        Add multiple rows to a table.\n\n        Parameters\n        ----------\n        rows : list[Row] or Table\n            The rows to be added.\n\n        Returns\n        -------\n        result : Table\n            A new table which combines the original table and the given rows.\n        \"\"\"\n        if isinstance(rows, Table):\n            rows = rows.to_rows()\n        result = self._data\n        for row in rows:\n            if self._schema != row.schema:\n                raise SchemaMismatchError\n\n        row_frames = [row._data.to_pandas() for row in rows]\n        for row_frame in row_frames:\n            row_frame.columns = self.column_names\n\n        result = pd.concat([result, *row_frames]).infer_objects()\n        result.columns = self.column_names\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/column_names@getter",
      "name": "column_names",
      "qname": "safeds.data.tabular.containers._table.Table.column_names",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/column_names@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names in this table.\n\nAlias for self.schema.column_names -> list[str].",
      "docstring": "Return a list of all column names in this table.\n\nAlias for self.schema.column_names -> list[str].\n\nReturns\n-------\ncolumn_names : list[str]\n    The list of the column names.",
      "code": "    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in this table.\n\n        Alias for self.schema.column_names -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The list of the column names.\n        \"\"\"\n        return self._schema.column_names"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows",
      "name": "filter_rows",
      "qname": "safeds.data.tabular.containers._table.Table.filter_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.filter_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows/query",
          "name": "query",
          "qname": "safeds.data.tabular.containers._table.Table.filter_rows.query",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "lambda function",
            "default_value": "",
            "description": "A Callable that is applied to all rows."
          },
          "type": {
            "kind": "NamedType",
            "name": "lambda function"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with rows filtered by Callable (e.g. lambda function).",
      "docstring": "Return a table with rows filtered by Callable (e.g. lambda function).\n\nParameters\n----------\nquery : lambda function\n    A Callable that is applied to all rows.\n\nReturns\n-------\ntable : Table\n    A table containing only the rows filtered by the query.",
      "code": "    def filter_rows(self, query: Callable[[Row], bool]) -> Table:\n        \"\"\"\n        Return a table with rows filtered by Callable (e.g. lambda function).\n\n        Parameters\n        ----------\n        query : lambda function\n            A Callable that is applied to all rows.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the rows filtered by the query.\n        \"\"\"\n        rows: list[Row] = [row for row in self.to_rows() if query(row)]\n        if len(rows) == 0:\n            result_table = Table([], self._schema)\n        else:\n            result_table = self.from_rows(rows)\n        return result_table"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_columns",
      "name": "from_columns",
      "qname": "safeds.data.tabular.containers._table.Table.from_columns",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_columns/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.containers._table.Table.from_columns.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Column]",
            "default_value": "",
            "description": "The columns to be combined. They need to have the same size."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[Column]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table created from a list of columns.",
      "docstring": "Return a table created from a list of columns.\n\nParameters\n----------\ncolumns : list[Column]\n    The columns to be combined. They need to have the same size.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nColumnLengthMismatchError\n    If any of the column sizes does not match with the others.",
      "code": "    @staticmethod\n    def from_columns(columns: list[Column]) -> Table:\n        \"\"\"\n        Return a table created from a list of columns.\n\n        Parameters\n        ----------\n        columns : list[Column]\n            The columns to be combined. They need to have the same size.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If any of the column sizes does not match with the others.\n        \"\"\"\n        dataframe: DataFrame = pd.DataFrame()\n\n        for column in columns:\n            if column._data.size != columns[0]._data.size:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column.name}: {column._data.size}\" for column in columns),\n                )\n            dataframe[column.name] = column._data\n\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_csv_file",
      "name": "from_csv_file",
      "qname": "safeds.data.tabular.containers._table.Table.from_csv_file",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_csv_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.from_csv_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the CSV file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Read data from a CSV file into a table.",
      "docstring": "Read data from a CSV file into a table.\n\nParameters\n----------\npath : str\n    The path to the CSV file.\n\nReturns\n-------\ntable : Table\n    The table created from the CSV file.\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist.\nValueError\n    If the file could not be read.",
      "code": "    @staticmethod\n    def from_csv_file(path: str) -> Table:\n        \"\"\"\n        Read data from a CSV file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the CSV file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the CSV file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_csv(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_dict",
      "name": "from_dict",
      "qname": "safeds.data.tabular.containers._table.Table.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_dict/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._table.Table.from_dict.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict[str, list[Any]]",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "list[Any]]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a table from a dictionary that maps column names to column values.",
      "docstring": "Create a table from a dictionary that maps column names to column values.\n\nParameters\n----------\ndata : dict[str, list[Any]]\n    The data.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nColumnLengthMismatchError\n    If columns have different lengths.",
      "code": "    @staticmethod\n    def from_dict(data: dict[str, list[Any]]) -> Table:\n        \"\"\"\n        Create a table from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, list[Any]]\n            The data.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If columns have different lengths.\n        \"\"\"\n        # Validation\n        expected_length: int | None = None\n        for column_values in data.values():\n            if expected_length is None:\n                expected_length = len(column_values)\n            elif len(column_values) != expected_length:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column_name}: {len(column_values)}\" for column_name, column_values in data.items()),\n                )\n\n        # Implementation\n        dataframe: DataFrame = pd.DataFrame()\n        for column_name, column_values in data.items():\n            dataframe[column_name] = column_values\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_json_file",
      "name": "from_json_file",
      "qname": "safeds.data.tabular.containers._table.Table.from_json_file",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_json_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.from_json_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the JSON file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Read data from a JSON file into a table.",
      "docstring": "Read data from a JSON file into a table.\n\nParameters\n----------\npath : str\n    The path to the JSON file.\n\nReturns\n-------\ntable : Table\n    The table created from the JSON file.\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist.\nValueError\n    If the file could not be read.",
      "code": "    @staticmethod\n    def from_json_file(path: str) -> Table:\n        \"\"\"\n        Read data from a JSON file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the JSON file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the JSON file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_json(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_rows",
      "name": "from_rows",
      "qname": "safeds.data.tabular.containers._table.Table.from_rows",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_rows/rows",
          "name": "rows",
          "qname": "safeds.data.tabular.containers._table.Table.from_rows.rows",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Row]",
            "default_value": "",
            "description": "The rows to be combined. They need to have a matching schema."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[Row]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table created from a list of rows.",
      "docstring": "Return a table created from a list of rows.\n\nParameters\n----------\nrows : list[Row]\n    The rows to be combined. They need to have a matching schema.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nMissingDataError\n    If an empty list is given.\nSchemaMismatchError\n    If any of the row schemas does not match with the others.",
      "code": "    @staticmethod\n    def from_rows(rows: list[Row]) -> Table:\n        \"\"\"\n        Return a table created from a list of rows.\n\n        Parameters\n        ----------\n        rows : list[Row]\n            The rows to be combined. They need to have a matching schema.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        SchemaMismatchError\n            If any of the row schemas does not match with the others.\n        \"\"\"\n        if len(rows) == 0:\n            raise MissingDataError(\"This function requires at least one row.\")\n\n        schema_compare: Schema = rows[0]._schema\n        row_array: list[pd.DataFrame] = []\n\n        for row in rows:\n            if schema_compare != row._schema:\n                raise SchemaMismatchError\n            row_array.append(row._data.to_pandas())\n\n        dataframe: DataFrame = pd.concat(row_array, ignore_index=True)\n        dataframe.columns = schema_compare.column_names\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column",
      "name": "get_column",
      "qname": "safeds.data.tabular.containers._table.Table.get_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.get_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a column with the data of the specified column.",
      "docstring": "Return a column with the data of the specified column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncolumn : Column\n    The column.\n\nRaises\n------\nUnknownColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_column(self, column_name: str) -> Column:\n        \"\"\"\n        Return a column with the data of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        column : Column\n            The column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if self._schema.has_column(column_name):\n            output_column = Column(\n                column_name,\n                self._data.iloc[:, [self._schema._get_column_index(column_name)]].squeeze(),\n                self._schema.get_column_type(column_name),\n            )\n            return output_column\n\n        raise UnknownColumnNameError([column_name])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_type",
      "name": "get_column_type",
      "qname": "safeds.data.tabular.containers._table.Table.get_column_type",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_type/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_column_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_type/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.get_column_type.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column to be queried."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the given column.\n\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.",
      "docstring": "Return the type of the given column.\n\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column to be queried.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column to be queried.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self._schema.get_column_type(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row",
      "name": "get_row",
      "qname": "safeds.data.tabular.containers._table.Table.get_row",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_row.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._table.Table.get_row.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The index."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the row at a specified index.",
      "docstring": "Return the row at a specified index.\n\nParameters\n----------\nindex : int\n    The index.\n\nReturns\n-------\nrow : Row\n    The row of the table at the index.\n\nRaises\n------\nIndexOutOfBoundsError\n    If no row at the specified index exists in this table.",
      "code": "    def get_row(self, index: int) -> Row:\n        \"\"\"\n        Return the row at a specified index.\n\n        Parameters\n        ----------\n        index : int\n            The index.\n\n        Returns\n        -------\n        row : Row\n            The row of the table at the index.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If no row at the specified index exists in this table.\n        \"\"\"\n        if len(self._data.index) - 1 < index or index < 0:\n            raise IndexOutOfBoundsError(index)\n\n        return Row._from_polars_dataframe(pl.DataFrame(self._data.iloc[[index]]), self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.containers._table.Table.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the table contains a given column.\n\nAlias for self.schema.hasColumn(column_name: str) -> bool.",
      "docstring": "Return whether the table contains a given column.\n\nAlias for self.schema.hasColumn(column_name: str) -> bool.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncontains : bool\n    True if the column exists.",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the table contains a given column.\n\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the column exists.\n        \"\"\"\n        return self._schema.has_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns",
      "name": "keep_only_columns",
      "qname": "safeds.data.tabular.containers._table.Table.keep_only_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.keep_only_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.containers._table.Table.keep_only_columns.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "A list containing only the columns to be kept."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with only the given column(s).",
      "docstring": "Return a table with only the given column(s).\n\nParameters\n----------\ncolumn_names : list[str]\n    A list containing only the columns to be kept.\n\nReturns\n-------\ntable : Table\n    A table containing only the given column(s).\n\nRaises\n------\nColumnNameError\n    If any of the given columns does not exist.",
      "code": "    def keep_only_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table with only the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing only the columns to be kept.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the given column(s).\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data[column_names]\n        transformed_data.columns = column_names\n        return Table(transformed_data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/n_columns@getter",
      "name": "n_columns",
      "qname": "safeds.data.tabular.containers._table.Table.n_columns",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/n_columns@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.n_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns.",
      "docstring": "Return the number of columns.\n\nReturns\n-------\nn_columns : int\n    The number of columns.",
      "code": "    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n        \"\"\"\n        return self._data.shape[1]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/n_rows@getter",
      "name": "n_rows",
      "qname": "safeds.data.tabular.containers._table.Table.n_rows",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/n_rows@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.n_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of rows.",
      "docstring": "Return the number of rows.\n\nReturns\n-------\nn_rows : int\n    The number of rows.",
      "code": "    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of rows.\n\n        Returns\n        -------\n        n_rows : int\n            The number of rows.\n        \"\"\"\n        return self._data.shape[0]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_correlation_heatmap",
      "name": "plot_correlation_heatmap",
      "qname": "safeds.data.tabular.containers._table.Table.plot_correlation_heatmap",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_correlation_heatmap/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.plot_correlation_heatmap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a correlation heatmap for all numerical columns of this `Table`.",
      "docstring": "Plot a correlation heatmap for all numerical columns of this `Table`.\n\nReturns\n-------\nplot: Image\n    The plot as an image.",
      "code": "    def plot_correlation_heatmap(self) -> Image:\n        \"\"\"\n        Plot a correlation heatmap for all numerical columns of this `Table`.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        only_numerical = self.remove_columns_with_non_numerical_values()\n\n        fig = plt.figure()\n        sns.heatmap(\n            data=only_numerical._data.corr(),\n            vmin=-1,\n            vmax=1,\n            xticklabels=only_numerical.column_names,\n            yticklabels=only_numerical.column_names,\n            cmap=\"vlag\",\n        )\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot",
      "name": "plot_lineplot",
      "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot/x_column_name",
          "name": "x_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot.x_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the x-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot/y_column_name",
          "name": "y_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot.y_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the y-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot two columns against each other in a lineplot.\n\nIf there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\nand the lower-transparency area around the line representing the 95% confidence interval.",
      "docstring": "Plot two columns against each other in a lineplot.\n\nIf there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\nand the lower-transparency area around the line representing the 95% confidence interval.\n\nParameters\n----------\nx_column_name : str\n    The column name of the column to be plotted on the x-Axis.\ny_column_name : str\n    The column name of the column to be plotted on the y-Axis.\n\nReturns\n-------\nplot: Image\n    The plot as an image.\n\nRaises\n------\nUnknownColumnNameError\n    If either of the columns do not exist.",
      "code": "    def plot_lineplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a lineplot.\n\n        If there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\n        and the lower-transparency area around the line representing the 95% confidence interval.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.lineplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot",
      "name": "plot_scatterplot",
      "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot/x_column_name",
          "name": "x_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot.x_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the x-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot/y_column_name",
          "name": "y_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot.y_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the y-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot two columns against each other in a scatterplot.",
      "docstring": "Plot two columns against each other in a scatterplot.\n\nParameters\n----------\nx_column_name : str\n    The column name of the column to be plotted on the x-Axis.\ny_column_name : str\n    The column name of the column to be plotted on the y-Axis.\n\nReturns\n-------\nplot: Image\n    The plot as an image.\n\nRaises\n------\nUnknownColumnNameError\n    If either of the columns do not exist.",
      "code": "    def plot_scatterplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a scatterplot.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.scatterplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns",
      "name": "remove_columns",
      "qname": "safeds.data.tabular.containers._table.Table.remove_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "A list containing all columns to be dropped."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the given column(s).",
      "docstring": "Return a table without the given column(s).\n\nParameters\n----------\ncolumn_names : list[str]\n    A list containing all columns to be dropped.\n\nReturns\n-------\ntable : Table\n    A table without the given columns.\n\nRaises\n------\nColumnNameError\n    If any of the given columns does not exist.",
      "code": "    def remove_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table without the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing all columns to be dropped.\n\n        Returns\n        -------\n        table : Table\n            A table without the given columns.\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data.drop(labels=column_names, axis=\"columns\")\n        transformed_data.columns = [name for name in self._schema.column_names if name not in column_names]\n        return Table(transformed_data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_missing_values",
      "name": "remove_columns_with_missing_values",
      "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the columns that contain missing values.",
      "docstring": "Return a table without the columns that contain missing values.\n\nReturns\n-------\ntable : Table\n    A table without the columns that contain missing values.",
      "code": "    def remove_columns_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain missing values.\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if not column.has_missing_values()])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_non_numerical_values",
      "name": "remove_columns_with_non_numerical_values",
      "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_non_numerical_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_non_numerical_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_non_numerical_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the columns that contain non-numerical values.",
      "docstring": "Return a table without the columns that contain non-numerical values.\n\nReturns\n-------\ntable : Table\n    A table without the columns that contain non-numerical values.",
      "code": "    def remove_columns_with_non_numerical_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain non-numerical values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain non-numerical values.\n\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if column.type.is_numeric()])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_duplicate_rows",
      "name": "remove_duplicate_rows",
      "qname": "safeds.data.tabular.containers._table.Table.remove_duplicate_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_duplicate_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_duplicate_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a copy of the table with every duplicate row removed.",
      "docstring": "Return a copy of the table with every duplicate row removed.\n\nReturns\n-------\nresult : Table\n    The table with the duplicate rows removed.",
      "code": "    def remove_duplicate_rows(self) -> Table:\n        \"\"\"\n        Return a copy of the table with every duplicate row removed.\n\n        Returns\n        -------\n        result : Table\n            The table with the duplicate rows removed.\n        \"\"\"\n        result = self._data.drop_duplicates(ignore_index=True)\n        result.columns = self._schema.column_names\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_missing_values",
      "name": "remove_rows_with_missing_values",
      "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the rows that contain missing values.",
      "docstring": "Return a table without the rows that contain missing values.\n\nReturns\n-------\ntable : Table\n    A table without the rows that contain missing values.",
      "code": "    def remove_rows_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the rows that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the rows that contain missing values.\n        \"\"\"\n        result = self._data.copy(deep=True)\n        result = result.dropna(axis=\"index\")\n        return Table(result, self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_outliers",
      "name": "remove_rows_with_outliers",
      "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_outliers",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_outliers/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_outliers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Remove all rows from the table that contain at least one outlier.\n\nWe define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\nMissing values are not considered outliers. They are also ignored during the calculation of the standard\ndeviation.",
      "docstring": "Remove all rows from the table that contain at least one outlier.\n\nWe define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\nMissing values are not considered outliers. They are also ignored during the calculation of the standard\ndeviation.\n\nReturns\n-------\nnew_table : Table\n    A new table without rows containing outliers.",
      "code": "    def remove_rows_with_outliers(self) -> Table:\n        \"\"\"\n        Remove all rows from the table that contain at least one outlier.\n\n        We define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\n        Missing values are not considered outliers. They are also ignored during the calculation of the standard\n        deviation.\n\n        Returns\n        -------\n        new_table : Table\n            A new table without rows containing outliers.\n        \"\"\"\n        copy = self._data.copy(deep=True)\n\n        table_without_nonnumericals = self.remove_columns_with_non_numerical_values()\n        z_scores = np.absolute(stats.zscore(table_without_nonnumericals._data, nan_policy=\"omit\"))\n        filter_ = ((z_scores < 3) | np.isnan(z_scores)).all(axis=1)\n\n        return Table(copy[filter_], self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column",
      "name": "rename_column",
      "qname": "safeds.data.tabular.containers._table.Table.rename_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/old_name",
          "name": "old_name",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.old_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The old name of the target column"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/new_name",
          "name": "new_name",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.new_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The new name of the target column"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Rename a single column.",
      "docstring": "Rename a single column.\n\nParameters\n----------\nold_name : str\n    The old name of the target column\nnew_name : str\n    The new name of the target column\n\nReturns\n-------\ntable : Table\n    The Table with the renamed column.\n\nRaises\n------\nColumnNameError\n    If the specified old target column name does not exist.\nDuplicateColumnNameError\n    If the specified new target column name already exists.",
      "code": "    def rename_column(self, old_name: str, new_name: str) -> Table:\n        \"\"\"\n        Rename a single column.\n\n        Parameters\n        ----------\n        old_name : str\n            The old name of the target column\n        new_name : str\n            The new name of the target column\n\n        Returns\n        -------\n        table : Table\n            The Table with the renamed column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified old target column name does not exist.\n        DuplicateColumnNameError\n            If the specified new target column name already exists.\n        \"\"\"\n        if old_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_name])\n        if old_name == new_name:\n            return self\n        if new_name in self._schema.column_names:\n            raise DuplicateColumnNameError(new_name)\n\n        new_df = self._data.copy()\n        new_df.columns = self._schema.column_names\n        return Table(new_df.rename(columns={old_name: new_name}))"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column",
      "name": "replace_column",
      "qname": "safeds.data.tabular.containers._table.Table.replace_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/old_column_name",
          "name": "old_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.old_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column to be replaced."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/new_column",
          "name": "new_column",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.new_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The new column replacing the old column."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.",
      "docstring": "Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\nParameters\n----------\nold_column_name : str\n    The name of the column to be replaced.\n\nnew_column : Column\n    The new column replacing the old column.\n\nReturns\n-------\nresult : Table\n    A table with the old column replaced by the new column.\n\nRaises\n------\nUnknownColumnNameError\n    If the old column does not exist.\n\nDuplicateColumnNameError\n    If the new column already exists and the existing column is not affected by the replacement.\n\nColumnSizeError\n    If the size of the column does not match the amount of rows.",
      "code": "    def replace_column(self, old_column_name: str, new_column: Column) -> Table:\n        \"\"\"\n        Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\n        Parameters\n        ----------\n        old_column_name : str\n            The name of the column to be replaced.\n\n        new_column : Column\n            The new column replacing the old column.\n\n        Returns\n        -------\n        result : Table\n            A table with the old column replaced by the new column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the old column does not exist.\n\n        DuplicateColumnNameError\n            If the new column already exists and the existing column is not affected by the replacement.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n        \"\"\"\n        if old_column_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_column_name])\n\n        if new_column.name in self._schema.column_names and new_column.name != old_column_name:\n            raise DuplicateColumnNameError(new_column.name)\n\n        if self.n_rows != new_column._data.size:\n            raise ColumnSizeError(str(self.n_rows), str(new_column._data.size))\n\n        if old_column_name != new_column.name:\n            renamed_table = self.rename_column(old_column_name, new_column.name)\n            result = renamed_table._data\n            result.columns = renamed_table._schema.column_names\n        else:\n            result = self._data.copy()\n            result.columns = self._schema.column_names\n\n        result[new_column.name] = new_column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/schema@getter",
      "name": "schema",
      "qname": "safeds.data.tabular.containers._table.Table.schema",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/schema@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.schema.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the schema of the table.",
      "docstring": "Return the schema of the table.\n\nReturns\n-------\nschema : Schema\n    The schema.",
      "code": "    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the table.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        return self._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/shuffle_rows",
      "name": "shuffle_rows",
      "qname": "safeds.data.tabular.containers._table.Table.shuffle_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/shuffle_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.shuffle_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Shuffle the table randomly.",
      "docstring": "Shuffle the table randomly.\n\nReturns\n-------\nresult : Table\n    The shuffled Table.",
      "code": "    def shuffle_rows(self) -> Table:\n        \"\"\"\n        Shuffle the table randomly.\n\n        Returns\n        -------\n        result : Table\n            The shuffled Table.\n\n        \"\"\"\n        new_df = self._data.sample(frac=1.0)\n        new_df.columns = self._schema.column_names\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows",
      "name": "slice_rows",
      "qname": "safeds.data.tabular.containers._table.Table.slice_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/start",
          "name": "start",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.start",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The first index of the range to be copied into a new table, None by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/end",
          "name": "end",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.end",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The last index of the range to be copied into a new table, None by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/step",
          "name": "step",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.step",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The step size used to iterate through the table, 1 by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Slice a part of the table into a new table.",
      "docstring": "Slice a part of the table into a new table.\n\nParameters\n----------\nstart : int\n    The first index of the range to be copied into a new table, None by default.\nend : int\n    The last index of the range to be copied into a new table, None by default.\nstep : int\n    The step size used to iterate through the table, 1 by default.\n\nReturns\n-------\nresult : Table\n    The resulting table.\n\nRaises\n------\nValueError\n    If the index is out of bounds.",
      "code": "    def slice_rows(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n        step: int = 1,\n    ) -> Table:\n        \"\"\"\n        Slice a part of the table into a new table.\n\n        Parameters\n        ----------\n        start : int\n            The first index of the range to be copied into a new table, None by default.\n        end : int\n            The last index of the range to be copied into a new table, None by default.\n        step : int\n            The step size used to iterate through the table, 1 by default.\n\n        Returns\n        -------\n        result : Table\n            The resulting table.\n\n        Raises\n        ------\n        ValueError\n            If the index is out of bounds.\n        \"\"\"\n        if start is None:\n            start = 0\n\n        if end is None:\n            end = self.n_rows\n\n        if start < 0 or end < 0 or start >= self.n_rows or end > self.n_rows or end < start:\n            raise ValueError(\"The given index is out of bounds\")\n\n        new_df = self._data.iloc[start:end:step]\n        new_df.columns = self._schema.column_names\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns",
      "name": "sort_columns",
      "qname": "safeds.data.tabular.containers._table.Table.sort_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.sort_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns/comparator",
          "name": "comparator",
          "qname": "safeds.data.tabular.containers._table.Table.sort_columns.comparator",
          "default_value": "lambda col1, col2: (col1.name > col2.name) - (col1.name < col2.name)",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Column, Column], int]",
            "default_value": "",
            "description": "The function used to compare two columns."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Column"
              },
              {
                "kind": "NamedType",
                "name": "Column]"
              },
              {
                "kind": "NamedType",
                "name": "int]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\nreturns an integer:\n\n* If `col1` should be ordered before `col2`, the function should return a negative number.\n* If `col1` should be ordered after `col2`, the function should return a positive number.\n* If the original order of `col1` and `col2` should be kept, the function should return 0.\n\nIf no comparator is given, the columns will be sorted alphabetically by their name.",
      "docstring": "Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\nreturns an integer:\n\n* If `col1` should be ordered before `col2`, the function should return a negative number.\n* If `col1` should be ordered after `col2`, the function should return a positive number.\n* If the original order of `col1` and `col2` should be kept, the function should return 0.\n\nIf no comparator is given, the columns will be sorted alphabetically by their name.\n\nParameters\n----------\ncomparator : Callable[[Column, Column], int]\n    The function used to compare two columns.\n\nReturns\n-------\nnew_table : Table\n    A new table with sorted columns.",
      "code": "    def sort_columns(\n        self,\n        comparator: Callable[[Column, Column], int] = lambda col1, col2: (col1.name > col2.name)\n        - (col1.name < col2.name),\n    ) -> Table:\n        \"\"\"\n        Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\n        returns an integer:\n\n        * If `col1` should be ordered before `col2`, the function should return a negative number.\n        * If `col1` should be ordered after `col2`, the function should return a positive number.\n        * If the original order of `col1` and `col2` should be kept, the function should return 0.\n\n        If no comparator is given, the columns will be sorted alphabetically by their name.\n\n        Parameters\n        ----------\n        comparator : Callable[[Column, Column], int]\n            The function used to compare two columns.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted columns.\n        \"\"\"\n        columns = self.to_columns()\n        columns.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_columns(columns)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_rows",
      "name": "sort_rows",
      "qname": "safeds.data.tabular.containers._table.Table.sort_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.sort_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_rows/comparator",
          "name": "comparator",
          "qname": "safeds.data.tabular.containers._table.Table.sort_rows.comparator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Row, Row], int]",
            "default_value": "",
            "description": "The function used to compare two rows."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Row"
              },
              {
                "kind": "NamedType",
                "name": "Row]"
              },
              {
                "kind": "NamedType",
                "name": "int]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\nreturns an integer:\n\n* If `row1` should be ordered before `row2`, the function should return a negative number.\n* If `row1` should be ordered after `row2`, the function should return a positive number.\n* If the original order of `row1` and `row2` should be kept, the function should return 0.",
      "docstring": "Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\nreturns an integer:\n\n* If `row1` should be ordered before `row2`, the function should return a negative number.\n* If `row1` should be ordered after `row2`, the function should return a positive number.\n* If the original order of `row1` and `row2` should be kept, the function should return 0.\n\nParameters\n----------\ncomparator : Callable[[Row, Row], int]\n    The function used to compare two rows.\n\nReturns\n-------\nnew_table : Table\n    A new table with sorted rows.",
      "code": "    def sort_rows(self, comparator: Callable[[Row, Row], int]) -> Table:\n        \"\"\"\n        Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\n        returns an integer:\n\n        * If `row1` should be ordered before `row2`, the function should return a negative number.\n        * If `row1` should be ordered after `row2`, the function should return a positive number.\n        * If the original order of `row1` and `row2` should be kept, the function should return 0.\n\n        Parameters\n        ----------\n        comparator : Callable[[Row, Row], int]\n            The function used to compare two rows.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted rows.\n        \"\"\"\n        rows = self.to_rows()\n        rows.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_rows(rows)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/split",
      "name": "split",
      "qname": "safeds.data.tabular.containers._table.Table.split",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/split/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.split.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/split/percentage_in_first",
          "name": "percentage_in_first",
          "qname": "safeds.data.tabular.containers._table.Table.split.percentage_in_first",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The desired size of the first table in percentage to the given table."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Split the table into two new tables.",
      "docstring": "Split the table into two new tables.\n\nParameters\n----------\npercentage_in_first : float\n    The desired size of the first table in percentage to the given table.\n\nReturns\n-------\nresult : (Table, Table)\n    A tuple containing the two resulting tables. The first table has the specified size, the second table\n    contains the rest of the data.",
      "code": "    def split(self, percentage_in_first: float) -> tuple[Table, Table]:\n        \"\"\"\n        Split the table into two new tables.\n\n        Parameters\n        ----------\n        percentage_in_first : float\n            The desired size of the first table in percentage to the given table.\n\n        Returns\n        -------\n        result : (Table, Table)\n            A tuple containing the two resulting tables. The first table has the specified size, the second table\n            contains the rest of the data.\n\n\n        \"\"\"\n        if percentage_in_first <= 0 or percentage_in_first >= 1:\n            raise ValueError(\"the given percentage is not in range\")\n        return (\n            self.slice_rows(0, round(percentage_in_first * self.n_rows)),\n            self.slice_rows(round(percentage_in_first * self.n_rows)),\n        )"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/summary",
      "name": "summary",
      "qname": "safeds.data.tabular.containers._table.Table.summary",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/summary/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.summary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with a number of statistical key values.",
      "docstring": "Return a table with a number of statistical key values.\n\nReturns\n-------\nresult : Table\n    The table with statistics.",
      "code": "    def summary(self) -> Table:\n        \"\"\"\n        Return a table with a number of statistical key values.\n\n        Returns\n        -------\n        result : Table\n            The table with statistics.\n        \"\"\"\n        columns = self.to_columns()\n        result = pd.DataFrame()\n        statistics = {}\n\n        for column in columns:\n            statistics = {\n                \"maximum\": column.maximum,\n                \"minimum\": column.minimum,\n                \"mean\": column.mean,\n                \"mode\": column.mode,\n                \"median\": column.median,\n                \"sum\": column.sum,\n                \"variance\": column.variance,\n                \"standard deviation\": column.standard_deviation,\n                \"idness\": column.idness,\n                \"stability\": column.stability,\n            }\n            values = []\n\n            for function in statistics.values():\n                try:\n                    values.append(str(function()))\n                except NonNumericColumnError:\n                    values.append(\"-\")\n\n            result = pd.concat([result, pd.DataFrame(values)], axis=1)\n\n        result = pd.concat([pd.DataFrame(list(statistics.keys())), result], axis=1)\n        result.columns = [\"metrics\", *self.column_names]\n\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns",
      "name": "tag_columns",
      "qname": "safeds.data.tabular.containers._table.Table.tag_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.tag_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns/target_name",
          "name": "target_name",
          "qname": "safeds.data.tabular.containers._table.Table.tag_columns.target_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Name of the target column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns/feature_names",
          "name": "feature_names",
          "qname": "safeds.data.tabular.containers._table.Table.tag_columns.feature_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "Names of the feature columns. If None, all columns except the target column are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Mark the columns of the table as target column or feature columns. The original table is not modified.",
      "docstring": "Mark the columns of the table as target column or feature columns. The original table is not modified.\n\nParameters\n----------\ntarget_name : str\n    Name of the target column.\nfeature_names : Optional[list[str]]\n    Names of the feature columns. If None, all columns except the target column are used.\n\nReturns\n-------\ntagged_table : TaggedTable\n    A new tagged table with the given target and feature names.",
      "code": "    def tag_columns(self, target_name: str, feature_names: list[str] | None = None) -> TaggedTable:\n        \"\"\"\n        Mark the columns of the table as target column or feature columns. The original table is not modified.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target column.\n        feature_names : Optional[list[str]]\n            Names of the feature columns. If None, all columns except the target column are used.\n\n        Returns\n        -------\n        tagged_table : TaggedTable\n            A new tagged table with the given target and feature names.\n        \"\"\"\n        from ._tagged_table import TaggedTable\n\n        return TaggedTable(self._data, target_name, feature_names, self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_columns",
      "name": "to_columns",
      "qname": "safeds.data.tabular.containers._table.Table.to_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of the columns.",
      "docstring": "Return a list of the columns.\n\nReturns\n-------\ncolumns : list[Columns]\n    List of columns.",
      "code": "    def to_columns(self) -> list[Column]:\n        \"\"\"\n        Return a list of the columns.\n\n        Returns\n        -------\n        columns : list[Columns]\n            List of columns.\n        \"\"\"\n        return [self.get_column(name) for name in self._schema.column_names]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file",
      "name": "to_csv_file",
      "qname": "safeds.data.tabular.containers._table.Table.to_csv_file",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_csv_file.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.to_csv_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the output file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Write the data from the table into a CSV file.\n\nIf the file and/or the directories do not exist they will be created. If the file already exists it will be\noverwritten.",
      "docstring": "Write the data from the table into a CSV file.\n\nIf the file and/or the directories do not exist they will be created. If the file already exists it will be\noverwritten.\n\nParameters\n----------\npath : str\n    The path to the output file.",
      "code": "    def to_csv_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a CSV file.\n\n        If the file and/or the directories do not exist they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_csv = self._data.copy()\n        data_to_csv.columns = self._schema.column_names\n        data_to_csv.to_csv(path, index=False)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_dict",
      "name": "to_dict",
      "qname": "safeds.data.tabular.containers._table.Table.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_dict/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a dictionary that maps column names to column values.",
      "docstring": "Return a dictionary that maps column names to column values.\n\nReturns\n-------\ndata : dict[str, list[Any]]\n    Dictionary representation of the table.",
      "code": "    def to_dict(self) -> dict[str, list[Any]]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, list[Any]]\n            Dictionary representation of the table.\n        \"\"\"\n        return {column_name: list(self.get_column(column_name)) for column_name in self.column_names}"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json_file",
      "name": "to_json_file",
      "qname": "safeds.data.tabular.containers._table.Table.to_json_file",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json_file/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_json_file.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.to_json_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the output file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Write the data from the table into a JSON file.\n\nIf the file and/or the directories do not exist, they will be created. If the file already exists it will be\noverwritten.",
      "docstring": "Write the data from the table into a JSON file.\n\nIf the file and/or the directories do not exist, they will be created. If the file already exists it will be\noverwritten.\n\nParameters\n----------\npath : str\n    The path to the output file.",
      "code": "    def to_json_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a JSON file.\n\n        If the file and/or the directories do not exist, they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_json = self._data.copy()\n        data_to_json.columns = self._schema.column_names\n        data_to_json.to_json(path)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_rows",
      "name": "to_rows",
      "qname": "safeds.data.tabular.containers._table.Table.to_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of the rows.",
      "docstring": "Return a list of the rows.\n\nReturns\n-------\nrows : list[Row]\n    List of rows.",
      "code": "    def to_rows(self) -> list[Row]:\n        \"\"\"\n        Return a list of the rows.\n\n        Returns\n        -------\n        rows : list[Row]\n            List of rows.\n        \"\"\"\n        return [\n            Row._from_polars_dataframe(\n                pl.DataFrame([list(series_row)], schema=self._schema.column_names),\n                self._schema,\n            )\n            for (_, series_row) in self._data.iterrows()\n        ]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column",
      "name": "transform_column",
      "qname": "safeds.data.tabular.containers._table.Table.transform_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/name",
          "name": "name",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/transformer",
          "name": "transformer",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.transformer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Transform provided column by calling provided transformer.",
      "docstring": "Transform provided column by calling provided transformer.\n\nReturns\n-------\nresult : Table\n    The table with the transformed column.\n\nRaises\n------\nUnknownColumnNameError\n    If the column does not exist.",
      "code": "    def transform_column(self, name: str, transformer: Callable[[Row], Any]) -> Table:\n        \"\"\"\n        Transform provided column by calling provided transformer.\n\n        Returns\n        -------\n        result : Table\n            The table with the transformed column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the column does not exist.\n\n        \"\"\"\n        if self.has_column(name):\n            items: list = [transformer(item) for item in self.to_rows()]\n            result: Column = Column(name, pd.Series(items))\n            return self.replace_column(name, result)\n        raise UnknownColumnNameError([name])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Iterable",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Iterable"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/target_name",
          "name": "target_name",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.target_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Name of the target column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/feature_names",
          "name": "feature_names",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.feature_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "Names of the feature columns. If None, all columns except the target column are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[Schema]",
            "default_value": "",
            "description": "The schema of the table. If not specified, the schema will be inferred from the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[Schema]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        data: Iterable,\n        target_name: str,\n        feature_names: list[str] | None = None,\n        schema: Schema | None = None,\n    ):\n        super().__init__(data, schema)\n\n        # If no feature names are specified, use all columns except the target column\n        if feature_names is None:\n            feature_names = self.column_names\n            if target_name in feature_names:\n                feature_names.remove(target_name)\n\n        # Validate inputs\n        if target_name in feature_names:\n            raise ValueError(f\"Column '{target_name}' cannot be both feature and target.\")\n        if len(feature_names) == 0:\n            raise ValueError(\"At least one feature column must be specified.\")\n\n        self._features: Table = self.keep_only_columns(feature_names)\n        self._target: Column = self.get_column(target_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        print(header_info)  # noqa: T201\n        return tmp._ipython_display_()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/features@getter",
      "name": "features",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.features",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/features@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.features.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def features(self) -> Table:\n        return self._features"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target@getter",
      "name": "target",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.target",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.target.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def target(self) -> Column:\n        return self._target"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__/column_info",
          "name": "column_info",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError.__init__.column_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when the lengths of two or more columns do not match.",
      "docstring": "",
      "code": "    def __init__(self, column_info: str):\n        super().__init__(f\"The length of at least one column differs: \\n{column_info}\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__/expected_size",
          "name": "expected_size",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__.expected_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The expected size of the column as an expression (e.g. 2, >0, !=0)."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__/actual_size",
          "name": "actual_size",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__.actual_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The actual size of the column as an expression (e.g. 2, >0, !=0)."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to use a column of unsupported size.",
      "docstring": "",
      "code": "    def __init__(self, expected_size: str, actual_size: str):\n        super().__init__(f\"Expected a column of size {expected_size} but got column of size {actual_size}.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError.__init__.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column that resulted in a duplicate."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to modify a table resulting in a duplicate column name.",
      "docstring": "",
      "code": "    def __init__(self, column_name: str):\n        super().__init__(f\"Column '{column_name}' already exists.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__/index",
          "name": "index",
          "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError.__init__.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The wrongly used index."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an element by an index that does not exist in the underlying data.",
      "docstring": "",
      "code": "    def __init__(self, index: int):\n        super().__init__(f\"There is no element at index '{index}'.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__/missing_data_info",
          "name": "missing_data_info",
          "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError.__init__.missing_data_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised if a function is not given enough data to succeed.",
      "docstring": "",
      "code": "    def __init__(self, missing_data_info: str):\n        super().__init__(f\"The function is missing data: \\n{missing_data_info}\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingSchemaError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.MissingSchemaError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a required schema is missing.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Failed because a required schema is missing.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__/column_info",
          "name": "column_info",
          "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError.__init__.column_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "docstring": "",
      "code": "    def __init__(self, column_info: str) -> None:\n        super().__init__(f\"Tried to do a numerical operation on one or multiple non numerical Columns: \\n{column_info}\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.SchemaMismatchError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.SchemaMismatchError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when schemas are unequal.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Failed because at least two schemas didn't match.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.TransformerNotFittedError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.TransformerNotFittedError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a transformer is used before fitting it.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"The transformer has not been fitted yet.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError.__init__.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "The name of the column that was tried to be accessed."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an invalid column name.",
      "docstring": "",
      "code": "    def __init__(self, column_names: list[str]):\n        super().__init__(f\"Could not find column(s) '{', '.join(column_names)}'\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__init__/value",
          "name": "value",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__init__.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The given value to impute missing values."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "An imputation strategy for imputing missing data with given constant values.",
      "docstring": "",
      "code": "            def __init__(self, value: Any):\n                self._value = value"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def __str__(self) -> str:\n                return f\"Constant({self._value})\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"constant\"\n                imputer.fill_value = self._value"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def __str__(self) -> str:\n                return \"Mean\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"mean\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def __str__(self) -> str:\n                return \"Median\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"median\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def __str__(self) -> str:\n                return \"Mode\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n                imputer.strategy = \"most_frequent\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__/strategy",
          "name": "strategy",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.__init__.strategy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "ImputerStrategy",
            "default_value": "",
            "description": "The strategy used to impute missing values. Use the classes nested inside `Imputer.Strategy` to specify it."
          },
          "type": {
            "kind": "NamedType",
            "name": "ImputerStrategy"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Replace missing values with the given strategy.",
      "docstring": "",
      "code": "    def __init__(self, strategy: ImputerStrategy):\n        self._strategy = strategy\n\n        self._wrapped_transformer: sk_SimpleImputer | None = None\n        self._column_names: list[str] | None = None"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the transformer."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "The list of columns from the table used to fit the transformer. If `None`, all columns are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Learn a transformation for a set of columns in a table.",
      "docstring": "Learn a transformation for a set of columns in a table.\n\nParameters\n----------\ntable : Table\n    The table used to fit the transformer.\ncolumn_names : Optional[list[str]]\n    The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\nReturns\n-------\nfitted_transformer : TableTransformer\n    The fitted transformer.",
      "code": "    def fit(self, table: Table, column_names: list[str] | None = None) -> Imputer:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n        if column_names is None:\n            column_names = table.column_names\n        else:\n            missing_columns = set(column_names) - set(table.column_names)\n            if len(missing_columns) > 0:\n                raise UnknownColumnNameError(list(missing_columns))\n\n        if isinstance(self._strategy, Imputer.Strategy.Mode):\n            for name in column_names:\n                if len(table.get_column(name).mode()) > 1:\n                    raise IndexError(\"There are multiple most frequent values in a column given for the Imputer\")\n\n        wrapped_transformer = sk_SimpleImputer()\n        self._strategy._augment_imputer(wrapped_transformer)\n        wrapped_transformer.fit(table._data[column_names])\n\n        result = Imputer(self._strategy)\n        result._wrapped_transformer = wrapped_transformer\n        result._column_names = column_names\n\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/is_fitted/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the transformer is fitted.",
      "docstring": "Check if the transformer is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the transformer is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n        return self._wrapped_transformer is not None"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to which the learned transformation is applied."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Apply the learned transformation to a table.",
      "docstring": "Apply the learned transformation to a table.\n\nParameters\n----------\ntable : Table\n    The table to which the learned transformation is applied.\n\nReturns\n-------\ntransformed_table : Table\n    The transformed table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        # Input table does not contain all columns used to fit the transformer\n        missing_columns = set(self._column_names) - set(table.column_names)\n        if len(missing_columns) > 0:\n            raise UnknownColumnNameError(list(missing_columns))\n\n        data = table._data.copy()\n        data[self._column_names] = pd.DataFrame(\n            self._wrapped_transformer.transform(data[self._column_names]),\n            columns=self._column_names,\n        )\n        return Table(data, table.schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "The LabelEncoder encodes one or more given columns into labels.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_transformer: sk_OrdinalEncoder | None = None\n        self._column_names: list[str] | None = None"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the transformer."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "The list of columns from the table used to fit the transformer. If `None`, all columns are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Learn a transformation for a set of columns in a table.",
      "docstring": "Learn a transformation for a set of columns in a table.\n\nParameters\n----------\ntable : Table\n    The table used to fit the transformer.\ncolumn_names : Optional[list[str]]\n    The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\nReturns\n-------\nfitted_transformer : TableTransformer\n    The fitted transformer.",
      "code": "    def fit(self, table: Table, column_names: list[str] | None = None) -> LabelEncoder:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n        if column_names is None:\n            column_names = table.column_names\n        else:\n            missing_columns = set(column_names) - set(table.column_names)\n            if len(missing_columns) > 0:\n                raise UnknownColumnNameError(list(missing_columns))\n\n        wrapped_transformer = sk_OrdinalEncoder()\n        wrapped_transformer.fit(table._data[column_names])\n\n        result = LabelEncoder()\n        result._wrapped_transformer = wrapped_transformer\n        result._column_names = column_names\n\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform",
      "name": "inverse_transform",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform/transformed_table",
          "name": "transformed_table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform.transformed_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be transformed back to the original version."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Undo the learned transformation.",
      "docstring": "Undo the learned transformation.\n\nParameters\n----------\ntransformed_table : Table\n    The table to be transformed back to the original version.\n\nReturns\n-------\ntable : Table\n    The original table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    def inverse_transform(self, transformed_table: Table) -> Table:\n        \"\"\"\n        Undo the learned transformation.\n\n        Parameters\n        ----------\n        transformed_table : Table\n            The table to be transformed back to the original version.\n\n        Returns\n        -------\n        table : Table\n            The original table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        data = transformed_table._data.copy()\n        data.columns = transformed_table.column_names\n        data[self._column_names] = self._wrapped_transformer.inverse_transform(data[self._column_names])\n        return Table(data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/is_fitted/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the transformer is fitted.",
      "docstring": "Check if the transformer is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the transformer is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n        return self._wrapped_transformer is not None"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to which the learned transformation is applied."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Apply the learned transformation to a table.",
      "docstring": "Apply the learned transformation to a table.\n\nParameters\n----------\ntable : Table\n    The table to which the learned transformation is applied.\n\nReturns\n-------\ntransformed_table : Table\n    The transformed table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        # Input table does not contain all columns used to fit the transformer\n        missing_columns = set(self._column_names) - set(table.column_names)\n        if len(missing_columns) > 0:\n            raise UnknownColumnNameError(list(missing_columns))\n\n        data = table._data.copy()\n        data.columns = table.column_names\n        data[self._column_names] = self._wrapped_transformer.transform(data[self._column_names])\n        return Table(data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/warn",
      "name": "warn",
      "qname": "safeds.data.tabular.transformation._label_encoder.warn",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/warn/_",
          "name": "_",
          "qname": "safeds.data.tabular.transformation._label_encoder.warn._",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/warn/__",
          "name": "__",
          "qname": "safeds.data.tabular.transformation._label_encoder.warn.__",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def warn(*_: Any, **__: Any) -> None:\n    pass"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Encodes categorical columns to numerical features [0,1] that represent the existence for each value.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_transformer: sk_OneHotEncoder | None = None\n        self._column_names: dict[str, list[str]] | None = None"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the transformer."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "The list of columns from the table used to fit the transformer. If `None`, all columns are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Learn a transformation for a set of columns in a table.",
      "docstring": "Learn a transformation for a set of columns in a table.\n\nParameters\n----------\ntable : Table\n    The table used to fit the transformer.\ncolumn_names : Optional[list[str]]\n    The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\nReturns\n-------\nfitted_transformer : TableTransformer\n    The fitted transformer.",
      "code": "    def fit(self, table: Table, column_names: list[str] | None = None) -> OneHotEncoder:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\"\n        if column_names is None:\n            column_names = table.column_names\n        else:\n            missing_columns = set(column_names) - set(table.column_names)\n            if len(missing_columns) > 0:\n                raise UnknownColumnNameError(list(missing_columns))\n\n        data = table._data.copy()\n        data.columns = table.column_names\n\n        wrapped_transformer = sk_OneHotEncoder()\n        wrapped_transformer.fit(data[column_names])\n\n        result = OneHotEncoder()\n        result._wrapped_transformer = wrapped_transformer\n        result._column_names = {\n            column: [f\"{column}_{element}\" for element in table.get_column(column).get_unique_values()]\n            for column in column_names\n        }\n\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform",
      "name": "inverse_transform",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.inverse_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.inverse_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform/transformed_table",
          "name": "transformed_table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.inverse_transform.transformed_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be transformed back to the original version."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Undo the learned transformation.",
      "docstring": "Undo the learned transformation.\n\nParameters\n----------\ntransformed_table : Table\n    The table to be transformed back to the original version.\n\nReturns\n-------\ntable : Table\n    The original table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    def inverse_transform(self, transformed_table: Table) -> Table:\n        \"\"\"\n        Undo the learned transformation.\n\n        Parameters\n        ----------\n        transformed_table : Table\n            The table to be transformed back to the original version.\n\n        Returns\n        -------\n        table : Table\n            The original table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        data = transformed_table._data.copy()\n        data.columns = transformed_table.column_names\n\n        decoded = pd.DataFrame(\n            self._wrapped_transformer.inverse_transform(\n                transformed_table.keep_only_columns(self._wrapped_transformer.get_feature_names_out())._data,\n            ),\n            columns=list(self._column_names.keys()),\n        )\n        unchanged = data.drop(self._wrapped_transformer.get_feature_names_out(), axis=1)\n\n        res = Table(pd.concat([unchanged, decoded], axis=1))\n        column_names = [\n            name\n            if name not in [value for value_list in list(self._column_names.values()) for value in value_list]\n            else list(self._column_names.keys())[\n                [\n                    list(self._column_names.values()).index(value)\n                    for value in list(self._column_names.values())\n                    if name in value\n                ][0]\n            ]\n            for name in transformed_table.column_names\n        ]\n        res = res.sort_columns(lambda col1, col2: column_names.index(col1.name) - column_names.index(col2.name))\n\n        return res"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/is_fitted/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the transformer is fitted.",
      "docstring": "Check if the transformer is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the transformer is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\"\n        return self._wrapped_transformer is not None"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to which the learned transformation is applied."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Apply the learned transformation to a table.",
      "docstring": "Apply the learned transformation to a table.\n\nParameters\n----------\ntable : Table\n    The table to which the learned transformation is applied.\n\nReturns\n-------\ntransformed_table : Table\n    The transformed table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\"\n        # Transformer has not been fitted yet\n        if self._wrapped_transformer is None or self._column_names is None:\n            raise TransformerNotFittedError\n\n        # Input table does not contain all columns used to fit the transformer\n        missing_columns = set(self._column_names.keys()) - set(table.column_names)\n        if len(missing_columns) > 0:\n            raise UnknownColumnNameError(list(missing_columns))\n\n        original = table._data.copy()\n        original.columns = table.schema.column_names\n\n        one_hot_encoded = pd.DataFrame(\n            self._wrapped_transformer.transform(original[self._column_names.keys()]).toarray(),\n        )\n        one_hot_encoded.columns = self._wrapped_transformer.get_feature_names_out()\n\n        unchanged = original.drop(self._column_names.keys(), axis=1)\n\n        res = Table(pd.concat([unchanged, one_hot_encoded], axis=1))\n        column_names = []\n\n        for name in table.column_names:\n            if name not in self._column_names.keys():\n                column_names.append(name)\n            else:\n                column_names.extend(\n                    [f_name for f_name in self._wrapped_transformer.get_feature_names_out() if f_name.startswith(name)],\n                )\n        res = res.sort_columns(lambda col1, col2: column_names.index(col1.name) - column_names.index(col2.name))\n\n        return res"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/InvertibleTableTransformer/inverse_transform",
      "name": "inverse_transform",
      "qname": "safeds.data.tabular.transformation._table_transformer.InvertibleTableTransformer.inverse_transform",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/InvertibleTableTransformer/inverse_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._table_transformer.InvertibleTableTransformer.inverse_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/InvertibleTableTransformer/inverse_transform/transformed_table",
          "name": "transformed_table",
          "qname": "safeds.data.tabular.transformation._table_transformer.InvertibleTableTransformer.inverse_transform.transformed_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be transformed back to the original version."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Undo the learned transformation.",
      "docstring": "Undo the learned transformation.\n\nParameters\n----------\ntransformed_table : Table\n    The table to be transformed back to the original version.\n\nReturns\n-------\ntable : Table\n    The original table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    @abstractmethod\n    def inverse_transform(self, transformed_table: Table) -> Table:\n        \"\"\"\n        Undo the learned transformation.\n\n        Parameters\n        ----------\n        transformed_table : Table\n            The table to be transformed back to the original version.\n\n        Returns\n        -------\n        table : Table\n            The original table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the transformer."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "The list of columns from the table used to fit the transformer. If `None`, all columns are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Learn a transformation for a set of columns in a table.",
      "docstring": "Learn a transformation for a set of columns in a table.\n\nParameters\n----------\ntable : Table\n    The table used to fit the transformer.\ncolumn_names : Optional[list[str]]\n    The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\nReturns\n-------\nfitted_transformer : TableTransformer\n    The fitted transformer.",
      "code": "    @abstractmethod\n    def fit(self, table: Table, column_names: list[str] | None = None) -> TableTransformer:\n        \"\"\"\n        Learn a transformation for a set of columns in a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        fitted_transformer : TableTransformer\n            The fitted transformer.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit_and_transform",
      "name": "fit_and_transform",
      "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit_and_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit_and_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit_and_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit_and_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit_and_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the transformer. The transformer is then applied to this table."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/fit_and_transform/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.fit_and_transform.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "The list of columns from the table used to fit the transformer. If `None`, all columns are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Learn a transformation for a set of columns in a table and apply the learned transformation to the same table.\n\nIf you also need the fitted transformer, use `fit` and `transform` separately.",
      "docstring": "Learn a transformation for a set of columns in a table and apply the learned transformation to the same table.\n\nIf you also need the fitted transformer, use `fit` and `transform` separately.\n\nParameters\n----------\ntable : Table\n    The table used to fit the transformer. The transformer is then applied to this table.\ncolumn_names : Optional[list[str]]\n    The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\nReturns\n-------\ntransformed_table : Table\n    The transformed table.",
      "code": "    def fit_and_transform(self, table: Table, column_names: list[str] | None = None) -> Table:\n        \"\"\"\n        Learn a transformation for a set of columns in a table and apply the learned transformation to the same table.\n\n        If you also need the fitted transformer, use `fit` and `transform` separately.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the transformer. The transformer is then applied to this table.\n        column_names : Optional[list[str]]\n            The list of columns from the table used to fit the transformer. If `None`, all columns are used.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n        \"\"\"\n        return self.fit(table, column_names).transform(table)"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.is_fitted",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/is_fitted/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the transformer is fitted.",
      "docstring": "Check if the transformer is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the transformer is fitted.",
      "code": "    @abstractmethod\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the transformer is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the transformer is fitted.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.transform",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._table_transformer/TableTransformer/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._table_transformer.TableTransformer.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to which the learned transformation is applied."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Apply the learned transformation to a table.",
      "docstring": "Apply the learned transformation to a table.\n\nParameters\n----------\ntable : Table\n    The table to which the learned transformation is applied.\n\nReturns\n-------\ntransformed_table : Table\n    The transformed table.\n\nRaises\n------\nTransformerNotFittedError\n    If the transformer has not been fitted yet.",
      "code": "    @abstractmethod\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Apply the learned transformation to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table to which the learned transformation is applied.\n\n        Returns\n        -------\n        transformed_table : Table\n            The transformed table.\n\n        Raises\n        ------\n        TransformerNotFittedError\n            If the transformer has not been fitted yet.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._column_type.Anything.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Anything.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/__init__/is_nullable",
          "name": "is_nullable",
          "qname": "safeds.data.tabular.typing._column_type.Anything.__init__.is_nullable",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether the type also allows null values."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that contains anything.",
      "docstring": "",
      "code": "    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.Anything.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Anything.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        result = \"Anything\"\n        if self._is_nullable:\n            result += \"?\"\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/is_nullable",
      "name": "is_nullable",
      "qname": "safeds.data.tabular.typing._column_type.Anything.is_nullable",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/is_nullable/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Anything.is_nullable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is nullable.",
      "docstring": "Return whether the given column type is nullable.\n\nReturns\n-------\nis_nullable : bool\n    True if the column is nullable.",
      "code": "    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.Anything.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Anything/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Anything.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.",
      "docstring": "Return whether the given column type is numeric.\n\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._column_type.Boolean.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Boolean.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/__init__/is_nullable",
          "name": "is_nullable",
          "qname": "safeds.data.tabular.typing._column_type.Boolean.__init__.is_nullable",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether the type also allows null values."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains booleans.",
      "docstring": "",
      "code": "    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.Boolean.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Boolean.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        result = \"Boolean\"\n        if self._is_nullable:\n            result += \"?\"\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/is_nullable",
      "name": "is_nullable",
      "qname": "safeds.data.tabular.typing._column_type.Boolean.is_nullable",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/is_nullable/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Boolean.is_nullable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is nullable.",
      "docstring": "Return whether the given column type is nullable.\n\nReturns\n-------\nis_nullable : bool\n    True if the column is nullable.",
      "code": "    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.Boolean.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Boolean/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Boolean.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.",
      "docstring": "Return whether the given column type is numeric.\n\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/_from_numpy_data_type",
      "name": "_from_numpy_data_type",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType._from_numpy_data_type",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/_from_numpy_data_type/data_type",
          "name": "data_type",
          "qname": "safeds.data.tabular.typing._column_type.ColumnType._from_numpy_data_type.data_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "numpy.dtype",
            "default_value": "",
            "description": "The `numpy` data type."
          },
          "type": {
            "kind": "NamedType",
            "name": "numpy.dtype"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the column type for a given `numpy` data type.",
      "docstring": "Return the column type for a given `numpy` data type.\n\nParameters\n----------\ndata_type : numpy.dtype\n    The `numpy` data type.\n\nReturns\n-------\ncolumn_type : ColumnType\n    The ColumnType.\n\nRaises\n------\nNotImplementedError\n    If the given data type is not supported.",
      "code": "    @staticmethod\n    def _from_numpy_data_type(data_type: np.dtype) -> ColumnType:\n        \"\"\"\n        Return the column type for a given `numpy` data type.\n\n        Parameters\n        ----------\n        data_type : numpy.dtype\n            The `numpy` data type.\n\n        Returns\n        -------\n        column_type : ColumnType\n            The ColumnType.\n\n        Raises\n        ------\n        NotImplementedError\n            If the given data type is not supported.\n        \"\"\"\n        if data_type.kind in (\"u\", \"i\"):\n            return Integer()\n        if data_type.kind == \"b\":\n            return Boolean()\n        if data_type.kind == \"f\":\n            return RealNumber()\n        if data_type.kind in (\"S\", \"U\", \"O\", \"M\", \"m\"):\n            return String()\n\n        message = f\"Unsupported numpy data type '{data_type}'.\"\n        raise NotImplementedError(message)"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/_from_polars_data_type",
      "name": "_from_polars_data_type",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType._from_polars_data_type",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/_from_polars_data_type/data_type",
          "name": "data_type",
          "qname": "safeds.data.tabular.typing._column_type.ColumnType._from_polars_data_type.data_type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "PolarsDataType",
            "default_value": "",
            "description": "The `polars` data type."
          },
          "type": {
            "kind": "NamedType",
            "name": "PolarsDataType"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the column type for a given `polars` data type.",
      "docstring": "Return the column type for a given `polars` data type.\n\nParameters\n----------\ndata_type : PolarsDataType\n    The `polars` data type.\n\nReturns\n-------\ncolumn_type : ColumnType\n    The ColumnType.\n\nRaises\n------\nNotImplementedError\n    If the given data type is not supported.",
      "code": "    @staticmethod\n    def _from_polars_data_type(data_type: PolarsDataType) -> ColumnType:\n        \"\"\"\n        Return the column type for a given `polars` data type.\n\n        Parameters\n        ----------\n        data_type : PolarsDataType\n            The `polars` data type.\n\n        Returns\n        -------\n        column_type : ColumnType\n            The ColumnType.\n\n        Raises\n        ------\n        NotImplementedError\n            If the given data type is not supported.\n        \"\"\"\n        if data_type in POLARS_INTEGER_DTYPES:\n            return Integer()\n        if data_type is PolarsBoolean:\n            return Boolean()\n        if data_type in POLARS_FLOAT_DTYPES or data_type is PolarsDecimal:\n            return RealNumber()\n        if data_type is PolarsUtf8 or data_type is PolarsObject or data_type in POLARS_TEMPORAL_DTYPES:\n            return String()\n\n        message = f\"Unsupported polars data type '{data_type}'.\"\n        raise NotImplementedError(message)"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_nullable",
      "name": "is_nullable",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType.is_nullable",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_nullable/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.ColumnType.is_nullable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is nullable.",
      "docstring": "Return whether the given column type is nullable.\n\nReturns\n-------\nis_nullable : bool\n    True if the column is nullable.",
      "code": "    @abstractmethod\n    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType.is_numeric",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.ColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.",
      "docstring": "Return whether the given column type is numeric.\n\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    @abstractmethod\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._column_type.Integer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Integer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/__init__/is_nullable",
          "name": "is_nullable",
          "qname": "safeds.data.tabular.typing._column_type.Integer.__init__.is_nullable",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether the type also allows null values."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains integers.",
      "docstring": "",
      "code": "    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.Integer.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Integer.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        result = \"Integer\"\n        if self._is_nullable:\n            result += \"?\"\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/is_nullable",
      "name": "is_nullable",
      "qname": "safeds.data.tabular.typing._column_type.Integer.is_nullable",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/is_nullable/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Integer.is_nullable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is nullable.",
      "docstring": "Return whether the given column type is nullable.\n\nReturns\n-------\nis_nullable : bool\n    True if the column is nullable.",
      "code": "    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.Integer.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/Integer/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.Integer.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.",
      "docstring": "Return whether the given column type is numeric.\n\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return True"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._column_type.RealNumber.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.RealNumber.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__init__/is_nullable",
          "name": "is_nullable",
          "qname": "safeds.data.tabular.typing._column_type.RealNumber.__init__.is_nullable",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether the type also allows null values."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains real numbers.",
      "docstring": "",
      "code": "    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.RealNumber.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.RealNumber.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        result = \"RealNumber\"\n        if self._is_nullable:\n            result += \"?\"\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/is_nullable",
      "name": "is_nullable",
      "qname": "safeds.data.tabular.typing._column_type.RealNumber.is_nullable",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/is_nullable/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.RealNumber.is_nullable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is nullable.",
      "docstring": "Return whether the given column type is nullable.\n\nReturns\n-------\nis_nullable : bool\n    True if the column is nullable.",
      "code": "    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.RealNumber.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/RealNumber/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.RealNumber.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.",
      "docstring": "Return whether the given column type is numeric.\n\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return True"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/String/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._column_type.String.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/String/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.String.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/String/__init__/is_nullable",
          "name": "is_nullable",
          "qname": "safeds.data.tabular.typing._column_type.String.__init__.is_nullable",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether the type also allows null values."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Type for a column that only contains strings.",
      "docstring": "",
      "code": "    def __init__(self, is_nullable: bool = False):\n        self._is_nullable = is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/String/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.String.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/String/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.String.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        result = \"String\"\n        if self._is_nullable:\n            result += \"?\"\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/String/is_nullable",
      "name": "is_nullable",
      "qname": "safeds.data.tabular.typing._column_type.String.is_nullable",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/String/is_nullable/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.String.is_nullable.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is nullable.",
      "docstring": "Return whether the given column type is nullable.\n\nReturns\n-------\nis_nullable : bool\n    True if the column is nullable.",
      "code": "    def is_nullable(self) -> bool:\n        \"\"\"\n        Return whether the given column type is nullable.\n\n        Returns\n        -------\n        is_nullable : bool\n            True if the column is nullable.\n        \"\"\"\n        return self._is_nullable"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/String/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.String.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/String/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.String.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.",
      "docstring": "Return whether the given column type is numeric.\n\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._imputer_strategy/ImputerStrategy/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.typing._imputer_strategy.ImputerStrategy._augment_imputer",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._imputer_strategy/ImputerStrategy/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._imputer_strategy.ImputerStrategy._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._imputer_strategy/ImputerStrategy/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.typing._imputer_strategy.ImputerStrategy._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def _augment_imputer(self, imputer: sk_SimpleImputer) -> None:\n        pass"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.typing._schema.Schema.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a hash value for the schema.",
      "docstring": "Return a hash value for the schema.\n\nReturns\n-------\nhash : int\n    The hash value.",
      "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Return a hash value for the schema.\n\n        Returns\n        -------\n        hash : int\n            The hash value.\n        \"\"\"\n        column_names = self._schema.keys()\n        column_types = map(repr, self._schema.values())\n        return hash(tuple(zip(column_names, column_types, strict=True)))"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._schema.Schema.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.typing._schema.Schema.__init__.schema",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict[str, ColumnType]",
            "default_value": "",
            "description": "Map from column names to data types."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "ColumnType]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Store column names and corresponding data types for a `Table` or `Row`.",
      "docstring": "",
      "code": "    def __init__(self, schema: dict[str, ColumnType]):\n        self._schema = dict(schema)  # Defensive copy"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.typing._schema.Schema.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a user-friendly string representation of the schema.",
      "docstring": "Return a user-friendly string representation of the schema.\n\nReturns\n-------\nstring : str\n    The string representation.",
      "code": "    def __str__(self) -> str:\n        \"\"\"\n        Return a user-friendly string representation of the schema.\n\n        Returns\n        -------\n        string : str\n            The string representation.\n        \"\"\"\n        match len(self._schema):\n            case 0:\n                return \"{}\"\n            case 1:\n                return str(self._schema)\n            case _:\n                lines = (f\"    {name!r}: {type_}\" for name, type_ in self._schema.items())\n                joined = \",\\n\".join(lines)\n                return f\"{{\\n{joined}\\n}}\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_from_pandas_dataframe",
      "name": "_from_pandas_dataframe",
      "qname": "safeds.data.tabular.typing._schema.Schema._from_pandas_dataframe",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_from_pandas_dataframe/dataframe",
          "name": "dataframe",
          "qname": "safeds.data.tabular.typing._schema.Schema._from_pandas_dataframe.dataframe",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "pd.DataFrame",
            "default_value": "",
            "description": "The dataframe."
          },
          "type": {
            "kind": "NamedType",
            "name": "pd.DataFrame"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a schema from a `pandas.DataFrame`.",
      "docstring": "Create a schema from a `pandas.DataFrame`.\n\nParameters\n----------\ndataframe : pd.DataFrame\n    The dataframe.\n\nReturns\n-------\nschema : Schema\n    The schema.",
      "code": "    @staticmethod\n    def _from_pandas_dataframe(dataframe: pd.DataFrame) -> Schema:\n        \"\"\"\n        Create a schema from a `pandas.DataFrame`.\n\n        Parameters\n        ----------\n        dataframe : pd.DataFrame\n            The dataframe.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        names = dataframe.columns\n        # noinspection PyProtectedMember\n        types = (ColumnType._from_numpy_data_type(data_type) for data_type in dataframe.dtypes)\n\n        return Schema(dict(zip(names, types, strict=True)))"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_from_polars_dataframe",
      "name": "_from_polars_dataframe",
      "qname": "safeds.data.tabular.typing._schema.Schema._from_polars_dataframe",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_from_polars_dataframe/dataframe",
          "name": "dataframe",
          "qname": "safeds.data.tabular.typing._schema.Schema._from_polars_dataframe.dataframe",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "pl.DataFrame",
            "default_value": "",
            "description": "The dataframe."
          },
          "type": {
            "kind": "NamedType",
            "name": "pl.DataFrame"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a schema from a `polars.Dataframe`.",
      "docstring": "Create a schema from a `polars.Dataframe`.\n\nParameters\n----------\ndataframe : pl.DataFrame\n    The dataframe.\n\nReturns\n-------\nschema : Schema\n    The schema.",
      "code": "    @staticmethod\n    def _from_polars_dataframe(dataframe: pl.DataFrame) -> Schema:\n        \"\"\"\n        Create a schema from a `polars.Dataframe`.\n\n        Parameters\n        ----------\n        dataframe : pl.DataFrame\n            The dataframe.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        names = dataframe.columns\n        # noinspection PyProtectedMember\n        types = (ColumnType._from_polars_data_type(data_type) for data_type in dataframe.dtypes)\n\n        return Schema(dict(zip(names, types, strict=True)))"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_get_column_index",
      "name": "_get_column_index",
      "qname": "safeds.data.tabular.typing._schema.Schema._get_column_index",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_get_column_index/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema._get_column_index.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/_get_column_index/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.typing._schema.Schema._get_column_index.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the index of the column with specified column name.",
      "docstring": " Return the index of the column with specified column name.\n\nParameters\n----------\n column_name : str\n     The name of the column.\n\nReturns\n-------\nindex : int\n     The index of the column.\n\nRaises\n------\nColumnNameError\n    If the specified column name does not exist.",
      "code": "    def _get_column_index(self, column_name: str) -> int:\n        \"\"\"\n         Return the index of the column with specified column name.\n\n        Parameters\n        ----------\n         column_name : str\n             The name of the column.\n\n        Returns\n        -------\n        index : int\n             The index of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified column name does not exist.\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n\n        return list(self._schema.keys()).index(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/column_names@getter",
      "name": "column_names",
      "qname": "safeds.data.tabular.typing._schema.Schema.column_names",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/column_names@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema.column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names saved in this schema.",
      "docstring": "Return a list of all column names saved in this schema.\n\nReturns\n-------\ncolumn_names : list[str]\n    The column names.",
      "code": "    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names saved in this schema.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n        \"\"\"\n        return list(self._schema.keys())"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/get_column_type",
      "name": "get_column_type",
      "qname": "safeds.data.tabular.typing._schema.Schema.get_column_type",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/get_column_type/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema.get_column_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/get_column_type/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.typing._schema.Schema.get_column_type.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the given column.",
      "docstring": "Return the type of the given column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nColumnNameError\n    If the specified column name does not exist.",
      "code": "    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified column name does not exist.\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n        return self._schema[column_name]"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._schema/Schema/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.typing._schema.Schema.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._schema.Schema.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._schema/Schema/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.typing._schema.Schema.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the schema contains a given column.",
      "docstring": "Return whether the schema contains a given column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncontains : bool\n    True if the schema contains the column.",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the schema contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the schema contains the column.\n        \"\"\"\n        return column_name in self._schema"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Ada Boost classification.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_classifier: sk_AdaBoostClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : AdaBoost\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    def fit(self, training_set: TaggedTable) -> AdaBoost:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : AdaBoost\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_AdaBoostClassifier()\n        fit(wrapped_classifier, training_set)\n\n        result = AdaBoost()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._ada_boost/AdaBoost/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._ada_boost.AdaBoost.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/accuracy",
      "name": "accuracy",
      "qname": "safeds.ml.classical.classification._classifier.Classifier.accuracy",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/accuracy/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.accuracy.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/accuracy/validation_or_test_set",
          "name": "validation_or_test_set",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.accuracy.validation_or_test_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The validation or test set."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Compute the accuracy of the classifier on the given data.",
      "docstring": "Compute the accuracy of the classifier on the given data.\n\nParameters\n----------\nvalidation_or_test_set : TaggedTable\n    The validation or test set.\n\nReturns\n-------\naccuracy : float\n    The calculated accuracy score, i.e. the percentage of equal data.",
      "code": "    def accuracy(self, validation_or_test_set: TaggedTable) -> float:\n        \"\"\"\n        Compute the accuracy of the classifier on the given data.\n\n        Parameters\n        ----------\n        validation_or_test_set : TaggedTable\n            The validation or test set.\n\n        Returns\n        -------\n        accuracy : float\n            The calculated accuracy score, i.e. the percentage of equal data.\n        \"\"\"\n        expected = validation_or_test_set.target\n        predicted = self.predict(validation_or_test_set.features).target\n\n        return sk_accuracy_score(expected._data, predicted._data)"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._classifier.Classifier.fit",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : Classifier\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    @abstractmethod\n    def fit(self, training_set: TaggedTable) -> Classifier:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : Classifier\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._classifier.Classifier.is_fitted",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    @abstractmethod\n    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._classifier.Classifier.predict",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._classifier/Classifier/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._classifier.Classifier.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    @abstractmethod\n    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Decision tree classification.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_classifier: sk_DecisionTreeClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : DecisionTree\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    def fit(self, training_set: TaggedTable) -> DecisionTree:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : DecisionTree\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_DecisionTreeClassifier()\n        fit(wrapped_classifier, training_set)\n\n        result = DecisionTree()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._decision_tree/DecisionTree/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._decision_tree.DecisionTree.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Gradient boosting classification.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_classifier: sk_GradientBoostingClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : GradientBoosting\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    def fit(self, training_set: TaggedTable) -> GradientBoosting:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : GradientBoosting\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_GradientBoostingClassifier()\n        fit(wrapped_classifier, training_set)\n\n        result = GradientBoosting()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._gradient_boosting_classification/GradientBoosting/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._gradient_boosting_classification.GradientBoosting.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/__init__/number_of_neighbors",
          "name": "number_of_neighbors",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.__init__.number_of_neighbors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The number of neighbors to be interpolated with. Has to be less than or equal to the sample size."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "K-nearest-neighbors classification.",
      "docstring": "",
      "code": "    def __init__(self, number_of_neighbors: int) -> None:\n        self._number_of_neighbors = number_of_neighbors\n\n        self._wrapped_classifier: sk_KNeighborsClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : KNearestNeighbors\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    def fit(self, training_set: TaggedTable) -> KNearestNeighbors:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : KNearestNeighbors\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_KNeighborsClassifier(self._number_of_neighbors, n_jobs=-1)\n        fit(wrapped_classifier, training_set)\n\n        result = KNearestNeighbors(self._number_of_neighbors)\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._k_nearest_neighbors/KNearestNeighbors/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._k_nearest_neighbors.KNearestNeighbors.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Regularized logistic regression.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_classifier: sk_LogisticRegression | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : LogisticRegression\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    def fit(self, training_set: TaggedTable) -> LogisticRegression:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : LogisticRegression\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_LogisticRegression(n_jobs=-1)\n        fit(wrapped_classifier, training_set)\n\n        result = LogisticRegression()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._logistic_regression/LogisticRegression/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._logistic_regression.LogisticRegression.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classical.classification._random_forest.RandomForest.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._random_forest.RandomForest.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Random forest classification.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._wrapped_classifier: sk_RandomForestClassifier | None = None\n        self._feature_names: list[str] | None = None\n        self._target_name: str | None = None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/fit",
      "name": "fit",
      "qname": "safeds.ml.classical.classification._random_forest.RandomForest.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/fit/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._random_forest.RandomForest.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/fit/training_set",
          "name": "training_set",
          "qname": "safeds.ml.classical.classification._random_forest.RandomForest.fit.training_set",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The training data containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.",
      "docstring": "Create a copy of this classifier and fit it with the given training data.\n\nThis classifier is not modified.\n\nParameters\n----------\ntraining_set : TaggedTable\n    The training data containing the feature and target vectors.\n\nReturns\n-------\nfitted_classifier : RandomForest\n    The fitted classifier.\n\nRaises\n------\nLearningError\n    If the training data contains invalid values or if the training failed.",
      "code": "    def fit(self, training_set: TaggedTable) -> RandomForest:\n        \"\"\"\n        Create a copy of this classifier and fit it with the given training data.\n\n        This classifier is not modified.\n\n        Parameters\n        ----------\n        training_set : TaggedTable\n            The training data containing the feature and target vectors.\n\n        Returns\n        -------\n        fitted_classifier : RandomForest\n            The fitted classifier.\n\n        Raises\n        ------\n        LearningError\n            If the training data contains invalid values or if the training failed.\n        \"\"\"\n        wrapped_classifier = sk_RandomForestClassifier(n_jobs=-1)\n        fit(wrapped_classifier, training_set)\n\n        result = RandomForest()\n        result._wrapped_classifier = wrapped_classifier\n        result._feature_names = training_set.features.column_names\n        result._target_name = training_set.target.name\n\n        return result"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/is_fitted",
      "name": "is_fitted",
      "qname": "safeds.ml.classical.classification._random_forest.RandomForest.is_fitted",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/is_fitted/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._random_forest.RandomForest.is_fitted.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if the classifier is fitted.",
      "docstring": "Check if the classifier is fitted.\n\nReturns\n-------\nis_fitted : bool\n    Whether the classifier is fitted.",
      "code": "    def is_fitted(self) -> bool:\n        \"\"\"\n        Check if the classifier is fitted.\n\n        Returns\n        -------\n        is_fitted : bool\n            Whether the classifier is fitted.\n        \"\"\"\n        return self._wrapped_classifier is not None"
    },
    {
      "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/predict",
      "name": "predict",
      "qname": "safeds.ml.classical.classification._random_forest.RandomForest.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/predict/self",
          "name": "self",
          "qname": "safeds.ml.classical.classification._random_forest.RandomForest.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classical.classification._random_forest/RandomForest/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classical.classification._random_forest.RandomForest.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\n\nReturns\n-------\ntable : TaggedTable\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nModelNotFittedError\n    If the model has not been fitted yet.\nDatasetContainsTargetError\n    If the dataset contains the target column already.\nDatasetMissesFeaturesError\n    If the dataset misses feature columns.\nPredictionError\n    If predicting with the given dataset failed.",
      "code": "    def predict(self, dataset: Table) -> TaggedTable:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n\n        Returns\n        -------\n        table : TaggedTable\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        ModelNotFittedError\n            If the model has not been fitted yet.\n        DatasetContainsTargetError\n            If the dataset contains the target column already.\n        DatasetMissesFeaturesError\n            If the dataset misses feature columns.\n        PredictionError\n            If predicting with the given dataset failed.\n        \"\"\"\n        return predict(self._wrapped_classifier, dataset, self._feature_names, self._target_name)"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__/target_name",
          "name": "target_name",
          "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError.__init__.target_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset contains the target column already.",
      "docstring": "",
      "code": "    def __init__(self, target_name: str):\n        super().__init__(f\"Dataset already contains the target column '{target_name}'.\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__/missing_feature_names",
          "name": "missing_feature_names",
          "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError.__init__.missing_feature_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset misses feature columns.",
      "docstring": "",
      "code": "    def __init__(self, missing_feature_names: list[str]):\n        super().__init__(f\"Dataset misses the feature columns '{missing_feature_names}'.\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.LearningError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.LearningError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__/reason",
          "name": "reason",
          "qname": "safeds.ml.exceptions._exceptions.LearningError.__init__.reason",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while training a model.",
      "docstring": "",
      "code": "    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while learning\")\n        else:\n            super().__init__(f\"Error occurred while learning: {reason}\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.ModelNotFittedError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.ModelNotFittedError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a model is used before fitting it.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"The model has not been fitted yet.\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.PredictionError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.PredictionError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__/reason",
          "name": "reason",
          "qname": "safeds.ml.exceptions._exceptions.PredictionError.__init__.reason",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while prediction a target vector using a model.",
      "docstring": "",
      "code": "    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while predicting\")\n        else:\n            super().__init__(f\"Error occurred while predicting: {reason}\")"
    }
  ]
}