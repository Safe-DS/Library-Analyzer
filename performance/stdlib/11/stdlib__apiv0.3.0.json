{
  "schemaVersion": 1,
  "distribution": "",
  "package": "stdlib",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column",
      "name": "Column",
      "qname": "safeds.data.tabular.containers._column.Column",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._column/Column/__init__",
        "stdlib/safeds.data.tabular.containers._column/Column/name@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/statistics@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/type@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/__eq__",
        "stdlib/safeds.data.tabular.containers._column/Column/__getitem__",
        "stdlib/safeds.data.tabular.containers._column/Column/__hash__",
        "stdlib/safeds.data.tabular.containers._column/Column/__iter__",
        "stdlib/safeds.data.tabular.containers._column/Column/__len__",
        "stdlib/safeds.data.tabular.containers._column/Column/__repr__",
        "stdlib/safeds.data.tabular.containers._column/Column/__str__",
        "stdlib/safeds.data.tabular.containers._column/Column/get_value",
        "stdlib/safeds.data.tabular.containers._column/Column/count",
        "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values",
        "stdlib/safeds.data.tabular.containers._column/Column/all",
        "stdlib/safeds.data.tabular.containers._column/Column/any",
        "stdlib/safeds.data.tabular.containers._column/Column/none",
        "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio",
        "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values",
        "stdlib/safeds.data.tabular.containers._column/Column/correlation_with",
        "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values",
        "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Column:\n    def __init__(self, data: typing.Iterable, name: str) -> None:\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        self._name: str = name\n        self._type: ColumnType = ColumnType.from_numpy_dtype(self._data.dtype)\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of the column.\n\n        Returns\n        -------\n        name : str\n            The name of the column.\n        \"\"\"\n        return self._name\n\n    @property\n    def statistics(self) -> ColumnStatistics:\n        return ColumnStatistics(self)\n\n    @property\n    def type(self) -> ColumnType:\n        \"\"\"\n        Return the type of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n        \"\"\"\n        return self._type\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Column):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._data.equals(other._data) and self.name == other.name\n\n    def __getitem__(self, index: int) -> Any:\n        return self.get_value(index)\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)\n\n    def __len__(self) -> int:\n        return len(self._data)\n\n    def __repr__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__str__()\n\n    def get_value(self, index: int) -> Any:\n        \"\"\"\n        Return column value at specified index, starting at 0.\n\n        Parameters\n        ----------\n        index : int\n            Index of requested element.\n\n        Returns\n        -------\n        value\n            Value at index in column.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If the given index does not exist in the column.\n        \"\"\"\n        if index < 0 or index >= self._data.size:\n            raise IndexOutOfBoundsError(index)\n\n        return self._data[index]\n\n    def count(self) -> int:\n        \"\"\"\n        Return the number of elements in the column.\n\n        Returns\n        -------\n        count : int\n            The number of elements.\n        \"\"\"\n        return len(self._data)\n\n    def _count_missing_values(self) -> int:\n        \"\"\"\n        Return the number of null values in the column.\n\n        Returns\n        -------\n        count : int\n            The number of null values.\n        \"\"\"\n        return self._data.isna().sum()\n\n    def all(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if all values have a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if all match.\n\n        \"\"\"\n        for value in self._data:\n            if not predicate(value):\n                return False\n        return True\n\n    def any(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if any value has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if any match.\n\n        \"\"\"\n        for value in self._data:\n            if predicate(value):\n                return True\n        return False\n\n    def none(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if no values has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if none match.\n\n        \"\"\"\n        for value in self._data:\n            if predicate(value):\n                return False\n        return True\n\n    def missing_value_ratio(self) -> float:\n        \"\"\"\n        Return the ratio of null values to the total number of elements in the column\n\n        Returns\n        -------\n        ratio : float\n            The ratio of null values to the total number of elements in the column.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._count_missing_values() / self._data.size\n\n    def has_missing_values(self) -> bool:\n        \"\"\"\n        Return whether the column has missing values.\n\n        Returns\n        -------\n        missing_values_exist : bool\n            True if missing values exist.\n        \"\"\"\n        return self.any(\n            lambda value: value is None\n            or (isinstance(value, Number) and np.isnan(value))\n        )\n\n    def correlation_with(self, other_column: Column) -> float:\n        \"\"\"\n        Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\n        Returns\n        -------\n        correlation : float\n            Correlation between the two columns.\n\n        Raises\n        ------\n        TypeError\n            If one of the columns is not numerical.\n        \"\"\"\n        if not self._type.is_numeric() or not other_column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"Columns must be numerical. {self.name} is {self._type}, \"\n                f\"{other_column.name} is {other_column._type}.\"\n            )\n        if self._data.size != other_column._data.size:\n            raise ColumnLengthMismatchError(\n                f\"{self.name} is of size {self._data.size}, \"\n                f\"{other_column.name} is of size {other_column._data.size}.\"\n            )\n        return self._data.corr(other_column._data)\n\n    def get_unique_values(self) -> list[typing.Any]:\n        \"\"\"\n        Return a list of all unique values in the column.\n\n        Returns\n        -------\n        unique_values : list[any]\n            List of unique values in the column.\n        \"\"\"\n        return list(self._data.unique())\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n\n        with pd.option_context(\n            \"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]\n        ):\n            return display(tmp)",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_type",
          "types": {
            "kind": "NamedType",
            "name": "ColumnType"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics",
      "name": "ColumnStatistics",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/__init__",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/max",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/min",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/mean",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/mode",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/median",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/sum",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/variance",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/standard_deviation",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/stability",
        "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/idness"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ColumnStatistics:\n    def __init__(self, column: Column):\n        self._column = column\n\n    def max(self) -> float:\n        \"\"\"\n        Return the maximum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        max : float\n            The maximum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.max()\n\n    def min(self) -> float:\n        \"\"\"\n        Return the minimum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        min : float\n            The minimum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.min()\n\n    def mean(self) -> float:\n        \"\"\"\n        Return the mean value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        mean : float\n            The mean value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.mean()\n\n    def mode(self) -> Any:\n        \"\"\"\n        Return the mode of the column.\n\n        Returns\n        -------\n        List :\n            Returns a list with the most common values.\n        \"\"\"\n        return self._column._data.mode().tolist()\n\n    def median(self) -> float:\n        \"\"\"\n        Return the median value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        median : float\n            The median value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.median()\n\n    def sum(self) -> float:\n        \"\"\"\n        Return the sum of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The sum of all values.\n\n        Raises\n        ---\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self._column.type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.sum()\n\n    def variance(self) -> float:\n        \"\"\"\n        Return the variance of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The variance of all values.\n\n        Raises\n        ---\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self._column.type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n\n        return self._column._data.var()\n\n    def standard_deviation(self) -> float:\n        \"\"\"\n        Return the standard deviation of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The standard deviation of all values.\n\n        Raises\n        ---\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self._column.type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.std()\n\n    def stability(self) -> float:\n        \"\"\"\n        Calculate the stability of this column, which we define as\n\n        $$\n        \\\\frac{\\\\text{number of occurrences of most common non-null value}}{\\\\text{number of non-null values}}\n        $$\n\n        Returns\n        -------\n        stability : float\n            The stability of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If the column is empty.\n        \"\"\"\n        if self._column._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return (\n            self._column._data.value_counts()[self._column.statistics.mode()[0]]\n            / self._column._data.count()\n        )\n\n    def idness(self) -> float:\n        \"\"\"\n        Calculate the idness of this column, which we define as\n\n        $$\n        \\\\frac{\\\\text{number of different values}}{\\\\text{number of rows}}\n        $$\n\n        Returns\n        -------\n        idness : float\n            The idness of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If this column is empty.\n        \"\"\"\n        if self._column._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._column._data.nunique() / self._column._data.size",
      "instance_attributes": [
        {
          "name": "_column",
          "types": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row",
      "name": "Row",
      "qname": "safeds.data.tabular.containers._row.Row",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._row/Row/__init__",
        "stdlib/safeds.data.tabular.containers._row/Row/__getitem__",
        "stdlib/safeds.data.tabular.containers._row/Row/__iter__",
        "stdlib/safeds.data.tabular.containers._row/Row/__len__",
        "stdlib/safeds.data.tabular.containers._row/Row/get_value",
        "stdlib/safeds.data.tabular.containers._row/Row/count",
        "stdlib/safeds.data.tabular.containers._row/Row/has_column",
        "stdlib/safeds.data.tabular.containers._row/Row/get_column_names",
        "stdlib/safeds.data.tabular.containers._row/Row/get_type_of_column",
        "stdlib/safeds.data.tabular.containers._row/Row/__eq__",
        "stdlib/safeds.data.tabular.containers._row/Row/__hash__",
        "stdlib/safeds.data.tabular.containers._row/Row/__str__",
        "stdlib/safeds.data.tabular.containers._row/Row/__repr__",
        "stdlib/safeds.data.tabular.containers._row/Row/_ipython_display_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Row:\n    def __init__(self, data: typing.Iterable, schema: TableSchema):\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        self.schema: TableSchema = schema\n        self._data = self._data.reset_index(drop=True)\n\n    def __getitem__(self, column_name: str) -> Any:\n        return self.get_value(column_name)\n\n    def __iter__(self) -> typing.Iterator[Any]:\n        return iter(self.get_column_names())\n\n    def __len__(self) -> int:\n        return len(self._data)\n\n    def get_value(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value :\n            The value of the column.\n        \"\"\"\n        if not self.schema.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n        return self._data[self.schema._get_column_index_by_name(column_name)]\n\n    def count(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        count : int\n            The number of columns.\n        \"\"\"\n        return len(self._data)\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the row contains a given column.\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True, if row contains the column.\n        \"\"\"\n        return self.schema.has_column(column_name)\n\n    def get_column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names saved in this schema.\n        Alias for self.schema.get_column_names() -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n        \"\"\"\n        return self.schema.get_column_names()\n\n    def get_type_of_column(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of a specified column.\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self.schema.get_type_of_column(column_name)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._data.equals(other._data) and self.schema == other.schema\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def __str__(self) -> str:\n        tmp = self._data.to_frame().T\n        tmp.columns = self.get_column_names()\n        return tmp.__str__()\n\n    def __repr__(self) -> str:\n        tmp = self._data.to_frame().T\n        tmp.columns = self.get_column_names()\n        return tmp.__repr__()\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame().T\n        tmp.columns = self.get_column_names()\n\n        with pd.option_context(\n            \"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]\n        ):\n            return display(tmp)",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "schema",
          "types": {
            "kind": "NamedType",
            "name": "TableSchema"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table",
      "name": "Table",
      "qname": "safeds.data.tabular.containers._table.Table",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._table/Table/__init__",
        "stdlib/safeds.data.tabular.containers._table/Table/get_row",
        "stdlib/safeds.data.tabular.containers._table/Table/from_json",
        "stdlib/safeds.data.tabular.containers._table/Table/from_csv",
        "stdlib/safeds.data.tabular.containers._table/Table/from_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/from_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/to_json",
        "stdlib/safeds.data.tabular.containers._table/Table/to_csv",
        "stdlib/safeds.data.tabular.containers._table/Table/rename_column",
        "stdlib/safeds.data.tabular.containers._table/Table/get_column",
        "stdlib/safeds.data.tabular.containers._table/Table/drop_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/keep_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/to_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/filter_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/count_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/count_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/to_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/drop_duplicate_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/replace_column",
        "stdlib/safeds.data.tabular.containers._table/Table/add_column",
        "stdlib/safeds.data.tabular.containers._table/Table/add_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/add_row",
        "stdlib/safeds.data.tabular.containers._table/Table/add_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/has_column",
        "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_missing_values",
        "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_non_numerical_values",
        "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_numerical_values",
        "stdlib/safeds.data.tabular.containers._table/Table/get_column_names",
        "stdlib/safeds.data.tabular.containers._table/Table/get_type_of_column",
        "stdlib/safeds.data.tabular.containers._table/Table/sort_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_outliers",
        "stdlib/safeds.data.tabular.containers._table/Table/__eq__",
        "stdlib/safeds.data.tabular.containers._table/Table/__hash__",
        "stdlib/safeds.data.tabular.containers._table/Table/transform_column",
        "stdlib/safeds.data.tabular.containers._table/Table/summary",
        "stdlib/safeds.data.tabular.containers._table/Table/__repr__",
        "stdlib/safeds.data.tabular.containers._table/Table/__str__",
        "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_",
        "stdlib/safeds.data.tabular.containers._table/Table/slice",
        "stdlib/safeds.data.tabular.containers._table/Table/split",
        "stdlib/safeds.data.tabular.containers._table/Table/shuffle"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Table:\n    def __init__(self, data: typing.Iterable, schema: Optional[TableSchema] = None):\n        \"\"\"\n        Create a new table.\n\n        Parameters\n        ----------\n        data : typing.Iterable\n            The data to be saved in the table.\n        schema : TableSchema\n            The schema for the table.\n            None by default. If None, the schema will be provided by the data that is given.\n            If a schema is set, there is no check if this schema is compatible with the data.\n\n        Raises\n        ----------\n        MissingSchemaError\n            If the schema is missing.\n        \"\"\"\n        self._data: pd.Dataframe = (\n            data if isinstance(data, pd.DataFrame) else pd.DataFrame(data)\n        )\n        if schema is None:\n            if self.count_columns() == 0:\n                raise MissingSchemaError()\n            self.schema: TableSchema = TableSchema._from_dataframe(self._data)\n        else:\n            self.schema = schema\n            if self._data.empty:\n                self._data = pd.DataFrame(columns=self.schema.get_column_names())\n\n        self._data = self._data.reset_index(drop=True)\n        self._data.columns = list(range(self.count_columns()))\n\n    def get_row(self, index: int) -> Row:\n        \"\"\"\n        Return the row at a specified index.\n\n        Parameters\n        ----------\n        index : int\n            The index.\n\n        Returns\n        -------\n        row : Row\n            The row of the table at the index.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If no row at the specified index exists in this table.\n        \"\"\"\n        if len(self._data.index) - 1 < index or index < 0:\n            raise IndexOutOfBoundsError(index)\n        return Row(self._data.iloc[[index]].squeeze(), self.schema)\n\n    @staticmethod\n    def from_json(path: str) -> Table:\n        \"\"\"\n        Read data from a JSON file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the JSON file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the JSON file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n\n        try:\n            return Table(pd.read_json(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n        except Exception as exception:\n            raise ValueError(\n                f'Could not read file from \"{path}\" as JSON'\n            ) from exception\n\n    @staticmethod\n    def from_csv(path: str) -> Table:\n        \"\"\"\n        Read data from a CSV file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the CSV file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the CSV file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n\n        try:\n            return Table(pd.read_csv(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n        except Exception as exception:\n            raise ValueError(f'Could not read file from \"{path}\" as CSV') from exception\n\n    @staticmethod\n    def from_rows(rows: list[Row]) -> Table:\n        \"\"\"\n        Return a table created from a list of rows.\n\n        Parameters\n        ----------\n        rows : list[Row]\n            The rows to be combined. They need to have a matching schema.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        SchemaMismatchError\n            If any of the row schemas does not match with the others.\n        \"\"\"\n        if len(rows) == 0:\n            raise MissingDataError(\"This function requires at least one row.\")\n\n        schema_compare: TableSchema = rows[0].schema\n        row_array: list[Series] = []\n\n        for row in rows:\n            if schema_compare != row.schema:\n                raise SchemaMismatchError()\n            row_array.append(row._data)\n\n        dataframe: DataFrame = pd.DataFrame(row_array)\n        dataframe.columns = schema_compare.get_column_names()\n        return Table(dataframe)\n\n    @staticmethod\n    def from_columns(columns: list[Column]) -> Table:\n        \"\"\"\n        Return a table created from a list of columns.\n\n        Parameters\n        ----------\n        columns : list[Column]\n            The columns to be combined. They need to have the same size.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        ColumnLengthMismatchError\n            If any of the column sizes does not match with the others.\n        \"\"\"\n        if len(columns) == 0:\n            raise MissingDataError(\"This function requires at least one column.\")\n\n        dataframe: DataFrame = pd.DataFrame()\n\n        for column in columns:\n            if column._data.size != columns[0]._data.size:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(\n                        [f\"{column.name}: {column._data.size}\" for column in columns]\n                    )\n                )\n            dataframe[column.name] = column._data\n\n        return Table(dataframe)\n\n    def to_json(self, path_to_file: str) -> None:\n        \"\"\"\n        Write the data from the table into a JSON file.\n        If the file and/or the directories do not exist, they will be created.\n        If the file already exists it will be overwritten.\n\n        Parameters\n        ----------\n        path_to_file : str\n            The path to the output file.\n        \"\"\"\n        Path(os.path.dirname(path_to_file)).mkdir(parents=True, exist_ok=True)\n        data_to_json = self._data.copy()\n        data_to_json.columns = self.schema.get_column_names()\n        data_to_json.to_json(path_to_file)\n\n    def to_csv(self, path_to_file: str) -> None:\n        \"\"\"\n        Write the data from the table into a CSV file.\n        If the file and/or the directories do not exist they will be created.\n        If the file already exists it will be overwritten.\n\n        Parameters\n        ----------\n        path_to_file : str\n            The path to the output file.\n        \"\"\"\n        Path(os.path.dirname(path_to_file)).mkdir(parents=True, exist_ok=True)\n        data_to_csv = self._data.copy()\n        data_to_csv.columns = self.schema.get_column_names()\n        data_to_csv.to_csv(path_to_file, index=False)\n\n    def rename_column(self, old_name: str, new_name: str) -> Table:\n        \"\"\"\n        Rename a single column.\n\n        Parameters\n        ----------\n        old_name : str\n            The old name of the target column\n        new_name : str\n            The new name of the target column\n\n        Returns\n        -------\n        table : Table\n            The Table with the renamed column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified old target column name does not exist.\n        DuplicateColumnNameError\n            If the specified new target column name already exists.\n        \"\"\"\n        if old_name not in self.schema.get_column_names():\n            raise UnknownColumnNameError([old_name])\n        if old_name == new_name:\n            return self\n        if new_name in self.schema.get_column_names():\n            raise DuplicateColumnNameError(new_name)\n\n        new_df = self._data.copy()\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df.rename(columns={old_name: new_name}))\n\n    def get_column(self, column_name: str) -> Column:\n        \"\"\"\n        Return a column with the data of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        column : Column\n            The column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if self.schema.has_column(column_name):\n            output_column = Column(\n                self._data.iloc[\n                    :, [self.schema._get_column_index_by_name(column_name)]\n                ].squeeze(),\n                column_name,\n            )\n            output_column._type = self.schema.get_type_of_column(column_name)\n            return output_column\n\n        raise UnknownColumnNameError([column_name])\n\n    def drop_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table without the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing all columns to be dropped.\n\n        Returns\n        -------\n        table : Table\n            A table without the given columns.\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns do not exist.\n        \"\"\"\n        invalid_columns = []\n        column_indices = []\n        for name in column_names:\n            if not self.schema.has_column(name):\n                invalid_columns.append(name)\n            else:\n                column_indices.append(self.schema._get_column_index_by_name(name))\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n        transformed_data = self._data.drop(labels=column_indices, axis=\"columns\")\n        transformed_data.columns = list(\n            name for name in self.schema.get_column_names() if name not in column_names\n        )\n        return Table(transformed_data)\n\n    def keep_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table with only the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing only the columns to be kept.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the given column(s).\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns do not exist.\n        \"\"\"\n        invalid_columns = []\n        column_indices = []\n        for name in column_names:\n            if not self.schema.has_column(name):\n                invalid_columns.append(name)\n            else:\n                column_indices.append(self.schema._get_column_index_by_name(name))\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n        transformed_data = self._data[column_indices]\n        transformed_data.columns = list(\n            name for name in self.schema.get_column_names() if name in column_names\n        )\n        return Table(transformed_data)\n\n    def to_rows(self) -> list[Row]:\n        \"\"\"\n        Return a list of the rows.\n\n        Returns\n        -------\n        rows : list[Row]\n            List of rows.\n        \"\"\"\n        return [\n            Row(series_row, self.schema) for (_, series_row) in self._data.iterrows()\n        ]\n\n    def filter_rows(self, query: Callable[[Row], bool]) -> Table:\n        \"\"\"\n        Return a table with rows filtered by Callable (e.g. lambda function).\n\n        Parameters\n        ----------\n        query : lambda function\n            A Callable that is applied to all rows.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the rows filtered by the query.\n        \"\"\"\n\n        rows: list[Row] = [row for row in self.to_rows() if query(row)]\n        if len(rows) == 0:\n            result_table = Table([], self.schema)\n        else:\n            result_table = self.from_rows(rows)\n        return result_table\n\n    def count_rows(self) -> int:\n        \"\"\"\n        Return the number of rows.\n\n        Returns\n        -------\n        count : int\n            The number of rows.\n        \"\"\"\n        return self._data.shape[0]\n\n    def count_columns(self) -> int:\n        \"\"\"\n        Return the number of columns.\n\n        Returns\n        -------\n        count : int\n            The number of columns.\n        \"\"\"\n        return self._data.shape[1]\n\n    def to_columns(self) -> list[Column]:\n        \"\"\"\n        Return a list of the columns.\n\n        Returns\n        -------\n        columns : list[Columns]\n            List of columns.\n        \"\"\"\n        return [self.get_column(name) for name in self.schema.get_column_names()]\n\n    def drop_duplicate_rows(self) -> Table:\n        \"\"\"\n        Return a copy of the table with every duplicate row removed.\n\n        Returns\n        -------\n        result : Table\n            The table with the duplicate rows removed.\n\n        \"\"\"\n        df = self._data.drop_duplicates(ignore_index=True)\n        df.columns = self.schema.get_column_names()\n        return Table(df)\n\n    def replace_column(self, old_column_name: str, new_column: Column) -> Table:\n        \"\"\"\n        Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\n        Parameters\n        ----------\n        old_column_name : str\n            The name of the column to be replaced.\n\n        new_column : Column\n            The new column replacing the old column.\n\n        Returns\n        -------\n        result : Table\n            A table with the old column replaced by the new column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the old column does not exist.\n\n        DuplicateColumnNameError\n            If the new column already exists and the existing column is not affected by the replacement.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n        \"\"\"\n        if old_column_name not in self.schema.get_column_names():\n            raise UnknownColumnNameError([old_column_name])\n\n        if (\n            new_column.name in self.schema.get_column_names()\n            and new_column.name != old_column_name\n        ):\n            raise DuplicateColumnNameError(new_column.name)\n\n        if self.count_rows() != new_column._data.size:\n            raise ColumnSizeError(str(self.count_rows()), str(new_column._data.size))\n\n        if old_column_name != new_column.name:\n            renamed_table = self.rename_column(old_column_name, new_column.name)\n            result = renamed_table._data\n            result.columns = renamed_table.schema.get_column_names()\n        else:\n            result = self._data.copy()\n            result.columns = self.schema.get_column_names()\n\n        result[new_column.name] = new_column._data\n        return Table(result)\n\n    def add_column(self, column: Column) -> Table:\n        \"\"\"\n        Return the original table with the provided column attached at the end.\n\n        Returns\n        -------\n        result : Table\n            The table with the column attached.\n\n        Raises\n        ------\n        DuplicateColumnNameError\n            If the new column already exists.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n\n        \"\"\"\n        if self.schema.has_column(column.name):\n            raise DuplicateColumnNameError(column.name)\n\n        if column._data.size != self.count_rows():\n            raise ColumnSizeError(str(self.count_rows()), str(column._data.size))\n\n        result = self._data.copy()\n        result.columns = self.schema.get_column_names()\n        result[column.name] = column._data\n        return Table(result)\n\n    def add_columns(self, columns: Union[list[Column], Table]) -> Table:\n        \"\"\"\n        Add multiple columns to the table.\n\n        Parameters\n        ----------\n        columns : list[Column] or Table\n            The columns to be added.\n\n        Returns\n        -------\n        result: Table\n            A new table combining the original table and the given columns.\n\n        Raises\n        --------\n        ColumnSizeError\n            If at least one of the column sizes from the provided column list does not match the table.\n        DuplicateColumnNameError\n            If at least one column name from the provided column list already exists in the table.\n        \"\"\"\n        if isinstance(columns, Table):\n            columns = columns.to_columns()\n        result = self._data.copy()\n        result.columns = self.schema.get_column_names()\n        for column in columns:\n            if column.name in result.columns:\n                raise DuplicateColumnNameError(column.name)\n\n            if column._data.size != self.count_rows():\n                raise ColumnSizeError(str(self.count_rows()), str(column._data.size))\n\n            result[column.name] = column._data\n        return Table(result)\n\n    def add_row(self, row: Row) -> Table:\n        \"\"\"\n        Add a row to the table.\n\n        Parameters\n        ----------\n        row : Row\n            The row to be added.\n\n        Returns\n        -------\n        table : Table\n            A new table with the added row at the end.\n\n        \"\"\"\n        if self.schema != row.schema:\n            raise SchemaMismatchError()\n        new_df = pd.concat([self._data, row._data.to_frame().T]).infer_objects()\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df)\n\n    def add_rows(self, rows: Union[list[Row], Table]) -> Table:\n        \"\"\"\n        Add multiple rows to a table.\n\n        Parameters\n        ----------\n        rows : list[Row] or Table\n            The rows to be added.\n\n        Returns\n        -------\n        result : Table\n            A new table which combines the original table and the given rows.\n        \"\"\"\n        if isinstance(rows, Table):\n            rows = rows.to_rows()\n        result = self._data\n        for row in rows:\n            if self.schema != row.schema:\n                raise SchemaMismatchError()\n        result = pd.concat(\n            [result, *[row._data.to_frame().T for row in rows]]\n        ).infer_objects()\n        result.columns = self.schema.get_column_names()\n        return Table(result)\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the table contains a given column.\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the column exists.\n        \"\"\"\n        return self.schema.has_column(column_name)\n\n    def list_columns_with_missing_values(self) -> list[Column]:\n        \"\"\"\n        Return a list of all the columns that have at least one missing value. Returns an empty list if there are none.\n\n        Returns\n        -------\n        columns_with_missing_values: list[Column]\n            The list of columns with missing values.\n        \"\"\"\n        columns = self.to_columns()\n        columns_with_missing_values = []\n        for column in columns:\n            if column.has_missing_values():\n                columns_with_missing_values.append(column)\n        return columns_with_missing_values\n\n    def list_columns_with_non_numerical_values(self) -> list[Column]:\n        \"\"\"\n        Return a list of columns only containing non-numerical values.\n\n        Returns\n        -------\n        cols : list[Column]\n            The list with only non-numerical columns.\n        \"\"\"\n        cols = []\n        for column_name, data_type in self.schema._schema.items():\n            if not data_type.is_numeric():\n                cols.append(self.get_column(column_name))\n        return cols\n\n    def list_columns_with_numerical_values(self) -> list[Column]:\n        \"\"\"\n        Return a list of columns only containing numerical values.\n\n        Returns\n        -------\n        cols : list[Column]\n            The list with only numerical columns.\n        \"\"\"\n        cols = []\n        for column_name, data_type in self.schema._schema.items():\n            if data_type.is_numeric():\n                cols.append(self.get_column(column_name))\n        return cols\n\n    def get_column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in this table.\n        Alias for self.schema.get_column_names() -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The list of the column names.\n        \"\"\"\n        return self.schema.get_column_names()\n\n    def get_type_of_column(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column to be queried.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self.schema.get_type_of_column(column_name)\n\n    def sort_columns(\n        self,\n        query: Callable[[Column, Column], int] = lambda col1, col2: (\n            col1.name > col2.name\n        )\n        - (col1.name < col2.name),\n    ) -> Table:\n        \"\"\"\n        Sort a table with the given lambda function.\n        If no function is given the columns will be sorted alphabetically.\n        This function uses the default python sort algorithm.\n        The query returns\n        0, if both columns are equal.\n        < 0, if the first column should be ordered after the second column.\n        > 0, if the first column should be ordered before the second column.\n\n        Parameters\n        ----------\n        query : a lambda function\n            The lambda function used to sort the columns.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted columns.\n        \"\"\"\n        columns = self.to_columns()\n        columns.sort(key=functools.cmp_to_key(query))\n        return Table.from_columns(columns)\n\n    def remove_outliers(self) -> Table:\n        \"\"\"\n        Remove all rows from the table that contain at least one outlier defined as having a value that has a distance of\n        more than 3 standard deviations from the column average.\n\n        Returns\n        -------\n        new_table : Table\n            A new table without rows containing outliers.\n        \"\"\"\n        result = self._data.copy(deep=True)\n\n        table_without_nonnumericals = Table.from_columns(\n            self.list_columns_with_numerical_values()\n        )\n\n        result = result[\n            (np.absolute(stats.zscore(table_without_nonnumericals._data)) < 3).all(\n                axis=1\n            )\n        ]\n\n        return Table(result, self.schema)\n\n    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, Table):\n            return NotImplemented\n        if self is other:\n            return True\n        table1 = self.sort_columns()\n        table2 = other.sort_columns()\n        return table1._data.equals(table2._data) and table1.schema == table2.schema\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def transform_column(\n        self, name: str, transformer: Callable[[Row], typing.Any]\n    ) -> Table:\n        \"\"\"\n        Transform provided column by calling provided transformer.\n\n        Returns\n        -------\n        result : Table\n            The table with the transformed column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the column does not exist.\n\n        \"\"\"\n        if self.has_column(name):\n            items: list = [transformer(item) for item in self.to_rows()]\n            result: Column = Column(pd.Series(items), name)\n            return self.replace_column(name, result)\n        raise UnknownColumnNameError([name])\n\n    def summary(self) -> Table:\n        \"\"\"\n        Return a table with a number of statistical key values.\n\n        Returns\n        -------\n        result : Table\n            The table with statistics.\n        \"\"\"\n\n        columns = self.to_columns()\n        result = pd.DataFrame()\n        statistics = {}\n\n        for column in columns:\n            statistics = {\n                \"max\": column.statistics.max,\n                \"min\": column.statistics.min,\n                \"mean\": column.statistics.mean,\n                \"mode\": column.statistics.mode,\n                \"median\": column.statistics.median,\n                \"sum\": column.statistics.sum,\n                \"variance\": column.statistics.variance,\n                \"standard deviation\": column.statistics.standard_deviation,\n                \"idness\": column.statistics.idness,\n                \"stability\": column.statistics.stability,\n                \"row count\": column.count,\n            }\n            values = []\n\n            for function in statistics.values():\n                try:\n                    values.append(str(function()))\n                except NonNumericColumnError:\n                    values.append(\"-\")\n\n            result = pd.concat([result, pd.DataFrame(values)], axis=1)\n\n        result = pd.concat([pd.DataFrame(list(statistics.keys())), result], axis=1)\n        result.columns = [\"metrics\"] + self.get_column_names()\n\n        return Table(result)\n\n    def __repr__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.get_column_names()\n        return tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.get_column_names()\n        return tmp.__str__()\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.get_column_names()\n\n        with pd.option_context(\n            \"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]\n        ):\n            return display(tmp)\n\n    def slice(\n        self,\n        start: typing.Optional[int] = None,\n        end: typing.Optional[int] = None,\n        step: int = 1,\n    ) -> Table:\n        \"\"\"\n        Slice a part of the table into a new table.\n\n        Parameters\n        ----------\n        start : int\n            The first index of the range to be copied into a new table, None by default.\n        end : int\n            The last index of the range to be copied into a new table, None by default.\n        step : int\n            The step size used to iterate through the table, 1 by default.\n\n        Returns\n        -------\n        result : Table\n            The resulting table.\n\n        Raises\n        -------\n        ValueError\n            If the index is out of bounds.\n        \"\"\"\n\n        if start is None:\n            start = 0\n\n        if end is None:\n            end = self.count_rows()\n\n        if (\n            start < 0\n            or end < 0\n            or start >= self.count_rows()\n            or end > self.count_rows()\n            or end < start\n        ):\n            raise ValueError(\"the given index is out of bounds\")\n\n        new_df = self._data.iloc[start:end:step]\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df)\n\n    def split(self, percentage_in_first: float) -> typing.Tuple[Table, Table]:\n        \"\"\"\n        Split the table into two new tables.\n\n        Parameters\n        -------\n        percentage_in_first : float\n            The desired size of the first table in percentage to the given table.\n\n        Returns\n        -------\n        result : (Table, Table)\n            A tuple containing the two resulting tables. The first table has the specified size, the second table contains the rest of the data.\n\n\n        \"\"\"\n        if percentage_in_first <= 0 or percentage_in_first >= 1:\n            raise ValueError(\"the given percentage is not in range\")\n        return (\n            self.slice(0, round(percentage_in_first * self.count_rows())),\n            self.slice(round(percentage_in_first * self.count_rows())),\n        )\n\n    def shuffle(self) -> Table:\n        \"\"\"\n        Shuffle the table randomly.\n\n        Returns\n        -------\n        result : Table\n            The shuffled Table.\n\n        \"\"\"\n        new_df = self._data.sample(frac=1.0)\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df)",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "schema",
          "types": {
            "kind": "NamedType",
            "name": "TableSchema"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable",
      "name": "TaggedTable",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable",
      "decorators": [],
      "superclasses": [
        "Table"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/feature_vectors@getter",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target_values@getter",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.",
      "docstring": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.\n\nParameters\n----------\ntable : Table\n    The table used to derive the feature and target vectors.\ntarget_column : str\n    Name of the target column.",
      "code": "class TaggedTable(Table):\n    \"\"\"\n    A tagged table is a table that additionally knows which columns are features and which are the target to predict.\n\n    Parameters\n    ----------\n    table : Table\n        The table used to derive the feature and target vectors.\n    target_column : str\n        Name of the target column.\n    \"\"\"\n\n    def __init__(self, table: Table, target_column: str):\n        super().__init__(table._data)\n\n        self._y: Column = table.get_column(target_column)\n        self._X: Table = table.drop_columns([target_column])\n\n    @property\n    def feature_vectors(self) -> Table:\n        return self._X\n\n    @property\n    def target_values(self) -> Column:\n        return self._y\n\n    def __repr__(self) -> str:\n        tmp = self._X.add_column(self._y)\n        header_info = \"Target Column is '\" + self._y.name + \"'\\n\"\n        return header_info + tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._X.add_column(self._y)\n        header_info = \"Target Column is '\" + self._y.name + \"'\\n\"\n        return header_info + tmp.__str__()\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._X.add_column(self._y)\n        header_info = \"Target Column is '\" + self._y.name + \"'\\n\"\n        print(header_info)\n        return tmp._ipython_display_()",
      "instance_attributes": [
        {
          "name": "_y",
          "types": {
            "kind": "NamedType",
            "name": "Column"
          }
        },
        {
          "name": "_X",
          "types": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer",
      "name": "Imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__",
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit",
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform",
        "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit_transform"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Impute the data for a given Table.",
      "docstring": "Impute the data for a given Table.\n\nParameters\n----------\nstrategy : ImputerStrategy\n    The strategy used to impute missing values.",
      "code": "class Imputer:\n    \"\"\"\n    Impute the data for a given Table.\n\n    Parameters\n    ----------\n    strategy : ImputerStrategy\n        The strategy used to impute missing values.\n    \"\"\"\n\n    class Strategy:\n        class Constant(ImputerStrategy):\n            \"\"\"\n            An imputation strategy for imputing missing data with given constant values.\n\n            Parameters\n            ----------\n            value :\n                The given value to impute missing values.\n            \"\"\"\n\n            def __init__(self, value: Any):\n                self._value = value\n\n            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"constant\"\n                imputer.fill_value = self._value\n\n        class Mean(ImputerStrategy):\n            \"\"\"\n            An imputation strategy for imputing missing data with mean values.\n            \"\"\"\n\n            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"mean\"\n\n        class Median(ImputerStrategy):\n            \"\"\"\n            An imputation strategy for imputing missing data with median values.\n            \"\"\"\n\n            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"median\"\n\n        class Mode(ImputerStrategy):\n            \"\"\"\n            An imputation strategy for imputing missing data with mode values.\n            \"\"\"\n\n            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"most_frequent\"\n\n    def __init__(self, strategy: ImputerStrategy):\n        self._imp = SimpleImputer()\n        strategy._augment_imputer(self._imp)\n        self._column_names: list[str] = []\n\n    def fit(self, table: Table, column_names: Optional[list[str]] = None) -> None:\n        \"\"\"\n        Fit the imputer on the dataset.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to learn the imputation values.\n        column_names : Optional[list[str]]\n            An optional list of column names, if the imputer is only supposed to run on specific columns.\n        \"\"\"\n        if column_names is None:\n            column_names = table.schema.get_column_names()\n\n        if self._imp.strategy == \"most_frequent\":\n            for name in column_names:\n                if 1 < len(ColumnStatistics(table.get_column(name)).mode()):\n                    raise IndexError(\n                        \"There are multiple frequent values in a column given for the Imputer\"\n                    )\n\n        self._column_names = column_names\n        indices = [\n            table.schema._get_column_index_by_name(name) for name in self._column_names\n        ]\n        self._imp.fit(table._data[indices])\n\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Impute the missing values on the dataset.\n\n        Parameters\n        ----------\n        table : Table\n            The dataset to be imputed.\n\n        Returns\n        -------\n        table : Table\n            The dataset with missing values imputed by the given strategy.\n        \"\"\"\n        data = table._data.copy()\n        indices = [\n            table.schema._get_column_index_by_name(name) for name in self._column_names\n        ]\n        data[indices] = pd.DataFrame(\n            self._imp.transform(data[indices]), columns=indices\n        )\n        table_imputed = Table(data)\n        table_imputed.schema = table.schema\n        return table_imputed\n\n    def fit_transform(\n        self, table: Table, column_names: Optional[list[str]] = None\n    ) -> Table:\n        \"\"\"\n        Fit the imputer on the dataset and impute the missing values.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to learn the imputation values.\n        column_names : Optional[list[str]]\n            An optional list of column names, if the imputer is only supposed to run on specific columns.\n\n        Returns\n        -------\n        table : Table\n            The dataset with missing values imputed by the given strategy.\n        \"\"\"\n        self.fit(table, column_names)\n        return self.transform(table)",
      "instance_attributes": [
        {
          "name": "_imp",
          "types": {
            "kind": "NamedType",
            "name": "SimpleImputer"
          }
        },
        {
          "name": "_column_names",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/ImputerStrategy",
      "name": "ImputerStrategy",
      "qname": "safeds.data.tabular.transformation._imputer.ImputerStrategy",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._imputer/ImputerStrategy/_augment_imputer"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class ImputerStrategy(ABC):\n    @abstractmethod\n    def _augment_imputer(self, imputer: SimpleImputer) -> None:\n        pass",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder",
      "name": "LabelEncoder",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/__init__",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit_transform",
        "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "The LabelEncoder encodes one or more given columns into labels.",
      "docstring": "The LabelEncoder encodes one or more given columns into labels.",
      "code": "class LabelEncoder:\n    \"\"\"\n    The LabelEncoder encodes one or more given columns into labels.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._is_fitted = 0\n        self._le = preprocessing.LabelEncoder()\n\n    def fit(self, table: Table, column: str) -> None:\n        \"\"\"\n        Fit the label encoder with the values in the table.\n\n        Parameters\n        ----------\n        table : Table\n            The table containing the data used to fit the label encoder.\n        column : str\n            The list of columns supposed to be label-encoded.\n\n        Returns\n        -------\n        None\n            This function does not return any value. It updates the internal state of the label encoder object.\n\n        Raises\n        -------\n        LearningError\n            If the model fitting was unsuccessful.\n        \"\"\"\n        try:\n            self._le.fit(table.keep_columns([column])._data)\n        except exceptions.NotFittedError as exc:\n            raise LearningError(\"\") from exc\n\n    def transform(self, table: Table, column: str) -> Table:\n        \"\"\"\n        Transform the given table to a normalized encoded table.\n\n        Parameters\n        ----------\n        table : Table\n                The table with target values.\n        column : str\n                The name of the column.\n\n        Returns\n        -------\n        result : Table\n            Table with normalized encodings.\n\n        Raises\n        ------\n        NotFittedError\n            If the Model wasn't fitted before transforming.\n        \"\"\"\n        p_df = table._data\n        p_df.columns = table.schema.get_column_names()\n        try:\n            p_df[column] = self._le.transform(p_df[column])\n            return Table(p_df)\n        except Exception as exc:\n            raise NotFittedError from exc\n\n    def fit_transform(self, table: Table, columns: list[str]) -> Table:\n        \"\"\"\n        Label-encode the table with the label encoder.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be transformed.\n        columns : list[str]\n            The list of column names to be encoded.\n\n        Returns\n        -------\n        table : Table\n            The label-encoded table.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n\n        \"\"\"\n        p_df = table._data\n        p_df.columns = table.schema.get_column_names()\n        try:\n            for col in columns:\n                # Fit the LabelEncoder on the Column\n                self._le.fit(p_df[col])\n\n                # transform the column using the trained Label Encoder\n                p_df[col] = self._le.transform(p_df[col])\n            return Table(pandas.DataFrame(p_df))\n        except exceptions.NotFittedError as exc:\n            raise NotFittedError from exc\n\n    def inverse_transform(self, table: Table, column: str) -> Table:\n        \"\"\"\n        Inverse-transform the table back to its original encodings.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be inverse-transformed.\n        column : str\n            The column to be inverse-transformed.\n\n        Returns\n        -------\n        table : Table\n            The inverse-transformed table.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n        \"\"\"\n\n        try:\n            p_df = table._data\n            p_df.columns = table.schema.get_column_names()\n            p_df[column] = self._le.inverse_transform(p_df[column])\n            return Table(p_df)\n        except exceptions.NotFittedError as exc:\n            raise NotFittedError from exc",
      "instance_attributes": [
        {
          "name": "_is_fitted",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_le",
          "types": {
            "kind": "NamedType",
            "name": "LabelEncoder"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder",
      "name": "OneHotEncoder",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/__init__",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit_transform",
        "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "The OneHotEncoder encodes categorical columns to numerical features [0,1] that represent the existence for each value.",
      "docstring": "The OneHotEncoder encodes categorical columns to numerical features [0,1] that represent the existence for each value.",
      "code": "class OneHotEncoder:\n    \"\"\"\n    The OneHotEncoder encodes categorical columns to numerical features [0,1] that represent the existence for each value.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._encoder = OHE_sklearn()\n\n    def fit(self, table: Table, columns: list[str]) -> None:\n        \"\"\"\n        Fit the encoder to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the encoder.\n        columns : list[str]:\n            The list of columns from the table used to fit the encoder.\n\n        Raises\n        ----------\n        LearningError\n            If there was an error during fitting.\n        \"\"\"\n        try:\n            table_k_columns = table.keep_columns(column_names=columns)\n            df = table_k_columns._data\n            df.columns = table_k_columns.schema.get_column_names()\n            self._encoder.fit(df)\n        except exceptions.NotFittedError as exc:\n            raise LearningError(\"\") from exc\n\n    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Transform the data with the trained encoder.\n\n        Parameters\n        ----------\n        table : Table\n            The data to be transformed.\n\n        Returns\n        ----------\n        table : Table\n            The transformed table.\n\n        Raises\n        ----------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n        \"\"\"\n        try:\n            table_k_columns = table.keep_columns(self._encoder.feature_names_in_)\n            df_k_columns = table_k_columns._data\n            df_k_columns.columns = table_k_columns.schema.get_column_names()\n            df_new = pd.DataFrame(self._encoder.transform(df_k_columns).toarray())\n            df_new.columns = self._encoder.get_feature_names_out()\n            df_concat = table._data.copy()\n            df_concat.columns = table.schema.get_column_names()\n            data_new = pd.concat([df_concat, df_new], axis=1).drop(\n                self._encoder.feature_names_in_, axis=1\n            )\n            return Table(data_new)\n        except Exception as exc:\n            raise NotFittedError from exc\n\n    def fit_transform(self, table: Table, columns: list[str]) -> Table:\n        \"\"\"\n        Fit and transform data with a OneHotEncoder.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the encoder and subsequently to be transformed\n        columns : list[str]:\n            The list of columns from the table used to fit the encoder and subsequently to be transformed.\n\n        Returns\n        ----------\n        table : Table\n            The transformed table.\n\n        \"\"\"\n        self.fit(table, columns)\n        return self.transform(table)\n\n    def inverse_transform(self, table: Table) -> Table:\n        \"\"\"\n        Reset a transformed table to its original state.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be inverse-transformed.\n\n        Returns\n        ----------\n        table : Table\n            The inverse-transformed table.\n\n        Raises\n        ----------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n\n        \"\"\"\n        try:\n            data = self._encoder.inverse_transform(\n                table.keep_columns(self._encoder.get_feature_names_out())._data\n            )\n            df = pd.DataFrame(data)\n            df.columns = self._encoder.feature_names_in_\n            new_table = Table(df)\n            for col in table.drop_columns(\n                self._encoder.get_feature_names_out()\n            ).to_columns():\n                new_table = new_table.add_column(col)\n            return new_table\n        except exceptions.NotFittedError as exc:\n            raise NotFittedError from exc",
      "instance_attributes": [
        {
          "name": "_encoder",
          "types": {
            "kind": "NamedType",
            "name": "OneHotEncoder"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder",
      "name": "OrdinalEncoder",
      "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/__init__",
        "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit",
        "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/transform",
        "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit_transform",
        "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/inverse_transform"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This OrdinalEncoder encodes one or more given columns into ordinal numbers. The encoding order must be provided.\n\nParameters\n--------\norder : list[str]\n    The order in which the ordinal encoder encodes the values.",
      "docstring": "This OrdinalEncoder encodes one or more given columns into ordinal numbers. The encoding order must be provided.\n\nParameters\n--------\norder : list[str]\n    The order in which the ordinal encoder encodes the values.",
      "code": "class OrdinalEncoder:\n    \"\"\"\n    This OrdinalEncoder encodes one or more given columns into ordinal numbers. The encoding order must be provided.\n\n    Parameters\n    --------\n    order : list[str]\n        The order in which the ordinal encoder encodes the values.\n    \"\"\"\n\n    def __init__(self, order: list[str]) -> None:\n        self._is_fitted = 0\n        self._oe = preprocessing.OrdinalEncoder(categories=[order])\n        self._order = order\n\n    def fit(self, table: Table, column_name: str) -> None:\n        \"\"\"\n        Fit the ordinal encoder with the values in the given table.\n\n        Parameters\n        ----------\n        table : Table\n            The table containing the data used to fit the ordinal encoder.\n        column_name : str\n            The column which should be ordinal-encoded.\n\n        Returns\n        -------\n        None\n            This function does not return any value. It updates the internal state of the ordinal encoder object.\n\n        Raises\n        -------\n        LearningError\n            If the model could not be fitted correctly.\n        \"\"\"\n\n        p_df = table._data\n        p_df.columns = table.schema.get_column_names()\n        try:\n            self._oe.fit(p_df[[column_name]])\n        except exceptions.NotFittedError as exc:\n            raise exceptions.LearningError(\"\") from exc\n\n    def transform(self, table: Table, column_name: str) -> Table:\n        \"\"\"\n        Transform the given table to an ordinal-encoded table.\n\n        Parameters\n        ----------\n        table : Table\n            The table with target values.\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        table : Table\n            The table with ordinal encodings.\n\n        Raises\n        ------\n        NotFittedError\n            If the model was not fitted before transforming.\n        \"\"\"\n        p_df = table._data.copy()\n        p_df.columns = table.schema.get_column_names()\n        try:\n            p_df[[column_name]] = self._oe.transform(p_df[[column_name]])\n            p_df[column_name] = p_df[column_name].astype(dtype=\"int64\", copy=False)\n            return Table(p_df)\n        except Exception as exc:\n            raise exceptions.NotFittedError from exc\n\n    def fit_transform(self, table: Table, columns: list[str]) -> Table:\n        \"\"\"\n        Oridnal-encode a given table with the given ordinal encoder.\n        The order is provided in the constructor. A new order will not be inferred from other columns.\n\n        Parameters\n        ----------\n        table : Table\n            The table which will be transformed.\n        columns : list[str]\n            The list of column names to be considered while encoding.\n\n        Returns\n        -------\n        table : Table\n            A new Table object which is ordinal-encoded.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder was not fitted before transforming.\n        KeyError\n            If the column does not exist.\n\n        \"\"\"\n        try:\n            for col in columns:\n                # Fit the Ordinal Encoder on the Column\n                self.fit(table, col)\n                # transform the column using the trained Ordinal Encoder\n                table = self.transform(table, col)\n            return table\n        except exceptions.NotFittedError as exc:\n            raise exceptions.NotFittedError from exc\n\n    def inverse_transform(self, table: Table, column_name: str) -> Table:\n        \"\"\"\n        Inverse the transformed table back to original encodings.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be inverse-transformed.\n        column_name : str\n            The column which should be inverse-transformed.\n\n        Returns\n        -------\n        table : Table\n            The inverse-transformed table.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder was not fitted before transforming.\n        \"\"\"\n\n        p_df = table._data.copy()\n        p_df.columns = table.schema.get_column_names()\n        try:\n            p_df[[column_name]] = self._oe.inverse_transform(p_df[[column_name]])\n            return Table(p_df)\n        except exceptions.NotFittedError as exc:\n            raise exceptions.NotFittedError from exc",
      "instance_attributes": [
        {
          "name": "_is_fitted",
          "types": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "name": "_oe",
          "types": {
            "kind": "NamedType",
            "name": "OrdinalEncoder"
          }
        },
        {
          "name": "_order",
          "types": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType",
      "name": "BooleanColumnType",
      "qname": "safeds.data.tabular.typing._column_type.BooleanColumnType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType/is_numeric",
        "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class BooleanColumnType(ColumnType):\n    def is_numeric(self) -> bool:\n        return False\n\n    def __repr__(self) -> str:\n        return \"bool\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType",
      "name": "ColumnType",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_numeric",
        "stdlib/safeds.data.tabular.typing._column_type/ColumnType/from_numpy_dtype"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Base type for Column, stored in TableSchema.",
      "docstring": "Base type for Column, stored in TableSchema.",
      "code": "class ColumnType(ABC):\n    \"\"\"\n    Base type for Column, stored in TableSchema.\n    \"\"\"\n\n    @abstractmethod\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False\n\n    @staticmethod\n    def from_numpy_dtype(_type: np.dtype) -> ColumnType:\n        \"\"\"\n        Return the column type for a given numpy dtype.\n        Parameters\n        ----------\n        _type : numpy.dtype\n\n        Returns\n        -------\n        column_type : ColumnType\n            The ColumnType.\n\n        Raises\n        -------\n        TypeError\n            If an unexpected column type is parsed.\n\n        \"\"\"\n        if _type.kind in (\"u\", \"i\"):\n            return IntColumnType()\n        if _type.kind == \"b\":\n            return BooleanColumnType()\n        if _type.kind == \"f\":\n            return FloatColumnType()\n        if _type.kind in (\"S\", \"U\", \"O\"):\n            return StringColumnType()\n        raise TypeError(\"Unexpected column type\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType",
      "name": "FloatColumnType",
      "qname": "safeds.data.tabular.typing._column_type.FloatColumnType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType/is_numeric",
        "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class FloatColumnType(ColumnType):\n    def is_numeric(self) -> bool:\n        return True\n\n    def __repr__(self) -> str:\n        return \"float\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/IntColumnType",
      "name": "IntColumnType",
      "qname": "safeds.data.tabular.typing._column_type.IntColumnType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/IntColumnType/is_numeric",
        "stdlib/safeds.data.tabular.typing._column_type/IntColumnType/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class IntColumnType(ColumnType):\n    def is_numeric(self) -> bool:\n        return True\n\n    def __repr__(self) -> str:\n        return \"int\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType",
      "name": "OptionalColumnType",
      "qname": "safeds.data.tabular.typing._column_type.OptionalColumnType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType/is_numeric",
        "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class OptionalColumnType(ColumnType):\n    _type: ColumnType\n\n    def is_numeric(self) -> bool:\n        return self._type.is_numeric()\n\n    def __repr__(self) -> str:\n        return f\"optional({self._type.__repr__()})\"",
      "instance_attributes": [
        {
          "name": "_type",
          "types": {
            "kind": "NamedType",
            "name": "ColumnType"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/StringColumnType",
      "name": "StringColumnType",
      "qname": "safeds.data.tabular.typing._column_type.StringColumnType",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [
        "ColumnType"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.typing._column_type/StringColumnType/is_numeric",
        "stdlib/safeds.data.tabular.typing._column_type/StringColumnType/__repr__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class StringColumnType(ColumnType):\n    def is_numeric(self) -> bool:\n        return False\n\n    def __repr__(self) -> str:\n        return \"string\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema",
      "name": "TableSchema",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema",
      "decorators": [
        "dataclass"
      ],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__init__",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/has_column",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_type_of_column",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_get_column_index_by_name",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_from_dataframe",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_column_names",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__str__",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__repr__",
        "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__eq__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Store column names and corresponding data types for a table.",
      "docstring": "Store column names and corresponding data types for a table.\n\nParameters\n----------\nschema : dict[str, ColumnType]\n    Map from column names to data types.",
      "code": "class TableSchema:\n    \"\"\"\n    Store column names and corresponding data types for a table.\n\n    Parameters\n    ----------\n    schema : dict[str, ColumnType]\n        Map from column names to data types.\n    \"\"\"\n\n    _schema: dict[str, ColumnType]\n\n    def __init__(self, schema: dict[str, ColumnType]):\n        self._schema = dict(schema)  # Defensive copy\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the schema contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the schema contains the column.\n        \"\"\"\n        return column_name in self._schema\n\n    def get_type_of_column(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n        return self._schema[column_name]\n\n    def _get_column_index_by_name(self, column_name: str) -> int:\n        \"\"\"\n         Return the index of the column with specified column name.\n\n         Parameters\n         ----------\n         column_name : str\n             The name of the column.\n\n         Returns\n         -------\n        index : int\n             The index of the column.\n        \"\"\"\n\n        return list(self._schema.keys()).index(column_name)\n\n    @staticmethod\n    def _from_dataframe(dataframe: pd.DataFrame) -> TableSchema:\n        \"\"\"\n        Construct a TableSchema from a Dataframe. This function is not supposed to be exposed to the user.\n\n        Parameters\n        ----------\n        dataframe : pd.Dataframe\n            The Dataframe used to construct the TableSchema.\n\n        Returns\n        -------\n        _from_dataframe: TableSchema\n            The constructed TableSchema.\n\n        \"\"\"\n\n        names = dataframe.columns\n        types = (ColumnType.from_numpy_dtype(dtype) for dtype in dataframe.dtypes)\n\n        return TableSchema(dict(zip(names, types)))\n\n    def get_column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names saved in this schema.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n        \"\"\"\n        return list(self._schema.keys())\n\n    def __str__(self) -> str:\n        \"\"\"\n        Return a print-string for the TableSchema.\n\n        Returns\n        -------\n        output_string : str\n            The string.\n        \"\"\"\n        column_count = len(self._schema)\n        output_string = f\"TableSchema:\\nColumn Count: {column_count}\\nColumns:\\n\"\n        for column_name, data_type in self._schema.items():\n            output_string += f\"    {column_name}: {data_type}\\n\"\n        return output_string\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    def __eq__(self, o: object) -> bool:\n        if not isinstance(o, TableSchema):\n            return NotImplemented\n        if self is o:\n            return True\n        return self._schema == o._schema",
      "instance_attributes": [
        {
          "name": "_schema",
          "types": {
            "kind": "NamedType",
            "name": "dict"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/ColumnLengthMismatchError",
      "name": "ColumnLengthMismatchError",
      "qname": "safeds.exceptions._data_exceptions.ColumnLengthMismatchError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/ColumnLengthMismatchError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when the lengths of two or more columns do not match.",
      "docstring": "Exception raised when the lengths of two or more columns do not match.",
      "code": "class ColumnLengthMismatchError(Exception):\n    \"\"\"\n    Exception raised when the lengths of two or more columns do not match.\n    \"\"\"\n\n    def __init__(self, column_info: str):\n        super().__init__(f\"The length of at least one column differs: \\n{column_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/ColumnSizeError",
      "name": "ColumnSizeError",
      "qname": "safeds.exceptions._data_exceptions.ColumnSizeError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/ColumnSizeError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to use a column of unsupported size.",
      "docstring": "Exception raised for trying to use a column of unsupported size.\n\nParameters\n----------\nexpected_size : str\n    The expected size of the column as an expression (e.g. 2, >0, !=0).\nactual_size : str\n    The actual size of the column as an expression (e.g. 2, >0, !=0).",
      "code": "class ColumnSizeError(Exception):\n    \"\"\"\n    Exception raised for trying to use a column of unsupported size.\n\n    Parameters\n    ----------\n    expected_size : str\n        The expected size of the column as an expression (e.g. 2, >0, !=0).\n    actual_size : str\n        The actual size of the column as an expression (e.g. 2, >0, !=0).\n    \"\"\"\n\n    def __init__(self, expected_size: str, actual_size: str):\n        super().__init__(\n            f\"Expected a column of size {expected_size} but got column of size {actual_size}.\"\n        )",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/DuplicateColumnNameError",
      "name": "DuplicateColumnNameError",
      "qname": "safeds.exceptions._data_exceptions.DuplicateColumnNameError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/DuplicateColumnNameError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to modify a table resulting in a duplicate column name.",
      "docstring": "Exception raised for trying to modify a table resulting in a duplicate column name.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column that resulted in a duplicate.",
      "code": "class DuplicateColumnNameError(Exception):\n    \"\"\"\n    Exception raised for trying to modify a table resulting in a duplicate column name.\n\n    Parameters\n    ----------\n    column_name : str\n        The name of the column that resulted in a duplicate.\n    \"\"\"\n\n    def __init__(self, column_name: str):\n        super().__init__(f\"Column '{column_name}' already exists.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/IndexOutOfBoundsError",
      "name": "IndexOutOfBoundsError",
      "qname": "safeds.exceptions._data_exceptions.IndexOutOfBoundsError",
      "decorators": [],
      "superclasses": [
        "IndexError"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/IndexOutOfBoundsError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an element by an index that does not exist in the underlying data.",
      "docstring": "Exception raised for trying to access an element by an index that does not exist in the underlying data.\n\nParameters\n----------\nindex : int\n    The wrongly used index.",
      "code": "class IndexOutOfBoundsError(IndexError):\n    \"\"\"\n    Exception raised for trying to access an element by an index that does not exist in the underlying data.\n\n    Parameters\n    ----------\n    index : int\n        The wrongly used index.\n    \"\"\"\n\n    def __init__(self, index: int):\n        super().__init__(f\"There is no element at index '{index}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/MissingDataError",
      "name": "MissingDataError",
      "qname": "safeds.exceptions._data_exceptions.MissingDataError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/MissingDataError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised if a function is not given enough data to succeed.",
      "docstring": "Exception raised if a function is not given enough data to succeed.",
      "code": "class MissingDataError(Exception):\n    \"\"\"\n    Exception raised if a function is not given enough data to succeed.\n    \"\"\"\n\n    def __init__(self, missing_data_info: str):\n        super().__init__(f\"The function is missing data: \\n{missing_data_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/MissingSchemaError",
      "name": "MissingSchemaError",
      "qname": "safeds.exceptions._data_exceptions.MissingSchemaError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/MissingSchemaError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a required schema is missing.",
      "docstring": "Exception raised when a required schema is missing.",
      "code": "class MissingSchemaError(Exception):\n    \"\"\"\n    Exception raised when a required schema is missing.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Failed because a required schema is missing.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/NonNumericColumnError",
      "name": "NonNumericColumnError",
      "qname": "safeds.exceptions._data_exceptions.NonNumericColumnError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/NonNumericColumnError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "docstring": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "code": "class NonNumericColumnError(Exception):\n    \"\"\"\n    Exception raised for trying to do numerical operations on a non-numerical column.\n    \"\"\"\n\n    def __init__(self, column_info: str) -> None:\n        super().__init__(\n            f\"Tried to do a numerical operation on one or multiple non numerical Columns: \\n{column_info}\"\n        )",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/SchemaMismatchError",
      "name": "SchemaMismatchError",
      "qname": "safeds.exceptions._data_exceptions.SchemaMismatchError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/SchemaMismatchError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when schemas are unequal.",
      "docstring": "Exception raised when schemas are unequal.",
      "code": "class SchemaMismatchError(Exception):\n    \"\"\"\n    Exception raised when schemas are unequal.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Failed because at least two schemas didn't match.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/UnknownColumnNameError",
      "name": "UnknownColumnNameError",
      "qname": "safeds.exceptions._data_exceptions.UnknownColumnNameError",
      "decorators": [],
      "superclasses": [
        "KeyError"
      ],
      "methods": [
        "stdlib/safeds.exceptions._data_exceptions/UnknownColumnNameError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an invalid column name.",
      "docstring": "Exception raised for trying to access an invalid column name.\n\nParameters\n----------\ncolumn_names : list[str]\n    The name of the column that was tried to be accessed.",
      "code": "class UnknownColumnNameError(KeyError):\n    \"\"\"\n    Exception raised for trying to access an invalid column name.\n\n    Parameters\n    ----------\n    column_names : list[str]\n        The name of the column that was tried to be accessed.\n    \"\"\"\n\n    def __init__(self, column_names: list[str]):\n        super().__init__(f\"Could not find column(s) '{', '.join(column_names)}'\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._learning_exceptions/LearningError",
      "name": "LearningError",
      "qname": "safeds.exceptions._learning_exceptions.LearningError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._learning_exceptions/LearningError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when an error occurred while training a model.",
      "docstring": "Exception raised when an error occurred while training a model.\n\nParameters\n----------\nreason: str | None\n    The reason for the error.",
      "code": "class LearningError(Exception):\n    \"\"\"\n    Exception raised when an error occurred while training a model.\n\n    Parameters\n    ----------\n    reason: str | None\n        The reason for the error.\n    \"\"\"\n\n    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while learning\")\n        else:\n            super().__init__(f\"Error occurred while learning: {reason}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._learning_exceptions/NotFittedError",
      "name": "NotFittedError",
      "qname": "safeds.exceptions._learning_exceptions.NotFittedError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._learning_exceptions/NotFittedError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a model is used before fitting it.",
      "docstring": "Exception raised when a model is used before fitting it.",
      "code": "class NotFittedError(Exception):\n    \"\"\"\n    Exception raised when a model is used before fitting it.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Model is not fitted, please fit it before using it\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.exceptions._learning_exceptions/PredictionError",
      "name": "PredictionError",
      "qname": "safeds.exceptions._learning_exceptions.PredictionError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.exceptions._learning_exceptions/PredictionError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when an error occurred while prediction a target vector using a model.",
      "docstring": "Exception raised when an error occurred while prediction a target vector using a model.\n\nParameters\n----------\nreason: str | None\n    The reason for the error.",
      "code": "class PredictionError(Exception):\n    \"\"\"\n    Exception raised when an error occurred while prediction a target vector using a model.\n\n    Parameters\n    ----------\n    reason: str | None\n        The reason for the error.\n    \"\"\"\n\n    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while predicting\")\n        else:\n            super().__init__(f\"Error occurred while predicting: {reason}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost",
      "name": "AdaBoost",
      "qname": "safeds.ml.classification._ada_boost.AdaBoost",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._ada_boost/AdaBoost/__init__",
        "stdlib/safeds.ml.classification._ada_boost/AdaBoost/fit",
        "stdlib/safeds.ml.classification._ada_boost/AdaBoost/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Ada Boost classification. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements Ada Boost classification. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "code": "class AdaBoost(Classifier):\n    \"\"\"\n    This class implements Ada Boost classification. It is used as a classifier model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._classification = sk_AdaBoostClassifier()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_classification",
          "types": {
            "kind": "NamedType",
            "name": "AdaBoostClassifier"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classification._classifier/Classifier",
      "name": "Classifier",
      "qname": "safeds.ml.classification._classifier.Classifier",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._classifier/Classifier/fit",
        "stdlib/safeds.ml.classification._classifier/Classifier/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Classifier(ABC):\n    @abstractmethod\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n\n    @abstractmethod\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree",
      "name": "DecisionTree",
      "qname": "safeds.ml.classification._decision_tree.DecisionTree",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._decision_tree/DecisionTree/__init__",
        "stdlib/safeds.ml.classification._decision_tree/DecisionTree/fit",
        "stdlib/safeds.ml.classification._decision_tree/DecisionTree/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements decision tree regression. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements decision tree regression. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "code": "class DecisionTree(Classifier):\n    \"\"\"\n    This class implements decision tree regression. It is used as a classifier model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._classification = sk_DecisionTreeClassifier()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_classification",
          "types": {
            "kind": "NamedType",
            "name": "DecisionTreeClassifier"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting",
      "name": "GradientBoosting",
      "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/__init__",
        "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/fit",
        "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements gradient boosting classification. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements gradient boosting classification. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "code": "class GradientBoosting(Classifier):\n    \"\"\"\n    This class implements gradient boosting classification. It is used as a classifier model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._classification = GradientBoostingClassifier()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )\n\n    # noinspection PyProtectedMember\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_classification",
          "types": {
            "kind": "NamedType",
            "name": "GradientBoostingClassifier"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors",
      "name": "KNearestNeighbors",
      "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/__init__",
        "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/fit",
        "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements K-nearest-neighbors classifier. It can only be trained on a tagged table.",
      "docstring": "This class implements K-nearest-neighbors classifier. It can only be trained on a tagged table.\n\nParameters\n----------\nn_neighbors : int\n    The number of neighbors to be interpolated with. Has to be less than or equal to the sample size.",
      "code": "class KNearestNeighbors(Classifier):\n    \"\"\"\n    This class implements K-nearest-neighbors classifier. It can only be trained on a tagged table.\n\n    Parameters\n    ----------\n    n_neighbors : int\n        The number of neighbors to be interpolated with. Has to be less than or equal to the sample size.\n    \"\"\"\n\n    def __init__(self, n_neighbors: int) -> None:\n        self._classification = KNeighborsClassifier(n_jobs=-1, n_neighbors=n_neighbors)\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_classification",
          "types": {
            "kind": "NamedType",
            "name": "KNeighborsClassifier"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression",
      "name": "LogisticRegression",
      "qname": "safeds.ml.classification._logistic_regression.LogisticRegression",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/__init__",
        "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/fit",
        "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements regularized logistic regression. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements regularized logistic regression. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "code": "class LogisticRegression(Classifier):\n    \"\"\"\n    This class implements regularized logistic regression. It is used as a classifier model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._classification = sk_LogisticRegression(n_jobs=-1)\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_classification",
          "types": {
            "kind": "NamedType",
            "name": "LogisticRegression"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.classification._random_forest/RandomForest",
      "name": "RandomForest",
      "qname": "safeds.ml.classification._random_forest.RandomForest",
      "decorators": [],
      "superclasses": [
        "Classifier"
      ],
      "methods": [
        "stdlib/safeds.ml.classification._random_forest/RandomForest/__init__",
        "stdlib/safeds.ml.classification._random_forest/RandomForest/fit",
        "stdlib/safeds.ml.classification._random_forest/RandomForest/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements the Random Forest classification. It can only be trained on a tagged table.",
      "docstring": "This class implements the Random Forest classification. It can only be trained on a tagged table.",
      "code": "class RandomForest(Classifier):\n    \"\"\"\n    This class implements the Random Forest classification. It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._classification = RandomForestClassifier(n_jobs=-1)\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_classification",
          "types": {
            "kind": "NamedType",
            "name": "RandomForestClassifier"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost",
      "name": "AdaBoost",
      "qname": "safeds.ml.regression._ada_boost.AdaBoost",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._ada_boost/AdaBoost/__init__",
        "stdlib/safeds.ml.regression._ada_boost/AdaBoost/fit",
        "stdlib/safeds.ml.regression._ada_boost/AdaBoost/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Ada Boost regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements Ada Boost regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class AdaBoost(Regressor):\n    \"\"\"\n    This class implements Ada Boost regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = sk_AdaBoostRegressor()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "AdaBoostRegressor"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree",
      "name": "DecisionTree",
      "qname": "safeds.ml.regression._decision_tree.DecisionTree",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._decision_tree/DecisionTree/__init__",
        "stdlib/safeds.ml.regression._decision_tree/DecisionTree/fit",
        "stdlib/safeds.ml.regression._decision_tree/DecisionTree/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Decision Tree regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements Decision Tree regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class DecisionTree(Regressor):\n    \"\"\"\n    This class implements Decision Tree regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = sk_DecisionTreeRegressor()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name:  Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "DecisionTreeRegressor"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression",
      "name": "ElasticNetRegression",
      "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/__init__",
        "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/fit",
        "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements elastic net regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements elastic net regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class ElasticNetRegression(Regressor):\n    \"\"\"\n    This class implements elastic net regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = sk_ElasticNet()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "ElasticNet"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting",
      "name": "GradientBoosting",
      "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/__init__",
        "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/fit",
        "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements gradient boosting regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements gradient boosting regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class GradientBoosting(Regressor):\n    \"\"\"\n    This class implements gradient boosting regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = GradientBoostingRegressor()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n\n        ----------\n        tagged_table : SupervisedDataset\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    # noinspection PyProtectedMember\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "GradientBoostingRegressor"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors",
      "name": "KNearestNeighbors",
      "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/__init__",
        "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/fit",
        "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements K-nearest-neighbors regressor. It can only be trained on a tagged table.",
      "docstring": "This class implements K-nearest-neighbors regressor. It can only be trained on a tagged table.\n\nParameters\n----------\nn_neighbors : int\n    The number of neighbors to be interpolated with. Has to be less than or equal than the sample size.",
      "code": "class KNearestNeighbors(Regressor):\n    \"\"\"\n    This class implements K-nearest-neighbors regressor. It can only be trained on a tagged table.\n\n    Parameters\n    ----------\n    n_neighbors : int\n        The number of neighbors to be interpolated with. Has to be less than or equal than the sample size.\n    \"\"\"\n\n    def __init__(self, n_neighbors: int) -> None:\n        self._regression = KNeighborsRegressor(n_neighbors)\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "KNeighborsRegressor"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression",
      "name": "LassoRegression",
      "qname": "safeds.ml.regression._lasso_regression.LassoRegression",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/__init__",
        "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/fit",
        "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements lasso regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements lasso regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class LassoRegression(Regressor):\n    \"\"\"\n    This class implements lasso regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = sk_Lasso()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "Lasso"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression",
      "name": "LinearRegression",
      "qname": "safeds.ml.regression._linear_regression.LinearRegression",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._linear_regression/LinearRegression/__init__",
        "stdlib/safeds.ml.regression._linear_regression/LinearRegression/fit",
        "stdlib/safeds.ml.regression._linear_regression/LinearRegression/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements linear regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements linear regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class LinearRegression(Regressor):\n    \"\"\"\n    This class implements linear regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = sk_LinearRegression(n_jobs=-1)\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "LinearRegression"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._random_forest/RandomForest",
      "name": "RandomForest",
      "qname": "safeds.ml.regression._random_forest.RandomForest",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._random_forest/RandomForest/__init__",
        "stdlib/safeds.ml.regression._random_forest/RandomForest/fit",
        "stdlib/safeds.ml.regression._random_forest/RandomForest/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Random Forest regression. It can only be trained on a tagged table.",
      "docstring": "This class implements Random Forest regression. It can only be trained on a tagged table.",
      "code": "class RandomForest(Regressor):\n    \"\"\"\n    This class implements Random Forest regression. It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = RandomForestRegressor(n_jobs=-1)\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "RandomForestRegressor"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.ml.regression._regressor/Regressor",
      "name": "Regressor",
      "qname": "safeds.ml.regression._regressor.Regressor",
      "decorators": [],
      "superclasses": [
        "ABC"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._regressor/Regressor/fit",
        "stdlib/safeds.ml.regression._regressor/Regressor/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "class Regressor(ABC):\n    @abstractmethod\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n\n    @abstractmethod\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression",
      "name": "RidgeRegression",
      "qname": "safeds.ml.regression._ridge_regression.RidgeRegression",
      "decorators": [],
      "superclasses": [
        "Regressor"
      ],
      "methods": [
        "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/__init__",
        "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/fit",
        "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/predict"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements ridge regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "This class implements ridge regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "code": "class RidgeRegression(Regressor):\n    \"\"\"\n    This class implements ridge regression. It is used as a regression model.\n    It can only be trained on a tagged table.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._regression = sk_Ridge()\n        self.target_name = \"\"\n\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)\n\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )",
      "instance_attributes": [
        {
          "name": "_regression",
          "types": {
            "kind": "NamedType",
            "name": "Ridge"
          }
        },
        {
          "name": "target_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ]
    }
  ],
  "functions": [
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._column.Column.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._column.Column.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Column):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._data.equals(other._data) and self.name == other.name"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__",
      "name": "__getitem__",
      "qname": "safeds.data.tabular.containers._column.Column.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._column.Column.__getitem__.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, index: int) -> Any:\n        return self.get_value(index)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._column.Column.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._column.Column.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/name",
          "name": "name",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, data: typing.Iterable, name: str) -> None:\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        self._name: str = name\n        self._type: ColumnType = ColumnType.from_numpy_dtype(self._data.dtype)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__iter__",
      "name": "__iter__",
      "qname": "safeds.data.tabular.containers._column.Column.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__iter__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__len__",
      "name": "__len__",
      "qname": "safeds.data.tabular.containers._column.Column.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__len__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self) -> int:\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._column.Column.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._column.Column.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values",
      "name": "_count_missing_values",
      "qname": "safeds.data.tabular.containers._column.Column._count_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column._count_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of null values in the column.",
      "docstring": "Return the number of null values in the column.\n\nReturns\n-------\ncount : int\n    The number of null values.",
      "code": "    def _count_missing_values(self) -> int:\n        \"\"\"\n        Return the number of null values in the column.\n\n        Returns\n        -------\n        count : int\n            The number of null values.\n        \"\"\"\n        return self._data.isna().sum()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._column.Column._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n\n        with pd.option_context(\n            \"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]\n        ):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/all",
      "name": "all",
      "qname": "safeds.data.tabular.containers._column.Column.all",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/all/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.all.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/all/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.all.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if all values have a given property.",
      "docstring": "Check if all values have a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if all match.",
      "code": "    def all(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if all values have a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if all match.\n\n        \"\"\"\n        for value in self._data:\n            if not predicate(value):\n                return False\n        return True"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/any",
      "name": "any",
      "qname": "safeds.data.tabular.containers._column.Column.any",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/any/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.any.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/any/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.any.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if any value has a given property.",
      "docstring": "Check if any value has a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if any match.",
      "code": "    def any(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if any value has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if any match.\n\n        \"\"\"\n        for value in self._data:\n            if predicate(value):\n                return True\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with",
      "name": "correlation_with",
      "qname": "safeds.data.tabular.containers._column.Column.correlation_with",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.correlation_with.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with/other_column",
          "name": "other_column",
          "qname": "safeds.data.tabular.containers._column.Column.correlation_with.other_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate Pearson correlation between this and another column. Both columns have to be numerical.",
      "docstring": "Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\nReturns\n-------\ncorrelation : float\n    Correlation between the two columns.\n\nRaises\n------\nTypeError\n    If one of the columns is not numerical.",
      "code": "    def correlation_with(self, other_column: Column) -> float:\n        \"\"\"\n        Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\n        Returns\n        -------\n        correlation : float\n            Correlation between the two columns.\n\n        Raises\n        ------\n        TypeError\n            If one of the columns is not numerical.\n        \"\"\"\n        if not self._type.is_numeric() or not other_column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"Columns must be numerical. {self.name} is {self._type}, \"\n                f\"{other_column.name} is {other_column._type}.\"\n            )\n        if self._data.size != other_column._data.size:\n            raise ColumnLengthMismatchError(\n                f\"{self.name} is of size {self._data.size}, \"\n                f\"{other_column.name} is of size {other_column._data.size}.\"\n            )\n        return self._data.corr(other_column._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/count",
      "name": "count",
      "qname": "safeds.data.tabular.containers._column.Column.count",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/count/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of elements in the column.",
      "docstring": "Return the number of elements in the column.\n\nReturns\n-------\ncount : int\n    The number of elements.",
      "code": "    def count(self) -> int:\n        \"\"\"\n        Return the number of elements in the column.\n\n        Returns\n        -------\n        count : int\n            The number of elements.\n        \"\"\"\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values",
      "name": "get_unique_values",
      "qname": "safeds.data.tabular.containers._column.Column.get_unique_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.get_unique_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all unique values in the column.",
      "docstring": "Return a list of all unique values in the column.\n\nReturns\n-------\nunique_values : list[any]\n    List of unique values in the column.",
      "code": "    def get_unique_values(self) -> list[typing.Any]:\n        \"\"\"\n        Return a list of all unique values in the column.\n\n        Returns\n        -------\n        unique_values : list[any]\n            List of unique values in the column.\n        \"\"\"\n        return list(self._data.unique())"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value",
      "name": "get_value",
      "qname": "safeds.data.tabular.containers._column.Column.get_value",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.get_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._column.Column.get_value.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Index of requested element."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return column value at specified index, starting at 0.",
      "docstring": "Return column value at specified index, starting at 0.\n\nParameters\n----------\nindex : int\n    Index of requested element.\n\nReturns\n-------\nvalue\n    Value at index in column.\n\nRaises\n------\nIndexOutOfBoundsError\n    If the given index does not exist in the column.",
      "code": "    def get_value(self, index: int) -> Any:\n        \"\"\"\n        Return column value at specified index, starting at 0.\n\n        Parameters\n        ----------\n        index : int\n            Index of requested element.\n\n        Returns\n        -------\n        value\n            Value at index in column.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If the given index does not exist in the column.\n        \"\"\"\n        if index < 0 or index >= self._data.size:\n            raise IndexOutOfBoundsError(index)\n\n        return self._data[index]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values",
      "name": "has_missing_values",
      "qname": "safeds.data.tabular.containers._column.Column.has_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.has_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the column has missing values.",
      "docstring": "Return whether the column has missing values.\n\nReturns\n-------\nmissing_values_exist : bool\n    True if missing values exist.",
      "code": "    def has_missing_values(self) -> bool:\n        \"\"\"\n        Return whether the column has missing values.\n\n        Returns\n        -------\n        missing_values_exist : bool\n            True if missing values exist.\n        \"\"\"\n        return self.any(\n            lambda value: value is None\n            or (isinstance(value, Number) and np.isnan(value))\n        )"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio",
      "name": "missing_value_ratio",
      "qname": "safeds.data.tabular.containers._column.Column.missing_value_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.missing_value_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the ratio of null values to the total number of elements in the column",
      "docstring": "Return the ratio of null values to the total number of elements in the column\n\nReturns\n-------\nratio : float\n    The ratio of null values to the total number of elements in the column.",
      "code": "    def missing_value_ratio(self) -> float:\n        \"\"\"\n        Return the ratio of null values to the total number of elements in the column\n\n        Returns\n        -------\n        ratio : float\n            The ratio of null values to the total number of elements in the column.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._count_missing_values() / self._data.size"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/name@getter",
      "name": "name",
      "qname": "safeds.data.tabular.containers._column.Column.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/name@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the name of the column.",
      "docstring": "Return the name of the column.\n\nReturns\n-------\nname : str\n    The name of the column.",
      "code": "    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of the column.\n\n        Returns\n        -------\n        name : str\n            The name of the column.\n        \"\"\"\n        return self._name"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/none",
      "name": "none",
      "qname": "safeds.data.tabular.containers._column.Column.none",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/none/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.none.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/none/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.none.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if no values has a given property.",
      "docstring": "Check if no values has a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if none match.",
      "code": "    def none(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if no values has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if none match.\n\n        \"\"\"\n        for value in self._data:\n            if predicate(value):\n                return False\n        return True"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/statistics@getter",
      "name": "statistics",
      "qname": "safeds.data.tabular.containers._column.Column.statistics",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/statistics@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.statistics.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def statistics(self) -> ColumnStatistics:\n        return ColumnStatistics(self)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/type@getter",
      "name": "type",
      "qname": "safeds.data.tabular.containers._column.Column.type",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/type@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the column.",
      "docstring": "Return the type of the column.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.",
      "code": "    @property\n    def type(self) -> ColumnType:\n        \"\"\"\n        Return the type of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n        \"\"\"\n        return self._type"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/__init__/column",
          "name": "column",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.__init__.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, column: Column):\n        self._column = column"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/idness",
      "name": "idness",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.idness",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/idness/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.idness.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate the idness of this column, which we define as\n\n$$\n\\frac{\\text{number of different values}}{\\text{number of rows}}\n$$",
      "docstring": "Calculate the idness of this column, which we define as\n\n$$\n\\frac{\\text{number of different values}}{\\text{number of rows}}\n$$\n\nReturns\n-------\nidness : float\n    The idness of the column.\n\nRaises\n------\nColumnSizeError\n    If this column is empty.",
      "code": "    def idness(self) -> float:\n        \"\"\"\n        Calculate the idness of this column, which we define as\n\n        $$\n        \\\\frac{\\\\text{number of different values}}{\\\\text{number of rows}}\n        $$\n\n        Returns\n        -------\n        idness : float\n            The idness of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If this column is empty.\n        \"\"\"\n        if self._column._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._column._data.nunique() / self._column._data.size"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/max",
      "name": "max",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.max",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/max/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.max.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the maximum value of the column. The column has to be numerical.",
      "docstring": "Return the maximum value of the column. The column has to be numerical.\n\nReturns\n-------\nmax : float\n    The maximum value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def max(self) -> float:\n        \"\"\"\n        Return the maximum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        max : float\n            The maximum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.max()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/mean",
      "name": "mean",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.mean",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/mean/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.mean.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mean value of the column. The column has to be numerical.",
      "docstring": "Return the mean value of the column. The column has to be numerical.\n\nReturns\n-------\nmean : float\n    The mean value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def mean(self) -> float:\n        \"\"\"\n        Return the mean value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        mean : float\n            The mean value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.mean()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/median",
      "name": "median",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.median",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/median/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.median.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the median value of the column. The column has to be numerical.",
      "docstring": "Return the median value of the column. The column has to be numerical.\n\nReturns\n-------\nmedian : float\n    The median value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def median(self) -> float:\n        \"\"\"\n        Return the median value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        median : float\n            The median value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.median()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/min",
      "name": "min",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.min",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/min/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.min.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the minimum value of the column. The column has to be numerical.",
      "docstring": "Return the minimum value of the column. The column has to be numerical.\n\nReturns\n-------\nmin : float\n    The minimum value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def min(self) -> float:\n        \"\"\"\n        Return the minimum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        min : float\n            The minimum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.min()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/mode",
      "name": "mode",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.mode",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/mode/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mode of the column.",
      "docstring": "Return the mode of the column.\n\nReturns\n-------\nList :\n    Returns a list with the most common values.",
      "code": "    def mode(self) -> Any:\n        \"\"\"\n        Return the mode of the column.\n\n        Returns\n        -------\n        List :\n            Returns a list with the most common values.\n        \"\"\"\n        return self._column._data.mode().tolist()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/stability",
      "name": "stability",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.stability",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/stability/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.stability.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate the stability of this column, which we define as\n\n$$\n\\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n$$",
      "docstring": "Calculate the stability of this column, which we define as\n\n$$\n\\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n$$\n\nReturns\n-------\nstability : float\n    The stability of the column.\n\nRaises\n------\nColumnSizeError\n    If the column is empty.",
      "code": "    def stability(self) -> float:\n        \"\"\"\n        Calculate the stability of this column, which we define as\n\n        $$\n        \\\\frac{\\\\text{number of occurrences of most common non-null value}}{\\\\text{number of non-null values}}\n        $$\n\n        Returns\n        -------\n        stability : float\n            The stability of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If the column is empty.\n        \"\"\"\n        if self._column._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return (\n            self._column._data.value_counts()[self._column.statistics.mode()[0]]\n            / self._column._data.count()\n        )"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/standard_deviation",
      "name": "standard_deviation",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.standard_deviation",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/standard_deviation/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.standard_deviation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the standard deviation of the column. The column has to be numerical.",
      "docstring": "Return the standard deviation of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The standard deviation of all values.\n\nRaises\n---\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def standard_deviation(self) -> float:\n        \"\"\"\n        Return the standard deviation of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The standard deviation of all values.\n\n        Raises\n        ---\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self._column.type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.std()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/sum",
      "name": "sum",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.sum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/sum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.sum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the sum of the column. The column has to be numerical.",
      "docstring": "Return the sum of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The sum of all values.\n\nRaises\n---\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def sum(self) -> float:\n        \"\"\"\n        Return the sum of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The sum of all values.\n\n        Raises\n        ---\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self._column.type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n        return self._column._data.sum()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/variance",
      "name": "variance",
      "qname": "safeds.data.tabular.containers._column.ColumnStatistics.variance",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/ColumnStatistics/variance/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.ColumnStatistics.variance.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the variance of the column. The column has to be numerical.",
      "docstring": "Return the variance of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The variance of all values.\n\nRaises\n---\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def variance(self) -> float:\n        \"\"\"\n        Return the variance of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The variance of all values.\n\n        Raises\n        ---\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self._column.type.is_numeric():\n            raise NonNumericColumnError(\n                f\"{self._column.name} is of type {self._column._type}.\"\n            )\n\n        return self._column._data.var()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._row.Row.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._row.Row.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._data.equals(other._data) and self.schema == other.schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__",
      "name": "__getitem__",
      "qname": "safeds.data.tabular.containers._row.Row.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.__getitem__.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, column_name: str) -> Any:\n        return self.get_value(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._row.Row.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._row.Row.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.schema",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __init__(self, data: typing.Iterable, schema: TableSchema):\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        self.schema: TableSchema = schema\n        self._data = self._data.reset_index(drop=True)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__iter__",
      "name": "__iter__",
      "qname": "safeds.data.tabular.containers._row.Row.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__iter__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __iter__(self) -> typing.Iterator[Any]:\n        return iter(self.get_column_names())"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__len__",
      "name": "__len__",
      "qname": "safeds.data.tabular.containers._row.Row.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__len__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self) -> int:\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._row.Row.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.to_frame().T\n        tmp.columns = self.get_column_names()\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._row.Row.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.to_frame().T\n        tmp.columns = self.get_column_names()\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._row.Row._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame().T\n        tmp.columns = self.get_column_names()\n\n        with pd.option_context(\n            \"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]\n        ):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/count",
      "name": "count",
      "qname": "safeds.data.tabular.containers._row.Row.count",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/count/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.count.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns in this row.",
      "docstring": "Return the number of columns in this row.\n\nReturns\n-------\ncount : int\n    The number of columns.",
      "code": "    def count(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        count : int\n            The number of columns.\n        \"\"\"\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_names",
      "name": "get_column_names",
      "qname": "safeds.data.tabular.containers._row.Row.get_column_names",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_names/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names saved in this schema.\nAlias for self.schema.get_column_names() -> list[str].",
      "docstring": "Return a list of all column names saved in this schema.\nAlias for self.schema.get_column_names() -> list[str].\n\nReturns\n-------\ncolumn_names : list[str]\n    The column names.",
      "code": "    def get_column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names saved in this schema.\n        Alias for self.schema.get_column_names() -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n        \"\"\"\n        return self.schema.get_column_names()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_type_of_column",
      "name": "get_type_of_column",
      "qname": "safeds.data.tabular.containers._row.Row.get_type_of_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_type_of_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_type_of_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_type_of_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.get_type_of_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of a specified column.\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.",
      "docstring": "Return the type of a specified column.\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_type_of_column(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of a specified column.\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self.schema.get_type_of_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value",
      "name": "get_value",
      "qname": "safeds.data.tabular.containers._row.Row.get_value",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.get_value.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the value of a specified column.",
      "docstring": "Return the value of a specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nvalue :\n    The value of the column.",
      "code": "    def get_value(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value :\n            The value of the column.\n        \"\"\"\n        if not self.schema.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n        return self._data[self.schema._get_column_index_by_name(column_name)]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.containers._row.Row.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the row contains a given column.\nAlias for self.schema.hasColumn(column_name: str) -> bool.",
      "docstring": "Return whether the row contains a given column.\nAlias for self.schema.hasColumn(column_name: str) -> bool.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncontains : bool\n    True, if row contains the column.",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the row contains a given column.\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True, if row contains the column.\n        \"\"\"\n        return self.schema.has_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._table.Table.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._table.Table.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: typing.Any) -> bool:\n        if not isinstance(other, Table):\n            return NotImplemented\n        if self is other:\n            return True\n        table1 = self.sort_columns()\n        table2 = other.sort_columns()\n        return table1._data.equals(table2._data) and table1.schema == table2.schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._table.Table.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._table.Table.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "Create a new table.\n\nParameters\n----------\ndata : typing.Iterable\n    The data to be saved in the table.\nschema : TableSchema\n    The schema for the table.\n    None by default. If None, the schema will be provided by the data that is given.\n    If a schema is set, there is no check if this schema is compatible with the data.\n\nRaises\n----------\nMissingSchemaError\n    If the schema is missing.",
      "code": "    def __init__(self, data: typing.Iterable, schema: Optional[TableSchema] = None):\n        \"\"\"\n        Create a new table.\n\n        Parameters\n        ----------\n        data : typing.Iterable\n            The data to be saved in the table.\n        schema : TableSchema\n            The schema for the table.\n            None by default. If None, the schema will be provided by the data that is given.\n            If a schema is set, there is no check if this schema is compatible with the data.\n\n        Raises\n        ----------\n        MissingSchemaError\n            If the schema is missing.\n        \"\"\"\n        self._data: pd.Dataframe = (\n            data if isinstance(data, pd.DataFrame) else pd.DataFrame(data)\n        )\n        if schema is None:\n            if self.count_columns() == 0:\n                raise MissingSchemaError()\n            self.schema: TableSchema = TableSchema._from_dataframe(self._data)\n        else:\n            self.schema = schema\n            if self._data.empty:\n                self._data = pd.DataFrame(columns=self.schema.get_column_names())\n\n        self._data = self._data.reset_index(drop=True)\n        self._data.columns = list(range(self.count_columns()))"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._table.Table.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.get_column_names()\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._table.Table.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.get_column_names()\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._table.Table._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.get_column_names()\n\n        with pd.option_context(\n            \"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]\n        ):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column",
      "name": "add_column",
      "qname": "safeds.data.tabular.containers._table.Table.add_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column/column",
          "name": "column",
          "qname": "safeds.data.tabular.containers._table.Table.add_column.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the original table with the provided column attached at the end.",
      "docstring": "Return the original table with the provided column attached at the end.\n\nReturns\n-------\nresult : Table\n    The table with the column attached.\n\nRaises\n------\nDuplicateColumnNameError\n    If the new column already exists.\n\nColumnSizeError\n    If the size of the column does not match the amount of rows.",
      "code": "    def add_column(self, column: Column) -> Table:\n        \"\"\"\n        Return the original table with the provided column attached at the end.\n\n        Returns\n        -------\n        result : Table\n            The table with the column attached.\n\n        Raises\n        ------\n        DuplicateColumnNameError\n            If the new column already exists.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n\n        \"\"\"\n        if self.schema.has_column(column.name):\n            raise DuplicateColumnNameError(column.name)\n\n        if column._data.size != self.count_rows():\n            raise ColumnSizeError(str(self.count_rows()), str(column._data.size))\n\n        result = self._data.copy()\n        result.columns = self.schema.get_column_names()\n        result[column.name] = column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns",
      "name": "add_columns",
      "qname": "safeds.data.tabular.containers._table.Table.add_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.containers._table.Table.add_columns.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Column] or Table",
            "default_value": "",
            "description": "The columns to be added."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list[Column]"
              },
              {
                "kind": "NamedType",
                "name": "Table"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add multiple columns to the table.",
      "docstring": "Add multiple columns to the table.\n\nParameters\n----------\ncolumns : list[Column] or Table\n    The columns to be added.\n\nReturns\n-------\nresult: Table\n    A new table combining the original table and the given columns.\n\nRaises\n--------\nColumnSizeError\n    If at least one of the column sizes from the provided column list does not match the table.\nDuplicateColumnNameError\n    If at least one column name from the provided column list already exists in the table.",
      "code": "    def add_columns(self, columns: Union[list[Column], Table]) -> Table:\n        \"\"\"\n        Add multiple columns to the table.\n\n        Parameters\n        ----------\n        columns : list[Column] or Table\n            The columns to be added.\n\n        Returns\n        -------\n        result: Table\n            A new table combining the original table and the given columns.\n\n        Raises\n        --------\n        ColumnSizeError\n            If at least one of the column sizes from the provided column list does not match the table.\n        DuplicateColumnNameError\n            If at least one column name from the provided column list already exists in the table.\n        \"\"\"\n        if isinstance(columns, Table):\n            columns = columns.to_columns()\n        result = self._data.copy()\n        result.columns = self.schema.get_column_names()\n        for column in columns:\n            if column.name in result.columns:\n                raise DuplicateColumnNameError(column.name)\n\n            if column._data.size != self.count_rows():\n                raise ColumnSizeError(str(self.count_rows()), str(column._data.size))\n\n            result[column.name] = column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row",
      "name": "add_row",
      "qname": "safeds.data.tabular.containers._table.Table.add_row",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_row.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row/row",
          "name": "row",
          "qname": "safeds.data.tabular.containers._table.Table.add_row.row",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Row",
            "default_value": "",
            "description": "The row to be added."
          },
          "type": {
            "kind": "NamedType",
            "name": "Row"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add a row to the table.",
      "docstring": "Add a row to the table.\n\nParameters\n----------\nrow : Row\n    The row to be added.\n\nReturns\n-------\ntable : Table\n    A new table with the added row at the end.",
      "code": "    def add_row(self, row: Row) -> Table:\n        \"\"\"\n        Add a row to the table.\n\n        Parameters\n        ----------\n        row : Row\n            The row to be added.\n\n        Returns\n        -------\n        table : Table\n            A new table with the added row at the end.\n\n        \"\"\"\n        if self.schema != row.schema:\n            raise SchemaMismatchError()\n        new_df = pd.concat([self._data, row._data.to_frame().T]).infer_objects()\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows",
      "name": "add_rows",
      "qname": "safeds.data.tabular.containers._table.Table.add_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows/rows",
          "name": "rows",
          "qname": "safeds.data.tabular.containers._table.Table.add_rows.rows",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Row] or Table",
            "default_value": "",
            "description": "The rows to be added."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list[Row]"
              },
              {
                "kind": "NamedType",
                "name": "Table"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add multiple rows to a table.",
      "docstring": "Add multiple rows to a table.\n\nParameters\n----------\nrows : list[Row] or Table\n    The rows to be added.\n\nReturns\n-------\nresult : Table\n    A new table which combines the original table and the given rows.",
      "code": "    def add_rows(self, rows: Union[list[Row], Table]) -> Table:\n        \"\"\"\n        Add multiple rows to a table.\n\n        Parameters\n        ----------\n        rows : list[Row] or Table\n            The rows to be added.\n\n        Returns\n        -------\n        result : Table\n            A new table which combines the original table and the given rows.\n        \"\"\"\n        if isinstance(rows, Table):\n            rows = rows.to_rows()\n        result = self._data\n        for row in rows:\n            if self.schema != row.schema:\n                raise SchemaMismatchError()\n        result = pd.concat(\n            [result, *[row._data.to_frame().T for row in rows]]\n        ).infer_objects()\n        result.columns = self.schema.get_column_names()\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/count_columns",
      "name": "count_columns",
      "qname": "safeds.data.tabular.containers._table.Table.count_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/count_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.count_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns.",
      "docstring": "Return the number of columns.\n\nReturns\n-------\ncount : int\n    The number of columns.",
      "code": "    def count_columns(self) -> int:\n        \"\"\"\n        Return the number of columns.\n\n        Returns\n        -------\n        count : int\n            The number of columns.\n        \"\"\"\n        return self._data.shape[1]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/count_rows",
      "name": "count_rows",
      "qname": "safeds.data.tabular.containers._table.Table.count_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/count_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.count_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of rows.",
      "docstring": "Return the number of rows.\n\nReturns\n-------\ncount : int\n    The number of rows.",
      "code": "    def count_rows(self) -> int:\n        \"\"\"\n        Return the number of rows.\n\n        Returns\n        -------\n        count : int\n            The number of rows.\n        \"\"\"\n        return self._data.shape[0]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/drop_columns",
      "name": "drop_columns",
      "qname": "safeds.data.tabular.containers._table.Table.drop_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/drop_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.drop_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/drop_columns/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.containers._table.Table.drop_columns.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "A list containing all columns to be dropped."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the given column(s).",
      "docstring": "Return a table without the given column(s).\n\nParameters\n----------\ncolumn_names : list[str]\n    A list containing all columns to be dropped.\n\nReturns\n-------\ntable : Table\n    A table without the given columns.\n\nRaises\n------\nColumnNameError\n    If any of the given columns do not exist.",
      "code": "    def drop_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table without the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing all columns to be dropped.\n\n        Returns\n        -------\n        table : Table\n            A table without the given columns.\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns do not exist.\n        \"\"\"\n        invalid_columns = []\n        column_indices = []\n        for name in column_names:\n            if not self.schema.has_column(name):\n                invalid_columns.append(name)\n            else:\n                column_indices.append(self.schema._get_column_index_by_name(name))\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n        transformed_data = self._data.drop(labels=column_indices, axis=\"columns\")\n        transformed_data.columns = list(\n            name for name in self.schema.get_column_names() if name not in column_names\n        )\n        return Table(transformed_data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/drop_duplicate_rows",
      "name": "drop_duplicate_rows",
      "qname": "safeds.data.tabular.containers._table.Table.drop_duplicate_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/drop_duplicate_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.drop_duplicate_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a copy of the table with every duplicate row removed.",
      "docstring": "Return a copy of the table with every duplicate row removed.\n\nReturns\n-------\nresult : Table\n    The table with the duplicate rows removed.",
      "code": "    def drop_duplicate_rows(self) -> Table:\n        \"\"\"\n        Return a copy of the table with every duplicate row removed.\n\n        Returns\n        -------\n        result : Table\n            The table with the duplicate rows removed.\n\n        \"\"\"\n        df = self._data.drop_duplicates(ignore_index=True)\n        df.columns = self.schema.get_column_names()\n        return Table(df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows",
      "name": "filter_rows",
      "qname": "safeds.data.tabular.containers._table.Table.filter_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.filter_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows/query",
          "name": "query",
          "qname": "safeds.data.tabular.containers._table.Table.filter_rows.query",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "lambda function",
            "default_value": "",
            "description": "A Callable that is applied to all rows."
          },
          "type": {
            "kind": "NamedType",
            "name": "lambda function"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with rows filtered by Callable (e.g. lambda function).",
      "docstring": "Return a table with rows filtered by Callable (e.g. lambda function).\n\nParameters\n----------\nquery : lambda function\n    A Callable that is applied to all rows.\n\nReturns\n-------\ntable : Table\n    A table containing only the rows filtered by the query.",
      "code": "    def filter_rows(self, query: Callable[[Row], bool]) -> Table:\n        \"\"\"\n        Return a table with rows filtered by Callable (e.g. lambda function).\n\n        Parameters\n        ----------\n        query : lambda function\n            A Callable that is applied to all rows.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the rows filtered by the query.\n        \"\"\"\n\n        rows: list[Row] = [row for row in self.to_rows() if query(row)]\n        if len(rows) == 0:\n            result_table = Table([], self.schema)\n        else:\n            result_table = self.from_rows(rows)\n        return result_table"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_columns",
      "name": "from_columns",
      "qname": "safeds.data.tabular.containers._table.Table.from_columns",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_columns/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.containers._table.Table.from_columns.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Column]",
            "default_value": "",
            "description": "The columns to be combined. They need to have the same size."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[Column]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table created from a list of columns.",
      "docstring": "Return a table created from a list of columns.\n\nParameters\n----------\ncolumns : list[Column]\n    The columns to be combined. They need to have the same size.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nMissingDataError\n    If an empty list is given.\nColumnLengthMismatchError\n    If any of the column sizes does not match with the others.",
      "code": "    @staticmethod\n    def from_columns(columns: list[Column]) -> Table:\n        \"\"\"\n        Return a table created from a list of columns.\n\n        Parameters\n        ----------\n        columns : list[Column]\n            The columns to be combined. They need to have the same size.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        ColumnLengthMismatchError\n            If any of the column sizes does not match with the others.\n        \"\"\"\n        if len(columns) == 0:\n            raise MissingDataError(\"This function requires at least one column.\")\n\n        dataframe: DataFrame = pd.DataFrame()\n\n        for column in columns:\n            if column._data.size != columns[0]._data.size:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(\n                        [f\"{column.name}: {column._data.size}\" for column in columns]\n                    )\n                )\n            dataframe[column.name] = column._data\n\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_csv",
      "name": "from_csv",
      "qname": "safeds.data.tabular.containers._table.Table.from_csv",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_csv/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.from_csv.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the CSV file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Read data from a CSV file into a table.",
      "docstring": "Read data from a CSV file into a table.\n\nParameters\n----------\npath : str\n    The path to the CSV file.\n\nReturns\n-------\ntable : Table\n    The table created from the CSV file.\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist.\nValueError\n    If the file could not be read.",
      "code": "    @staticmethod\n    def from_csv(path: str) -> Table:\n        \"\"\"\n        Read data from a CSV file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the CSV file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the CSV file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n\n        try:\n            return Table(pd.read_csv(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n        except Exception as exception:\n            raise ValueError(f'Could not read file from \"{path}\" as CSV') from exception"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_json",
      "name": "from_json",
      "qname": "safeds.data.tabular.containers._table.Table.from_json",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_json/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.from_json.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the JSON file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Read data from a JSON file into a table.",
      "docstring": "Read data from a JSON file into a table.\n\nParameters\n----------\npath : str\n    The path to the JSON file.\n\nReturns\n-------\ntable : Table\n    The table created from the JSON file.\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist.\nValueError\n    If the file could not be read.",
      "code": "    @staticmethod\n    def from_json(path: str) -> Table:\n        \"\"\"\n        Read data from a JSON file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the JSON file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the JSON file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n\n        try:\n            return Table(pd.read_json(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n        except Exception as exception:\n            raise ValueError(\n                f'Could not read file from \"{path}\" as JSON'\n            ) from exception"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_rows",
      "name": "from_rows",
      "qname": "safeds.data.tabular.containers._table.Table.from_rows",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_rows/rows",
          "name": "rows",
          "qname": "safeds.data.tabular.containers._table.Table.from_rows.rows",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Row]",
            "default_value": "",
            "description": "The rows to be combined. They need to have a matching schema."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[Row]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table created from a list of rows.",
      "docstring": "Return a table created from a list of rows.\n\nParameters\n----------\nrows : list[Row]\n    The rows to be combined. They need to have a matching schema.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nMissingDataError\n    If an empty list is given.\nSchemaMismatchError\n    If any of the row schemas does not match with the others.",
      "code": "    @staticmethod\n    def from_rows(rows: list[Row]) -> Table:\n        \"\"\"\n        Return a table created from a list of rows.\n\n        Parameters\n        ----------\n        rows : list[Row]\n            The rows to be combined. They need to have a matching schema.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        SchemaMismatchError\n            If any of the row schemas does not match with the others.\n        \"\"\"\n        if len(rows) == 0:\n            raise MissingDataError(\"This function requires at least one row.\")\n\n        schema_compare: TableSchema = rows[0].schema\n        row_array: list[Series] = []\n\n        for row in rows:\n            if schema_compare != row.schema:\n                raise SchemaMismatchError()\n            row_array.append(row._data)\n\n        dataframe: DataFrame = pd.DataFrame(row_array)\n        dataframe.columns = schema_compare.get_column_names()\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column",
      "name": "get_column",
      "qname": "safeds.data.tabular.containers._table.Table.get_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.get_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a column with the data of the specified column.",
      "docstring": "Return a column with the data of the specified column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncolumn : Column\n    The column.\n\nRaises\n------\nUnknownColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_column(self, column_name: str) -> Column:\n        \"\"\"\n        Return a column with the data of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        column : Column\n            The column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if self.schema.has_column(column_name):\n            output_column = Column(\n                self._data.iloc[\n                    :, [self.schema._get_column_index_by_name(column_name)]\n                ].squeeze(),\n                column_name,\n            )\n            output_column._type = self.schema.get_type_of_column(column_name)\n            return output_column\n\n        raise UnknownColumnNameError([column_name])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_names",
      "name": "get_column_names",
      "qname": "safeds.data.tabular.containers._table.Table.get_column_names",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_names/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names in this table.\nAlias for self.schema.get_column_names() -> list[str].",
      "docstring": "Return a list of all column names in this table.\nAlias for self.schema.get_column_names() -> list[str].\n\nReturns\n-------\ncolumn_names : list[str]\n    The list of the column names.",
      "code": "    def get_column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in this table.\n        Alias for self.schema.get_column_names() -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The list of the column names.\n        \"\"\"\n        return self.schema.get_column_names()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row",
      "name": "get_row",
      "qname": "safeds.data.tabular.containers._table.Table.get_row",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_row.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._table.Table.get_row.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The index."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the row at a specified index.",
      "docstring": "Return the row at a specified index.\n\nParameters\n----------\nindex : int\n    The index.\n\nReturns\n-------\nrow : Row\n    The row of the table at the index.\n\nRaises\n------\nIndexOutOfBoundsError\n    If no row at the specified index exists in this table.",
      "code": "    def get_row(self, index: int) -> Row:\n        \"\"\"\n        Return the row at a specified index.\n\n        Parameters\n        ----------\n        index : int\n            The index.\n\n        Returns\n        -------\n        row : Row\n            The row of the table at the index.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If no row at the specified index exists in this table.\n        \"\"\"\n        if len(self._data.index) - 1 < index or index < 0:\n            raise IndexOutOfBoundsError(index)\n        return Row(self._data.iloc[[index]].squeeze(), self.schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_type_of_column",
      "name": "get_type_of_column",
      "qname": "safeds.data.tabular.containers._table.Table.get_type_of_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_type_of_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_type_of_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_type_of_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.get_type_of_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column to be queried."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the given column.\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.",
      "docstring": "Return the type of the given column.\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column to be queried.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_type_of_column(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column to be queried.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self.schema.get_type_of_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.containers._table.Table.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the table contains a given column.\nAlias for self.schema.hasColumn(column_name: str) -> bool.",
      "docstring": "Return whether the table contains a given column.\nAlias for self.schema.hasColumn(column_name: str) -> bool.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncontains : bool\n    True if the column exists.",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the table contains a given column.\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the column exists.\n        \"\"\"\n        return self.schema.has_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_columns",
      "name": "keep_columns",
      "qname": "safeds.data.tabular.containers._table.Table.keep_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.keep_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_columns/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.containers._table.Table.keep_columns.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "A list containing only the columns to be kept."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with only the given column(s).",
      "docstring": "Return a table with only the given column(s).\n\nParameters\n----------\ncolumn_names : list[str]\n    A list containing only the columns to be kept.\n\nReturns\n-------\ntable : Table\n    A table containing only the given column(s).\n\nRaises\n------\nColumnNameError\n    If any of the given columns do not exist.",
      "code": "    def keep_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table with only the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing only the columns to be kept.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the given column(s).\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns do not exist.\n        \"\"\"\n        invalid_columns = []\n        column_indices = []\n        for name in column_names:\n            if not self.schema.has_column(name):\n                invalid_columns.append(name)\n            else:\n                column_indices.append(self.schema._get_column_index_by_name(name))\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n        transformed_data = self._data[column_indices]\n        transformed_data.columns = list(\n            name for name in self.schema.get_column_names() if name in column_names\n        )\n        return Table(transformed_data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_missing_values",
      "name": "list_columns_with_missing_values",
      "qname": "safeds.data.tabular.containers._table.Table.list_columns_with_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.list_columns_with_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all the columns that have at least one missing value. Returns an empty list if there are none.",
      "docstring": "Return a list of all the columns that have at least one missing value. Returns an empty list if there are none.\n\nReturns\n-------\ncolumns_with_missing_values: list[Column]\n    The list of columns with missing values.",
      "code": "    def list_columns_with_missing_values(self) -> list[Column]:\n        \"\"\"\n        Return a list of all the columns that have at least one missing value. Returns an empty list if there are none.\n\n        Returns\n        -------\n        columns_with_missing_values: list[Column]\n            The list of columns with missing values.\n        \"\"\"\n        columns = self.to_columns()\n        columns_with_missing_values = []\n        for column in columns:\n            if column.has_missing_values():\n                columns_with_missing_values.append(column)\n        return columns_with_missing_values"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_non_numerical_values",
      "name": "list_columns_with_non_numerical_values",
      "qname": "safeds.data.tabular.containers._table.Table.list_columns_with_non_numerical_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_non_numerical_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.list_columns_with_non_numerical_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of columns only containing non-numerical values.",
      "docstring": "Return a list of columns only containing non-numerical values.\n\nReturns\n-------\ncols : list[Column]\n    The list with only non-numerical columns.",
      "code": "    def list_columns_with_non_numerical_values(self) -> list[Column]:\n        \"\"\"\n        Return a list of columns only containing non-numerical values.\n\n        Returns\n        -------\n        cols : list[Column]\n            The list with only non-numerical columns.\n        \"\"\"\n        cols = []\n        for column_name, data_type in self.schema._schema.items():\n            if not data_type.is_numeric():\n                cols.append(self.get_column(column_name))\n        return cols"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_numerical_values",
      "name": "list_columns_with_numerical_values",
      "qname": "safeds.data.tabular.containers._table.Table.list_columns_with_numerical_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/list_columns_with_numerical_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.list_columns_with_numerical_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of columns only containing numerical values.",
      "docstring": "Return a list of columns only containing numerical values.\n\nReturns\n-------\ncols : list[Column]\n    The list with only numerical columns.",
      "code": "    def list_columns_with_numerical_values(self) -> list[Column]:\n        \"\"\"\n        Return a list of columns only containing numerical values.\n\n        Returns\n        -------\n        cols : list[Column]\n            The list with only numerical columns.\n        \"\"\"\n        cols = []\n        for column_name, data_type in self.schema._schema.items():\n            if data_type.is_numeric():\n                cols.append(self.get_column(column_name))\n        return cols"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_outliers",
      "name": "remove_outliers",
      "qname": "safeds.data.tabular.containers._table.Table.remove_outliers",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_outliers/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_outliers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Remove all rows from the table that contain at least one outlier defined as having a value that has a distance of\nmore than 3 standard deviations from the column average.",
      "docstring": "Remove all rows from the table that contain at least one outlier defined as having a value that has a distance of\nmore than 3 standard deviations from the column average.\n\nReturns\n-------\nnew_table : Table\n    A new table without rows containing outliers.",
      "code": "    def remove_outliers(self) -> Table:\n        \"\"\"\n        Remove all rows from the table that contain at least one outlier defined as having a value that has a distance of\n        more than 3 standard deviations from the column average.\n\n        Returns\n        -------\n        new_table : Table\n            A new table without rows containing outliers.\n        \"\"\"\n        result = self._data.copy(deep=True)\n\n        table_without_nonnumericals = Table.from_columns(\n            self.list_columns_with_numerical_values()\n        )\n\n        result = result[\n            (np.absolute(stats.zscore(table_without_nonnumericals._data)) < 3).all(\n                axis=1\n            )\n        ]\n\n        return Table(result, self.schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column",
      "name": "rename_column",
      "qname": "safeds.data.tabular.containers._table.Table.rename_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/old_name",
          "name": "old_name",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.old_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The old name of the target column"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/new_name",
          "name": "new_name",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.new_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The new name of the target column"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Rename a single column.",
      "docstring": "Rename a single column.\n\nParameters\n----------\nold_name : str\n    The old name of the target column\nnew_name : str\n    The new name of the target column\n\nReturns\n-------\ntable : Table\n    The Table with the renamed column.\n\nRaises\n------\nColumnNameError\n    If the specified old target column name does not exist.\nDuplicateColumnNameError\n    If the specified new target column name already exists.",
      "code": "    def rename_column(self, old_name: str, new_name: str) -> Table:\n        \"\"\"\n        Rename a single column.\n\n        Parameters\n        ----------\n        old_name : str\n            The old name of the target column\n        new_name : str\n            The new name of the target column\n\n        Returns\n        -------\n        table : Table\n            The Table with the renamed column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified old target column name does not exist.\n        DuplicateColumnNameError\n            If the specified new target column name already exists.\n        \"\"\"\n        if old_name not in self.schema.get_column_names():\n            raise UnknownColumnNameError([old_name])\n        if old_name == new_name:\n            return self\n        if new_name in self.schema.get_column_names():\n            raise DuplicateColumnNameError(new_name)\n\n        new_df = self._data.copy()\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df.rename(columns={old_name: new_name}))"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column",
      "name": "replace_column",
      "qname": "safeds.data.tabular.containers._table.Table.replace_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/old_column_name",
          "name": "old_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.old_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column to be replaced."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/new_column",
          "name": "new_column",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.new_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The new column replacing the old column."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.",
      "docstring": "Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\nParameters\n----------\nold_column_name : str\n    The name of the column to be replaced.\n\nnew_column : Column\n    The new column replacing the old column.\n\nReturns\n-------\nresult : Table\n    A table with the old column replaced by the new column.\n\nRaises\n------\nUnknownColumnNameError\n    If the old column does not exist.\n\nDuplicateColumnNameError\n    If the new column already exists and the existing column is not affected by the replacement.\n\nColumnSizeError\n    If the size of the column does not match the amount of rows.",
      "code": "    def replace_column(self, old_column_name: str, new_column: Column) -> Table:\n        \"\"\"\n        Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\n        Parameters\n        ----------\n        old_column_name : str\n            The name of the column to be replaced.\n\n        new_column : Column\n            The new column replacing the old column.\n\n        Returns\n        -------\n        result : Table\n            A table with the old column replaced by the new column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the old column does not exist.\n\n        DuplicateColumnNameError\n            If the new column already exists and the existing column is not affected by the replacement.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n        \"\"\"\n        if old_column_name not in self.schema.get_column_names():\n            raise UnknownColumnNameError([old_column_name])\n\n        if (\n            new_column.name in self.schema.get_column_names()\n            and new_column.name != old_column_name\n        ):\n            raise DuplicateColumnNameError(new_column.name)\n\n        if self.count_rows() != new_column._data.size:\n            raise ColumnSizeError(str(self.count_rows()), str(new_column._data.size))\n\n        if old_column_name != new_column.name:\n            renamed_table = self.rename_column(old_column_name, new_column.name)\n            result = renamed_table._data\n            result.columns = renamed_table.schema.get_column_names()\n        else:\n            result = self._data.copy()\n            result.columns = self.schema.get_column_names()\n\n        result[new_column.name] = new_column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/shuffle",
      "name": "shuffle",
      "qname": "safeds.data.tabular.containers._table.Table.shuffle",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/shuffle/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.shuffle.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Shuffle the table randomly.",
      "docstring": "Shuffle the table randomly.\n\nReturns\n-------\nresult : Table\n    The shuffled Table.",
      "code": "    def shuffle(self) -> Table:\n        \"\"\"\n        Shuffle the table randomly.\n\n        Returns\n        -------\n        result : Table\n            The shuffled Table.\n\n        \"\"\"\n        new_df = self._data.sample(frac=1.0)\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/slice",
      "name": "slice",
      "qname": "safeds.data.tabular.containers._table.Table.slice",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.slice.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice/start",
          "name": "start",
          "qname": "safeds.data.tabular.containers._table.Table.slice.start",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The first index of the range to be copied into a new table, None by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice/end",
          "name": "end",
          "qname": "safeds.data.tabular.containers._table.Table.slice.end",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The last index of the range to be copied into a new table, None by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice/step",
          "name": "step",
          "qname": "safeds.data.tabular.containers._table.Table.slice.step",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The step size used to iterate through the table, 1 by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Slice a part of the table into a new table.",
      "docstring": "Slice a part of the table into a new table.\n\nParameters\n----------\nstart : int\n    The first index of the range to be copied into a new table, None by default.\nend : int\n    The last index of the range to be copied into a new table, None by default.\nstep : int\n    The step size used to iterate through the table, 1 by default.\n\nReturns\n-------\nresult : Table\n    The resulting table.\n\nRaises\n-------\nValueError\n    If the index is out of bounds.",
      "code": "    def slice(\n        self,\n        start: typing.Optional[int] = None,\n        end: typing.Optional[int] = None,\n        step: int = 1,\n    ) -> Table:\n        \"\"\"\n        Slice a part of the table into a new table.\n\n        Parameters\n        ----------\n        start : int\n            The first index of the range to be copied into a new table, None by default.\n        end : int\n            The last index of the range to be copied into a new table, None by default.\n        step : int\n            The step size used to iterate through the table, 1 by default.\n\n        Returns\n        -------\n        result : Table\n            The resulting table.\n\n        Raises\n        -------\n        ValueError\n            If the index is out of bounds.\n        \"\"\"\n\n        if start is None:\n            start = 0\n\n        if end is None:\n            end = self.count_rows()\n\n        if (\n            start < 0\n            or end < 0\n            or start >= self.count_rows()\n            or end > self.count_rows()\n            or end < start\n        ):\n            raise ValueError(\"the given index is out of bounds\")\n\n        new_df = self._data.iloc[start:end:step]\n        new_df.columns = self.schema.get_column_names()\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns",
      "name": "sort_columns",
      "qname": "safeds.data.tabular.containers._table.Table.sort_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.sort_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns/query",
          "name": "query",
          "qname": "safeds.data.tabular.containers._table.Table.sort_columns.query",
          "default_value": "lambda col1, col2: (col1.name > col2.name) - (col1.name < col2.name)",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "a lambda function",
            "default_value": "",
            "description": "The lambda function used to sort the columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "a lambda function"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Sort a table with the given lambda function.\nIf no function is given the columns will be sorted alphabetically.\nThis function uses the default python sort algorithm.\nThe query returns\n0, if both columns are equal.\n< 0, if the first column should be ordered after the second column.\n> 0, if the first column should be ordered before the second column.",
      "docstring": "Sort a table with the given lambda function.\nIf no function is given the columns will be sorted alphabetically.\nThis function uses the default python sort algorithm.\nThe query returns\n0, if both columns are equal.\n< 0, if the first column should be ordered after the second column.\n> 0, if the first column should be ordered before the second column.\n\nParameters\n----------\nquery : a lambda function\n    The lambda function used to sort the columns.\n\nReturns\n-------\nnew_table : Table\n    A new table with sorted columns.",
      "code": "    def sort_columns(\n        self,\n        query: Callable[[Column, Column], int] = lambda col1, col2: (\n            col1.name > col2.name\n        )\n        - (col1.name < col2.name),\n    ) -> Table:\n        \"\"\"\n        Sort a table with the given lambda function.\n        If no function is given the columns will be sorted alphabetically.\n        This function uses the default python sort algorithm.\n        The query returns\n        0, if both columns are equal.\n        < 0, if the first column should be ordered after the second column.\n        > 0, if the first column should be ordered before the second column.\n\n        Parameters\n        ----------\n        query : a lambda function\n            The lambda function used to sort the columns.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted columns.\n        \"\"\"\n        columns = self.to_columns()\n        columns.sort(key=functools.cmp_to_key(query))\n        return Table.from_columns(columns)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/split",
      "name": "split",
      "qname": "safeds.data.tabular.containers._table.Table.split",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/split/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.split.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/split/percentage_in_first",
          "name": "percentage_in_first",
          "qname": "safeds.data.tabular.containers._table.Table.split.percentage_in_first",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Split the table into two new tables.\n\nParameters\n-------\npercentage_in_first : float\n    The desired size of the first table in percentage to the given table.",
      "docstring": "Split the table into two new tables.\n\nParameters\n-------\npercentage_in_first : float\n    The desired size of the first table in percentage to the given table.\n\nReturns\n-------\nresult : (Table, Table)\n    A tuple containing the two resulting tables. The first table has the specified size, the second table contains the rest of the data.",
      "code": "    def split(self, percentage_in_first: float) -> typing.Tuple[Table, Table]:\n        \"\"\"\n        Split the table into two new tables.\n\n        Parameters\n        -------\n        percentage_in_first : float\n            The desired size of the first table in percentage to the given table.\n\n        Returns\n        -------\n        result : (Table, Table)\n            A tuple containing the two resulting tables. The first table has the specified size, the second table contains the rest of the data.\n\n\n        \"\"\"\n        if percentage_in_first <= 0 or percentage_in_first >= 1:\n            raise ValueError(\"the given percentage is not in range\")\n        return (\n            self.slice(0, round(percentage_in_first * self.count_rows())),\n            self.slice(round(percentage_in_first * self.count_rows())),\n        )"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/summary",
      "name": "summary",
      "qname": "safeds.data.tabular.containers._table.Table.summary",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/summary/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.summary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with a number of statistical key values.",
      "docstring": "Return a table with a number of statistical key values.\n\nReturns\n-------\nresult : Table\n    The table with statistics.",
      "code": "    def summary(self) -> Table:\n        \"\"\"\n        Return a table with a number of statistical key values.\n\n        Returns\n        -------\n        result : Table\n            The table with statistics.\n        \"\"\"\n\n        columns = self.to_columns()\n        result = pd.DataFrame()\n        statistics = {}\n\n        for column in columns:\n            statistics = {\n                \"max\": column.statistics.max,\n                \"min\": column.statistics.min,\n                \"mean\": column.statistics.mean,\n                \"mode\": column.statistics.mode,\n                \"median\": column.statistics.median,\n                \"sum\": column.statistics.sum,\n                \"variance\": column.statistics.variance,\n                \"standard deviation\": column.statistics.standard_deviation,\n                \"idness\": column.statistics.idness,\n                \"stability\": column.statistics.stability,\n                \"row count\": column.count,\n            }\n            values = []\n\n            for function in statistics.values():\n                try:\n                    values.append(str(function()))\n                except NonNumericColumnError:\n                    values.append(\"-\")\n\n            result = pd.concat([result, pd.DataFrame(values)], axis=1)\n\n        result = pd.concat([pd.DataFrame(list(statistics.keys())), result], axis=1)\n        result.columns = [\"metrics\"] + self.get_column_names()\n\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_columns",
      "name": "to_columns",
      "qname": "safeds.data.tabular.containers._table.Table.to_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of the columns.",
      "docstring": "Return a list of the columns.\n\nReturns\n-------\ncolumns : list[Columns]\n    List of columns.",
      "code": "    def to_columns(self) -> list[Column]:\n        \"\"\"\n        Return a list of the columns.\n\n        Returns\n        -------\n        columns : list[Columns]\n            List of columns.\n        \"\"\"\n        return [self.get_column(name) for name in self.schema.get_column_names()]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv",
      "name": "to_csv",
      "qname": "safeds.data.tabular.containers._table.Table.to_csv",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_csv.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv/path_to_file",
          "name": "path_to_file",
          "qname": "safeds.data.tabular.containers._table.Table.to_csv.path_to_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the output file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Write the data from the table into a CSV file.\nIf the file and/or the directories do not exist they will be created.\nIf the file already exists it will be overwritten.",
      "docstring": "Write the data from the table into a CSV file.\nIf the file and/or the directories do not exist they will be created.\nIf the file already exists it will be overwritten.\n\nParameters\n----------\npath_to_file : str\n    The path to the output file.",
      "code": "    def to_csv(self, path_to_file: str) -> None:\n        \"\"\"\n        Write the data from the table into a CSV file.\n        If the file and/or the directories do not exist they will be created.\n        If the file already exists it will be overwritten.\n\n        Parameters\n        ----------\n        path_to_file : str\n            The path to the output file.\n        \"\"\"\n        Path(os.path.dirname(path_to_file)).mkdir(parents=True, exist_ok=True)\n        data_to_csv = self._data.copy()\n        data_to_csv.columns = self.schema.get_column_names()\n        data_to_csv.to_csv(path_to_file, index=False)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json",
      "name": "to_json",
      "qname": "safeds.data.tabular.containers._table.Table.to_json",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_json.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json/path_to_file",
          "name": "path_to_file",
          "qname": "safeds.data.tabular.containers._table.Table.to_json.path_to_file",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the output file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Write the data from the table into a JSON file.\nIf the file and/or the directories do not exist, they will be created.\nIf the file already exists it will be overwritten.",
      "docstring": "Write the data from the table into a JSON file.\nIf the file and/or the directories do not exist, they will be created.\nIf the file already exists it will be overwritten.\n\nParameters\n----------\npath_to_file : str\n    The path to the output file.",
      "code": "    def to_json(self, path_to_file: str) -> None:\n        \"\"\"\n        Write the data from the table into a JSON file.\n        If the file and/or the directories do not exist, they will be created.\n        If the file already exists it will be overwritten.\n\n        Parameters\n        ----------\n        path_to_file : str\n            The path to the output file.\n        \"\"\"\n        Path(os.path.dirname(path_to_file)).mkdir(parents=True, exist_ok=True)\n        data_to_json = self._data.copy()\n        data_to_json.columns = self.schema.get_column_names()\n        data_to_json.to_json(path_to_file)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_rows",
      "name": "to_rows",
      "qname": "safeds.data.tabular.containers._table.Table.to_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of the rows.",
      "docstring": "Return a list of the rows.\n\nReturns\n-------\nrows : list[Row]\n    List of rows.",
      "code": "    def to_rows(self) -> list[Row]:\n        \"\"\"\n        Return a list of the rows.\n\n        Returns\n        -------\n        rows : list[Row]\n            List of rows.\n        \"\"\"\n        return [\n            Row(series_row, self.schema) for (_, series_row) in self._data.iterrows()\n        ]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column",
      "name": "transform_column",
      "qname": "safeds.data.tabular.containers._table.Table.transform_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/name",
          "name": "name",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/transformer",
          "name": "transformer",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.transformer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Transform provided column by calling provided transformer.",
      "docstring": "Transform provided column by calling provided transformer.\n\nReturns\n-------\nresult : Table\n    The table with the transformed column.\n\nRaises\n------\nUnknownColumnNameError\n    If the column does not exist.",
      "code": "    def transform_column(\n        self, name: str, transformer: Callable[[Row], typing.Any]\n    ) -> Table:\n        \"\"\"\n        Transform provided column by calling provided transformer.\n\n        Returns\n        -------\n        result : Table\n            The table with the transformed column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the column does not exist.\n\n        \"\"\"\n        if self.has_column(name):\n            items: list = [transformer(item) for item in self.to_rows()]\n            result: Column = Column(pd.Series(items), name)\n            return self.replace_column(name, result)\n        raise UnknownColumnNameError([name])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/table",
          "name": "table",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to derive the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/target_column",
          "name": "target_column",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.target_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Name of the target column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.",
      "docstring": "",
      "code": "    def __init__(self, table: Table, target_column: str):\n        super().__init__(table._data)\n\n        self._y: Column = table.get_column(target_column)\n        self._X: Table = table.drop_columns([target_column])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._X.add_column(self._y)\n        header_info = \"Target Column is '\" + self._y.name + \"'\\n\"\n        return header_info + tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._X.add_column(self._y)\n        header_info = \"Target Column is '\" + self._y.name + \"'\\n\"\n        return header_info + tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._X.add_column(self._y)\n        header_info = \"Target Column is '\" + self._y.name + \"'\\n\"\n        print(header_info)\n        return tmp._ipython_display_()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/feature_vectors@getter",
      "name": "feature_vectors",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.feature_vectors",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/feature_vectors@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.feature_vectors.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def feature_vectors(self) -> Table:\n        return self._X"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target_values@getter",
      "name": "target_values",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.target_values",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target_values@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.target_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def target_values(self) -> Column:\n        return self._y"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/__init__/value",
          "name": "value",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant.__init__.value",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": "The given value to impute missing values."
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "An imputation strategy for imputing missing data with given constant values.",
      "docstring": "",
      "code": "            def __init__(self, value: Any):\n                self._value = value"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Constant/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Constant._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"constant\"\n                imputer.fill_value = self._value"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mean/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mean._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"mean\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Median/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Median._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"median\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode._augment_imputer",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/Strategy/Mode/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.Strategy.Mode._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "            def _augment_imputer(self, imputer: SimpleImputer) -> None:\n                imputer.strategy = \"most_frequent\""
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/__init__/strategy",
          "name": "strategy",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.__init__.strategy",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "ImputerStrategy",
            "default_value": "",
            "description": "The strategy used to impute missing values."
          },
          "type": {
            "kind": "NamedType",
            "name": "ImputerStrategy"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Impute the data for a given Table.",
      "docstring": "",
      "code": "    def __init__(self, strategy: ImputerStrategy):\n        self._imp = SimpleImputer()\n        strategy._augment_imputer(self._imp)\n        self._column_names: list[str] = []"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to learn the imputation values."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "An optional list of column names, if the imputer is only supposed to run on specific columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit the imputer on the dataset.",
      "docstring": "Fit the imputer on the dataset.\n\nParameters\n----------\ntable : Table\n    The table used to learn the imputation values.\ncolumn_names : Optional[list[str]]\n    An optional list of column names, if the imputer is only supposed to run on specific columns.",
      "code": "    def fit(self, table: Table, column_names: Optional[list[str]] = None) -> None:\n        \"\"\"\n        Fit the imputer on the dataset.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to learn the imputation values.\n        column_names : Optional[list[str]]\n            An optional list of column names, if the imputer is only supposed to run on specific columns.\n        \"\"\"\n        if column_names is None:\n            column_names = table.schema.get_column_names()\n\n        if self._imp.strategy == \"most_frequent\":\n            for name in column_names:\n                if 1 < len(ColumnStatistics(table.get_column(name)).mode()):\n                    raise IndexError(\n                        \"There are multiple frequent values in a column given for the Imputer\"\n                    )\n\n        self._column_names = column_names\n        indices = [\n            table.schema._get_column_index_by_name(name) for name in self._column_names\n        ]\n        self._imp.fit(table._data[indices])"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit_transform",
      "name": "fit_transform",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to learn the imputation values."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/fit_transform/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.fit_transform.column_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "An optional list of column names, if the imputer is only supposed to run on specific columns."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit the imputer on the dataset and impute the missing values.",
      "docstring": "Fit the imputer on the dataset and impute the missing values.\n\nParameters\n----------\ntable : Table\n    The table used to learn the imputation values.\ncolumn_names : Optional[list[str]]\n    An optional list of column names, if the imputer is only supposed to run on specific columns.\n\nReturns\n-------\ntable : Table\n    The dataset with missing values imputed by the given strategy.",
      "code": "    def fit_transform(\n        self, table: Table, column_names: Optional[list[str]] = None\n    ) -> Table:\n        \"\"\"\n        Fit the imputer on the dataset and impute the missing values.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to learn the imputation values.\n        column_names : Optional[list[str]]\n            An optional list of column names, if the imputer is only supposed to run on specific columns.\n\n        Returns\n        -------\n        table : Table\n            The dataset with missing values imputed by the given strategy.\n        \"\"\"\n        self.fit(table, column_names)\n        return self.transform(table)"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._imputer.Imputer.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/Imputer/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._imputer.Imputer.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset to be imputed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Impute the missing values on the dataset.",
      "docstring": "Impute the missing values on the dataset.\n\nParameters\n----------\ntable : Table\n    The dataset to be imputed.\n\nReturns\n-------\ntable : Table\n    The dataset with missing values imputed by the given strategy.",
      "code": "    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Impute the missing values on the dataset.\n\n        Parameters\n        ----------\n        table : Table\n            The dataset to be imputed.\n\n        Returns\n        -------\n        table : Table\n            The dataset with missing values imputed by the given strategy.\n        \"\"\"\n        data = table._data.copy()\n        indices = [\n            table.schema._get_column_index_by_name(name) for name in self._column_names\n        ]\n        data[indices] = pd.DataFrame(\n            self._imp.transform(data[indices]), columns=indices\n        )\n        table_imputed = Table(data)\n        table_imputed.schema = table.schema\n        return table_imputed"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._imputer/ImputerStrategy/_augment_imputer",
      "name": "_augment_imputer",
      "qname": "safeds.data.tabular.transformation._imputer.ImputerStrategy._augment_imputer",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/ImputerStrategy/_augment_imputer/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._imputer.ImputerStrategy._augment_imputer.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._imputer/ImputerStrategy/_augment_imputer/imputer",
          "name": "imputer",
          "qname": "safeds.data.tabular.transformation._imputer.ImputerStrategy._augment_imputer.imputer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @abstractmethod\n    def _augment_imputer(self, imputer: SimpleImputer) -> None:\n        pass"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "The LabelEncoder encodes one or more given columns into labels.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._is_fitted = 0\n        self._le = preprocessing.LabelEncoder()"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table containing the data used to fit the label encoder."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit/column",
          "name": "column",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The list of columns supposed to be label-encoded."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit the label encoder with the values in the table.",
      "docstring": "Fit the label encoder with the values in the table.\n\nParameters\n----------\ntable : Table\n    The table containing the data used to fit the label encoder.\ncolumn : str\n    The list of columns supposed to be label-encoded.\n\nReturns\n-------\nNone\n    This function does not return any value. It updates the internal state of the label encoder object.\n\nRaises\n-------\nLearningError\n    If the model fitting was unsuccessful.",
      "code": "    def fit(self, table: Table, column: str) -> None:\n        \"\"\"\n        Fit the label encoder with the values in the table.\n\n        Parameters\n        ----------\n        table : Table\n            The table containing the data used to fit the label encoder.\n        column : str\n            The list of columns supposed to be label-encoded.\n\n        Returns\n        -------\n        None\n            This function does not return any value. It updates the internal state of the label encoder object.\n\n        Raises\n        -------\n        LearningError\n            If the model fitting was unsuccessful.\n        \"\"\"\n        try:\n            self._le.fit(table.keep_columns([column])._data)\n        except exceptions.NotFittedError as exc:\n            raise LearningError(\"\") from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit_transform",
      "name": "fit_transform",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/fit_transform/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.fit_transform.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "The list of column names to be encoded."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Label-encode the table with the label encoder.",
      "docstring": "Label-encode the table with the label encoder.\n\nParameters\n----------\ntable : Table\n    The table to be transformed.\ncolumns : list[str]\n    The list of column names to be encoded.\n\nReturns\n-------\ntable : Table\n    The label-encoded table.\n\nRaises\n-------\nNotFittedError\n    If the encoder wasn't fitted before transforming.",
      "code": "    def fit_transform(self, table: Table, columns: list[str]) -> Table:\n        \"\"\"\n        Label-encode the table with the label encoder.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be transformed.\n        columns : list[str]\n            The list of column names to be encoded.\n\n        Returns\n        -------\n        table : Table\n            The label-encoded table.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n\n        \"\"\"\n        p_df = table._data\n        p_df.columns = table.schema.get_column_names()\n        try:\n            for col in columns:\n                # Fit the LabelEncoder on the Column\n                self._le.fit(p_df[col])\n\n                # transform the column using the trained Label Encoder\n                p_df[col] = self._le.transform(p_df[col])\n            return Table(pandas.DataFrame(p_df))\n        except exceptions.NotFittedError as exc:\n            raise NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform",
      "name": "inverse_transform",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be inverse-transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/inverse_transform/column",
          "name": "column",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.inverse_transform.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column to be inverse-transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Inverse-transform the table back to its original encodings.",
      "docstring": "Inverse-transform the table back to its original encodings.\n\nParameters\n----------\ntable : Table\n    The table to be inverse-transformed.\ncolumn : str\n    The column to be inverse-transformed.\n\nReturns\n-------\ntable : Table\n    The inverse-transformed table.\n\nRaises\n-------\nNotFittedError\n    If the encoder wasn't fitted before transforming.",
      "code": "    def inverse_transform(self, table: Table, column: str) -> Table:\n        \"\"\"\n        Inverse-transform the table back to its original encodings.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be inverse-transformed.\n        column : str\n            The column to be inverse-transformed.\n\n        Returns\n        -------\n        table : Table\n            The inverse-transformed table.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n        \"\"\"\n\n        try:\n            p_df = table._data\n            p_df.columns = table.schema.get_column_names()\n            p_df[column] = self._le.inverse_transform(p_df[column])\n            return Table(p_df)\n        except exceptions.NotFittedError as exc:\n            raise NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table with target values."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/LabelEncoder/transform/column",
          "name": "column",
          "qname": "safeds.data.tabular.transformation._label_encoder.LabelEncoder.transform.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Transform the given table to a normalized encoded table.",
      "docstring": "Transform the given table to a normalized encoded table.\n\nParameters\n----------\ntable : Table\n        The table with target values.\ncolumn : str\n        The name of the column.\n\nReturns\n-------\nresult : Table\n    Table with normalized encodings.\n\nRaises\n------\nNotFittedError\n    If the Model wasn't fitted before transforming.",
      "code": "    def transform(self, table: Table, column: str) -> Table:\n        \"\"\"\n        Transform the given table to a normalized encoded table.\n\n        Parameters\n        ----------\n        table : Table\n                The table with target values.\n        column : str\n                The name of the column.\n\n        Returns\n        -------\n        result : Table\n            Table with normalized encodings.\n\n        Raises\n        ------\n        NotFittedError\n            If the Model wasn't fitted before transforming.\n        \"\"\"\n        p_df = table._data\n        p_df.columns = table.schema.get_column_names()\n        try:\n            p_df[column] = self._le.transform(p_df[column])\n            return Table(p_df)\n        except Exception as exc:\n            raise NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._label_encoder/warn",
      "name": "warn",
      "qname": "safeds.data.tabular.transformation._label_encoder.warn",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/warn/_",
          "name": "_",
          "qname": "safeds.data.tabular.transformation._label_encoder.warn._",
          "default_value": null,
          "assigned_by": "POSITIONAL_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._label_encoder/warn/__",
          "name": "__",
          "qname": "safeds.data.tabular.transformation._label_encoder.warn.__",
          "default_value": null,
          "assigned_by": "NAMED_VARARG",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def warn(*_: Any, **__: Any) -> None:\n    pass"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "The OneHotEncoder encodes categorical columns to numerical features [0,1] that represent the existence for each value.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._encoder = OHE_sklearn()"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the encoder."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]:",
            "default_value": "",
            "description": "The list of columns from the table used to fit the encoder."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]:"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit the encoder to a table.",
      "docstring": "Fit the encoder to a table.\n\nParameters\n----------\ntable : Table\n    The table used to fit the encoder.\ncolumns : list[str]:\n    The list of columns from the table used to fit the encoder.\n\nRaises\n----------\nLearningError\n    If there was an error during fitting.",
      "code": "    def fit(self, table: Table, columns: list[str]) -> None:\n        \"\"\"\n        Fit the encoder to a table.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the encoder.\n        columns : list[str]:\n            The list of columns from the table used to fit the encoder.\n\n        Raises\n        ----------\n        LearningError\n            If there was an error during fitting.\n        \"\"\"\n        try:\n            table_k_columns = table.keep_columns(column_names=columns)\n            df = table_k_columns._data\n            df.columns = table_k_columns.schema.get_column_names()\n            self._encoder.fit(df)\n        except exceptions.NotFittedError as exc:\n            raise LearningError(\"\") from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit_transform",
      "name": "fit_transform",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table used to fit the encoder and subsequently to be transformed"
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/fit_transform/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.fit_transform.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]:",
            "default_value": "",
            "description": "The list of columns from the table used to fit the encoder and subsequently to be transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]:"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit and transform data with a OneHotEncoder.",
      "docstring": "Fit and transform data with a OneHotEncoder.\n\nParameters\n----------\ntable : Table\n    The table used to fit the encoder and subsequently to be transformed\ncolumns : list[str]:\n    The list of columns from the table used to fit the encoder and subsequently to be transformed.\n\nReturns\n----------\ntable : Table\n    The transformed table.",
      "code": "    def fit_transform(self, table: Table, columns: list[str]) -> Table:\n        \"\"\"\n        Fit and transform data with a OneHotEncoder.\n\n        Parameters\n        ----------\n        table : Table\n            The table used to fit the encoder and subsequently to be transformed\n        columns : list[str]:\n            The list of columns from the table used to fit the encoder and subsequently to be transformed.\n\n        Returns\n        ----------\n        table : Table\n            The transformed table.\n\n        \"\"\"\n        self.fit(table, columns)\n        return self.transform(table)"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform",
      "name": "inverse_transform",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.inverse_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.inverse_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/inverse_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.inverse_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be inverse-transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Reset a transformed table to its original state.",
      "docstring": "Reset a transformed table to its original state.\n\nParameters\n----------\ntable : Table\n    The table to be inverse-transformed.\n\nReturns\n----------\ntable : Table\n    The inverse-transformed table.\n\nRaises\n----------\nNotFittedError\n    If the encoder wasn't fitted before transforming.",
      "code": "    def inverse_transform(self, table: Table) -> Table:\n        \"\"\"\n        Reset a transformed table to its original state.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be inverse-transformed.\n\n        Returns\n        ----------\n        table : Table\n            The inverse-transformed table.\n\n        Raises\n        ----------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n\n        \"\"\"\n        try:\n            data = self._encoder.inverse_transform(\n                table.keep_columns(self._encoder.get_feature_names_out())._data\n            )\n            df = pd.DataFrame(data)\n            df.columns = self._encoder.feature_names_in_\n            new_table = Table(df)\n            for col in table.drop_columns(\n                self._encoder.get_feature_names_out()\n            ).to_columns():\n                new_table = new_table.add_column(col)\n            return new_table\n        except exceptions.NotFittedError as exc:\n            raise NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._one_hot_encoder/OneHotEncoder/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._one_hot_encoder.OneHotEncoder.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The data to be transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Transform the data with the trained encoder.",
      "docstring": "Transform the data with the trained encoder.\n\nParameters\n----------\ntable : Table\n    The data to be transformed.\n\nReturns\n----------\ntable : Table\n    The transformed table.\n\nRaises\n----------\nNotFittedError\n    If the encoder wasn't fitted before transforming.",
      "code": "    def transform(self, table: Table) -> Table:\n        \"\"\"\n        Transform the data with the trained encoder.\n\n        Parameters\n        ----------\n        table : Table\n            The data to be transformed.\n\n        Returns\n        ----------\n        table : Table\n            The transformed table.\n\n        Raises\n        ----------\n        NotFittedError\n            If the encoder wasn't fitted before transforming.\n        \"\"\"\n        try:\n            table_k_columns = table.keep_columns(self._encoder.feature_names_in_)\n            df_k_columns = table_k_columns._data\n            df_k_columns.columns = table_k_columns.schema.get_column_names()\n            df_new = pd.DataFrame(self._encoder.transform(df_k_columns).toarray())\n            df_new.columns = self._encoder.get_feature_names_out()\n            df_concat = table._data.copy()\n            df_concat.columns = table.schema.get_column_names()\n            data_new = pd.concat([df_concat, df_new], axis=1).drop(\n                self._encoder.feature_names_in_, axis=1\n            )\n            return Table(data_new)\n        except Exception as exc:\n            raise NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/__init__/order",
          "name": "order",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.__init__.order",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This OrdinalEncoder encodes one or more given columns into ordinal numbers. The encoding order must be provided.\n\nParameters\n--------\norder : list[str]\n    The order in which the ordinal encoder encodes the values.",
      "docstring": "",
      "code": "    def __init__(self, order: list[str]) -> None:\n        self._is_fitted = 0\n        self._oe = preprocessing.OrdinalEncoder(categories=[order])\n        self._order = order"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit",
      "name": "fit",
      "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table containing the data used to fit the ordinal encoder."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column which should be ordinal-encoded."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit the ordinal encoder with the values in the given table.",
      "docstring": "Fit the ordinal encoder with the values in the given table.\n\nParameters\n----------\ntable : Table\n    The table containing the data used to fit the ordinal encoder.\ncolumn_name : str\n    The column which should be ordinal-encoded.\n\nReturns\n-------\nNone\n    This function does not return any value. It updates the internal state of the ordinal encoder object.\n\nRaises\n-------\nLearningError\n    If the model could not be fitted correctly.",
      "code": "    def fit(self, table: Table, column_name: str) -> None:\n        \"\"\"\n        Fit the ordinal encoder with the values in the given table.\n\n        Parameters\n        ----------\n        table : Table\n            The table containing the data used to fit the ordinal encoder.\n        column_name : str\n            The column which should be ordinal-encoded.\n\n        Returns\n        -------\n        None\n            This function does not return any value. It updates the internal state of the ordinal encoder object.\n\n        Raises\n        -------\n        LearningError\n            If the model could not be fitted correctly.\n        \"\"\"\n\n        p_df = table._data\n        p_df.columns = table.schema.get_column_names()\n        try:\n            self._oe.fit(p_df[[column_name]])\n        except exceptions.NotFittedError as exc:\n            raise exceptions.LearningError(\"\") from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit_transform",
      "name": "fit_transform",
      "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table which will be transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/fit_transform/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.fit_transform.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "The list of column names to be considered while encoding."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Oridnal-encode a given table with the given ordinal encoder.\nThe order is provided in the constructor. A new order will not be inferred from other columns.",
      "docstring": "Oridnal-encode a given table with the given ordinal encoder.\nThe order is provided in the constructor. A new order will not be inferred from other columns.\n\nParameters\n----------\ntable : Table\n    The table which will be transformed.\ncolumns : list[str]\n    The list of column names to be considered while encoding.\n\nReturns\n-------\ntable : Table\n    A new Table object which is ordinal-encoded.\n\nRaises\n-------\nNotFittedError\n    If the encoder was not fitted before transforming.\nKeyError\n    If the column does not exist.",
      "code": "    def fit_transform(self, table: Table, columns: list[str]) -> Table:\n        \"\"\"\n        Oridnal-encode a given table with the given ordinal encoder.\n        The order is provided in the constructor. A new order will not be inferred from other columns.\n\n        Parameters\n        ----------\n        table : Table\n            The table which will be transformed.\n        columns : list[str]\n            The list of column names to be considered while encoding.\n\n        Returns\n        -------\n        table : Table\n            A new Table object which is ordinal-encoded.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder was not fitted before transforming.\n        KeyError\n            If the column does not exist.\n\n        \"\"\"\n        try:\n            for col in columns:\n                # Fit the Ordinal Encoder on the Column\n                self.fit(table, col)\n                # transform the column using the trained Ordinal Encoder\n                table = self.transform(table, col)\n            return table\n        except exceptions.NotFittedError as exc:\n            raise exceptions.NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/inverse_transform",
      "name": "inverse_transform",
      "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.inverse_transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/inverse_transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.inverse_transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/inverse_transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.inverse_transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table to be inverse-transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/inverse_transform/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.inverse_transform.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column which should be inverse-transformed."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Inverse the transformed table back to original encodings.",
      "docstring": "Inverse the transformed table back to original encodings.\n\nParameters\n----------\ntable : Table\n    The table to be inverse-transformed.\ncolumn_name : str\n    The column which should be inverse-transformed.\n\nReturns\n-------\ntable : Table\n    The inverse-transformed table.\n\nRaises\n-------\nNotFittedError\n    If the encoder was not fitted before transforming.",
      "code": "    def inverse_transform(self, table: Table, column_name: str) -> Table:\n        \"\"\"\n        Inverse the transformed table back to original encodings.\n\n        Parameters\n        ----------\n        table : Table\n            The table to be inverse-transformed.\n        column_name : str\n            The column which should be inverse-transformed.\n\n        Returns\n        -------\n        table : Table\n            The inverse-transformed table.\n\n        Raises\n        -------\n        NotFittedError\n            If the encoder was not fitted before transforming.\n        \"\"\"\n\n        p_df = table._data.copy()\n        p_df.columns = table.schema.get_column_names()\n        try:\n            p_df[[column_name]] = self._oe.inverse_transform(p_df[[column_name]])\n            return Table(p_df)\n        except exceptions.NotFittedError as exc:\n            raise exceptions.NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/transform",
      "name": "transform",
      "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.transform",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/transform/self",
          "name": "self",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.transform.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/transform/table",
          "name": "table",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.transform.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table with target values."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.transformation._ordinal_encoder/OrdinalEncoder/transform/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.transformation._ordinal_encoder.OrdinalEncoder.transform.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Transform the given table to an ordinal-encoded table.",
      "docstring": "Transform the given table to an ordinal-encoded table.\n\nParameters\n----------\ntable : Table\n    The table with target values.\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ntable : Table\n    The table with ordinal encodings.\n\nRaises\n------\nNotFittedError\n    If the model was not fitted before transforming.",
      "code": "    def transform(self, table: Table, column_name: str) -> Table:\n        \"\"\"\n        Transform the given table to an ordinal-encoded table.\n\n        Parameters\n        ----------\n        table : Table\n            The table with target values.\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        table : Table\n            The table with ordinal encodings.\n\n        Raises\n        ------\n        NotFittedError\n            If the model was not fitted before transforming.\n        \"\"\"\n        p_df = table._data.copy()\n        p_df.columns = table.schema.get_column_names()\n        try:\n            p_df[[column_name]] = self._oe.transform(p_df[[column_name]])\n            p_df[column_name] = p_df[column_name].astype(dtype=\"int64\", copy=False)\n            return Table(p_df)\n        except Exception as exc:\n            raise exceptions.NotFittedError from exc"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.BooleanColumnType.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.BooleanColumnType.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"bool\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.BooleanColumnType.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/BooleanColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.BooleanColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_numeric(self) -> bool:\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/from_numpy_dtype",
      "name": "from_numpy_dtype",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType.from_numpy_dtype",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/from_numpy_dtype/_type",
          "name": "_type",
          "qname": "safeds.data.tabular.typing._column_type.ColumnType.from_numpy_dtype._type",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the column type for a given numpy dtype.\nParameters\n----------\n_type : numpy.dtype",
      "docstring": "Return the column type for a given numpy dtype.\nParameters\n----------\n_type : numpy.dtype\n\nReturns\n-------\ncolumn_type : ColumnType\n    The ColumnType.\n\nRaises\n-------\nTypeError\n    If an unexpected column type is parsed.",
      "code": "    @staticmethod\n    def from_numpy_dtype(_type: np.dtype) -> ColumnType:\n        \"\"\"\n        Return the column type for a given numpy dtype.\n        Parameters\n        ----------\n        _type : numpy.dtype\n\n        Returns\n        -------\n        column_type : ColumnType\n            The ColumnType.\n\n        Raises\n        -------\n        TypeError\n            If an unexpected column type is parsed.\n\n        \"\"\"\n        if _type.kind in (\"u\", \"i\"):\n            return IntColumnType()\n        if _type.kind == \"b\":\n            return BooleanColumnType()\n        if _type.kind == \"f\":\n            return FloatColumnType()\n        if _type.kind in (\"S\", \"U\", \"O\"):\n            return StringColumnType()\n        raise TypeError(\"Unexpected column type\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.ColumnType.is_numeric",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/ColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.ColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the given column type is numeric.\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "docstring": "Return whether the given column type is numeric.\nReturns\n-------\nis_numeric : bool\n    True if the column is numeric.",
      "code": "    @abstractmethod\n    def is_numeric(self) -> bool:\n        \"\"\"\n        Return whether the given column type is numeric.\n        Returns\n        -------\n        is_numeric : bool\n            True if the column is numeric.\n        \"\"\"\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.FloatColumnType.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.FloatColumnType.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"float\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.FloatColumnType.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/FloatColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.FloatColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_numeric(self) -> bool:\n        return True"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/IntColumnType/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.IntColumnType.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/IntColumnType/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.IntColumnType.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"int\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/IntColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.IntColumnType.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/IntColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.IntColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_numeric(self) -> bool:\n        return True"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.OptionalColumnType.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.OptionalColumnType.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return f\"optional({self._type.__repr__()})\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.OptionalColumnType.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/OptionalColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.OptionalColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_numeric(self) -> bool:\n        return self._type.is_numeric()"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/StringColumnType/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._column_type.StringColumnType.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/StringColumnType/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.StringColumnType.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return \"string\""
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._column_type/StringColumnType/is_numeric",
      "name": "is_numeric",
      "qname": "safeds.data.tabular.typing._column_type.StringColumnType.is_numeric",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._column_type/StringColumnType/is_numeric/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._column_type.StringColumnType.is_numeric.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def is_numeric(self) -> bool:\n        return False"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__eq__/o",
          "name": "o",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__eq__.o",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, o: object) -> bool:\n        if not isinstance(o, TableSchema):\n            return NotImplemented\n        if self is o:\n            return True\n        return self._schema == o._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__init__.schema",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict[str, ColumnType]",
            "default_value": "",
            "description": "Map from column names to data types."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "ColumnType]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Store column names and corresponding data types for a table.",
      "docstring": "",
      "code": "    def __init__(self, schema: dict[str, ColumnType]):\n        self._schema = dict(schema)  # Defensive copy"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        return self.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a print-string for the TableSchema.",
      "docstring": "Return a print-string for the TableSchema.\n\nReturns\n-------\noutput_string : str\n    The string.",
      "code": "    def __str__(self) -> str:\n        \"\"\"\n        Return a print-string for the TableSchema.\n\n        Returns\n        -------\n        output_string : str\n            The string.\n        \"\"\"\n        column_count = len(self._schema)\n        output_string = f\"TableSchema:\\nColumn Count: {column_count}\\nColumns:\\n\"\n        for column_name, data_type in self._schema.items():\n            output_string += f\"    {column_name}: {data_type}\\n\"\n        return output_string"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_from_dataframe",
      "name": "_from_dataframe",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema._from_dataframe",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_from_dataframe/dataframe",
          "name": "dataframe",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema._from_dataframe.dataframe",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "pd.Dataframe",
            "default_value": "",
            "description": "The Dataframe used to construct the TableSchema."
          },
          "type": {
            "kind": "NamedType",
            "name": "pd.Dataframe"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Construct a TableSchema from a Dataframe. This function is not supposed to be exposed to the user.",
      "docstring": "Construct a TableSchema from a Dataframe. This function is not supposed to be exposed to the user.\n\nParameters\n----------\ndataframe : pd.Dataframe\n    The Dataframe used to construct the TableSchema.\n\nReturns\n-------\n_from_dataframe: TableSchema\n    The constructed TableSchema.",
      "code": "    @staticmethod\n    def _from_dataframe(dataframe: pd.DataFrame) -> TableSchema:\n        \"\"\"\n        Construct a TableSchema from a Dataframe. This function is not supposed to be exposed to the user.\n\n        Parameters\n        ----------\n        dataframe : pd.Dataframe\n            The Dataframe used to construct the TableSchema.\n\n        Returns\n        -------\n        _from_dataframe: TableSchema\n            The constructed TableSchema.\n\n        \"\"\"\n\n        names = dataframe.columns\n        types = (ColumnType.from_numpy_dtype(dtype) for dtype in dataframe.dtypes)\n\n        return TableSchema(dict(zip(names, types)))"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_get_column_index_by_name",
      "name": "_get_column_index_by_name",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema._get_column_index_by_name",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_get_column_index_by_name/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema._get_column_index_by_name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/_get_column_index_by_name/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema._get_column_index_by_name.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the index of the column with specified column name.",
      "docstring": " Return the index of the column with specified column name.\n\n Parameters\n ----------\n column_name : str\n     The name of the column.\n\n Returns\n -------\nindex : int\n     The index of the column.",
      "code": "    def _get_column_index_by_name(self, column_name: str) -> int:\n        \"\"\"\n         Return the index of the column with specified column name.\n\n         Parameters\n         ----------\n         column_name : str\n             The name of the column.\n\n         Returns\n         -------\n        index : int\n             The index of the column.\n        \"\"\"\n\n        return list(self._schema.keys()).index(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_column_names",
      "name": "get_column_names",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.get_column_names",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_column_names/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.get_column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names saved in this schema.",
      "docstring": "Return a list of all column names saved in this schema.\n\nReturns\n-------\ncolumn_names : list[str]\n    The column names.",
      "code": "    def get_column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names saved in this schema.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n        \"\"\"\n        return list(self._schema.keys())"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_type_of_column",
      "name": "get_type_of_column",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.get_type_of_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_type_of_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.get_type_of_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/get_type_of_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.get_type_of_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the given column.",
      "docstring": "Return the type of the given column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_type_of_column(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n        return self._schema[column_name]"
    },
    {
      "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.typing._table_schema.TableSchema.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.typing._table_schema/TableSchema/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.typing._table_schema.TableSchema.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the schema contains a given column.",
      "docstring": "Return whether the schema contains a given column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncontains : bool\n    True if the schema contains the column.",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the schema contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the schema contains the column.\n        \"\"\"\n        return column_name in self._schema"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/ColumnLengthMismatchError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.ColumnLengthMismatchError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/ColumnLengthMismatchError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.ColumnLengthMismatchError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/ColumnLengthMismatchError/__init__/column_info",
          "name": "column_info",
          "qname": "safeds.exceptions._data_exceptions.ColumnLengthMismatchError.__init__.column_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when the lengths of two or more columns do not match.",
      "docstring": "",
      "code": "    def __init__(self, column_info: str):\n        super().__init__(f\"The length of at least one column differs: \\n{column_info}\")"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/ColumnSizeError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.ColumnSizeError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/ColumnSizeError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.ColumnSizeError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/ColumnSizeError/__init__/expected_size",
          "name": "expected_size",
          "qname": "safeds.exceptions._data_exceptions.ColumnSizeError.__init__.expected_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The expected size of the column as an expression (e.g. 2, >0, !=0)."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/ColumnSizeError/__init__/actual_size",
          "name": "actual_size",
          "qname": "safeds.exceptions._data_exceptions.ColumnSizeError.__init__.actual_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The actual size of the column as an expression (e.g. 2, >0, !=0)."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to use a column of unsupported size.",
      "docstring": "",
      "code": "    def __init__(self, expected_size: str, actual_size: str):\n        super().__init__(\n            f\"Expected a column of size {expected_size} but got column of size {actual_size}.\"\n        )"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/DuplicateColumnNameError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.DuplicateColumnNameError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/DuplicateColumnNameError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.DuplicateColumnNameError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/DuplicateColumnNameError/__init__/column_name",
          "name": "column_name",
          "qname": "safeds.exceptions._data_exceptions.DuplicateColumnNameError.__init__.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column that resulted in a duplicate."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to modify a table resulting in a duplicate column name.",
      "docstring": "",
      "code": "    def __init__(self, column_name: str):\n        super().__init__(f\"Column '{column_name}' already exists.\")"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/IndexOutOfBoundsError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.IndexOutOfBoundsError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/IndexOutOfBoundsError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.IndexOutOfBoundsError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/IndexOutOfBoundsError/__init__/index",
          "name": "index",
          "qname": "safeds.exceptions._data_exceptions.IndexOutOfBoundsError.__init__.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The wrongly used index."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an element by an index that does not exist in the underlying data.",
      "docstring": "",
      "code": "    def __init__(self, index: int):\n        super().__init__(f\"There is no element at index '{index}'.\")"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/MissingDataError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.MissingDataError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/MissingDataError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.MissingDataError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/MissingDataError/__init__/missing_data_info",
          "name": "missing_data_info",
          "qname": "safeds.exceptions._data_exceptions.MissingDataError.__init__.missing_data_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised if a function is not given enough data to succeed.",
      "docstring": "",
      "code": "    def __init__(self, missing_data_info: str):\n        super().__init__(f\"The function is missing data: \\n{missing_data_info}\")"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/MissingSchemaError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.MissingSchemaError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/MissingSchemaError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.MissingSchemaError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a required schema is missing.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Failed because a required schema is missing.\")"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/NonNumericColumnError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.NonNumericColumnError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/NonNumericColumnError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.NonNumericColumnError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/NonNumericColumnError/__init__/column_info",
          "name": "column_info",
          "qname": "safeds.exceptions._data_exceptions.NonNumericColumnError.__init__.column_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "docstring": "",
      "code": "    def __init__(self, column_info: str) -> None:\n        super().__init__(\n            f\"Tried to do a numerical operation on one or multiple non numerical Columns: \\n{column_info}\"\n        )"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/SchemaMismatchError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.SchemaMismatchError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/SchemaMismatchError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.SchemaMismatchError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when schemas are unequal.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Failed because at least two schemas didn't match.\")"
    },
    {
      "id": "stdlib/safeds.exceptions._data_exceptions/UnknownColumnNameError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._data_exceptions.UnknownColumnNameError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/UnknownColumnNameError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._data_exceptions.UnknownColumnNameError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._data_exceptions/UnknownColumnNameError/__init__/column_names",
          "name": "column_names",
          "qname": "safeds.exceptions._data_exceptions.UnknownColumnNameError.__init__.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "The name of the column that was tried to be accessed."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an invalid column name.",
      "docstring": "",
      "code": "    def __init__(self, column_names: list[str]):\n        super().__init__(f\"Could not find column(s) '{', '.join(column_names)}'\")"
    },
    {
      "id": "stdlib/safeds.exceptions._learning_exceptions/LearningError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._learning_exceptions.LearningError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._learning_exceptions/LearningError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._learning_exceptions.LearningError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._learning_exceptions/LearningError/__init__/reason",
          "name": "reason",
          "qname": "safeds.exceptions._learning_exceptions.LearningError.__init__.reason",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when an error occurred while training a model.",
      "docstring": "",
      "code": "    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while learning\")\n        else:\n            super().__init__(f\"Error occurred while learning: {reason}\")"
    },
    {
      "id": "stdlib/safeds.exceptions._learning_exceptions/NotFittedError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._learning_exceptions.NotFittedError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._learning_exceptions/NotFittedError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._learning_exceptions.NotFittedError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a model is used before fitting it.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Model is not fitted, please fit it before using it\")"
    },
    {
      "id": "stdlib/safeds.exceptions._learning_exceptions/PredictionError/__init__",
      "name": "__init__",
      "qname": "safeds.exceptions._learning_exceptions.PredictionError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.exceptions._learning_exceptions/PredictionError/__init__/self",
          "name": "self",
          "qname": "safeds.exceptions._learning_exceptions.PredictionError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.exceptions._learning_exceptions/PredictionError/__init__/reason",
          "name": "reason",
          "qname": "safeds.exceptions._learning_exceptions.PredictionError.__init__.reason",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when an error occurred while prediction a target vector using a model.",
      "docstring": "",
      "code": "    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while predicting\")\n        else:\n            super().__init__(f\"Error occurred while predicting: {reason}\")"
    },
    {
      "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classification._ada_boost.AdaBoost.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classification._ada_boost.AdaBoost.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Ada Boost classification. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._classification = sk_AdaBoostClassifier()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._ada_boost.AdaBoost.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._ada_boost.AdaBoost.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._ada_boost.AdaBoost.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._ada_boost.AdaBoost.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._ada_boost.AdaBoost.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._ada_boost.AdaBoost.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._ada_boost/AdaBoost/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._ada_boost.AdaBoost.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._classifier/Classifier/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._classifier.Classifier.fit",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._classifier/Classifier/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._classifier.Classifier.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._classifier/Classifier/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._classifier.Classifier.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    @abstractmethod\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._classifier/Classifier/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._classifier.Classifier.predict",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._classifier/Classifier/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._classifier.Classifier.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._classifier/Classifier/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._classifier.Classifier.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._classifier/Classifier/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._classifier.Classifier.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    @abstractmethod\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classification._decision_tree.DecisionTree.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classification._decision_tree.DecisionTree.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements decision tree regression. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._classification = sk_DecisionTreeClassifier()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._decision_tree.DecisionTree.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._decision_tree.DecisionTree.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._decision_tree.DecisionTree.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._decision_tree.DecisionTree.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._decision_tree.DecisionTree.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._decision_tree.DecisionTree.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._decision_tree/DecisionTree/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._decision_tree.DecisionTree.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements gradient boosting classification. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._classification = GradientBoostingClassifier()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._gradient_boosting_classification/GradientBoosting/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._gradient_boosting_classification.GradientBoosting.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/__init__/n_neighbors",
          "name": "n_neighbors",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.__init__.n_neighbors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The number of neighbors to be interpolated with. Has to be less than or equal to the sample size."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements K-nearest-neighbors classifier. It can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self, n_neighbors: int) -> None:\n        self._classification = KNeighborsClassifier(n_jobs=-1, n_neighbors=n_neighbors)\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._k_nearest_neighbors/KNearestNeighbors/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._k_nearest_neighbors.KNearestNeighbors.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements regularized logistic regression. It is used as a classifier model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._classification = sk_LogisticRegression(n_jobs=-1)\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._logistic_regression/LogisticRegression/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._logistic_regression.LogisticRegression.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/__init__",
      "name": "__init__",
      "qname": "safeds.ml.classification._random_forest.RandomForest.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/__init__/self",
          "name": "self",
          "qname": "safeds.ml.classification._random_forest.RandomForest.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements the Random Forest classification. It can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._classification = RandomForestClassifier(n_jobs=-1)\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/fit",
      "name": "fit",
      "qname": "safeds.ml.classification._random_forest.RandomForest.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/fit/self",
          "name": "self",
          "qname": "safeds.ml.classification._random_forest.RandomForest.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.classification._random_forest.RandomForest.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(\n            self._classification, tagged_table\n        )"
    },
    {
      "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/predict",
      "name": "predict",
      "qname": "safeds.ml.classification._random_forest.RandomForest.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/predict/self",
          "name": "self",
          "qname": "safeds.ml.classification._random_forest.RandomForest.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.classification._random_forest.RandomForest.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.classification._random_forest/RandomForest/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.classification._random_forest.RandomForest.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._classification,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._ada_boost.AdaBoost.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._ada_boost.AdaBoost.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Ada Boost regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = sk_AdaBoostRegressor()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._ada_boost.AdaBoost.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._ada_boost.AdaBoost.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._ada_boost.AdaBoost.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._ada_boost.AdaBoost.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._ada_boost.AdaBoost.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._ada_boost.AdaBoost.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._ada_boost/AdaBoost/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._ada_boost.AdaBoost.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._decision_tree.DecisionTree.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._decision_tree.DecisionTree.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Decision Tree regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = sk_DecisionTreeRegressor()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._decision_tree.DecisionTree.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._decision_tree.DecisionTree.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._decision_tree.DecisionTree.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._decision_tree.DecisionTree.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._decision_tree.DecisionTree.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._decision_tree.DecisionTree.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._decision_tree/DecisionTree/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._decision_tree.DecisionTree.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name:  Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name:  Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements elastic net regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = sk_ElasticNet()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._elastic_net_regression/ElasticNetRegression/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._elastic_net_regression.ElasticNetRegression.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name: Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements gradient boosting regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = GradientBoostingRegressor()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.\n\nParameters\n\n----------\ntagged_table : SupervisedDataset\n    The tagged table containing the feature and target vectors.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n\n----------\ntagged_table : SupervisedDataset\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n\n        ----------\n        tagged_table : SupervisedDataset\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._gradient_boosting_regression/GradientBoosting/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._gradient_boosting_regression.GradientBoosting.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/__init__/n_neighbors",
          "name": "n_neighbors",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.__init__.n_neighbors",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The number of neighbors to be interpolated with. Has to be less than or equal than the sample size."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements K-nearest-neighbors regressor. It can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self, n_neighbors: int) -> None:\n        self._regression = KNeighborsRegressor(n_neighbors)\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._k_nearest_neighbors/KNearestNeighbors/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._k_nearest_neighbors.KNearestNeighbors.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name: Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._lasso_regression.LassoRegression.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._lasso_regression.LassoRegression.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements lasso regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = sk_Lasso()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._lasso_regression.LassoRegression.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._lasso_regression.LassoRegression.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._lasso_regression.LassoRegression.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._lasso_regression.LassoRegression.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._lasso_regression.LassoRegression.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._lasso_regression.LassoRegression.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._lasso_regression/LassoRegression/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._lasso_regression.LassoRegression.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name: Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._linear_regression.LinearRegression.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._linear_regression.LinearRegression.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements linear regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = sk_LinearRegression(n_jobs=-1)\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._linear_regression.LinearRegression.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._linear_regression.LinearRegression.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._linear_regression.LinearRegression.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._linear_regression.LinearRegression.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._linear_regression.LinearRegression.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._linear_regression.LinearRegression.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._linear_regression/LinearRegression/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._linear_regression.LinearRegression.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name: Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._random_forest.RandomForest.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._random_forest.RandomForest.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements Random Forest regression. It can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = RandomForestRegressor(n_jobs=-1)\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._random_forest.RandomForest.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._random_forest.RandomForest.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._random_forest.RandomForest.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._random_forest.RandomForest.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._random_forest.RandomForest.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._random_forest.RandomForest.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._random_forest/RandomForest/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._random_forest.RandomForest.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression._regressor/Regressor/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._regressor.Regressor.fit",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._regressor/Regressor/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._regressor.Regressor.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._regressor/Regressor/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._regressor.Regressor.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    @abstractmethod\n    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._regressor/Regressor/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._regressor.Regressor.predict",
      "decorators": [
        "abstractmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._regressor/Regressor/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._regressor.Regressor.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._regressor/Regressor/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._regressor.Regressor.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._regressor/Regressor/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._regressor.Regressor.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name: Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default.\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    @abstractmethod\n    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name: Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default.\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/__init__",
      "name": "__init__",
      "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/__init__/self",
          "name": "self",
          "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "This class implements ridge regression. It is used as a regression model.\nIt can only be trained on a tagged table.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        self._regression = sk_Ridge()\n        self.target_name = \"\""
    },
    {
      "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/fit",
      "name": "fit",
      "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.fit",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/fit/self",
          "name": "self",
          "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.fit.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/fit/tagged_table",
          "name": "tagged_table",
          "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.fit.tagged_table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "TaggedTable",
            "default_value": "",
            "description": "The tagged table containing the feature and target vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "TaggedTable"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Fit this model given a tagged table.",
      "docstring": "Fit this model given a tagged table.\n\nParameters\n----------\ntagged_table : TaggedTable\n    The tagged table containing the feature and target vectors.\n\nRaises\n------\nLearningError\n    If the tagged table contains invalid values or if the training failed.",
      "code": "    def fit(self, tagged_table: TaggedTable) -> None:\n        \"\"\"\n        Fit this model given a tagged table.\n\n        Parameters\n        ----------\n        tagged_table : TaggedTable\n            The tagged table containing the feature and target vectors.\n\n        Raises\n        ------\n        LearningError\n            If the tagged table contains invalid values or if the training failed.\n        \"\"\"\n        self.target_name = safeds.ml._util_sklearn.fit(self._regression, tagged_table)"
    },
    {
      "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/predict",
      "name": "predict",
      "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.predict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/predict/self",
          "name": "self",
          "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.predict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/predict/dataset",
          "name": "dataset",
          "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.predict.dataset",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The dataset containing the feature vectors."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression._ridge_regression/RidgeRegression/predict/target_name",
          "name": "target_name",
          "qname": "safeds.ml.regression._ridge_regression.RidgeRegression.predict.target_name",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[str]",
            "default_value": "",
            "description": "The name of the target vector. The name of the target column inferred from fit is used by default"
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.",
      "docstring": "Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\nParameters\n----------\ndataset : Table\n    The dataset containing the feature vectors.\ntarget_name : Optional[str]\n    The name of the target vector. The name of the target column inferred from fit is used by default\n\nReturns\n-------\ntable : Table\n    A dataset containing the given feature vectors and the predicted target vector.\n\nRaises\n------\nPredictionError\n    If prediction with the given dataset failed.",
      "code": "    def predict(self, dataset: Table, target_name: Optional[str] = None) -> Table:\n        \"\"\"\n        Predict a target vector using a dataset containing feature vectors. The model has to be trained first.\n\n        Parameters\n        ----------\n        dataset : Table\n            The dataset containing the feature vectors.\n        target_name : Optional[str]\n            The name of the target vector. The name of the target column inferred from fit is used by default\n\n        Returns\n        -------\n        table : Table\n            A dataset containing the given feature vectors and the predicted target vector.\n\n        Raises\n        ------\n        PredictionError\n            If prediction with the given dataset failed.\n        \"\"\"\n        return safeds.ml._util_sklearn.predict(\n            self._regression,\n            dataset,\n            target_name if target_name is not None else self.target_name,\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/_check_metrics_preconditions",
      "name": "_check_metrics_preconditions",
      "qname": "safeds.ml.regression.metrics._module_level_functions._check_metrics_preconditions",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/_check_metrics_preconditions/actual",
          "name": "actual",
          "qname": "safeds.ml.regression.metrics._module_level_functions._check_metrics_preconditions.actual",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/_check_metrics_preconditions/expected",
          "name": "expected",
          "qname": "safeds.ml.regression.metrics._module_level_functions._check_metrics_preconditions.expected",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "def _check_metrics_preconditions(actual: Column, expected: Column) -> None:\n    if not actual.type.is_numeric():\n        raise TypeError(f\"Column 'actual' is not numerical but {actual.type}.\")\n    if not expected.type.is_numeric():\n        raise TypeError(f\"Column 'expected' is not numerical but {expected.type}.\")\n\n    if actual._data.size != expected._data.size:\n        raise ColumnLengthMismatchError(\n            \"\\n\".join(\n                [f\"{column.name}: {column._data.size}\" for column in [actual, expected]]\n            )\n        )"
    },
    {
      "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/mean_absolute_error",
      "name": "mean_absolute_error",
      "qname": "safeds.ml.regression.metrics._module_level_functions.mean_absolute_error",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/mean_absolute_error/actual",
          "name": "actual",
          "qname": "safeds.ml.regression.metrics._module_level_functions.mean_absolute_error.actual",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/mean_absolute_error/expected",
          "name": "expected",
          "qname": "safeds.ml.regression.metrics._module_level_functions.mean_absolute_error.expected",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mean absolute error, calculated from a given known truth and a column to compare.",
      "docstring": "Return the mean absolute error, calculated from a given known truth and a column to compare.\n\nParameters\n----------\nactual: Column\n    The column containing estimated values.\nexpected: Column\n    The column containing ground truth.\n\nReturns\n-------\nmean_absolute_error : float\n    The calculated mean absolute error (the average of the distance of each individual row).",
      "code": "def mean_absolute_error(actual: Column, expected: Column) -> float:\n    \"\"\"\n    Return the mean absolute error, calculated from a given known truth and a column to compare.\n\n    Parameters\n    ----------\n    actual: Column\n        The column containing estimated values.\n    expected: Column\n        The column containing ground truth.\n\n    Returns\n    -------\n    mean_absolute_error : float\n        The calculated mean absolute error (the average of the distance of each individual row).\n    \"\"\"\n    _check_metrics_preconditions(actual, expected)\n    return mean_absolute_error_sklearn(expected._data.tolist(), actual._data.tolist())"
    },
    {
      "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/mean_squared_error",
      "name": "mean_squared_error",
      "qname": "safeds.ml.regression.metrics._module_level_functions.mean_squared_error",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/mean_squared_error/actual",
          "name": "actual",
          "qname": "safeds.ml.regression.metrics._module_level_functions.mean_squared_error.actual",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The column containing estimated values."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        },
        {
          "id": "stdlib/safeds.ml.regression.metrics._module_level_functions/mean_squared_error/expected",
          "name": "expected",
          "qname": "safeds.ml.regression.metrics._module_level_functions.mean_squared_error.expected",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The column containing ground truth."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mean squared error, calculated from a given known truth and a column to compare.",
      "docstring": "Return the mean squared error, calculated from a given known truth and a column to compare.\n\nParameters\n----------\nactual : Column\n    The column containing estimated values.\nexpected : Column\n    The column containing ground truth.\n\nReturns\n-------\nmean_squared_error : float\n    The calculated mean squared error (the average of the distance of each individual row squared).",
      "code": "def mean_squared_error(actual: Column, expected: Column) -> float:\n    \"\"\"\n    Return the mean squared error, calculated from a given known truth and a column to compare.\n\n    Parameters\n    ----------\n    actual : Column\n        The column containing estimated values.\n    expected : Column\n        The column containing ground truth.\n\n    Returns\n    -------\n    mean_squared_error : float\n        The calculated mean squared error (the average of the distance of each individual row squared).\n    \"\"\"\n    _check_metrics_preconditions(actual, expected)\n    return mean_squared_error_sklearn(expected._data.tolist(), actual._data.tolist())"
    },
    {
      "id": "stdlib/safeds.plotting._boxplot/boxplot",
      "name": "boxplot",
      "qname": "safeds.plotting._boxplot.boxplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.plotting._boxplot/boxplot/column",
          "name": "column",
          "qname": "safeds.plotting._boxplot.boxplot.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The column to be plotted."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a column in a boxplot. This function can only plot real numerical data.",
      "docstring": "Plot a column in a boxplot. This function can only plot real numerical data.\n\nParameters\n----------\ncolumn : Column\n    The column to be plotted.\n\nRaises\n-------\nTypeError\n    If the column contains non-numerical data or complex data.",
      "code": "def boxplot(column: Column) -> None:\n    \"\"\"\n    Plot a column in a boxplot. This function can only plot real numerical data.\n\n    Parameters\n    ----------\n    column : Column\n        The column to be plotted.\n\n    Raises\n    -------\n    TypeError\n        If the column contains non-numerical data or complex data.\n    \"\"\"\n    # noinspection PyProtectedMember\n    for data in column._data:\n        if (\n            not isinstance(data, int)\n            and not isinstance(data, float)\n            and not isinstance(data, complex)\n        ):\n            raise NonNumericColumnError(column.name)\n        if isinstance(data, complex):\n            raise TypeError(\n                \"The column contains complex data. Boxplots cannot plot the imaginary part of complex \"\n                \"data. Please provide a Column with only real numbers\"\n            )\n    # noinspection PyProtectedMember\n    ax = sns.boxplot(data=column._data)\n    ax.set(xlabel=column.name)\n    plt.tight_layout()\n    plt.show()"
    },
    {
      "id": "stdlib/safeds.plotting._correlation_heatmap/correlation_heatmap",
      "name": "correlation_heatmap",
      "qname": "safeds.plotting._correlation_heatmap.correlation_heatmap",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.plotting._correlation_heatmap/correlation_heatmap/table",
          "name": "table",
          "qname": "safeds.plotting._correlation_heatmap.correlation_heatmap.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The column to be plotted."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a correlation heatmap of an entire table. This function can only plot real numerical data.",
      "docstring": "Plot a correlation heatmap of an entire table. This function can only plot real numerical data.\n\nParameters\n----------\ntable : Table\n    The column to be plotted.\n\nRaises\n-------\nTypeError\n    If the table contains non-numerical data or complex data.",
      "code": "def correlation_heatmap(table: Table) -> None:\n    \"\"\"\n    Plot a correlation heatmap of an entire table. This function can only plot real numerical data.\n\n    Parameters\n    ----------\n    table : Table\n        The column to be plotted.\n\n    Raises\n    -------\n    TypeError\n        If the table contains non-numerical data or complex data.\n    \"\"\"\n    # noinspection PyProtectedMember\n    for column in table.to_columns():\n        if not column.type.is_numeric():\n            raise NonNumericColumnError(column.name)\n    # noinspection PyProtectedMember\n    sns.heatmap(\n        data=table._data.corr(),\n        vmin=-1,\n        vmax=1,\n        xticklabels=table.get_column_names(),\n        yticklabels=table.get_column_names(),\n        cmap=\"vlag\",\n    )\n    plt.tight_layout()\n    plt.show()"
    },
    {
      "id": "stdlib/safeds.plotting._histogram/histogram",
      "name": "histogram",
      "qname": "safeds.plotting._histogram.histogram",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.plotting._histogram/histogram/column",
          "name": "column",
          "qname": "safeds.plotting._histogram.histogram.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The column to be plotted."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a column in a histogram.",
      "docstring": "Plot a column in a histogram.\n\nParameters\n----------\ncolumn : Column\n    The column to be plotted.",
      "code": "def histogram(column: Column) -> None:\n    \"\"\"\n    Plot a column in a histogram.\n\n    Parameters\n    ----------\n    column : Column\n        The column to be plotted.\n    \"\"\"\n    # noinspection PyProtectedMember\n    ax = sns.histplot(data=column._data)\n    ax.set_xticks(ax.get_xticks())\n    ax.set(xlabel=column.name)\n    ax.set_xticklabels(\n        ax.get_xticklabels(), rotation=45, horizontalalignment=\"right\"\n    )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n    plt.tight_layout()\n    plt.show()"
    },
    {
      "id": "stdlib/safeds.plotting._lineplot/lineplot",
      "name": "lineplot",
      "qname": "safeds.plotting._lineplot.lineplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.plotting._lineplot/lineplot/table",
          "name": "table",
          "qname": "safeds.plotting._lineplot.lineplot.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table containing the data to be plotted."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.plotting._lineplot/lineplot/x",
          "name": "x",
          "qname": "safeds.plotting._lineplot.lineplot.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the x-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.plotting._lineplot/lineplot/y",
          "name": "y",
          "qname": "safeds.plotting._lineplot.lineplot.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the y-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot two columns against each other in a lineplot. If there are multiple x-values for a y-value,\nthe resulting plot will consist of a line representing the mean and the lower-transparency area around the line\nrepresenting the 95% confidence interval.",
      "docstring": "Plot two columns against each other in a lineplot. If there are multiple x-values for a y-value,\nthe resulting plot will consist of a line representing the mean and the lower-transparency area around the line\nrepresenting the 95% confidence interval.\n\nParameters\n----------\ntable : Table\n    The table containing the data to be plotted.\nx : str\n    The column name of the column to be plotted on the x-Axis.\ny : str\n    The column name of the column to be plotted on the y-Axis.\n\nRaises\n---------\nUnknownColumnNameError\n    If either of the columns do not exist.",
      "code": "def lineplot(table: Table, x: str, y: str) -> None:\n    \"\"\"\n    Plot two columns against each other in a lineplot. If there are multiple x-values for a y-value,\n    the resulting plot will consist of a line representing the mean and the lower-transparency area around the line\n    representing the 95% confidence interval.\n\n    Parameters\n    ----------\n    table : Table\n        The table containing the data to be plotted.\n    x : str\n        The column name of the column to be plotted on the x-Axis.\n    y : str\n        The column name of the column to be plotted on the y-Axis.\n\n    Raises\n    ---------\n    UnknownColumnNameError\n        If either of the columns do not exist.\n    \"\"\"\n    # noinspection PyProtectedMember\n    if not table.has_column(x):\n        raise UnknownColumnNameError([x])\n    if not table.has_column(y):\n        raise UnknownColumnNameError([y])\n\n    ax = sns.lineplot(\n        data=table._data,\n        x=table.schema._get_column_index_by_name(x),\n        y=table.schema._get_column_index_by_name(y),\n    )\n    ax.set(xlabel=x, ylabel=y)\n    ax.set_xticks(ax.get_xticks())\n    ax.set_xticklabels(\n        ax.get_xticklabels(), rotation=45, horizontalalignment=\"right\"\n    )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n    plt.tight_layout()\n    plt.show()"
    },
    {
      "id": "stdlib/safeds.plotting._scatterplot/scatterplot",
      "name": "scatterplot",
      "qname": "safeds.plotting._scatterplot.scatterplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.plotting._scatterplot/scatterplot/table",
          "name": "table",
          "qname": "safeds.plotting._scatterplot.scatterplot.table",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Table",
            "default_value": "",
            "description": "The table containing the data to be plotted."
          },
          "type": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "id": "stdlib/safeds.plotting._scatterplot/scatterplot/x",
          "name": "x",
          "qname": "safeds.plotting._scatterplot.scatterplot.x",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the x-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.plotting._scatterplot/scatterplot/y",
          "name": "y",
          "qname": "safeds.plotting._scatterplot.scatterplot.y",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the y-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot two columns against each other in a scatterplot.",
      "docstring": "Plot two columns against each other in a scatterplot.\n\nParameters\n----------\ntable : Table\n    The table containing the data to be plotted.\nx : str\n    The column name of the column to be plotted on the x-Axis.\ny : str\n    The column name of the column to be plotted on the y-Axis.\n\nRaises\n---------\nUnknownColumnNameError\n    If either of the columns do not exist.",
      "code": "def scatterplot(table: Table, x: str, y: str) -> None:\n    \"\"\"\n    Plot two columns against each other in a scatterplot.\n\n    Parameters\n    ----------\n    table : Table\n        The table containing the data to be plotted.\n    x : str\n        The column name of the column to be plotted on the x-Axis.\n    y : str\n        The column name of the column to be plotted on the y-Axis.\n\n    Raises\n    ---------\n    UnknownColumnNameError\n        If either of the columns do not exist.\n    \"\"\"\n    # noinspection PyProtectedMember\n    if not table.has_column(x):\n        raise UnknownColumnNameError([x])\n    if not table.has_column(y):\n        raise UnknownColumnNameError([y])\n\n    ax = sns.scatterplot(\n        data=table._data,\n        x=table.schema._get_column_index_by_name(x),\n        y=table.schema._get_column_index_by_name(y),\n    )\n    ax.set(xlabel=x, ylabel=y)\n    ax.set_xticks(ax.get_xticks())\n    ax.set_xticklabels(\n        ax.get_xticklabels(), rotation=45, horizontalalignment=\"right\"\n    )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n    plt.tight_layout()\n    plt.show()"
    }
  ]
}