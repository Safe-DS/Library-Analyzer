{
  "schemaVersion": 1,
  "distribution": "",
  "package": "stdlib",
  "version": "",
  "modules": [],
  "classes": [
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column",
      "name": "Column",
      "qname": "safeds.data.tabular.containers._column.Column",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._column/Column/__init__",
        "stdlib/safeds.data.tabular.containers._column/Column/__eq__",
        "stdlib/safeds.data.tabular.containers._column/Column/__getitem__",
        "stdlib/safeds.data.tabular.containers._column/Column/__hash__",
        "stdlib/safeds.data.tabular.containers._column/Column/__iter__",
        "stdlib/safeds.data.tabular.containers._column/Column/__len__",
        "stdlib/safeds.data.tabular.containers._column/Column/__repr__",
        "stdlib/safeds.data.tabular.containers._column/Column/__str__",
        "stdlib/safeds.data.tabular.containers._column/Column/name@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/n_rows@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/type@getter",
        "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values",
        "stdlib/safeds.data.tabular.containers._column/Column/get_value",
        "stdlib/safeds.data.tabular.containers._column/Column/all",
        "stdlib/safeds.data.tabular.containers._column/Column/any",
        "stdlib/safeds.data.tabular.containers._column/Column/none",
        "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values",
        "stdlib/safeds.data.tabular.containers._column/Column/rename",
        "stdlib/safeds.data.tabular.containers._column/Column/correlation_with",
        "stdlib/safeds.data.tabular.containers._column/Column/idness",
        "stdlib/safeds.data.tabular.containers._column/Column/maximum",
        "stdlib/safeds.data.tabular.containers._column/Column/mean",
        "stdlib/safeds.data.tabular.containers._column/Column/median",
        "stdlib/safeds.data.tabular.containers._column/Column/minimum",
        "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio",
        "stdlib/safeds.data.tabular.containers._column/Column/mode",
        "stdlib/safeds.data.tabular.containers._column/Column/stability",
        "stdlib/safeds.data.tabular.containers._column/Column/standard_deviation",
        "stdlib/safeds.data.tabular.containers._column/Column/sum",
        "stdlib/safeds.data.tabular.containers._column/Column/variance",
        "stdlib/safeds.data.tabular.containers._column/Column/plot_boxplot",
        "stdlib/safeds.data.tabular.containers._column/Column/plot_histogram",
        "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_",
        "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A column is a named collection of values.",
      "docstring": "A column is a named collection of values.\n\nParameters\n----------\nname : str\n    The name of the column.\ndata : Iterable\n    The data.\ntype_ : Optional[ColumnType]\n    The type of the column. If not specified, the type will be inferred from the data.",
      "code": "class Column:\n    \"\"\"\n    A column is a named collection of values.\n\n    Parameters\n    ----------\n    name : str\n        The name of the column.\n    data : Iterable\n        The data.\n    type_ : Optional[ColumnType]\n        The type of the column. If not specified, the type will be inferred from the data.\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(self, name: str, data: Iterable, type_: ColumnType | None = None) -> None:\n        self._name: str = name\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        # noinspection PyProtectedMember\n        self._type: ColumnType = type_ if type_ is not None else ColumnType._from_numpy_data_type(self._data.dtype)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Column):\n            return NotImplemented\n        if self is other:\n            return True\n        return self.name == other.name and self._data.equals(other._data)\n\n    def __getitem__(self, index: int) -> Any:\n        return self.get_value(index)\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)\n\n    def __len__(self) -> int:\n        return len(self._data)\n\n    def __repr__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__str__()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of the column.\n\n        Returns\n        -------\n        name : str\n            The name of the column.\n        \"\"\"\n        return self._name\n\n    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of elements in the column.\n\n        Returns\n        -------\n        n_rows : int\n            The number of elements.\n        \"\"\"\n        return len(self._data)\n\n    @property\n    def type(self) -> ColumnType:\n        \"\"\"\n        Return the type of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n        \"\"\"\n        return self._type\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Getters\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def get_unique_values(self) -> list[Any]:\n        \"\"\"\n        Return a list of all unique values in the column.\n\n        Returns\n        -------\n        unique_values : list[any]\n            List of unique values in the column.\n        \"\"\"\n        return list(self._data.unique())\n\n    def get_value(self, index: int) -> Any:\n        \"\"\"\n        Return column value at specified index, starting at 0.\n\n        Parameters\n        ----------\n        index : int\n            Index of requested element.\n\n        Returns\n        -------\n        value\n            Value at index in column.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If the given index does not exist in the column.\n        \"\"\"\n        if index < 0 or index >= self._data.size:\n            raise IndexOutOfBoundsError(index)\n\n        return self._data[index]\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Information\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def all(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if all values have a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if all match.\n\n        \"\"\"\n        return all(predicate(value) for value in self._data)\n\n    def any(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if any value has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if any match.\n\n        \"\"\"\n        return any(predicate(value) for value in self._data)\n\n    def none(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if no values has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if none match.\n\n        \"\"\"\n        return all(not predicate(value) for value in self._data)\n\n    def has_missing_values(self) -> bool:\n        \"\"\"\n        Return whether the column has missing values.\n\n        Returns\n        -------\n        missing_values_exist : bool\n            True if missing values exist.\n        \"\"\"\n        return self.any(lambda value: value is None or (isinstance(value, Number) and np.isnan(value)))\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Transformations\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def rename(self, new_name: str) -> Column:\n        \"\"\"\n        Return a new column with a new name.\n\n        Parameters\n        ----------\n        new_name : str\n            The new name of the column.\n\n        Returns\n        -------\n        column : Column\n            A new column with the new name.\n        \"\"\"\n        return Column(new_name, self._data, self._type)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Statistics\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def correlation_with(self, other_column: Column) -> float:\n        \"\"\"\n        Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\n        Returns\n        -------\n        correlation : float\n            Correlation between the two columns.\n\n        Raises\n        ------\n        TypeError\n            If one of the columns is not numerical.\n        \"\"\"\n        if not self._type.is_numeric() or not other_column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"Columns must be numerical. {self.name} is {self._type}, \"\n                f\"{other_column.name} is {other_column._type}.\",\n            )\n        if self._data.size != other_column._data.size:\n            raise ColumnLengthMismatchError(\n                f\"{self.name} is of size {self._data.size}, \"\n                f\"{other_column.name} is of size {other_column._data.size}.\",\n            )\n        return self._data.corr(other_column._data)\n\n    def idness(self) -> float:\n        r\"\"\"\n        Calculate the idness of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of different values}}{\\text{number of rows}}\n        $$\n\n        Returns\n        -------\n        idness : float\n            The idness of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If this column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.nunique() / self._data.size\n\n    def maximum(self) -> float:\n        \"\"\"\n        Return the maximum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        max : float\n            The maximum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.max()\n\n    def mean(self) -> float:\n        \"\"\"\n        Return the mean value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        mean : float\n            The mean value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.mean()\n\n    def median(self) -> float:\n        \"\"\"\n        Return the median value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        median : float\n            The median value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.median()\n\n    def minimum(self) -> float:\n        \"\"\"\n        Return the minimum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        min : float\n            The minimum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.min()\n\n    def missing_value_ratio(self) -> float:\n        \"\"\"\n        Return the ratio of null values to the total number of elements in the column.\n\n        Returns\n        -------\n        ratio : float\n            The ratio of null values to the total number of elements in the column.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._count_missing_values() / self._data.size\n\n    def mode(self) -> Any:\n        \"\"\"\n        Return the mode of the column.\n\n        Returns\n        -------\n        List :\n            Returns a list with the most common values.\n        \"\"\"\n        return self._data.mode().tolist()\n\n    def stability(self) -> float:\n        r\"\"\"\n        Calculate the stability of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n        $$\n\n        Returns\n        -------\n        stability : float\n            The stability of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If the column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.value_counts()[self.mode()[0]] / self._data.count()\n\n    def standard_deviation(self) -> float:\n        \"\"\"\n        Return the standard deviation of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The standard deviation of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.std()\n\n    def sum(self) -> float:\n        \"\"\"\n        Return the sum of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The sum of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.sum()\n\n    def variance(self) -> float:\n        \"\"\"\n        Return the variance of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The variance of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n\n        return self._data.var()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Plotting\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def plot_boxplot(self) -> Image:\n        \"\"\"\n        Plot this column in a boxplot. This function can only plot real numerical data.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        TypeError\n            If the column contains non-numerical data or complex data.\n        \"\"\"\n        for data in self._data:\n            if not isinstance(data, int) and not isinstance(data, float) and not isinstance(data, complex):\n                raise NonNumericColumnError(self.name)\n            if isinstance(data, complex):\n                raise TypeError(\n                    \"The column contains complex data. Boxplots cannot plot the imaginary part of complex \"\n                    \"data. Please provide a Column with only real numbers\",\n                )\n\n        fig = plt.figure()\n        ax = sns.boxplot(data=self._data)\n        ax.set(xlabel=self.name)\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)\n\n    def plot_histogram(self) -> Image:\n        \"\"\"\n        Plot a column in a histogram.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        fig = plt.figure()\n        ax = sns.histplot(data=self._data)\n        ax.set_xticks(ax.get_xticks())\n        ax.set(xlabel=self.name)\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Other\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _count_missing_values(self) -> int:\n        \"\"\"\n        Return the number of null values in the column.\n\n        Returns\n        -------\n        count : int\n            The number of null values.\n        \"\"\"\n        return self._data.isna().sum()",
      "instance_attributes": [
        {
          "name": "_name",
          "types": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_type",
          "types": {
            "kind": "NamedType",
            "name": "ColumnType"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row",
      "name": "Row",
      "qname": "safeds.data.tabular.containers._row.Row",
      "decorators": [],
      "superclasses": [
        "Mapping[str, Any]"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.containers._row/Row/from_dict",
        "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe",
        "stdlib/safeds.data.tabular.containers._row/Row/__init__",
        "stdlib/safeds.data.tabular.containers._row/Row/__contains__",
        "stdlib/safeds.data.tabular.containers._row/Row/__eq__",
        "stdlib/safeds.data.tabular.containers._row/Row/__getitem__",
        "stdlib/safeds.data.tabular.containers._row/Row/__iter__",
        "stdlib/safeds.data.tabular.containers._row/Row/__len__",
        "stdlib/safeds.data.tabular.containers._row/Row/__repr__",
        "stdlib/safeds.data.tabular.containers._row/Row/__str__",
        "stdlib/safeds.data.tabular.containers._row/Row/column_names@getter",
        "stdlib/safeds.data.tabular.containers._row/Row/n_columns@getter",
        "stdlib/safeds.data.tabular.containers._row/Row/schema@getter",
        "stdlib/safeds.data.tabular.containers._row/Row/get_value",
        "stdlib/safeds.data.tabular.containers._row/Row/has_column",
        "stdlib/safeds.data.tabular.containers._row/Row/get_column_type",
        "stdlib/safeds.data.tabular.containers._row/Row/to_dict",
        "stdlib/safeds.data.tabular.containers._row/Row/_repr_html_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A row is a collection of named values.",
      "docstring": "A row is a collection of named values.\n\nParameters\n----------\ndata : Mapping[str, Any] | None\n    The data. If None, an empty row is created.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})",
      "code": "class Row(Mapping[str, Any]):\n    \"\"\"\n    A row is a collection of named values.\n\n    Parameters\n    ----------\n    data : Mapping[str, Any] | None\n        The data. If None, an empty row is created.\n\n    Examples\n    --------\n    >>> from safeds.data.tabular.containers import Row\n    >>> row = Row({\"a\": 1, \"b\": 2})\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Creation\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def from_dict(data: dict[str, Any]) -> Row:\n        \"\"\"\n        Create a row from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, Any]\n            The data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row.from_dict({\"a\": 1, \"b\": 2})\n        \"\"\"\n        return Row(data)\n\n    @staticmethod\n    def _from_polars_dataframe(data: pl.DataFrame, schema: Schema | None = None) -> Row:\n        \"\"\"\n        Create a row from a `polars.DataFrame`.\n\n        Parameters\n        ----------\n        data : polars.DataFrame\n            The data.\n        schema : Schema | None\n            The schema. If None, the schema is inferred from the data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> import polars as pl\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row._from_polars_dataframe(pl.DataFrame({\"a\": [1], \"b\": [2]}))\n        \"\"\"\n        result = object.__new__(Row)\n        result._data = data\n\n        if schema is None:\n            # noinspection PyProtectedMember\n            result._schema = Schema._from_polars_dataframe(data)\n        else:\n            result._schema = schema\n\n        return result\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(self, data: Mapping[str, Any] | None = None):\n        \"\"\"\n        Create a row from a mapping of column names to column values.\n\n        Parameters\n        ----------\n        data : Mapping[str, Any] | None\n            The data. If None, an empty row is created.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        \"\"\"\n        if data is None:\n            data = {}\n\n        self._data: pl.DataFrame = pl.DataFrame(data)\n        # noinspection PyProtectedMember\n        self._schema: Schema = Schema._from_polars_dataframe(self._data)\n\n    def __contains__(self, obj: Any) -> bool:\n        \"\"\"\n        Check whether the row contains an object as key.\n\n        Parameters\n        ----------\n        obj : Any\n            The object.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the object as key, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> \"a\" in row\n        True\n\n        >>> \"c\" in row\n        False\n        \"\"\"\n        return isinstance(obj, str) and self.has_column(obj)\n\n    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Check whether this row is equal to another object.\n\n        Parameters\n        ----------\n        other : Any\n            The other object.\n\n        Returns\n        -------\n        equal : bool\n            True if the other object is an identical row. False if the other object is a different row. NotImplemented\n            if the other object is not a row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row1 = Row({\"a\": 1, \"b\": 2})\n        >>> row2 = Row({\"a\": 1, \"b\": 2})\n        >>> row1 == row2\n        True\n\n        >>> row3 = Row({\"a\": 1, \"b\": 3})\n        >>> row1 == row3\n        False\n        \"\"\"\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._schema == other._schema and self._data.frame_equal(other._data)\n\n    def __getitem__(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row[\"a\"]\n        1\n        \"\"\"\n        return self.get_value(column_name)\n\n    def __iter__(self) -> Iterator[Any]:\n        \"\"\"\n        Create an iterator for the column names of this row.\n\n        Returns\n        -------\n        iterator : Iterator[Any]\n            The iterator.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> list(row)\n        ['a', 'b']\n        \"\"\"\n        return iter(self.column_names)\n\n    def __len__(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> len(row)\n        2\n        \"\"\"\n        return self._data.width\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return an unambiguous string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> repr(row)\n        \"Row({'a': 1})\"\n        \"\"\"\n        return f\"Row({str(self)})\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Return a user-friendly string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> str(row)\n        \"{'a': 1}\"\n        \"\"\"\n        match len(self):\n            case 0:\n                return \"{}\"\n            case 1:\n                return str(self.to_dict())\n            case _:\n                lines = (f\"    {name!r}: {value!r}\" for name, value in self.to_dict().items())\n                joined = \",\\n\".join(lines)\n                return f\"{{\\n{joined}\\n}}\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in the row.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.column_names\n        ['a', 'b']\n        \"\"\"\n        return self._schema.column_names\n\n    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.n_columns\n        2\n        \"\"\"\n        return self._data.width\n\n    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the row.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> schema = row.schema\n        \"\"\"\n        return self._schema\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Getters\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def get_value(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_value(\"a\")\n        1\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n\n        return self._data[0, column_name]\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Check whether the row contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the column, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.has_column(\"a\")\n        True\n\n        >>> row.has_column(\"c\")\n        False\n        \"\"\"\n        return self._schema.has_column(column_name)\n\n    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_column_type(\"a\")\n        Integer\n        \"\"\"\n        return self._schema.get_column_type(column_name)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Conversion\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def to_dict(self) -> dict[str, Any]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, Any]\n            Dictionary representation of the row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.to_dict()\n        {'a': 1, 'b': 2}\n        \"\"\"\n        return {column_name: self.get_value(column_name) for column_name in self.column_names}\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _repr_html_(self) -> str:\n        \"\"\"\n        Return an HTML representation of the row.\n\n        Returns\n        -------\n        output : str\n            The generated HTML.\n        \"\"\"\n        # noinspection PyProtectedMember\n        return self._data._repr_html_()",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_schema",
          "types": {
            "kind": "NamedType",
            "name": "Schema"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table",
      "name": "Table",
      "qname": "safeds.data.tabular.containers._table.Table",
      "decorators": [],
      "superclasses": [],
      "methods": [
        "stdlib/safeds.data.tabular.containers._table/Table/from_csv_file",
        "stdlib/safeds.data.tabular.containers._table/Table/from_json_file",
        "stdlib/safeds.data.tabular.containers._table/Table/from_dict",
        "stdlib/safeds.data.tabular.containers._table/Table/from_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/from_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/__init__",
        "stdlib/safeds.data.tabular.containers._table/Table/__eq__",
        "stdlib/safeds.data.tabular.containers._table/Table/__hash__",
        "stdlib/safeds.data.tabular.containers._table/Table/__repr__",
        "stdlib/safeds.data.tabular.containers._table/Table/__str__",
        "stdlib/safeds.data.tabular.containers._table/Table/column_names@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/n_columns@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/n_rows@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/schema@getter",
        "stdlib/safeds.data.tabular.containers._table/Table/get_column",
        "stdlib/safeds.data.tabular.containers._table/Table/has_column",
        "stdlib/safeds.data.tabular.containers._table/Table/get_column_type",
        "stdlib/safeds.data.tabular.containers._table/Table/get_row",
        "stdlib/safeds.data.tabular.containers._table/Table/summary",
        "stdlib/safeds.data.tabular.containers._table/Table/add_column",
        "stdlib/safeds.data.tabular.containers._table/Table/add_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/add_row",
        "stdlib/safeds.data.tabular.containers._table/Table/add_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/filter_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_missing_values",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_non_numerical_values",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_duplicate_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_missing_values",
        "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_outliers",
        "stdlib/safeds.data.tabular.containers._table/Table/rename_column",
        "stdlib/safeds.data.tabular.containers._table/Table/replace_column",
        "stdlib/safeds.data.tabular.containers._table/Table/shuffle_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/slice_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/sort_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/sort_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/split",
        "stdlib/safeds.data.tabular.containers._table/Table/tag_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/transform_column",
        "stdlib/safeds.data.tabular.containers._table/Table/plot_correlation_heatmap",
        "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot",
        "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot",
        "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file",
        "stdlib/safeds.data.tabular.containers._table/Table/to_json_file",
        "stdlib/safeds.data.tabular.containers._table/Table/to_dict",
        "stdlib/safeds.data.tabular.containers._table/Table/to_columns",
        "stdlib/safeds.data.tabular.containers._table/Table/to_rows",
        "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_",
        "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\nTo create a `Table`, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "docstring": "A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\nTo create a `Table`, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "code": "class Table:\n    \"\"\"\n    A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\n    To create a `Table`, use one of the following static methods:\n\n    | Method                                                                       | Description                            |\n    | ---------------------------------------------------------------------------- | -------------------------------------- |\n    | [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n    | [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n    | [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n    | [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n    | [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Creation\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def from_csv_file(path: str) -> Table:\n        \"\"\"\n        Read data from a CSV file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the CSV file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the CSV file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_csv(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n\n    @staticmethod\n    def from_json_file(path: str) -> Table:\n        \"\"\"\n        Read data from a JSON file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the JSON file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the JSON file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_json(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception\n\n    @staticmethod\n    def from_dict(data: dict[str, list[Any]]) -> Table:\n        \"\"\"\n        Create a table from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, list[Any]]\n            The data.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If columns have different lengths.\n        \"\"\"\n        # Validation\n        expected_length: int | None = None\n        for column_values in data.values():\n            if expected_length is None:\n                expected_length = len(column_values)\n            elif len(column_values) != expected_length:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column_name}: {len(column_values)}\" for column_name, column_values in data.items()),\n                )\n\n        # Implementation\n        dataframe: DataFrame = pd.DataFrame()\n        for column_name, column_values in data.items():\n            dataframe[column_name] = column_values\n        return Table(dataframe)\n\n    @staticmethod\n    def from_columns(columns: list[Column]) -> Table:\n        \"\"\"\n        Return a table created from a list of columns.\n\n        Parameters\n        ----------\n        columns : list[Column]\n            The columns to be combined. They need to have the same size.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If any of the column sizes does not match with the others.\n        \"\"\"\n        dataframe: DataFrame = pd.DataFrame()\n\n        for column in columns:\n            if column._data.size != columns[0]._data.size:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column.name}: {column._data.size}\" for column in columns),\n                )\n            dataframe[column.name] = column._data\n\n        return Table(dataframe)\n\n    @staticmethod\n    def from_rows(rows: list[Row]) -> Table:\n        \"\"\"\n        Return a table created from a list of rows.\n\n        Parameters\n        ----------\n        rows : list[Row]\n            The rows to be combined. They need to have a matching schema.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        SchemaMismatchError\n            If any of the row schemas does not match with the others.\n        \"\"\"\n        if len(rows) == 0:\n            raise MissingDataError(\"This function requires at least one row.\")\n\n        schema_compare: Schema = rows[0]._schema\n        row_array: list[pd.DataFrame] = []\n\n        for row in rows:\n            if schema_compare != row._schema:\n                raise SchemaMismatchError\n            row_array.append(row._data.to_pandas())\n\n        dataframe: DataFrame = pd.concat(row_array, ignore_index=True)\n        dataframe.columns = schema_compare.column_names\n        return Table(dataframe)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(self, data: Iterable, schema: Schema | None = None):\n        \"\"\"\n        Create a table from a `DataFrame`.\n\n        You should not use this constructor directly. Instead, use one of the following static methods:\n\n        | Method                                                                       | Description                            |\n        | ---------------------------------------------------------------------------- | -------------------------------------- |\n        | [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n        | [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n        | [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n        | [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n        | [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |\n        \"\"\"\n        self._data: pd.DataFrame = data if isinstance(data, pd.DataFrame) else pd.DataFrame(data)\n        self._schema: Schema = Schema._from_pandas_dataframe(self._data) if schema is None else schema\n\n        if self._data.empty:\n            self._data = pd.DataFrame(columns=self._schema.column_names)\n\n        self._data = self._data.reset_index(drop=True)\n        self._data.columns = self._schema.column_names\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Table):\n            return NotImplemented\n        if self is other:\n            return True\n        table1 = self.sort_columns()\n        table2 = other.sort_columns()\n        return table1._data.equals(table2._data) and table1._schema == table2._schema\n\n    def __hash__(self) -> int:\n        return hash(self._data)\n\n    def __repr__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__str__()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in this table.\n\n        Alias for self.schema.column_names -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The list of the column names.\n        \"\"\"\n        return self._schema.column_names\n\n    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n        \"\"\"\n        return self._data.shape[1]\n\n    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of rows.\n\n        Returns\n        -------\n        n_rows : int\n            The number of rows.\n        \"\"\"\n        return self._data.shape[0]\n\n    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the table.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        return self._schema\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Getters\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def get_column(self, column_name: str) -> Column:\n        \"\"\"\n        Return a column with the data of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        column : Column\n            The column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if self._schema.has_column(column_name):\n            output_column = Column(\n                column_name,\n                self._data.iloc[:, [self._schema._get_column_index(column_name)]].squeeze(),\n                self._schema.get_column_type(column_name),\n            )\n            return output_column\n\n        raise UnknownColumnNameError([column_name])\n\n    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the table contains a given column.\n\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the column exists.\n        \"\"\"\n        return self._schema.has_column(column_name)\n\n    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column to be queried.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self._schema.get_column_type(column_name)\n\n    def get_row(self, index: int) -> Row:\n        \"\"\"\n        Return the row at a specified index.\n\n        Parameters\n        ----------\n        index : int\n            The index.\n\n        Returns\n        -------\n        row : Row\n            The row of the table at the index.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If no row at the specified index exists in this table.\n        \"\"\"\n        if len(self._data.index) - 1 < index or index < 0:\n            raise IndexOutOfBoundsError(index)\n\n        return Row._from_polars_dataframe(pl.DataFrame(self._data.iloc[[index]]), self._schema)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Information\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def summary(self) -> Table:\n        \"\"\"\n        Return a table with a number of statistical key values.\n\n        Returns\n        -------\n        result : Table\n            The table with statistics.\n        \"\"\"\n        columns = self.to_columns()\n        result = pd.DataFrame()\n        statistics = {}\n\n        for column in columns:\n            statistics = {\n                \"maximum\": column.maximum,\n                \"minimum\": column.minimum,\n                \"mean\": column.mean,\n                \"mode\": column.mode,\n                \"median\": column.median,\n                \"sum\": column.sum,\n                \"variance\": column.variance,\n                \"standard deviation\": column.standard_deviation,\n                \"idness\": column.idness,\n                \"stability\": column.stability,\n            }\n            values = []\n\n            for function in statistics.values():\n                try:\n                    values.append(str(function()))\n                except NonNumericColumnError:\n                    values.append(\"-\")\n\n            result = pd.concat([result, pd.DataFrame(values)], axis=1)\n\n        result = pd.concat([pd.DataFrame(list(statistics.keys())), result], axis=1)\n        result.columns = [\"metrics\", *self.column_names]\n\n        return Table(result)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Transformations\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def add_column(self, column: Column) -> Table:\n        \"\"\"\n        Return the original table with the provided column attached at the end.\n\n        Returns\n        -------\n        result : Table\n            The table with the column attached.\n\n        Raises\n        ------\n        DuplicateColumnNameError\n            If the new column already exists.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n\n        \"\"\"\n        if self.has_column(column.name):\n            raise DuplicateColumnNameError(column.name)\n\n        if column._data.size != self.n_rows:\n            raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        result[column.name] = column._data\n        return Table(result)\n\n    def add_columns(self, columns: list[Column] | Table) -> Table:\n        \"\"\"\n        Add multiple columns to the table.\n\n        Parameters\n        ----------\n        columns : list[Column] or Table\n            The columns to be added.\n\n        Returns\n        -------\n        result: Table\n            A new table combining the original table and the given columns.\n\n        Raises\n        ------\n        ColumnSizeError\n            If at least one of the column sizes from the provided column list does not match the table.\n        DuplicateColumnNameError\n            If at least one column name from the provided column list already exists in the table.\n        \"\"\"\n        if isinstance(columns, Table):\n            columns = columns.to_columns()\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        for column in columns:\n            if column.name in result.columns:\n                raise DuplicateColumnNameError(column.name)\n\n            if column._data.size != self.n_rows:\n                raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n            result[column.name] = column._data\n        return Table(result)\n\n    def add_row(self, row: Row) -> Table:\n        \"\"\"\n        Add a row to the table.\n\n        Parameters\n        ----------\n        row : Row\n            The row to be added.\n\n        Returns\n        -------\n        table : Table\n            A new table with the added row at the end.\n\n        \"\"\"\n        if self._schema != row.schema:\n            raise SchemaMismatchError\n\n        row_frame = row._data.to_pandas()\n\n        new_df = pd.concat([self._data, row_frame]).infer_objects()\n        new_df.columns = self.column_names\n        return Table(new_df)\n\n    def add_rows(self, rows: list[Row] | Table) -> Table:\n        \"\"\"\n        Add multiple rows to a table.\n\n        Parameters\n        ----------\n        rows : list[Row] or Table\n            The rows to be added.\n\n        Returns\n        -------\n        result : Table\n            A new table which combines the original table and the given rows.\n        \"\"\"\n        if isinstance(rows, Table):\n            rows = rows.to_rows()\n        result = self._data\n        for row in rows:\n            if self._schema != row.schema:\n                raise SchemaMismatchError\n\n        row_frames = [row._data.to_pandas() for row in rows]\n        for row_frame in row_frames:\n            row_frame.columns = self.column_names\n\n        result = pd.concat([result, *row_frames]).infer_objects()\n        result.columns = self.column_names\n        return Table(result)\n\n    def filter_rows(self, query: Callable[[Row], bool]) -> Table:\n        \"\"\"\n        Return a table with rows filtered by Callable (e.g. lambda function).\n\n        Parameters\n        ----------\n        query : lambda function\n            A Callable that is applied to all rows.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the rows filtered by the query.\n        \"\"\"\n        rows: list[Row] = [row for row in self.to_rows() if query(row)]\n        if len(rows) == 0:\n            result_table = Table([], self._schema)\n        else:\n            result_table = self.from_rows(rows)\n        return result_table\n\n    def keep_only_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table with only the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing only the columns to be kept.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the given column(s).\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data[column_names]\n        transformed_data.columns = column_names\n        return Table(transformed_data)\n\n    def remove_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table without the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing all columns to be dropped.\n\n        Returns\n        -------\n        table : Table\n            A table without the given columns.\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data.drop(labels=column_names, axis=\"columns\")\n        transformed_data.columns = [name for name in self._schema.column_names if name not in column_names]\n        return Table(transformed_data)\n\n    def remove_columns_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain missing values.\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if not column.has_missing_values()])\n\n    def remove_columns_with_non_numerical_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain non-numerical values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain non-numerical values.\n\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if column.type.is_numeric()])\n\n    def remove_duplicate_rows(self) -> Table:\n        \"\"\"\n        Return a copy of the table with every duplicate row removed.\n\n        Returns\n        -------\n        result : Table\n            The table with the duplicate rows removed.\n        \"\"\"\n        result = self._data.drop_duplicates(ignore_index=True)\n        result.columns = self._schema.column_names\n        return Table(result)\n\n    def remove_rows_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the rows that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the rows that contain missing values.\n        \"\"\"\n        result = self._data.copy(deep=True)\n        result = result.dropna(axis=\"index\")\n        return Table(result, self._schema)\n\n    def remove_rows_with_outliers(self) -> Table:\n        \"\"\"\n        Remove all rows from the table that contain at least one outlier.\n\n        We define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\n        Missing values are not considered outliers. They are also ignored during the calculation of the standard\n        deviation.\n\n        Returns\n        -------\n        new_table : Table\n            A new table without rows containing outliers.\n        \"\"\"\n        copy = self._data.copy(deep=True)\n\n        table_without_nonnumericals = self.remove_columns_with_non_numerical_values()\n        z_scores = np.absolute(stats.zscore(table_without_nonnumericals._data, nan_policy=\"omit\"))\n        filter_ = ((z_scores < 3) | np.isnan(z_scores)).all(axis=1)\n\n        return Table(copy[filter_], self._schema)\n\n    def rename_column(self, old_name: str, new_name: str) -> Table:\n        \"\"\"\n        Rename a single column.\n\n        Parameters\n        ----------\n        old_name : str\n            The old name of the target column\n        new_name : str\n            The new name of the target column\n\n        Returns\n        -------\n        table : Table\n            The Table with the renamed column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified old target column name does not exist.\n        DuplicateColumnNameError\n            If the specified new target column name already exists.\n        \"\"\"\n        if old_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_name])\n        if old_name == new_name:\n            return self\n        if new_name in self._schema.column_names:\n            raise DuplicateColumnNameError(new_name)\n\n        new_df = self._data.copy()\n        new_df.columns = self._schema.column_names\n        return Table(new_df.rename(columns={old_name: new_name}))\n\n    def replace_column(self, old_column_name: str, new_column: Column) -> Table:\n        \"\"\"\n        Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\n        Parameters\n        ----------\n        old_column_name : str\n            The name of the column to be replaced.\n\n        new_column : Column\n            The new column replacing the old column.\n\n        Returns\n        -------\n        result : Table\n            A table with the old column replaced by the new column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the old column does not exist.\n\n        DuplicateColumnNameError\n            If the new column already exists and the existing column is not affected by the replacement.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n        \"\"\"\n        if old_column_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_column_name])\n\n        if new_column.name in self._schema.column_names and new_column.name != old_column_name:\n            raise DuplicateColumnNameError(new_column.name)\n\n        if self.n_rows != new_column._data.size:\n            raise ColumnSizeError(str(self.n_rows), str(new_column._data.size))\n\n        if old_column_name != new_column.name:\n            renamed_table = self.rename_column(old_column_name, new_column.name)\n            result = renamed_table._data\n            result.columns = renamed_table._schema.column_names\n        else:\n            result = self._data.copy()\n            result.columns = self._schema.column_names\n\n        result[new_column.name] = new_column._data\n        return Table(result)\n\n    def shuffle_rows(self) -> Table:\n        \"\"\"\n        Shuffle the table randomly.\n\n        Returns\n        -------\n        result : Table\n            The shuffled Table.\n\n        \"\"\"\n        new_df = self._data.sample(frac=1.0)\n        new_df.columns = self._schema.column_names\n        return Table(new_df)\n\n    def slice_rows(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n        step: int = 1,\n    ) -> Table:\n        \"\"\"\n        Slice a part of the table into a new table.\n\n        Parameters\n        ----------\n        start : int\n            The first index of the range to be copied into a new table, None by default.\n        end : int\n            The last index of the range to be copied into a new table, None by default.\n        step : int\n            The step size used to iterate through the table, 1 by default.\n\n        Returns\n        -------\n        result : Table\n            The resulting table.\n\n        Raises\n        ------\n        ValueError\n            If the index is out of bounds.\n        \"\"\"\n        if start is None:\n            start = 0\n\n        if end is None:\n            end = self.n_rows\n\n        if start < 0 or end < 0 or start >= self.n_rows or end > self.n_rows or end < start:\n            raise ValueError(\"The given index is out of bounds\")\n\n        new_df = self._data.iloc[start:end:step]\n        new_df.columns = self._schema.column_names\n        return Table(new_df)\n\n    def sort_columns(\n        self,\n        comparator: Callable[[Column, Column], int] = lambda col1, col2: (col1.name > col2.name)\n        - (col1.name < col2.name),\n    ) -> Table:\n        \"\"\"\n        Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\n        returns an integer:\n\n        * If `col1` should be ordered before `col2`, the function should return a negative number.\n        * If `col1` should be ordered after `col2`, the function should return a positive number.\n        * If the original order of `col1` and `col2` should be kept, the function should return 0.\n\n        If no comparator is given, the columns will be sorted alphabetically by their name.\n\n        Parameters\n        ----------\n        comparator : Callable[[Column, Column], int]\n            The function used to compare two columns.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted columns.\n        \"\"\"\n        columns = self.to_columns()\n        columns.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_columns(columns)\n\n    def sort_rows(self, comparator: Callable[[Row, Row], int]) -> Table:\n        \"\"\"\n        Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\n        returns an integer:\n\n        * If `row1` should be ordered before `row2`, the function should return a negative number.\n        * If `row1` should be ordered after `row2`, the function should return a positive number.\n        * If the original order of `row1` and `row2` should be kept, the function should return 0.\n\n        Parameters\n        ----------\n        comparator : Callable[[Row, Row], int]\n            The function used to compare two rows.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted rows.\n        \"\"\"\n        rows = self.to_rows()\n        rows.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_rows(rows)\n\n    def split(self, percentage_in_first: float) -> tuple[Table, Table]:\n        \"\"\"\n        Split the table into two new tables.\n\n        Parameters\n        ----------\n        percentage_in_first : float\n            The desired size of the first table in percentage to the given table.\n\n        Returns\n        -------\n        result : (Table, Table)\n            A tuple containing the two resulting tables. The first table has the specified size, the second table\n            contains the rest of the data.\n\n\n        \"\"\"\n        if percentage_in_first <= 0 or percentage_in_first >= 1:\n            raise ValueError(\"the given percentage is not in range\")\n        return (\n            self.slice_rows(0, round(percentage_in_first * self.n_rows)),\n            self.slice_rows(round(percentage_in_first * self.n_rows)),\n        )\n\n    def tag_columns(self, target_name: str, feature_names: list[str] | None = None) -> TaggedTable:\n        \"\"\"\n        Mark the columns of the table as target column or feature columns. The original table is not modified.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target column.\n        feature_names : Optional[list[str]]\n            Names of the feature columns. If None, all columns except the target column are used.\n\n        Returns\n        -------\n        tagged_table : TaggedTable\n            A new tagged table with the given target and feature names.\n        \"\"\"\n        from ._tagged_table import TaggedTable\n\n        return TaggedTable(self._data, target_name, feature_names, self._schema)\n\n    def transform_column(self, name: str, transformer: Callable[[Row], Any]) -> Table:\n        \"\"\"\n        Transform provided column by calling provided transformer.\n\n        Returns\n        -------\n        result : Table\n            The table with the transformed column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the column does not exist.\n\n        \"\"\"\n        if self.has_column(name):\n            items: list = [transformer(item) for item in self.to_rows()]\n            result: Column = Column(name, pd.Series(items))\n            return self.replace_column(name, result)\n        raise UnknownColumnNameError([name])\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Plotting\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def plot_correlation_heatmap(self) -> Image:\n        \"\"\"\n        Plot a correlation heatmap for all numerical columns of this `Table`.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        only_numerical = self.remove_columns_with_non_numerical_values()\n\n        fig = plt.figure()\n        sns.heatmap(\n            data=only_numerical._data.corr(),\n            vmin=-1,\n            vmax=1,\n            xticklabels=only_numerical.column_names,\n            yticklabels=only_numerical.column_names,\n            cmap=\"vlag\",\n        )\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)\n\n    def plot_lineplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a lineplot.\n\n        If there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\n        and the lower-transparency area around the line representing the 95% confidence interval.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.lineplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)\n\n    def plot_scatterplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a scatterplot.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.scatterplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Conversion\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def to_csv_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a CSV file.\n\n        If the file and/or the directories do not exist they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_csv = self._data.copy()\n        data_to_csv.columns = self._schema.column_names\n        data_to_csv.to_csv(path, index=False)\n\n    def to_json_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a JSON file.\n\n        If the file and/or the directories do not exist, they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_json = self._data.copy()\n        data_to_json.columns = self._schema.column_names\n        data_to_json.to_json(path)\n\n    def to_dict(self) -> dict[str, list[Any]]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, list[Any]]\n            Dictionary representation of the table.\n        \"\"\"\n        return {column_name: list(self.get_column(column_name)) for column_name in self.column_names}\n\n    def to_columns(self) -> list[Column]:\n        \"\"\"\n        Return a list of the columns.\n\n        Returns\n        -------\n        columns : list[Columns]\n            List of columns.\n        \"\"\"\n        return [self.get_column(name) for name in self._schema.column_names]\n\n    def to_rows(self) -> list[Row]:\n        \"\"\"\n        Return a list of the rows.\n\n        Returns\n        -------\n        rows : list[Row]\n            List of rows.\n        \"\"\"\n        return [\n            Row._from_polars_dataframe(\n                pl.DataFrame([list(series_row)], schema=self._schema.column_names),\n                self._schema,\n            )\n            for (_, series_row) in self._data.iterrows()\n        ]\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dataframe interchange protocol\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True):  # type: ignore[no-untyped-def]\n        \"\"\"\n        Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\n        Generally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\n        allow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\n        decide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\n        interchange protocol.\n\n        The specification of the dataframe interchange protocol can be found on\n        [GitHub](https://github.com/data-apis/dataframe-api).\n\n        Parameters\n        ----------\n        nan_as_null : bool\n            Whether to replace missing values in the data with `NaN`.\n        allow_copy : bool\n            Whether memory may be copied to create the DataFrame exchange object.\n\n        Returns\n        -------\n        dataframe\n            A DataFrame object that conforms to the dataframe interchange protocol.\n        \"\"\"\n        if not allow_copy:\n            raise NotImplementedError(\"For the moment we need to copy the data, so `allow_copy` must be True.\")\n\n        data_copy = self._data.copy()\n        data_copy.columns = self.column_names\n        return data_copy.__dataframe__(nan_as_null, allow_copy)",
      "instance_attributes": [
        {
          "name": "_data",
          "types": null
        },
        {
          "name": "_schema",
          "types": {
            "kind": "NamedType",
            "name": "Schema"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable",
      "name": "TaggedTable",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable",
      "decorators": [],
      "superclasses": [
        "Table"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/features@getter",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target@getter",
        "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.",
      "docstring": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.\n\nParameters\n----------\ndata : Iterable\n    The data.\ntarget_name : str\n    Name of the target column.\nfeature_names : Optional[list[str]]\n    Names of the feature columns. If None, all columns except the target column are used.\nschema : Optional[Schema]\n    The schema of the table. If not specified, the schema will be inferred from the data.",
      "code": "class TaggedTable(Table):\n    \"\"\"\n    A tagged table is a table that additionally knows which columns are features and which are the target to predict.\n\n    Parameters\n    ----------\n    data : Iterable\n        The data.\n    target_name : str\n        Name of the target column.\n    feature_names : Optional[list[str]]\n        Names of the feature columns. If None, all columns except the target column are used.\n    schema : Optional[Schema]\n        The schema of the table. If not specified, the schema will be inferred from the data.\n    \"\"\"\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def __init__(\n        self,\n        data: Iterable,\n        target_name: str,\n        feature_names: list[str] | None = None,\n        schema: Schema | None = None,\n    ):\n        super().__init__(data, schema)\n\n        # If no feature names are specified, use all columns except the target column\n        if feature_names is None:\n            feature_names = self.column_names\n            if target_name in feature_names:\n                feature_names.remove(target_name)\n\n        # Validate inputs\n        if target_name in feature_names:\n            raise ValueError(f\"Column '{target_name}' cannot be both feature and target.\")\n        if len(feature_names) == 0:\n            raise ValueError(\"At least one feature column must be specified.\")\n\n        self._features: Table = self.keep_only_columns(feature_names)\n        self._target: Column = self.get_column(target_name)\n\n    def __repr__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__repr__()\n\n    def __str__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__str__()\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------------------------------------------------------\n\n    @property\n    def features(self) -> Table:\n        return self._features\n\n    @property\n    def target(self) -> Column:\n        return self._target\n\n    # ------------------------------------------------------------------------------------------------------------------\n    # IPython integration\n    # ------------------------------------------------------------------------------------------------------------------\n\n    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        print(header_info)  # noqa: T201\n        return tmp._ipython_display_()",
      "instance_attributes": [
        {
          "name": "_features",
          "types": {
            "kind": "NamedType",
            "name": "Table"
          }
        },
        {
          "name": "_target",
          "types": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ]
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError",
      "name": "ColumnLengthMismatchError",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when the lengths of two or more columns do not match.",
      "docstring": "Exception raised when the lengths of two or more columns do not match.",
      "code": "class ColumnLengthMismatchError(Exception):\n    \"\"\"Exception raised when the lengths of two or more columns do not match.\"\"\"\n\n    def __init__(self, column_info: str):\n        super().__init__(f\"The length of at least one column differs: \\n{column_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError",
      "name": "ColumnSizeError",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to use a column of unsupported size.",
      "docstring": "Exception raised for trying to use a column of unsupported size.\n\nParameters\n----------\nexpected_size : str\n    The expected size of the column as an expression (e.g. 2, >0, !=0).\nactual_size : str\n    The actual size of the column as an expression (e.g. 2, >0, !=0).",
      "code": "class ColumnSizeError(Exception):\n    \"\"\"\n    Exception raised for trying to use a column of unsupported size.\n\n    Parameters\n    ----------\n    expected_size : str\n        The expected size of the column as an expression (e.g. 2, >0, !=0).\n    actual_size : str\n        The actual size of the column as an expression (e.g. 2, >0, !=0).\n    \"\"\"\n\n    def __init__(self, expected_size: str, actual_size: str):\n        super().__init__(f\"Expected a column of size {expected_size} but got column of size {actual_size}.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError",
      "name": "DuplicateColumnNameError",
      "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to modify a table resulting in a duplicate column name.",
      "docstring": "Exception raised for trying to modify a table resulting in a duplicate column name.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column that resulted in a duplicate.",
      "code": "class DuplicateColumnNameError(Exception):\n    \"\"\"\n    Exception raised for trying to modify a table resulting in a duplicate column name.\n\n    Parameters\n    ----------\n    column_name : str\n        The name of the column that resulted in a duplicate.\n    \"\"\"\n\n    def __init__(self, column_name: str):\n        super().__init__(f\"Column '{column_name}' already exists.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError",
      "name": "IndexOutOfBoundsError",
      "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError",
      "decorators": [],
      "superclasses": [
        "IndexError"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an element by an index that does not exist in the underlying data.",
      "docstring": "Exception raised for trying to access an element by an index that does not exist in the underlying data.\n\nParameters\n----------\nindex : int\n    The wrongly used index.",
      "code": "class IndexOutOfBoundsError(IndexError):\n    \"\"\"\n    Exception raised for trying to access an element by an index that does not exist in the underlying data.\n\n    Parameters\n    ----------\n    index : int\n        The wrongly used index.\n    \"\"\"\n\n    def __init__(self, index: int):\n        super().__init__(f\"There is no element at index '{index}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError",
      "name": "MissingDataError",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised if a function is not given enough data to succeed.",
      "docstring": "Exception raised if a function is not given enough data to succeed.",
      "code": "class MissingDataError(Exception):\n    \"\"\"Exception raised if a function is not given enough data to succeed.\"\"\"\n\n    def __init__(self, missing_data_info: str):\n        super().__init__(f\"The function is missing data: \\n{missing_data_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError",
      "name": "MissingSchemaError",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingSchemaError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a required schema is missing.",
      "docstring": "Exception raised when a required schema is missing.",
      "code": "class MissingSchemaError(Exception):\n    \"\"\"Exception raised when a required schema is missing.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Failed because a required schema is missing.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError",
      "name": "NonNumericColumnError",
      "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "docstring": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "code": "class NonNumericColumnError(Exception):\n    \"\"\"Exception raised for trying to do numerical operations on a non-numerical column.\"\"\"\n\n    def __init__(self, column_info: str) -> None:\n        super().__init__(f\"Tried to do a numerical operation on one or multiple non numerical Columns: \\n{column_info}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError",
      "name": "SchemaMismatchError",
      "qname": "safeds.data.tabular.exceptions._exceptions.SchemaMismatchError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when schemas are unequal.",
      "docstring": "Exception raised when schemas are unequal.",
      "code": "class SchemaMismatchError(Exception):\n    \"\"\"Exception raised when schemas are unequal.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"Failed because at least two schemas didn't match.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError",
      "name": "TransformerNotFittedError",
      "qname": "safeds.data.tabular.exceptions._exceptions.TransformerNotFittedError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a transformer is used before fitting it.",
      "docstring": "Raised when a transformer is used before fitting it.",
      "code": "class TransformerNotFittedError(Exception):\n    \"\"\"Raised when a transformer is used before fitting it.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"The transformer has not been fitted yet.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError",
      "name": "UnknownColumnNameError",
      "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError",
      "decorators": [],
      "superclasses": [
        "KeyError"
      ],
      "methods": [
        "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an invalid column name.",
      "docstring": "Exception raised for trying to access an invalid column name.\n\nParameters\n----------\ncolumn_names : list[str]\n    The name of the column that was tried to be accessed.",
      "code": "class UnknownColumnNameError(KeyError):\n    \"\"\"\n    Exception raised for trying to access an invalid column name.\n\n    Parameters\n    ----------\n    column_names : list[str]\n        The name of the column that was tried to be accessed.\n    \"\"\"\n\n    def __init__(self, column_names: list[str]):\n        super().__init__(f\"Could not find column(s) '{', '.join(column_names)}'\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError",
      "name": "DatasetContainsTargetError",
      "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError",
      "decorators": [],
      "superclasses": [
        "ValueError"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset contains the target column already.",
      "docstring": "Raised when a dataset contains the target column already.\n\nParameters\n----------\ntarget_name: str\n    The name of the target column.",
      "code": "class DatasetContainsTargetError(ValueError):\n    \"\"\"\n    Raised when a dataset contains the target column already.\n\n    Parameters\n    ----------\n    target_name: str\n        The name of the target column.\n    \"\"\"\n\n    def __init__(self, target_name: str):\n        super().__init__(f\"Dataset already contains the target column '{target_name}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError",
      "name": "DatasetMissesFeaturesError",
      "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError",
      "decorators": [],
      "superclasses": [
        "ValueError"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset misses feature columns.",
      "docstring": "Raised when a dataset misses feature columns.\n\nParameters\n----------\nmissing_feature_names: list[str]\n    The names of the missing feature columns.",
      "code": "class DatasetMissesFeaturesError(ValueError):\n    \"\"\"\n    Raised when a dataset misses feature columns.\n\n    Parameters\n    ----------\n    missing_feature_names: list[str]\n        The names of the missing feature columns.\n    \"\"\"\n\n    def __init__(self, missing_feature_names: list[str]):\n        super().__init__(f\"Dataset misses the feature columns '{missing_feature_names}'.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError",
      "name": "LearningError",
      "qname": "safeds.ml.exceptions._exceptions.LearningError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while training a model.",
      "docstring": "Raised when an error occurred while training a model.\n\nParameters\n----------\nreason: str | None\n    The reason for the error.",
      "code": "class LearningError(Exception):\n    \"\"\"\n    Raised when an error occurred while training a model.\n\n    Parameters\n    ----------\n    reason: str | None\n        The reason for the error.\n    \"\"\"\n\n    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while learning\")\n        else:\n            super().__init__(f\"Error occurred while learning: {reason}\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError",
      "name": "ModelNotFittedError",
      "qname": "safeds.ml.exceptions._exceptions.ModelNotFittedError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a model is used before fitting it.",
      "docstring": "Raised when a model is used before fitting it.",
      "code": "class ModelNotFittedError(Exception):\n    \"\"\"Raised when a model is used before fitting it.\"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(\"The model has not been fitted yet.\")",
      "instance_attributes": []
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError",
      "name": "PredictionError",
      "qname": "safeds.ml.exceptions._exceptions.PredictionError",
      "decorators": [],
      "superclasses": [
        "Exception"
      ],
      "methods": [
        "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__"
      ],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while prediction a target vector using a model.",
      "docstring": "Raised when an error occurred while prediction a target vector using a model.\n\nParameters\n----------\nreason: str | None\n    The reason for the error.",
      "code": "class PredictionError(Exception):\n    \"\"\"\n    Raised when an error occurred while prediction a target vector using a model.\n\n    Parameters\n    ----------\n    reason: str | None\n        The reason for the error.\n    \"\"\"\n\n    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while predicting\")\n        else:\n            super().__init__(f\"Error occurred while predicting: {reason}\")",
      "instance_attributes": []
    }
  ],
  "functions": [
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._column.Column.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._column.Column.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Column):\n            return NotImplemented\n        if self is other:\n            return True\n        return self.name == other.name and self._data.equals(other._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__",
      "name": "__getitem__",
      "qname": "safeds.data.tabular.containers._column.Column.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__getitem__/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._column.Column.__getitem__.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __getitem__(self, index: int) -> Any:\n        return self.get_value(index)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._column.Column.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._column.Column.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/name",
          "name": "name",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Iterable",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Iterable"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__init__/type_",
          "name": "type_",
          "qname": "safeds.data.tabular.containers._column.Column.__init__.type_",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[ColumnType]",
            "default_value": "",
            "description": "The type of the column. If not specified, the type will be inferred from the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[ColumnType]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A column is a named collection of values.",
      "docstring": "",
      "code": "    def __init__(self, name: str, data: Iterable, type_: ColumnType | None = None) -> None:\n        self._name: str = name\n        self._data: pd.Series = data if isinstance(data, pd.Series) else pd.Series(data)\n        # noinspection PyProtectedMember\n        self._type: ColumnType = type_ if type_ is not None else ColumnType._from_numpy_data_type(self._data.dtype)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__iter__",
      "name": "__iter__",
      "qname": "safeds.data.tabular.containers._column.Column.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__iter__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __iter__(self) -> Iterator[Any]:\n        return iter(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__len__",
      "name": "__len__",
      "qname": "safeds.data.tabular.containers._column.Column.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__len__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __len__(self) -> int:\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._column.Column.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._column.Column.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values",
      "name": "_count_missing_values",
      "qname": "safeds.data.tabular.containers._column.Column._count_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/_count_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column._count_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of null values in the column.",
      "docstring": "Return the number of null values in the column.\n\nReturns\n-------\ncount : int\n    The number of null values.",
      "code": "    def _count_missing_values(self) -> int:\n        \"\"\"\n        Return the number of null values in the column.\n\n        Returns\n        -------\n        count : int\n            The number of null values.\n        \"\"\"\n        return self._data.isna().sum()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._column.Column._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.to_frame()\n        tmp.columns = [self.name]\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/all",
      "name": "all",
      "qname": "safeds.data.tabular.containers._column.Column.all",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/all/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.all.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/all/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.all.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if all values have a given property.",
      "docstring": "Check if all values have a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if all match.",
      "code": "    def all(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if all values have a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if all match.\n\n        \"\"\"\n        return all(predicate(value) for value in self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/any",
      "name": "any",
      "qname": "safeds.data.tabular.containers._column.Column.any",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/any/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.any.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/any/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.any.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if any value has a given property.",
      "docstring": "Check if any value has a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if any match.",
      "code": "    def any(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if any value has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if any match.\n\n        \"\"\"\n        return any(predicate(value) for value in self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with",
      "name": "correlation_with",
      "qname": "safeds.data.tabular.containers._column.Column.correlation_with",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.correlation_with.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/correlation_with/other_column",
          "name": "other_column",
          "qname": "safeds.data.tabular.containers._column.Column.correlation_with.other_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate Pearson correlation between this and another column. Both columns have to be numerical.",
      "docstring": "Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\nReturns\n-------\ncorrelation : float\n    Correlation between the two columns.\n\nRaises\n------\nTypeError\n    If one of the columns is not numerical.",
      "code": "    def correlation_with(self, other_column: Column) -> float:\n        \"\"\"\n        Calculate Pearson correlation between this and another column. Both columns have to be numerical.\n\n        Returns\n        -------\n        correlation : float\n            Correlation between the two columns.\n\n        Raises\n        ------\n        TypeError\n            If one of the columns is not numerical.\n        \"\"\"\n        if not self._type.is_numeric() or not other_column._type.is_numeric():\n            raise NonNumericColumnError(\n                f\"Columns must be numerical. {self.name} is {self._type}, \"\n                f\"{other_column.name} is {other_column._type}.\",\n            )\n        if self._data.size != other_column._data.size:\n            raise ColumnLengthMismatchError(\n                f\"{self.name} is of size {self._data.size}, \"\n                f\"{other_column.name} is of size {other_column._data.size}.\",\n            )\n        return self._data.corr(other_column._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values",
      "name": "get_unique_values",
      "qname": "safeds.data.tabular.containers._column.Column.get_unique_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_unique_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.get_unique_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all unique values in the column.",
      "docstring": "Return a list of all unique values in the column.\n\nReturns\n-------\nunique_values : list[any]\n    List of unique values in the column.",
      "code": "    def get_unique_values(self) -> list[Any]:\n        \"\"\"\n        Return a list of all unique values in the column.\n\n        Returns\n        -------\n        unique_values : list[any]\n            List of unique values in the column.\n        \"\"\"\n        return list(self._data.unique())"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value",
      "name": "get_value",
      "qname": "safeds.data.tabular.containers._column.Column.get_value",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.get_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/get_value/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._column.Column.get_value.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "Index of requested element."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return column value at specified index, starting at 0.",
      "docstring": "Return column value at specified index, starting at 0.\n\nParameters\n----------\nindex : int\n    Index of requested element.\n\nReturns\n-------\nvalue\n    Value at index in column.\n\nRaises\n------\nIndexOutOfBoundsError\n    If the given index does not exist in the column.",
      "code": "    def get_value(self, index: int) -> Any:\n        \"\"\"\n        Return column value at specified index, starting at 0.\n\n        Parameters\n        ----------\n        index : int\n            Index of requested element.\n\n        Returns\n        -------\n        value\n            Value at index in column.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If the given index does not exist in the column.\n        \"\"\"\n        if index < 0 or index >= self._data.size:\n            raise IndexOutOfBoundsError(index)\n\n        return self._data[index]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values",
      "name": "has_missing_values",
      "qname": "safeds.data.tabular.containers._column.Column.has_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/has_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.has_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the column has missing values.",
      "docstring": "Return whether the column has missing values.\n\nReturns\n-------\nmissing_values_exist : bool\n    True if missing values exist.",
      "code": "    def has_missing_values(self) -> bool:\n        \"\"\"\n        Return whether the column has missing values.\n\n        Returns\n        -------\n        missing_values_exist : bool\n            True if missing values exist.\n        \"\"\"\n        return self.any(lambda value: value is None or (isinstance(value, Number) and np.isnan(value)))"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/idness",
      "name": "idness",
      "qname": "safeds.data.tabular.containers._column.Column.idness",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/idness/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.idness.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate the idness of this column, which we define as.\n\n$$\n\\frac{\\text{number of different values}}{\\text{number of rows}}\n$$",
      "docstring": "Calculate the idness of this column, which we define as.\n\n$$\n\\frac{\\text{number of different values}}{\\text{number of rows}}\n$$\n\nReturns\n-------\nidness : float\n    The idness of the column.\n\nRaises\n------\nColumnSizeError\n    If this column is empty.",
      "code": "    def idness(self) -> float:\n        r\"\"\"\n        Calculate the idness of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of different values}}{\\text{number of rows}}\n        $$\n\n        Returns\n        -------\n        idness : float\n            The idness of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If this column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.nunique() / self._data.size"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/maximum",
      "name": "maximum",
      "qname": "safeds.data.tabular.containers._column.Column.maximum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/maximum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.maximum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the maximum value of the column. The column has to be numerical.",
      "docstring": "Return the maximum value of the column. The column has to be numerical.\n\nReturns\n-------\nmax : float\n    The maximum value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def maximum(self) -> float:\n        \"\"\"\n        Return the maximum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        max : float\n            The maximum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.max()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/mean",
      "name": "mean",
      "qname": "safeds.data.tabular.containers._column.Column.mean",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/mean/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.mean.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mean value of the column. The column has to be numerical.",
      "docstring": "Return the mean value of the column. The column has to be numerical.\n\nReturns\n-------\nmean : float\n    The mean value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def mean(self) -> float:\n        \"\"\"\n        Return the mean value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        mean : float\n            The mean value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.mean()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/median",
      "name": "median",
      "qname": "safeds.data.tabular.containers._column.Column.median",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/median/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.median.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the median value of the column. The column has to be numerical.",
      "docstring": "Return the median value of the column. The column has to be numerical.\n\nReturns\n-------\nmedian : float\n    The median value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def median(self) -> float:\n        \"\"\"\n        Return the median value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        median : float\n            The median value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.median()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/minimum",
      "name": "minimum",
      "qname": "safeds.data.tabular.containers._column.Column.minimum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/minimum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.minimum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the minimum value of the column. The column has to be numerical.",
      "docstring": "Return the minimum value of the column. The column has to be numerical.\n\nReturns\n-------\nmin : float\n    The minimum value.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def minimum(self) -> float:\n        \"\"\"\n        Return the minimum value of the column. The column has to be numerical.\n\n        Returns\n        -------\n        min : float\n            The minimum value.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n        \"\"\"\n        if not self._type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.min()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio",
      "name": "missing_value_ratio",
      "qname": "safeds.data.tabular.containers._column.Column.missing_value_ratio",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/missing_value_ratio/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.missing_value_ratio.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the ratio of null values to the total number of elements in the column.",
      "docstring": "Return the ratio of null values to the total number of elements in the column.\n\nReturns\n-------\nratio : float\n    The ratio of null values to the total number of elements in the column.",
      "code": "    def missing_value_ratio(self) -> float:\n        \"\"\"\n        Return the ratio of null values to the total number of elements in the column.\n\n        Returns\n        -------\n        ratio : float\n            The ratio of null values to the total number of elements in the column.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._count_missing_values() / self._data.size"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/mode",
      "name": "mode",
      "qname": "safeds.data.tabular.containers._column.Column.mode",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/mode/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.mode.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the mode of the column.",
      "docstring": "Return the mode of the column.\n\nReturns\n-------\nList :\n    Returns a list with the most common values.",
      "code": "    def mode(self) -> Any:\n        \"\"\"\n        Return the mode of the column.\n\n        Returns\n        -------\n        List :\n            Returns a list with the most common values.\n        \"\"\"\n        return self._data.mode().tolist()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/n_rows@getter",
      "name": "n_rows",
      "qname": "safeds.data.tabular.containers._column.Column.n_rows",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/n_rows@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.n_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of elements in the column.",
      "docstring": "Return the number of elements in the column.\n\nReturns\n-------\nn_rows : int\n    The number of elements.",
      "code": "    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of elements in the column.\n\n        Returns\n        -------\n        n_rows : int\n            The number of elements.\n        \"\"\"\n        return len(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/name@getter",
      "name": "name",
      "qname": "safeds.data.tabular.containers._column.Column.name",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/name@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.name.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the name of the column.",
      "docstring": "Return the name of the column.\n\nReturns\n-------\nname : str\n    The name of the column.",
      "code": "    @property\n    def name(self) -> str:\n        \"\"\"\n        Return the name of the column.\n\n        Returns\n        -------\n        name : str\n            The name of the column.\n        \"\"\"\n        return self._name"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/none",
      "name": "none",
      "qname": "safeds.data.tabular.containers._column.Column.none",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/none/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.none.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/none/predicate",
          "name": "predicate",
          "qname": "safeds.data.tabular.containers._column.Column.none.predicate",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Any], bool])",
            "default_value": "",
            "description": "Callable that is used to find matches."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Any]"
              },
              {
                "kind": "NamedType",
                "name": "bool]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check if no values has a given property.",
      "docstring": "Check if no values has a given property.\n\nParameters\n----------\npredicate : Callable[[Any], bool])\n    Callable that is used to find matches.\n\nReturns\n-------\nresult : bool\n    True if none match.",
      "code": "    def none(self, predicate: Callable[[Any], bool]) -> bool:\n        \"\"\"\n        Check if no values has a given property.\n\n        Parameters\n        ----------\n        predicate : Callable[[Any], bool])\n            Callable that is used to find matches.\n\n        Returns\n        -------\n        result : bool\n            True if none match.\n\n        \"\"\"\n        return all(not predicate(value) for value in self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_boxplot",
      "name": "plot_boxplot",
      "qname": "safeds.data.tabular.containers._column.Column.plot_boxplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_boxplot/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.plot_boxplot.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot this column in a boxplot. This function can only plot real numerical data.",
      "docstring": "Plot this column in a boxplot. This function can only plot real numerical data.\n\nReturns\n-------\nplot: Image\n    The plot as an image.\n\nRaises\n------\nTypeError\n    If the column contains non-numerical data or complex data.",
      "code": "    def plot_boxplot(self) -> Image:\n        \"\"\"\n        Plot this column in a boxplot. This function can only plot real numerical data.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        TypeError\n            If the column contains non-numerical data or complex data.\n        \"\"\"\n        for data in self._data:\n            if not isinstance(data, int) and not isinstance(data, float) and not isinstance(data, complex):\n                raise NonNumericColumnError(self.name)\n            if isinstance(data, complex):\n                raise TypeError(\n                    \"The column contains complex data. Boxplots cannot plot the imaginary part of complex \"\n                    \"data. Please provide a Column with only real numbers\",\n                )\n\n        fig = plt.figure()\n        ax = sns.boxplot(data=self._data)\n        ax.set(xlabel=self.name)\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_histogram",
      "name": "plot_histogram",
      "qname": "safeds.data.tabular.containers._column.Column.plot_histogram",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/plot_histogram/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.plot_histogram.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a column in a histogram.",
      "docstring": "Plot a column in a histogram.\n\nReturns\n-------\nplot: Image\n    The plot as an image.",
      "code": "    def plot_histogram(self) -> Image:\n        \"\"\"\n        Plot a column in a histogram.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        fig = plt.figure()\n        ax = sns.histplot(data=self._data)\n        ax.set_xticks(ax.get_xticks())\n        ax.set(xlabel=self.name)\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/rename",
      "name": "rename",
      "qname": "safeds.data.tabular.containers._column.Column.rename",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/rename/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.rename.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/rename/new_name",
          "name": "new_name",
          "qname": "safeds.data.tabular.containers._column.Column.rename.new_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The new name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a new column with a new name.",
      "docstring": "Return a new column with a new name.\n\nParameters\n----------\nnew_name : str\n    The new name of the column.\n\nReturns\n-------\ncolumn : Column\n    A new column with the new name.",
      "code": "    def rename(self, new_name: str) -> Column:\n        \"\"\"\n        Return a new column with a new name.\n\n        Parameters\n        ----------\n        new_name : str\n            The new name of the column.\n\n        Returns\n        -------\n        column : Column\n            A new column with the new name.\n        \"\"\"\n        return Column(new_name, self._data, self._type)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/stability",
      "name": "stability",
      "qname": "safeds.data.tabular.containers._column.Column.stability",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/stability/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.stability.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Calculate the stability of this column, which we define as.\n\n$$\n\\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n$$",
      "docstring": "Calculate the stability of this column, which we define as.\n\n$$\n\\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n$$\n\nReturns\n-------\nstability : float\n    The stability of the column.\n\nRaises\n------\nColumnSizeError\n    If the column is empty.",
      "code": "    def stability(self) -> float:\n        r\"\"\"\n        Calculate the stability of this column, which we define as.\n\n        $$\n        \\frac{\\text{number of occurrences of most common non-null value}}{\\text{number of non-null values}}\n        $$\n\n        Returns\n        -------\n        stability : float\n            The stability of the column.\n\n        Raises\n        ------\n        ColumnSizeError\n            If the column is empty.\n        \"\"\"\n        if self._data.size == 0:\n            raise ColumnSizeError(\"> 0\", \"0\")\n        return self._data.value_counts()[self.mode()[0]] / self._data.count()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/standard_deviation",
      "name": "standard_deviation",
      "qname": "safeds.data.tabular.containers._column.Column.standard_deviation",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/standard_deviation/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.standard_deviation.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the standard deviation of the column. The column has to be numerical.",
      "docstring": "Return the standard deviation of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The standard deviation of all values.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def standard_deviation(self) -> float:\n        \"\"\"\n        Return the standard deviation of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The standard deviation of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.std()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/sum",
      "name": "sum",
      "qname": "safeds.data.tabular.containers._column.Column.sum",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/sum/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.sum.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the sum of the column. The column has to be numerical.",
      "docstring": "Return the sum of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The sum of all values.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def sum(self) -> float:\n        \"\"\"\n        Return the sum of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The sum of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n        return self._data.sum()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/type@getter",
      "name": "type",
      "qname": "safeds.data.tabular.containers._column.Column.type",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/type@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the column.",
      "docstring": "Return the type of the column.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.",
      "code": "    @property\n    def type(self) -> ColumnType:\n        \"\"\"\n        Return the type of the column.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n        \"\"\"\n        return self._type"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._column/Column/variance",
      "name": "variance",
      "qname": "safeds.data.tabular.containers._column.Column.variance",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._column/Column/variance/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._column.Column.variance.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the variance of the column. The column has to be numerical.",
      "docstring": "Return the variance of the column. The column has to be numerical.\n\nReturns\n-------\nsum : float\n    The variance of all values.\n\nRaises\n------\nNonNumericColumnError\n    If the data contains non-numerical data.",
      "code": "    def variance(self) -> float:\n        \"\"\"\n        Return the variance of the column. The column has to be numerical.\n\n        Returns\n        -------\n        sum : float\n            The variance of all values.\n\n        Raises\n        ------\n        NonNumericColumnError\n            If the data contains non-numerical data.\n\n        \"\"\"\n        if not self.type.is_numeric():\n            raise NonNumericColumnError(f\"{self.name} is of type {self._type}.\")\n\n        return self._data.var()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__contains__",
      "name": "__contains__",
      "qname": "safeds.data.tabular.containers._row.Row.__contains__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__contains__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__contains__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__contains__/obj",
          "name": "obj",
          "qname": "safeds.data.tabular.containers._row.Row.__contains__.obj",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Any",
            "default_value": "",
            "description": "The object."
          },
          "type": {
            "kind": "NamedType",
            "name": "Any"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check whether the row contains an object as key.",
      "docstring": "Check whether the row contains an object as key.\n\nParameters\n----------\nobj : Any\n    The object.\n\nReturns\n-------\nhas_column : bool\n    True, if the row contains the object as key, False otherwise.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> \"a\" in row\nTrue\n\n>>> \"c\" in row\nFalse",
      "code": "    def __contains__(self, obj: Any) -> bool:\n        \"\"\"\n        Check whether the row contains an object as key.\n\n        Parameters\n        ----------\n        obj : Any\n            The object.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the object as key, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> \"a\" in row\n        True\n\n        >>> \"c\" in row\n        False\n        \"\"\"\n        return isinstance(obj, str) and self.has_column(obj)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._row.Row.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._row.Row.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Any",
            "default_value": "",
            "description": "The other object."
          },
          "type": {
            "kind": "NamedType",
            "name": "Any"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check whether this row is equal to another object.",
      "docstring": "Check whether this row is equal to another object.\n\nParameters\n----------\nother : Any\n    The other object.\n\nReturns\n-------\nequal : bool\n    True if the other object is an identical row. False if the other object is a different row. NotImplemented\n    if the other object is not a row.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row1 = Row({\"a\": 1, \"b\": 2})\n>>> row2 = Row({\"a\": 1, \"b\": 2})\n>>> row1 == row2\nTrue\n\n>>> row3 = Row({\"a\": 1, \"b\": 3})\n>>> row1 == row3\nFalse",
      "code": "    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Check whether this row is equal to another object.\n\n        Parameters\n        ----------\n        other : Any\n            The other object.\n\n        Returns\n        -------\n        equal : bool\n            True if the other object is an identical row. False if the other object is a different row. NotImplemented\n            if the other object is not a row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row1 = Row({\"a\": 1, \"b\": 2})\n        >>> row2 = Row({\"a\": 1, \"b\": 2})\n        >>> row1 == row2\n        True\n\n        >>> row3 = Row({\"a\": 1, \"b\": 3})\n        >>> row1 == row3\n        False\n        \"\"\"\n        if not isinstance(other, Row):\n            return NotImplemented\n        if self is other:\n            return True\n        return self._schema == other._schema and self._data.frame_equal(other._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__",
      "name": "__getitem__",
      "qname": "safeds.data.tabular.containers._row.Row.__getitem__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__getitem__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__getitem__/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.__getitem__.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the value of a specified column.",
      "docstring": "Return the value of a specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nvalue : Any\n    The column value.\n\nRaises\n------\nUnknownColumnNameError\n    If the row does not contain the specified column.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row[\"a\"]\n1",
      "code": "    def __getitem__(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row[\"a\"]\n        1\n        \"\"\"\n        return self.get_value(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._row.Row.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row.__init__.data",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Mapping[str, Any] | None",
            "default_value": "",
            "description": "The data. If None, an empty row is created."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Mapping[str"
              },
              {
                "kind": "NamedType",
                "name": "Any] | None"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A row is a collection of named values.",
      "docstring": "Create a row from a mapping of column names to column values.\n\nParameters\n----------\ndata : Mapping[str, Any] | None\n    The data. If None, an empty row is created.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})",
      "code": "    def __init__(self, data: Mapping[str, Any] | None = None):\n        \"\"\"\n        Create a row from a mapping of column names to column values.\n\n        Parameters\n        ----------\n        data : Mapping[str, Any] | None\n            The data. If None, an empty row is created.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        \"\"\"\n        if data is None:\n            data = {}\n\n        self._data: pl.DataFrame = pl.DataFrame(data)\n        # noinspection PyProtectedMember\n        self._schema: Schema = Schema._from_polars_dataframe(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__iter__",
      "name": "__iter__",
      "qname": "safeds.data.tabular.containers._row.Row.__iter__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__iter__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__iter__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create an iterator for the column names of this row.",
      "docstring": "Create an iterator for the column names of this row.\n\nReturns\n-------\niterator : Iterator[Any]\n    The iterator.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> list(row)\n['a', 'b']",
      "code": "    def __iter__(self) -> Iterator[Any]:\n        \"\"\"\n        Create an iterator for the column names of this row.\n\n        Returns\n        -------\n        iterator : Iterator[Any]\n            The iterator.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> list(row)\n        ['a', 'b']\n        \"\"\"\n        return iter(self.column_names)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__len__",
      "name": "__len__",
      "qname": "safeds.data.tabular.containers._row.Row.__len__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__len__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__len__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns in this row.",
      "docstring": "Return the number of columns in this row.\n\nReturns\n-------\nn_columns : int\n    The number of columns.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> len(row)\n2",
      "code": "    def __len__(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> len(row)\n        2\n        \"\"\"\n        return self._data.width"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._row.Row.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return an unambiguous string representation of this row.",
      "docstring": "Return an unambiguous string representation of this row.\n\nReturns\n-------\nrepresentation : str\n    The string representation.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1})\n>>> repr(row)\n\"Row({'a': 1})\"",
      "code": "    def __repr__(self) -> str:\n        \"\"\"\n        Return an unambiguous string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> repr(row)\n        \"Row({'a': 1})\"\n        \"\"\"\n        return f\"Row({str(self)})\""
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._row.Row.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a user-friendly string representation of this row.",
      "docstring": "Return a user-friendly string representation of this row.\n\nReturns\n-------\nrepresentation : str\n    The string representation.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1})\n>>> str(row)\n\"{'a': 1}\"",
      "code": "    def __str__(self) -> str:\n        \"\"\"\n        Return a user-friendly string representation of this row.\n\n        Returns\n        -------\n        representation : str\n            The string representation.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1})\n        >>> str(row)\n        \"{'a': 1}\"\n        \"\"\"\n        match len(self):\n            case 0:\n                return \"{}\"\n            case 1:\n                return str(self.to_dict())\n            case _:\n                lines = (f\"    {name!r}: {value!r}\" for name, value in self.to_dict().items())\n                joined = \",\\n\".join(lines)\n                return f\"{{\\n{joined}\\n}}\""
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe",
      "name": "_from_polars_dataframe",
      "qname": "safeds.data.tabular.containers._row.Row._from_polars_dataframe",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row._from_polars_dataframe.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "polars.DataFrame",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "NamedType",
            "name": "polars.DataFrame"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_from_polars_dataframe/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._row.Row._from_polars_dataframe.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Schema | None",
            "default_value": "",
            "description": "The schema. If None, the schema is inferred from the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Schema | None"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a row from a `polars.DataFrame`.",
      "docstring": "Create a row from a `polars.DataFrame`.\n\nParameters\n----------\ndata : polars.DataFrame\n    The data.\nschema : Schema | None\n    The schema. If None, the schema is inferred from the data.\n\nReturns\n-------\nrow : Row\n    The created row.\n\nExamples\n--------\n>>> import polars as pl\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row._from_polars_dataframe(pl.DataFrame({\"a\": [1], \"b\": [2]}))",
      "code": "    @staticmethod\n    def _from_polars_dataframe(data: pl.DataFrame, schema: Schema | None = None) -> Row:\n        \"\"\"\n        Create a row from a `polars.DataFrame`.\n\n        Parameters\n        ----------\n        data : polars.DataFrame\n            The data.\n        schema : Schema | None\n            The schema. If None, the schema is inferred from the data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> import polars as pl\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row._from_polars_dataframe(pl.DataFrame({\"a\": [1], \"b\": [2]}))\n        \"\"\"\n        result = object.__new__(Row)\n        result._data = data\n\n        if schema is None:\n            # noinspection PyProtectedMember\n            result._schema = Schema._from_polars_dataframe(data)\n        else:\n            result._schema = schema\n\n        return result"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/_repr_html_",
      "name": "_repr_html_",
      "qname": "safeds.data.tabular.containers._row.Row._repr_html_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/_repr_html_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row._repr_html_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return an HTML representation of the row.",
      "docstring": "Return an HTML representation of the row.\n\nReturns\n-------\noutput : str\n    The generated HTML.",
      "code": "    def _repr_html_(self) -> str:\n        \"\"\"\n        Return an HTML representation of the row.\n\n        Returns\n        -------\n        output : str\n            The generated HTML.\n        \"\"\"\n        # noinspection PyProtectedMember\n        return self._data._repr_html_()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/column_names@getter",
      "name": "column_names",
      "qname": "safeds.data.tabular.containers._row.Row.column_names",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/column_names@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names in the row.",
      "docstring": "Return a list of all column names in the row.\n\nReturns\n-------\ncolumn_names : list[str]\n    The column names.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.column_names\n['a', 'b']",
      "code": "    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in the row.\n\n        Returns\n        -------\n        column_names : list[str]\n            The column names.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.column_names\n        ['a', 'b']\n        \"\"\"\n        return self._schema.column_names"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/from_dict",
      "name": "from_dict",
      "qname": "safeds.data.tabular.containers._row.Row.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/from_dict/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._row.Row.from_dict.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict[str, Any]",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "Any]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a row from a dictionary that maps column names to column values.",
      "docstring": "Create a row from a dictionary that maps column names to column values.\n\nParameters\n----------\ndata : dict[str, Any]\n    The data.\n\nReturns\n-------\nrow : Row\n    The created row.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row.from_dict({\"a\": 1, \"b\": 2})",
      "code": "    @staticmethod\n    def from_dict(data: dict[str, Any]) -> Row:\n        \"\"\"\n        Create a row from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, Any]\n            The data.\n\n        Returns\n        -------\n        row : Row\n            The created row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row.from_dict({\"a\": 1, \"b\": 2})\n        \"\"\"\n        return Row(data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_type",
      "name": "get_column_type",
      "qname": "safeds.data.tabular.containers._row.Row.get_column_type",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_type/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_column_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_column_type/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.get_column_type.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the specified column.",
      "docstring": "Return the type of the specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nUnknownColumnNameError\n    If the row does not contain the specified column.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.get_column_type(\"a\")\nInteger",
      "code": "    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_column_type(\"a\")\n        Integer\n        \"\"\"\n        return self._schema.get_column_type(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value",
      "name": "get_value",
      "qname": "safeds.data.tabular.containers._row.Row.get_value",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.get_value.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/get_value/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.get_value.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the value of a specified column.",
      "docstring": "Return the value of a specified column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nvalue : Any\n    The column value.\n\nRaises\n------\nUnknownColumnNameError\n    If the row does not contain the specified column.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.get_value(\"a\")\n1",
      "code": "    def get_value(self, column_name: str) -> Any:\n        \"\"\"\n        Return the value of a specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        value : Any\n            The column value.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the row does not contain the specified column.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.get_value(\"a\")\n        1\n        \"\"\"\n        if not self.has_column(column_name):\n            raise UnknownColumnNameError([column_name])\n\n        return self._data[0, column_name]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.containers._row.Row.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._row.Row.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Check whether the row contains a given column.",
      "docstring": "Check whether the row contains a given column.\n\nParameters\n----------\ncolumn_name : str\n    The column name.\n\nReturns\n-------\nhas_column : bool\n    True, if the row contains the column, False otherwise.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.has_column(\"a\")\nTrue\n\n>>> row.has_column(\"c\")\nFalse",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Check whether the row contains a given column.\n\n        Parameters\n        ----------\n        column_name : str\n            The column name.\n\n        Returns\n        -------\n        has_column : bool\n            True, if the row contains the column, False otherwise.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.has_column(\"a\")\n        True\n\n        >>> row.has_column(\"c\")\n        False\n        \"\"\"\n        return self._schema.has_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/n_columns@getter",
      "name": "n_columns",
      "qname": "safeds.data.tabular.containers._row.Row.n_columns",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/n_columns@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.n_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns in this row.",
      "docstring": "Return the number of columns in this row.\n\nReturns\n-------\nn_columns : int\n    The number of columns.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.n_columns\n2",
      "code": "    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns in this row.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.n_columns\n        2\n        \"\"\"\n        return self._data.width"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/schema@getter",
      "name": "schema",
      "qname": "safeds.data.tabular.containers._row.Row.schema",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/schema@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.schema.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the schema of the row.",
      "docstring": "Return the schema of the row.\n\nReturns\n-------\nschema : Schema\n    The schema.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> schema = row.schema",
      "code": "    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the row.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> schema = row.schema\n        \"\"\"\n        return self._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._row/Row/to_dict",
      "name": "to_dict",
      "qname": "safeds.data.tabular.containers._row.Row.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._row/Row/to_dict/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._row.Row.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a dictionary that maps column names to column values.",
      "docstring": "Return a dictionary that maps column names to column values.\n\nReturns\n-------\ndata : dict[str, Any]\n    Dictionary representation of the row.\n\nExamples\n--------\n>>> from safeds.data.tabular.containers import Row\n>>> row = Row({\"a\": 1, \"b\": 2})\n>>> row.to_dict()\n{'a': 1, 'b': 2}",
      "code": "    def to_dict(self) -> dict[str, Any]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, Any]\n            Dictionary representation of the row.\n\n        Examples\n        --------\n        >>> from safeds.data.tabular.containers import Row\n        >>> row = Row({\"a\": 1, \"b\": 2})\n        >>> row.to_dict()\n        {'a': 1, 'b': 2}\n        \"\"\"\n        return {column_name: self.get_value(column_name) for column_name in self.column_names}"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__",
      "name": "__dataframe__",
      "qname": "safeds.data.tabular.containers._table.Table.__dataframe__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__dataframe__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__/nan_as_null",
          "name": "nan_as_null",
          "qname": "safeds.data.tabular.containers._table.Table.__dataframe__.nan_as_null",
          "default_value": "False",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether to replace missing values in the data with `NaN`."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__dataframe__/allow_copy",
          "name": "allow_copy",
          "qname": "safeds.data.tabular.containers._table.Table.__dataframe__.allow_copy",
          "default_value": "True",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "bool",
            "default_value": "",
            "description": "Whether memory may be copied to create the DataFrame exchange object."
          },
          "type": {
            "kind": "NamedType",
            "name": "bool"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\nGenerally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\nallow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\ndecide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\ninterchange protocol.\n\nThe specification of the dataframe interchange protocol can be found on\n[GitHub](https://github.com/data-apis/dataframe-api).",
      "docstring": "Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\nGenerally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\nallow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\ndecide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\ninterchange protocol.\n\nThe specification of the dataframe interchange protocol can be found on\n[GitHub](https://github.com/data-apis/dataframe-api).\n\nParameters\n----------\nnan_as_null : bool\n    Whether to replace missing values in the data with `NaN`.\nallow_copy : bool\n    Whether memory may be copied to create the DataFrame exchange object.\n\nReturns\n-------\ndataframe\n    A DataFrame object that conforms to the dataframe interchange protocol.",
      "code": "    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True):  # type: ignore[no-untyped-def]\n        \"\"\"\n        Return a DataFrame exchange object that conforms to the dataframe interchange protocol.\n\n        Generally, there is no reason to call this method directly. The dataframe interchange protocol is designed to\n        allow libraries to consume tabular data from different sources, such as `pandas` or `polars`. If you still\n        decide to call this method, you should not rely on any capabilities of the returned object beyond the dataframe\n        interchange protocol.\n\n        The specification of the dataframe interchange protocol can be found on\n        [GitHub](https://github.com/data-apis/dataframe-api).\n\n        Parameters\n        ----------\n        nan_as_null : bool\n            Whether to replace missing values in the data with `NaN`.\n        allow_copy : bool\n            Whether memory may be copied to create the DataFrame exchange object.\n\n        Returns\n        -------\n        dataframe\n            A DataFrame object that conforms to the dataframe interchange protocol.\n        \"\"\"\n        if not allow_copy:\n            raise NotImplementedError(\"For the moment we need to copy the data, so `allow_copy` must be True.\")\n\n        data_copy = self._data.copy()\n        data_copy.columns = self.column_names\n        return data_copy.__dataframe__(nan_as_null, allow_copy)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__",
      "name": "__eq__",
      "qname": "safeds.data.tabular.containers._table.Table.__eq__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__eq__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__eq__/other",
          "name": "other",
          "qname": "safeds.data.tabular.containers._table.Table.__eq__.other",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Table):\n            return NotImplemented\n        if self is other:\n            return True\n        table1 = self.sort_columns()\n        table2 = other.sort_columns()\n        return table1._data.equals(table2._data) and table1._schema == table2._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__hash__",
      "name": "__hash__",
      "qname": "safeds.data.tabular.containers._table.Table.__hash__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__hash__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__hash__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __hash__(self) -> int:\n        return hash(self._data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._table.Table.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._table.Table.__init__.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A table is a two-dimensional collection of data. It can either be seen as a list of rows or as a list of columns.\n\nTo create a `Table`, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "docstring": "Create a table from a `DataFrame`.\n\nYou should not use this constructor directly. Instead, use one of the following static methods:\n\n| Method                                                                       | Description                            |\n| ---------------------------------------------------------------------------- | -------------------------------------- |\n| [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n| [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n| [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n| [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n| [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |",
      "code": "    def __init__(self, data: Iterable, schema: Schema | None = None):\n        \"\"\"\n        Create a table from a `DataFrame`.\n\n        You should not use this constructor directly. Instead, use one of the following static methods:\n\n        | Method                                                                       | Description                            |\n        | ---------------------------------------------------------------------------- | -------------------------------------- |\n        | [from_csv_file][safeds.data.tabular.containers._table.Table.from_csv_file]   | Create a table from a CSV file.        |\n        | [from_json_file][safeds.data.tabular.containers._table.Table.from_json_file] | Create a table from a JSON file.       |\n        | [from_dict][safeds.data.tabular.containers._table.Table.from_dict]           | Create a table from a dictionary.      |\n        | [from_columns][safeds.data.tabular.containers._table.Table.from_columns]     | Create a table from a list of columns. |\n        | [from_rows][safeds.data.tabular.containers._table.Table.from_rows]           | Create a table from a list of rows.    |\n        \"\"\"\n        self._data: pd.DataFrame = data if isinstance(data, pd.DataFrame) else pd.DataFrame(data)\n        self._schema: Schema = Schema._from_pandas_dataframe(self._data) if schema is None else schema\n\n        if self._data.empty:\n            self._data = pd.DataFrame(columns=self._schema.column_names)\n\n        self._data = self._data.reset_index(drop=True)\n        self._data.columns = self._schema.column_names"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._table.Table.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._table.Table.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n        return tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._table.Table._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._data.copy(deep=True)\n        tmp.columns = self.column_names\n\n        with pd.option_context(\"display.max_rows\", tmp.shape[0], \"display.max_columns\", tmp.shape[1]):\n            return display(tmp)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column",
      "name": "add_column",
      "qname": "safeds.data.tabular.containers._table.Table.add_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_column/column",
          "name": "column",
          "qname": "safeds.data.tabular.containers._table.Table.add_column.column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the original table with the provided column attached at the end.",
      "docstring": "Return the original table with the provided column attached at the end.\n\nReturns\n-------\nresult : Table\n    The table with the column attached.\n\nRaises\n------\nDuplicateColumnNameError\n    If the new column already exists.\n\nColumnSizeError\n    If the size of the column does not match the amount of rows.",
      "code": "    def add_column(self, column: Column) -> Table:\n        \"\"\"\n        Return the original table with the provided column attached at the end.\n\n        Returns\n        -------\n        result : Table\n            The table with the column attached.\n\n        Raises\n        ------\n        DuplicateColumnNameError\n            If the new column already exists.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n\n        \"\"\"\n        if self.has_column(column.name):\n            raise DuplicateColumnNameError(column.name)\n\n        if column._data.size != self.n_rows:\n            raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        result[column.name] = column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns",
      "name": "add_columns",
      "qname": "safeds.data.tabular.containers._table.Table.add_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_columns/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.containers._table.Table.add_columns.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Column] or Table",
            "default_value": "",
            "description": "The columns to be added."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list[Column]"
              },
              {
                "kind": "NamedType",
                "name": "Table"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add multiple columns to the table.",
      "docstring": "Add multiple columns to the table.\n\nParameters\n----------\ncolumns : list[Column] or Table\n    The columns to be added.\n\nReturns\n-------\nresult: Table\n    A new table combining the original table and the given columns.\n\nRaises\n------\nColumnSizeError\n    If at least one of the column sizes from the provided column list does not match the table.\nDuplicateColumnNameError\n    If at least one column name from the provided column list already exists in the table.",
      "code": "    def add_columns(self, columns: list[Column] | Table) -> Table:\n        \"\"\"\n        Add multiple columns to the table.\n\n        Parameters\n        ----------\n        columns : list[Column] or Table\n            The columns to be added.\n\n        Returns\n        -------\n        result: Table\n            A new table combining the original table and the given columns.\n\n        Raises\n        ------\n        ColumnSizeError\n            If at least one of the column sizes from the provided column list does not match the table.\n        DuplicateColumnNameError\n            If at least one column name from the provided column list already exists in the table.\n        \"\"\"\n        if isinstance(columns, Table):\n            columns = columns.to_columns()\n        result = self._data.copy()\n        result.columns = self._schema.column_names\n        for column in columns:\n            if column.name in result.columns:\n                raise DuplicateColumnNameError(column.name)\n\n            if column._data.size != self.n_rows:\n                raise ColumnSizeError(str(self.n_rows), str(column._data.size))\n\n            result[column.name] = column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row",
      "name": "add_row",
      "qname": "safeds.data.tabular.containers._table.Table.add_row",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_row.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_row/row",
          "name": "row",
          "qname": "safeds.data.tabular.containers._table.Table.add_row.row",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Row",
            "default_value": "",
            "description": "The row to be added."
          },
          "type": {
            "kind": "NamedType",
            "name": "Row"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add a row to the table.",
      "docstring": "Add a row to the table.\n\nParameters\n----------\nrow : Row\n    The row to be added.\n\nReturns\n-------\ntable : Table\n    A new table with the added row at the end.",
      "code": "    def add_row(self, row: Row) -> Table:\n        \"\"\"\n        Add a row to the table.\n\n        Parameters\n        ----------\n        row : Row\n            The row to be added.\n\n        Returns\n        -------\n        table : Table\n            A new table with the added row at the end.\n\n        \"\"\"\n        if self._schema != row.schema:\n            raise SchemaMismatchError\n\n        row_frame = row._data.to_pandas()\n\n        new_df = pd.concat([self._data, row_frame]).infer_objects()\n        new_df.columns = self.column_names\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows",
      "name": "add_rows",
      "qname": "safeds.data.tabular.containers._table.Table.add_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.add_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/add_rows/rows",
          "name": "rows",
          "qname": "safeds.data.tabular.containers._table.Table.add_rows.rows",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Row] or Table",
            "default_value": "",
            "description": "The rows to be added."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "list[Row]"
              },
              {
                "kind": "NamedType",
                "name": "Table"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Add multiple rows to a table.",
      "docstring": "Add multiple rows to a table.\n\nParameters\n----------\nrows : list[Row] or Table\n    The rows to be added.\n\nReturns\n-------\nresult : Table\n    A new table which combines the original table and the given rows.",
      "code": "    def add_rows(self, rows: list[Row] | Table) -> Table:\n        \"\"\"\n        Add multiple rows to a table.\n\n        Parameters\n        ----------\n        rows : list[Row] or Table\n            The rows to be added.\n\n        Returns\n        -------\n        result : Table\n            A new table which combines the original table and the given rows.\n        \"\"\"\n        if isinstance(rows, Table):\n            rows = rows.to_rows()\n        result = self._data\n        for row in rows:\n            if self._schema != row.schema:\n                raise SchemaMismatchError\n\n        row_frames = [row._data.to_pandas() for row in rows]\n        for row_frame in row_frames:\n            row_frame.columns = self.column_names\n\n        result = pd.concat([result, *row_frames]).infer_objects()\n        result.columns = self.column_names\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/column_names@getter",
      "name": "column_names",
      "qname": "safeds.data.tabular.containers._table.Table.column_names",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/column_names@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.column_names.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of all column names in this table.\n\nAlias for self.schema.column_names -> list[str].",
      "docstring": "Return a list of all column names in this table.\n\nAlias for self.schema.column_names -> list[str].\n\nReturns\n-------\ncolumn_names : list[str]\n    The list of the column names.",
      "code": "    @property\n    def column_names(self) -> list[str]:\n        \"\"\"\n        Return a list of all column names in this table.\n\n        Alias for self.schema.column_names -> list[str].\n\n        Returns\n        -------\n        column_names : list[str]\n            The list of the column names.\n        \"\"\"\n        return self._schema.column_names"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows",
      "name": "filter_rows",
      "qname": "safeds.data.tabular.containers._table.Table.filter_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.filter_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/filter_rows/query",
          "name": "query",
          "qname": "safeds.data.tabular.containers._table.Table.filter_rows.query",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "lambda function",
            "default_value": "",
            "description": "A Callable that is applied to all rows."
          },
          "type": {
            "kind": "NamedType",
            "name": "lambda function"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with rows filtered by Callable (e.g. lambda function).",
      "docstring": "Return a table with rows filtered by Callable (e.g. lambda function).\n\nParameters\n----------\nquery : lambda function\n    A Callable that is applied to all rows.\n\nReturns\n-------\ntable : Table\n    A table containing only the rows filtered by the query.",
      "code": "    def filter_rows(self, query: Callable[[Row], bool]) -> Table:\n        \"\"\"\n        Return a table with rows filtered by Callable (e.g. lambda function).\n\n        Parameters\n        ----------\n        query : lambda function\n            A Callable that is applied to all rows.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the rows filtered by the query.\n        \"\"\"\n        rows: list[Row] = [row for row in self.to_rows() if query(row)]\n        if len(rows) == 0:\n            result_table = Table([], self._schema)\n        else:\n            result_table = self.from_rows(rows)\n        return result_table"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_columns",
      "name": "from_columns",
      "qname": "safeds.data.tabular.containers._table.Table.from_columns",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_columns/columns",
          "name": "columns",
          "qname": "safeds.data.tabular.containers._table.Table.from_columns.columns",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Column]",
            "default_value": "",
            "description": "The columns to be combined. They need to have the same size."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[Column]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table created from a list of columns.",
      "docstring": "Return a table created from a list of columns.\n\nParameters\n----------\ncolumns : list[Column]\n    The columns to be combined. They need to have the same size.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nColumnLengthMismatchError\n    If any of the column sizes does not match with the others.",
      "code": "    @staticmethod\n    def from_columns(columns: list[Column]) -> Table:\n        \"\"\"\n        Return a table created from a list of columns.\n\n        Parameters\n        ----------\n        columns : list[Column]\n            The columns to be combined. They need to have the same size.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If any of the column sizes does not match with the others.\n        \"\"\"\n        dataframe: DataFrame = pd.DataFrame()\n\n        for column in columns:\n            if column._data.size != columns[0]._data.size:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column.name}: {column._data.size}\" for column in columns),\n                )\n            dataframe[column.name] = column._data\n\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_csv_file",
      "name": "from_csv_file",
      "qname": "safeds.data.tabular.containers._table.Table.from_csv_file",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_csv_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.from_csv_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the CSV file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Read data from a CSV file into a table.",
      "docstring": "Read data from a CSV file into a table.\n\nParameters\n----------\npath : str\n    The path to the CSV file.\n\nReturns\n-------\ntable : Table\n    The table created from the CSV file.\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist.\nValueError\n    If the file could not be read.",
      "code": "    @staticmethod\n    def from_csv_file(path: str) -> Table:\n        \"\"\"\n        Read data from a CSV file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the CSV file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the CSV file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_csv(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_dict",
      "name": "from_dict",
      "qname": "safeds.data.tabular.containers._table.Table.from_dict",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_dict/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._table.Table.from_dict.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "dict[str, list[Any]]",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "dict[str"
              },
              {
                "kind": "NamedType",
                "name": "list[Any]]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Create a table from a dictionary that maps column names to column values.",
      "docstring": "Create a table from a dictionary that maps column names to column values.\n\nParameters\n----------\ndata : dict[str, list[Any]]\n    The data.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nColumnLengthMismatchError\n    If columns have different lengths.",
      "code": "    @staticmethod\n    def from_dict(data: dict[str, list[Any]]) -> Table:\n        \"\"\"\n        Create a table from a dictionary that maps column names to column values.\n\n        Parameters\n        ----------\n        data : dict[str, list[Any]]\n            The data.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        ColumnLengthMismatchError\n            If columns have different lengths.\n        \"\"\"\n        # Validation\n        expected_length: int | None = None\n        for column_values in data.values():\n            if expected_length is None:\n                expected_length = len(column_values)\n            elif len(column_values) != expected_length:\n                raise ColumnLengthMismatchError(\n                    \"\\n\".join(f\"{column_name}: {len(column_values)}\" for column_name, column_values in data.items()),\n                )\n\n        # Implementation\n        dataframe: DataFrame = pd.DataFrame()\n        for column_name, column_values in data.items():\n            dataframe[column_name] = column_values\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_json_file",
      "name": "from_json_file",
      "qname": "safeds.data.tabular.containers._table.Table.from_json_file",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_json_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.from_json_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the JSON file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Read data from a JSON file into a table.",
      "docstring": "Read data from a JSON file into a table.\n\nParameters\n----------\npath : str\n    The path to the JSON file.\n\nReturns\n-------\ntable : Table\n    The table created from the JSON file.\n\nRaises\n------\nFileNotFoundError\n    If the specified file does not exist.\nValueError\n    If the file could not be read.",
      "code": "    @staticmethod\n    def from_json_file(path: str) -> Table:\n        \"\"\"\n        Read data from a JSON file into a table.\n\n        Parameters\n        ----------\n        path : str\n            The path to the JSON file.\n\n        Returns\n        -------\n        table : Table\n            The table created from the JSON file.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the specified file does not exist.\n        ValueError\n            If the file could not be read.\n        \"\"\"\n        try:\n            return Table(pd.read_json(path))\n        except FileNotFoundError as exception:\n            raise FileNotFoundError(f'File \"{path}\" does not exist') from exception"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/from_rows",
      "name": "from_rows",
      "qname": "safeds.data.tabular.containers._table.Table.from_rows",
      "decorators": [
        "staticmethod"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/from_rows/rows",
          "name": "rows",
          "qname": "safeds.data.tabular.containers._table.Table.from_rows.rows",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[Row]",
            "default_value": "",
            "description": "The rows to be combined. They need to have a matching schema."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[Row]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table created from a list of rows.",
      "docstring": "Return a table created from a list of rows.\n\nParameters\n----------\nrows : list[Row]\n    The rows to be combined. They need to have a matching schema.\n\nReturns\n-------\ntable : Table\n    The generated table.\n\nRaises\n------\nMissingDataError\n    If an empty list is given.\nSchemaMismatchError\n    If any of the row schemas does not match with the others.",
      "code": "    @staticmethod\n    def from_rows(rows: list[Row]) -> Table:\n        \"\"\"\n        Return a table created from a list of rows.\n\n        Parameters\n        ----------\n        rows : list[Row]\n            The rows to be combined. They need to have a matching schema.\n\n        Returns\n        -------\n        table : Table\n            The generated table.\n\n        Raises\n        ------\n        MissingDataError\n            If an empty list is given.\n        SchemaMismatchError\n            If any of the row schemas does not match with the others.\n        \"\"\"\n        if len(rows) == 0:\n            raise MissingDataError(\"This function requires at least one row.\")\n\n        schema_compare: Schema = rows[0]._schema\n        row_array: list[pd.DataFrame] = []\n\n        for row in rows:\n            if schema_compare != row._schema:\n                raise SchemaMismatchError\n            row_array.append(row._data.to_pandas())\n\n        dataframe: DataFrame = pd.concat(row_array, ignore_index=True)\n        dataframe.columns = schema_compare.column_names\n        return Table(dataframe)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column",
      "name": "get_column",
      "qname": "safeds.data.tabular.containers._table.Table.get_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.get_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a column with the data of the specified column.",
      "docstring": "Return a column with the data of the specified column.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncolumn : Column\n    The column.\n\nRaises\n------\nUnknownColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_column(self, column_name: str) -> Column:\n        \"\"\"\n        Return a column with the data of the specified column.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        column : Column\n            The column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        if self._schema.has_column(column_name):\n            output_column = Column(\n                column_name,\n                self._data.iloc[:, [self._schema._get_column_index(column_name)]].squeeze(),\n                self._schema.get_column_type(column_name),\n            )\n            return output_column\n\n        raise UnknownColumnNameError([column_name])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_type",
      "name": "get_column_type",
      "qname": "safeds.data.tabular.containers._table.Table.get_column_type",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_type/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_column_type.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_column_type/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.get_column_type.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column to be queried."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the type of the given column.\n\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.",
      "docstring": "Return the type of the given column.\n\nAlias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column to be queried.\n\nReturns\n-------\ntype : ColumnType\n    The type of the column.\n\nRaises\n------\nColumnNameError\n    If the specified target column name does not exist.",
      "code": "    def get_column_type(self, column_name: str) -> ColumnType:\n        \"\"\"\n        Return the type of the given column.\n\n        Alias for self.schema.get_type_of_column(column_name: str) -> ColumnType.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column to be queried.\n\n        Returns\n        -------\n        type : ColumnType\n            The type of the column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified target column name does not exist.\n        \"\"\"\n        return self._schema.get_column_type(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row",
      "name": "get_row",
      "qname": "safeds.data.tabular.containers._table.Table.get_row",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.get_row.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/get_row/index",
          "name": "index",
          "qname": "safeds.data.tabular.containers._table.Table.get_row.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The index."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the row at a specified index.",
      "docstring": "Return the row at a specified index.\n\nParameters\n----------\nindex : int\n    The index.\n\nReturns\n-------\nrow : Row\n    The row of the table at the index.\n\nRaises\n------\nIndexOutOfBoundsError\n    If no row at the specified index exists in this table.",
      "code": "    def get_row(self, index: int) -> Row:\n        \"\"\"\n        Return the row at a specified index.\n\n        Parameters\n        ----------\n        index : int\n            The index.\n\n        Returns\n        -------\n        row : Row\n            The row of the table at the index.\n\n        Raises\n        ------\n        IndexOutOfBoundsError\n            If no row at the specified index exists in this table.\n        \"\"\"\n        if len(self._data.index) - 1 < index or index < 0:\n            raise IndexOutOfBoundsError(index)\n\n        return Row._from_polars_dataframe(pl.DataFrame(self._data.iloc[[index]]), self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column",
      "name": "has_column",
      "qname": "safeds.data.tabular.containers._table.Table.has_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.has_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/has_column/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.containers._table.Table.has_column.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return whether the table contains a given column.\n\nAlias for self.schema.hasColumn(column_name: str) -> bool.",
      "docstring": "Return whether the table contains a given column.\n\nAlias for self.schema.hasColumn(column_name: str) -> bool.\n\nParameters\n----------\ncolumn_name : str\n    The name of the column.\n\nReturns\n-------\ncontains : bool\n    True if the column exists.",
      "code": "    def has_column(self, column_name: str) -> bool:\n        \"\"\"\n        Return whether the table contains a given column.\n\n        Alias for self.schema.hasColumn(column_name: str) -> bool.\n\n        Parameters\n        ----------\n        column_name : str\n            The name of the column.\n\n        Returns\n        -------\n        contains : bool\n            True if the column exists.\n        \"\"\"\n        return self._schema.has_column(column_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns",
      "name": "keep_only_columns",
      "qname": "safeds.data.tabular.containers._table.Table.keep_only_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.keep_only_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/keep_only_columns/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.containers._table.Table.keep_only_columns.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "A list containing only the columns to be kept."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with only the given column(s).",
      "docstring": "Return a table with only the given column(s).\n\nParameters\n----------\ncolumn_names : list[str]\n    A list containing only the columns to be kept.\n\nReturns\n-------\ntable : Table\n    A table containing only the given column(s).\n\nRaises\n------\nColumnNameError\n    If any of the given columns does not exist.",
      "code": "    def keep_only_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table with only the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing only the columns to be kept.\n\n        Returns\n        -------\n        table : Table\n            A table containing only the given column(s).\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data[column_names]\n        transformed_data.columns = column_names\n        return Table(transformed_data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/n_columns@getter",
      "name": "n_columns",
      "qname": "safeds.data.tabular.containers._table.Table.n_columns",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/n_columns@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.n_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of columns.",
      "docstring": "Return the number of columns.\n\nReturns\n-------\nn_columns : int\n    The number of columns.",
      "code": "    @property\n    def n_columns(self) -> int:\n        \"\"\"\n        Return the number of columns.\n\n        Returns\n        -------\n        n_columns : int\n            The number of columns.\n        \"\"\"\n        return self._data.shape[1]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/n_rows@getter",
      "name": "n_rows",
      "qname": "safeds.data.tabular.containers._table.Table.n_rows",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/n_rows@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.n_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the number of rows.",
      "docstring": "Return the number of rows.\n\nReturns\n-------\nn_rows : int\n    The number of rows.",
      "code": "    @property\n    def n_rows(self) -> int:\n        \"\"\"\n        Return the number of rows.\n\n        Returns\n        -------\n        n_rows : int\n            The number of rows.\n        \"\"\"\n        return self._data.shape[0]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_correlation_heatmap",
      "name": "plot_correlation_heatmap",
      "qname": "safeds.data.tabular.containers._table.Table.plot_correlation_heatmap",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_correlation_heatmap/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.plot_correlation_heatmap.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot a correlation heatmap for all numerical columns of this `Table`.",
      "docstring": "Plot a correlation heatmap for all numerical columns of this `Table`.\n\nReturns\n-------\nplot: Image\n    The plot as an image.",
      "code": "    def plot_correlation_heatmap(self) -> Image:\n        \"\"\"\n        Plot a correlation heatmap for all numerical columns of this `Table`.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n        \"\"\"\n        only_numerical = self.remove_columns_with_non_numerical_values()\n\n        fig = plt.figure()\n        sns.heatmap(\n            data=only_numerical._data.corr(),\n            vmin=-1,\n            vmax=1,\n            xticklabels=only_numerical.column_names,\n            yticklabels=only_numerical.column_names,\n            cmap=\"vlag\",\n        )\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot",
      "name": "plot_lineplot",
      "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot/x_column_name",
          "name": "x_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot.x_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the x-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_lineplot/y_column_name",
          "name": "y_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_lineplot.y_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the y-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot two columns against each other in a lineplot.\n\nIf there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\nand the lower-transparency area around the line representing the 95% confidence interval.",
      "docstring": "Plot two columns against each other in a lineplot.\n\nIf there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\nand the lower-transparency area around the line representing the 95% confidence interval.\n\nParameters\n----------\nx_column_name : str\n    The column name of the column to be plotted on the x-Axis.\ny_column_name : str\n    The column name of the column to be plotted on the y-Axis.\n\nReturns\n-------\nplot: Image\n    The plot as an image.\n\nRaises\n------\nUnknownColumnNameError\n    If either of the columns do not exist.",
      "code": "    def plot_lineplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a lineplot.\n\n        If there are multiple x-values for a y-value, the resulting plot will consist of a line representing the mean\n        and the lower-transparency area around the line representing the 95% confidence interval.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.lineplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot",
      "name": "plot_scatterplot",
      "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot/x_column_name",
          "name": "x_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot.x_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the x-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/plot_scatterplot/y_column_name",
          "name": "y_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.plot_scatterplot.y_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The column name of the column to be plotted on the y-Axis."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Plot two columns against each other in a scatterplot.",
      "docstring": "Plot two columns against each other in a scatterplot.\n\nParameters\n----------\nx_column_name : str\n    The column name of the column to be plotted on the x-Axis.\ny_column_name : str\n    The column name of the column to be plotted on the y-Axis.\n\nReturns\n-------\nplot: Image\n    The plot as an image.\n\nRaises\n------\nUnknownColumnNameError\n    If either of the columns do not exist.",
      "code": "    def plot_scatterplot(self, x_column_name: str, y_column_name: str) -> Image:\n        \"\"\"\n        Plot two columns against each other in a scatterplot.\n\n        Parameters\n        ----------\n        x_column_name : str\n            The column name of the column to be plotted on the x-Axis.\n        y_column_name : str\n            The column name of the column to be plotted on the y-Axis.\n\n        Returns\n        -------\n        plot: Image\n            The plot as an image.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If either of the columns do not exist.\n        \"\"\"\n        if not self.has_column(x_column_name):\n            raise UnknownColumnNameError([x_column_name])\n        if not self.has_column(y_column_name):\n            raise UnknownColumnNameError([y_column_name])\n\n        fig = plt.figure()\n        ax = sns.scatterplot(\n            data=self._data,\n            x=x_column_name,\n            y=y_column_name,\n        )\n        ax.set(xlabel=x_column_name, ylabel=y_column_name)\n        ax.set_xticks(ax.get_xticks())\n        ax.set_xticklabels(\n            ax.get_xticklabels(),\n            rotation=45,\n            horizontalalignment=\"right\",\n        )  # rotate the labels of the x Axis to prevent the chance of overlapping of the labels\n        plt.tight_layout()\n\n        buffer = io.BytesIO()\n        fig.savefig(buffer, format=\"png\")\n        plt.close()  # Prevents the figure from being displayed directly\n        buffer.seek(0)\n        return Image(buffer, format_=ImageFormat.PNG)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns",
      "name": "remove_columns",
      "qname": "safeds.data.tabular.containers._table.Table.remove_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "A list containing all columns to be dropped."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the given column(s).",
      "docstring": "Return a table without the given column(s).\n\nParameters\n----------\ncolumn_names : list[str]\n    A list containing all columns to be dropped.\n\nReturns\n-------\ntable : Table\n    A table without the given columns.\n\nRaises\n------\nColumnNameError\n    If any of the given columns does not exist.",
      "code": "    def remove_columns(self, column_names: list[str]) -> Table:\n        \"\"\"\n        Return a table without the given column(s).\n\n        Parameters\n        ----------\n        column_names : list[str]\n            A list containing all columns to be dropped.\n\n        Returns\n        -------\n        table : Table\n            A table without the given columns.\n\n        Raises\n        ------\n        ColumnNameError\n            If any of the given columns does not exist.\n        \"\"\"\n        invalid_columns = []\n        for name in column_names:\n            if not self._schema.has_column(name):\n                invalid_columns.append(name)\n        if len(invalid_columns) != 0:\n            raise UnknownColumnNameError(invalid_columns)\n\n        transformed_data = self._data.drop(labels=column_names, axis=\"columns\")\n        transformed_data.columns = [name for name in self._schema.column_names if name not in column_names]\n        return Table(transformed_data)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_missing_values",
      "name": "remove_columns_with_missing_values",
      "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the columns that contain missing values.",
      "docstring": "Return a table without the columns that contain missing values.\n\nReturns\n-------\ntable : Table\n    A table without the columns that contain missing values.",
      "code": "    def remove_columns_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain missing values.\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if not column.has_missing_values()])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_non_numerical_values",
      "name": "remove_columns_with_non_numerical_values",
      "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_non_numerical_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_columns_with_non_numerical_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_columns_with_non_numerical_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the columns that contain non-numerical values.",
      "docstring": "Return a table without the columns that contain non-numerical values.\n\nReturns\n-------\ntable : Table\n    A table without the columns that contain non-numerical values.",
      "code": "    def remove_columns_with_non_numerical_values(self) -> Table:\n        \"\"\"\n        Return a table without the columns that contain non-numerical values.\n\n        Returns\n        -------\n        table : Table\n            A table without the columns that contain non-numerical values.\n\n        \"\"\"\n        return Table.from_columns([column for column in self.to_columns() if column.type.is_numeric()])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_duplicate_rows",
      "name": "remove_duplicate_rows",
      "qname": "safeds.data.tabular.containers._table.Table.remove_duplicate_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_duplicate_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_duplicate_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a copy of the table with every duplicate row removed.",
      "docstring": "Return a copy of the table with every duplicate row removed.\n\nReturns\n-------\nresult : Table\n    The table with the duplicate rows removed.",
      "code": "    def remove_duplicate_rows(self) -> Table:\n        \"\"\"\n        Return a copy of the table with every duplicate row removed.\n\n        Returns\n        -------\n        result : Table\n            The table with the duplicate rows removed.\n        \"\"\"\n        result = self._data.drop_duplicates(ignore_index=True)\n        result.columns = self._schema.column_names\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_missing_values",
      "name": "remove_rows_with_missing_values",
      "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_missing_values",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_missing_values/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_missing_values.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table without the rows that contain missing values.",
      "docstring": "Return a table without the rows that contain missing values.\n\nReturns\n-------\ntable : Table\n    A table without the rows that contain missing values.",
      "code": "    def remove_rows_with_missing_values(self) -> Table:\n        \"\"\"\n        Return a table without the rows that contain missing values.\n\n        Returns\n        -------\n        table : Table\n            A table without the rows that contain missing values.\n        \"\"\"\n        result = self._data.copy(deep=True)\n        result = result.dropna(axis=\"index\")\n        return Table(result, self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_outliers",
      "name": "remove_rows_with_outliers",
      "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_outliers",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/remove_rows_with_outliers/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.remove_rows_with_outliers.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Remove all rows from the table that contain at least one outlier.\n\nWe define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\nMissing values are not considered outliers. They are also ignored during the calculation of the standard\ndeviation.",
      "docstring": "Remove all rows from the table that contain at least one outlier.\n\nWe define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\nMissing values are not considered outliers. They are also ignored during the calculation of the standard\ndeviation.\n\nReturns\n-------\nnew_table : Table\n    A new table without rows containing outliers.",
      "code": "    def remove_rows_with_outliers(self) -> Table:\n        \"\"\"\n        Remove all rows from the table that contain at least one outlier.\n\n        We define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.\n        Missing values are not considered outliers. They are also ignored during the calculation of the standard\n        deviation.\n\n        Returns\n        -------\n        new_table : Table\n            A new table without rows containing outliers.\n        \"\"\"\n        copy = self._data.copy(deep=True)\n\n        table_without_nonnumericals = self.remove_columns_with_non_numerical_values()\n        z_scores = np.absolute(stats.zscore(table_without_nonnumericals._data, nan_policy=\"omit\"))\n        filter_ = ((z_scores < 3) | np.isnan(z_scores)).all(axis=1)\n\n        return Table(copy[filter_], self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column",
      "name": "rename_column",
      "qname": "safeds.data.tabular.containers._table.Table.rename_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/old_name",
          "name": "old_name",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.old_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The old name of the target column"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/rename_column/new_name",
          "name": "new_name",
          "qname": "safeds.data.tabular.containers._table.Table.rename_column.new_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The new name of the target column"
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Rename a single column.",
      "docstring": "Rename a single column.\n\nParameters\n----------\nold_name : str\n    The old name of the target column\nnew_name : str\n    The new name of the target column\n\nReturns\n-------\ntable : Table\n    The Table with the renamed column.\n\nRaises\n------\nColumnNameError\n    If the specified old target column name does not exist.\nDuplicateColumnNameError\n    If the specified new target column name already exists.",
      "code": "    def rename_column(self, old_name: str, new_name: str) -> Table:\n        \"\"\"\n        Rename a single column.\n\n        Parameters\n        ----------\n        old_name : str\n            The old name of the target column\n        new_name : str\n            The new name of the target column\n\n        Returns\n        -------\n        table : Table\n            The Table with the renamed column.\n\n        Raises\n        ------\n        ColumnNameError\n            If the specified old target column name does not exist.\n        DuplicateColumnNameError\n            If the specified new target column name already exists.\n        \"\"\"\n        if old_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_name])\n        if old_name == new_name:\n            return self\n        if new_name in self._schema.column_names:\n            raise DuplicateColumnNameError(new_name)\n\n        new_df = self._data.copy()\n        new_df.columns = self._schema.column_names\n        return Table(new_df.rename(columns={old_name: new_name}))"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column",
      "name": "replace_column",
      "qname": "safeds.data.tabular.containers._table.Table.replace_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/old_column_name",
          "name": "old_column_name",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.old_column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column to be replaced."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/replace_column/new_column",
          "name": "new_column",
          "qname": "safeds.data.tabular.containers._table.Table.replace_column.new_column",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Column",
            "default_value": "",
            "description": "The new column replacing the old column."
          },
          "type": {
            "kind": "NamedType",
            "name": "Column"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.",
      "docstring": "Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\nParameters\n----------\nold_column_name : str\n    The name of the column to be replaced.\n\nnew_column : Column\n    The new column replacing the old column.\n\nReturns\n-------\nresult : Table\n    A table with the old column replaced by the new column.\n\nRaises\n------\nUnknownColumnNameError\n    If the old column does not exist.\n\nDuplicateColumnNameError\n    If the new column already exists and the existing column is not affected by the replacement.\n\nColumnSizeError\n    If the size of the column does not match the amount of rows.",
      "code": "    def replace_column(self, old_column_name: str, new_column: Column) -> Table:\n        \"\"\"\n        Return a copy of the table with the specified old column replaced by a new column. Keeps the order of columns.\n\n        Parameters\n        ----------\n        old_column_name : str\n            The name of the column to be replaced.\n\n        new_column : Column\n            The new column replacing the old column.\n\n        Returns\n        -------\n        result : Table\n            A table with the old column replaced by the new column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the old column does not exist.\n\n        DuplicateColumnNameError\n            If the new column already exists and the existing column is not affected by the replacement.\n\n        ColumnSizeError\n            If the size of the column does not match the amount of rows.\n        \"\"\"\n        if old_column_name not in self._schema.column_names:\n            raise UnknownColumnNameError([old_column_name])\n\n        if new_column.name in self._schema.column_names and new_column.name != old_column_name:\n            raise DuplicateColumnNameError(new_column.name)\n\n        if self.n_rows != new_column._data.size:\n            raise ColumnSizeError(str(self.n_rows), str(new_column._data.size))\n\n        if old_column_name != new_column.name:\n            renamed_table = self.rename_column(old_column_name, new_column.name)\n            result = renamed_table._data\n            result.columns = renamed_table._schema.column_names\n        else:\n            result = self._data.copy()\n            result.columns = self._schema.column_names\n\n        result[new_column.name] = new_column._data\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/schema@getter",
      "name": "schema",
      "qname": "safeds.data.tabular.containers._table.Table.schema",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/schema@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.schema.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return the schema of the table.",
      "docstring": "Return the schema of the table.\n\nReturns\n-------\nschema : Schema\n    The schema.",
      "code": "    @property\n    def schema(self) -> Schema:\n        \"\"\"\n        Return the schema of the table.\n\n        Returns\n        -------\n        schema : Schema\n            The schema.\n        \"\"\"\n        return self._schema"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/shuffle_rows",
      "name": "shuffle_rows",
      "qname": "safeds.data.tabular.containers._table.Table.shuffle_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/shuffle_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.shuffle_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Shuffle the table randomly.",
      "docstring": "Shuffle the table randomly.\n\nReturns\n-------\nresult : Table\n    The shuffled Table.",
      "code": "    def shuffle_rows(self) -> Table:\n        \"\"\"\n        Shuffle the table randomly.\n\n        Returns\n        -------\n        result : Table\n            The shuffled Table.\n\n        \"\"\"\n        new_df = self._data.sample(frac=1.0)\n        new_df.columns = self._schema.column_names\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows",
      "name": "slice_rows",
      "qname": "safeds.data.tabular.containers._table.Table.slice_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/start",
          "name": "start",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.start",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The first index of the range to be copied into a new table, None by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/end",
          "name": "end",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.end",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The last index of the range to be copied into a new table, None by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/slice_rows/step",
          "name": "step",
          "qname": "safeds.data.tabular.containers._table.Table.slice_rows.step",
          "default_value": "1",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The step size used to iterate through the table, 1 by default."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Slice a part of the table into a new table.",
      "docstring": "Slice a part of the table into a new table.\n\nParameters\n----------\nstart : int\n    The first index of the range to be copied into a new table, None by default.\nend : int\n    The last index of the range to be copied into a new table, None by default.\nstep : int\n    The step size used to iterate through the table, 1 by default.\n\nReturns\n-------\nresult : Table\n    The resulting table.\n\nRaises\n------\nValueError\n    If the index is out of bounds.",
      "code": "    def slice_rows(\n        self,\n        start: int | None = None,\n        end: int | None = None,\n        step: int = 1,\n    ) -> Table:\n        \"\"\"\n        Slice a part of the table into a new table.\n\n        Parameters\n        ----------\n        start : int\n            The first index of the range to be copied into a new table, None by default.\n        end : int\n            The last index of the range to be copied into a new table, None by default.\n        step : int\n            The step size used to iterate through the table, 1 by default.\n\n        Returns\n        -------\n        result : Table\n            The resulting table.\n\n        Raises\n        ------\n        ValueError\n            If the index is out of bounds.\n        \"\"\"\n        if start is None:\n            start = 0\n\n        if end is None:\n            end = self.n_rows\n\n        if start < 0 or end < 0 or start >= self.n_rows or end > self.n_rows or end < start:\n            raise ValueError(\"The given index is out of bounds\")\n\n        new_df = self._data.iloc[start:end:step]\n        new_df.columns = self._schema.column_names\n        return Table(new_df)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns",
      "name": "sort_columns",
      "qname": "safeds.data.tabular.containers._table.Table.sort_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.sort_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_columns/comparator",
          "name": "comparator",
          "qname": "safeds.data.tabular.containers._table.Table.sort_columns.comparator",
          "default_value": "lambda col1, col2: (col1.name > col2.name) - (col1.name < col2.name)",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Column, Column], int]",
            "default_value": "",
            "description": "The function used to compare two columns."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Column"
              },
              {
                "kind": "NamedType",
                "name": "Column]"
              },
              {
                "kind": "NamedType",
                "name": "int]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\nreturns an integer:\n\n* If `col1` should be ordered before `col2`, the function should return a negative number.\n* If `col1` should be ordered after `col2`, the function should return a positive number.\n* If the original order of `col1` and `col2` should be kept, the function should return 0.\n\nIf no comparator is given, the columns will be sorted alphabetically by their name.",
      "docstring": "Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\nreturns an integer:\n\n* If `col1` should be ordered before `col2`, the function should return a negative number.\n* If `col1` should be ordered after `col2`, the function should return a positive number.\n* If the original order of `col1` and `col2` should be kept, the function should return 0.\n\nIf no comparator is given, the columns will be sorted alphabetically by their name.\n\nParameters\n----------\ncomparator : Callable[[Column, Column], int]\n    The function used to compare two columns.\n\nReturns\n-------\nnew_table : Table\n    A new table with sorted columns.",
      "code": "    def sort_columns(\n        self,\n        comparator: Callable[[Column, Column], int] = lambda col1, col2: (col1.name > col2.name)\n        - (col1.name < col2.name),\n    ) -> Table:\n        \"\"\"\n        Sort the columns of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two columns `col1` and `col2` and\n        returns an integer:\n\n        * If `col1` should be ordered before `col2`, the function should return a negative number.\n        * If `col1` should be ordered after `col2`, the function should return a positive number.\n        * If the original order of `col1` and `col2` should be kept, the function should return 0.\n\n        If no comparator is given, the columns will be sorted alphabetically by their name.\n\n        Parameters\n        ----------\n        comparator : Callable[[Column, Column], int]\n            The function used to compare two columns.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted columns.\n        \"\"\"\n        columns = self.to_columns()\n        columns.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_columns(columns)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_rows",
      "name": "sort_rows",
      "qname": "safeds.data.tabular.containers._table.Table.sort_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.sort_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/sort_rows/comparator",
          "name": "comparator",
          "qname": "safeds.data.tabular.containers._table.Table.sort_rows.comparator",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Callable[[Row, Row], int]",
            "default_value": "",
            "description": "The function used to compare two rows."
          },
          "type": {
            "kind": "UnionType",
            "types": [
              {
                "kind": "NamedType",
                "name": "Callable[[Row"
              },
              {
                "kind": "NamedType",
                "name": "Row]"
              },
              {
                "kind": "NamedType",
                "name": "int]"
              }
            ]
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\nreturns an integer:\n\n* If `row1` should be ordered before `row2`, the function should return a negative number.\n* If `row1` should be ordered after `row2`, the function should return a positive number.\n* If the original order of `row1` and `row2` should be kept, the function should return 0.",
      "docstring": "Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\nThe original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\nreturns an integer:\n\n* If `row1` should be ordered before `row2`, the function should return a negative number.\n* If `row1` should be ordered after `row2`, the function should return a positive number.\n* If the original order of `row1` and `row2` should be kept, the function should return 0.\n\nParameters\n----------\ncomparator : Callable[[Row, Row], int]\n    The function used to compare two rows.\n\nReturns\n-------\nnew_table : Table\n    A new table with sorted rows.",
      "code": "    def sort_rows(self, comparator: Callable[[Row, Row], int]) -> Table:\n        \"\"\"\n        Sort the rows of a `Table` with the given comparator and return a new `Table`.\n\n        The original table is not modified. The comparator is a function that takes two rows `row1` and `row2` and\n        returns an integer:\n\n        * If `row1` should be ordered before `row2`, the function should return a negative number.\n        * If `row1` should be ordered after `row2`, the function should return a positive number.\n        * If the original order of `row1` and `row2` should be kept, the function should return 0.\n\n        Parameters\n        ----------\n        comparator : Callable[[Row, Row], int]\n            The function used to compare two rows.\n\n        Returns\n        -------\n        new_table : Table\n            A new table with sorted rows.\n        \"\"\"\n        rows = self.to_rows()\n        rows.sort(key=functools.cmp_to_key(comparator))\n        return Table.from_rows(rows)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/split",
      "name": "split",
      "qname": "safeds.data.tabular.containers._table.Table.split",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/split/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.split.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/split/percentage_in_first",
          "name": "percentage_in_first",
          "qname": "safeds.data.tabular.containers._table.Table.split.percentage_in_first",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "float",
            "default_value": "",
            "description": "The desired size of the first table in percentage to the given table."
          },
          "type": {
            "kind": "NamedType",
            "name": "float"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Split the table into two new tables.",
      "docstring": "Split the table into two new tables.\n\nParameters\n----------\npercentage_in_first : float\n    The desired size of the first table in percentage to the given table.\n\nReturns\n-------\nresult : (Table, Table)\n    A tuple containing the two resulting tables. The first table has the specified size, the second table\n    contains the rest of the data.",
      "code": "    def split(self, percentage_in_first: float) -> tuple[Table, Table]:\n        \"\"\"\n        Split the table into two new tables.\n\n        Parameters\n        ----------\n        percentage_in_first : float\n            The desired size of the first table in percentage to the given table.\n\n        Returns\n        -------\n        result : (Table, Table)\n            A tuple containing the two resulting tables. The first table has the specified size, the second table\n            contains the rest of the data.\n\n\n        \"\"\"\n        if percentage_in_first <= 0 or percentage_in_first >= 1:\n            raise ValueError(\"the given percentage is not in range\")\n        return (\n            self.slice_rows(0, round(percentage_in_first * self.n_rows)),\n            self.slice_rows(round(percentage_in_first * self.n_rows)),\n        )"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/summary",
      "name": "summary",
      "qname": "safeds.data.tabular.containers._table.Table.summary",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/summary/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.summary.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a table with a number of statistical key values.",
      "docstring": "Return a table with a number of statistical key values.\n\nReturns\n-------\nresult : Table\n    The table with statistics.",
      "code": "    def summary(self) -> Table:\n        \"\"\"\n        Return a table with a number of statistical key values.\n\n        Returns\n        -------\n        result : Table\n            The table with statistics.\n        \"\"\"\n        columns = self.to_columns()\n        result = pd.DataFrame()\n        statistics = {}\n\n        for column in columns:\n            statistics = {\n                \"maximum\": column.maximum,\n                \"minimum\": column.minimum,\n                \"mean\": column.mean,\n                \"mode\": column.mode,\n                \"median\": column.median,\n                \"sum\": column.sum,\n                \"variance\": column.variance,\n                \"standard deviation\": column.standard_deviation,\n                \"idness\": column.idness,\n                \"stability\": column.stability,\n            }\n            values = []\n\n            for function in statistics.values():\n                try:\n                    values.append(str(function()))\n                except NonNumericColumnError:\n                    values.append(\"-\")\n\n            result = pd.concat([result, pd.DataFrame(values)], axis=1)\n\n        result = pd.concat([pd.DataFrame(list(statistics.keys())), result], axis=1)\n        result.columns = [\"metrics\", *self.column_names]\n\n        return Table(result)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns",
      "name": "tag_columns",
      "qname": "safeds.data.tabular.containers._table.Table.tag_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.tag_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns/target_name",
          "name": "target_name",
          "qname": "safeds.data.tabular.containers._table.Table.tag_columns.target_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Name of the target column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/tag_columns/feature_names",
          "name": "feature_names",
          "qname": "safeds.data.tabular.containers._table.Table.tag_columns.feature_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "Names of the feature columns. If None, all columns except the target column are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Mark the columns of the table as target column or feature columns. The original table is not modified.",
      "docstring": "Mark the columns of the table as target column or feature columns. The original table is not modified.\n\nParameters\n----------\ntarget_name : str\n    Name of the target column.\nfeature_names : Optional[list[str]]\n    Names of the feature columns. If None, all columns except the target column are used.\n\nReturns\n-------\ntagged_table : TaggedTable\n    A new tagged table with the given target and feature names.",
      "code": "    def tag_columns(self, target_name: str, feature_names: list[str] | None = None) -> TaggedTable:\n        \"\"\"\n        Mark the columns of the table as target column or feature columns. The original table is not modified.\n\n        Parameters\n        ----------\n        target_name : str\n            Name of the target column.\n        feature_names : Optional[list[str]]\n            Names of the feature columns. If None, all columns except the target column are used.\n\n        Returns\n        -------\n        tagged_table : TaggedTable\n            A new tagged table with the given target and feature names.\n        \"\"\"\n        from ._tagged_table import TaggedTable\n\n        return TaggedTable(self._data, target_name, feature_names, self._schema)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_columns",
      "name": "to_columns",
      "qname": "safeds.data.tabular.containers._table.Table.to_columns",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_columns/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_columns.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of the columns.",
      "docstring": "Return a list of the columns.\n\nReturns\n-------\ncolumns : list[Columns]\n    List of columns.",
      "code": "    def to_columns(self) -> list[Column]:\n        \"\"\"\n        Return a list of the columns.\n\n        Returns\n        -------\n        columns : list[Columns]\n            List of columns.\n        \"\"\"\n        return [self.get_column(name) for name in self._schema.column_names]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file",
      "name": "to_csv_file",
      "qname": "safeds.data.tabular.containers._table.Table.to_csv_file",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_csv_file.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_csv_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.to_csv_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the output file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Write the data from the table into a CSV file.\n\nIf the file and/or the directories do not exist they will be created. If the file already exists it will be\noverwritten.",
      "docstring": "Write the data from the table into a CSV file.\n\nIf the file and/or the directories do not exist they will be created. If the file already exists it will be\noverwritten.\n\nParameters\n----------\npath : str\n    The path to the output file.",
      "code": "    def to_csv_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a CSV file.\n\n        If the file and/or the directories do not exist they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_csv = self._data.copy()\n        data_to_csv.columns = self._schema.column_names\n        data_to_csv.to_csv(path, index=False)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_dict",
      "name": "to_dict",
      "qname": "safeds.data.tabular.containers._table.Table.to_dict",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_dict/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_dict.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a dictionary that maps column names to column values.",
      "docstring": "Return a dictionary that maps column names to column values.\n\nReturns\n-------\ndata : dict[str, list[Any]]\n    Dictionary representation of the table.",
      "code": "    def to_dict(self) -> dict[str, list[Any]]:\n        \"\"\"\n        Return a dictionary that maps column names to column values.\n\n        Returns\n        -------\n        data : dict[str, list[Any]]\n            Dictionary representation of the table.\n        \"\"\"\n        return {column_name: list(self.get_column(column_name)) for column_name in self.column_names}"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json_file",
      "name": "to_json_file",
      "qname": "safeds.data.tabular.containers._table.Table.to_json_file",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json_file/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_json_file.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_json_file/path",
          "name": "path",
          "qname": "safeds.data.tabular.containers._table.Table.to_json_file.path",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The path to the output file."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Write the data from the table into a JSON file.\n\nIf the file and/or the directories do not exist, they will be created. If the file already exists it will be\noverwritten.",
      "docstring": "Write the data from the table into a JSON file.\n\nIf the file and/or the directories do not exist, they will be created. If the file already exists it will be\noverwritten.\n\nParameters\n----------\npath : str\n    The path to the output file.",
      "code": "    def to_json_file(self, path: str) -> None:\n        \"\"\"\n        Write the data from the table into a JSON file.\n\n        If the file and/or the directories do not exist, they will be created. If the file already exists it will be\n        overwritten.\n\n        Parameters\n        ----------\n        path : str\n            The path to the output file.\n        \"\"\"\n        Path(path).parent.mkdir(parents=True, exist_ok=True)\n        data_to_json = self._data.copy()\n        data_to_json.columns = self._schema.column_names\n        data_to_json.to_json(path)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/to_rows",
      "name": "to_rows",
      "qname": "safeds.data.tabular.containers._table.Table.to_rows",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/to_rows/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.to_rows.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a list of the rows.",
      "docstring": "Return a list of the rows.\n\nReturns\n-------\nrows : list[Row]\n    List of rows.",
      "code": "    def to_rows(self) -> list[Row]:\n        \"\"\"\n        Return a list of the rows.\n\n        Returns\n        -------\n        rows : list[Row]\n            List of rows.\n        \"\"\"\n        return [\n            Row._from_polars_dataframe(\n                pl.DataFrame([list(series_row)], schema=self._schema.column_names),\n                self._schema,\n            )\n            for (_, series_row) in self._data.iterrows()\n        ]"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column",
      "name": "transform_column",
      "qname": "safeds.data.tabular.containers._table.Table.transform_column",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/name",
          "name": "name",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._table/Table/transform_column/transformer",
          "name": "transformer",
          "qname": "safeds.data.tabular.containers._table.Table.transform_column.transformer",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Transform provided column by calling provided transformer.",
      "docstring": "Transform provided column by calling provided transformer.\n\nReturns\n-------\nresult : Table\n    The table with the transformed column.\n\nRaises\n------\nUnknownColumnNameError\n    If the column does not exist.",
      "code": "    def transform_column(self, name: str, transformer: Callable[[Row], Any]) -> Table:\n        \"\"\"\n        Transform provided column by calling provided transformer.\n\n        Returns\n        -------\n        result : Table\n            The table with the transformed column.\n\n        Raises\n        ------\n        UnknownColumnNameError\n            If the column does not exist.\n\n        \"\"\"\n        if self.has_column(name):\n            items: list = [transformer(item) for item in self.to_rows()]\n            result: Column = Column(name, pd.Series(items))\n            return self.replace_column(name, result)\n        raise UnknownColumnNameError([name])"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/data",
          "name": "data",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.data",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Iterable",
            "default_value": "",
            "description": "The data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Iterable"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/target_name",
          "name": "target_name",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.target_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "Name of the target column."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/feature_names",
          "name": "feature_names",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.feature_names",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[list[str]]",
            "default_value": "",
            "description": "Names of the feature columns. If None, all columns except the target column are used."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[list[str]]"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__init__/schema",
          "name": "schema",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__init__.schema",
          "default_value": "None",
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "Optional[Schema]",
            "default_value": "",
            "description": "The schema of the table. If not specified, the schema will be inferred from the data."
          },
          "type": {
            "kind": "NamedType",
            "name": "Optional[Schema]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "A tagged table is a table that additionally knows which columns are features and which are the target to predict.",
      "docstring": "",
      "code": "    def __init__(\n        self,\n        data: Iterable,\n        target_name: str,\n        feature_names: list[str] | None = None,\n        schema: Schema | None = None,\n    ):\n        super().__init__(data, schema)\n\n        # If no feature names are specified, use all columns except the target column\n        if feature_names is None:\n            feature_names = self.column_names\n            if target_name in feature_names:\n                feature_names.remove(target_name)\n\n        # Validate inputs\n        if target_name in feature_names:\n            raise ValueError(f\"Column '{target_name}' cannot be both feature and target.\")\n        if len(feature_names) == 0:\n            raise ValueError(\"At least one feature column must be specified.\")\n\n        self._features: Table = self.keep_only_columns(feature_names)\n        self._target: Column = self.get_column(target_name)"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__",
      "name": "__repr__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__repr__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__repr__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__repr__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __repr__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__repr__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__",
      "name": "__str__",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__str__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/__str__/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.__str__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    def __str__(self) -> str:\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        return header_info + tmp.__str__()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_",
      "name": "_ipython_display_",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable._ipython_display_",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/_ipython_display_/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable._ipython_display_.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Return a display object for the column to be used in Jupyter Notebooks.",
      "docstring": "Return a display object for the column to be used in Jupyter Notebooks.\n\nReturns\n-------\noutput : DisplayHandle\n    Output object.",
      "code": "    def _ipython_display_(self) -> DisplayHandle:\n        \"\"\"\n        Return a display object for the column to be used in Jupyter Notebooks.\n\n        Returns\n        -------\n        output : DisplayHandle\n            Output object.\n        \"\"\"\n        tmp = self._features.add_column(self._target)\n        header_info = \"Target Column is '\" + self._target.name + \"'\\n\"\n        print(header_info)  # noqa: T201\n        return tmp._ipython_display_()"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/features@getter",
      "name": "features",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.features",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/features@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.features.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def features(self) -> Table:\n        return self._features"
    },
    {
      "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target@getter",
      "name": "target",
      "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.target",
      "decorators": [
        "property"
      ],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.containers._tagged_table/TaggedTable/target@getter/self",
          "name": "self",
          "qname": "safeds.data.tabular.containers._tagged_table.TaggedTable.target.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "",
      "docstring": "",
      "code": "    @property\n    def target(self) -> Column:\n        return self._target"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnLengthMismatchError/__init__/column_info",
          "name": "column_info",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnLengthMismatchError.__init__.column_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when the lengths of two or more columns do not match.",
      "docstring": "",
      "code": "    def __init__(self, column_info: str):\n        super().__init__(f\"The length of at least one column differs: \\n{column_info}\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__/expected_size",
          "name": "expected_size",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__.expected_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The expected size of the column as an expression (e.g. 2, >0, !=0)."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/ColumnSizeError/__init__/actual_size",
          "name": "actual_size",
          "qname": "safeds.data.tabular.exceptions._exceptions.ColumnSizeError.__init__.actual_size",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The actual size of the column as an expression (e.g. 2, >0, !=0)."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to use a column of unsupported size.",
      "docstring": "",
      "code": "    def __init__(self, expected_size: str, actual_size: str):\n        super().__init__(f\"Expected a column of size {expected_size} but got column of size {actual_size}.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/DuplicateColumnNameError/__init__/column_name",
          "name": "column_name",
          "qname": "safeds.data.tabular.exceptions._exceptions.DuplicateColumnNameError.__init__.column_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "str",
            "default_value": "",
            "description": "The name of the column that resulted in a duplicate."
          },
          "type": {
            "kind": "NamedType",
            "name": "str"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to modify a table resulting in a duplicate column name.",
      "docstring": "",
      "code": "    def __init__(self, column_name: str):\n        super().__init__(f\"Column '{column_name}' already exists.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/IndexOutOfBoundsError/__init__/index",
          "name": "index",
          "qname": "safeds.data.tabular.exceptions._exceptions.IndexOutOfBoundsError.__init__.index",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "int",
            "default_value": "",
            "description": "The wrongly used index."
          },
          "type": {
            "kind": "NamedType",
            "name": "int"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an element by an index that does not exist in the underlying data.",
      "docstring": "",
      "code": "    def __init__(self, index: int):\n        super().__init__(f\"There is no element at index '{index}'.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingDataError/__init__/missing_data_info",
          "name": "missing_data_info",
          "qname": "safeds.data.tabular.exceptions._exceptions.MissingDataError.__init__.missing_data_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised if a function is not given enough data to succeed.",
      "docstring": "",
      "code": "    def __init__(self, missing_data_info: str):\n        super().__init__(f\"The function is missing data: \\n{missing_data_info}\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.MissingSchemaError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/MissingSchemaError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.MissingSchemaError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when a required schema is missing.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Failed because a required schema is missing.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/NonNumericColumnError/__init__/column_info",
          "name": "column_info",
          "qname": "safeds.data.tabular.exceptions._exceptions.NonNumericColumnError.__init__.column_info",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to do numerical operations on a non-numerical column.",
      "docstring": "",
      "code": "    def __init__(self, column_info: str) -> None:\n        super().__init__(f\"Tried to do a numerical operation on one or multiple non numerical Columns: \\n{column_info}\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.SchemaMismatchError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/SchemaMismatchError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.SchemaMismatchError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised when schemas are unequal.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"Failed because at least two schemas didn't match.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.TransformerNotFittedError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/TransformerNotFittedError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.TransformerNotFittedError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a transformer is used before fitting it.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"The transformer has not been fitted yet.\")"
    },
    {
      "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__",
      "name": "__init__",
      "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__/self",
          "name": "self",
          "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.data.tabular.exceptions._exceptions/UnknownColumnNameError/__init__/column_names",
          "name": "column_names",
          "qname": "safeds.data.tabular.exceptions._exceptions.UnknownColumnNameError.__init__.column_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "list[str]",
            "default_value": "",
            "description": "The name of the column that was tried to be accessed."
          },
          "type": {
            "kind": "NamedType",
            "name": "list[str]"
          }
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Exception raised for trying to access an invalid column name.",
      "docstring": "",
      "code": "    def __init__(self, column_names: list[str]):\n        super().__init__(f\"Could not find column(s) '{', '.join(column_names)}'\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetContainsTargetError/__init__/target_name",
          "name": "target_name",
          "qname": "safeds.ml.exceptions._exceptions.DatasetContainsTargetError.__init__.target_name",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset contains the target column already.",
      "docstring": "",
      "code": "    def __init__(self, target_name: str):\n        super().__init__(f\"Dataset already contains the target column '{target_name}'.\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/DatasetMissesFeaturesError/__init__/missing_feature_names",
          "name": "missing_feature_names",
          "qname": "safeds.ml.exceptions._exceptions.DatasetMissesFeaturesError.__init__.missing_feature_names",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a dataset misses feature columns.",
      "docstring": "",
      "code": "    def __init__(self, missing_feature_names: list[str]):\n        super().__init__(f\"Dataset misses the feature columns '{missing_feature_names}'.\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.LearningError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.LearningError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/LearningError/__init__/reason",
          "name": "reason",
          "qname": "safeds.ml.exceptions._exceptions.LearningError.__init__.reason",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while training a model.",
      "docstring": "",
      "code": "    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while learning\")\n        else:\n            super().__init__(f\"Error occurred while learning: {reason}\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.ModelNotFittedError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/ModelNotFittedError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.ModelNotFittedError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when a model is used before fitting it.",
      "docstring": "",
      "code": "    def __init__(self) -> None:\n        super().__init__(\"The model has not been fitted yet.\")"
    },
    {
      "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__",
      "name": "__init__",
      "qname": "safeds.ml.exceptions._exceptions.PredictionError.__init__",
      "decorators": [],
      "parameters": [
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__/self",
          "name": "self",
          "qname": "safeds.ml.exceptions._exceptions.PredictionError.__init__.self",
          "default_value": null,
          "assigned_by": "IMPLICIT",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        },
        {
          "id": "stdlib/safeds.ml.exceptions._exceptions/PredictionError/__init__/reason",
          "name": "reason",
          "qname": "safeds.ml.exceptions._exceptions.PredictionError.__init__.reason",
          "default_value": null,
          "assigned_by": "POSITION_OR_NAME",
          "is_public": false,
          "docstring": {
            "type": "",
            "default_value": "",
            "description": ""
          },
          "type": {}
        }
      ],
      "results": [],
      "is_public": false,
      "reexported_by": [],
      "description": "Raised when an error occurred while prediction a target vector using a model.",
      "docstring": "",
      "code": "    def __init__(self, reason: str | None):\n        if reason is None:\n            super().__init__(\"Error occurred while predicting\")\n        else:\n            super().__init__(f\"Error occurred while predicting: {reason}\")"
    }
  ]
}